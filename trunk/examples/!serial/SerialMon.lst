 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 1 - 1/18/2018 14:51:19


       1/       0 :                     ; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Thu Jan 18 14:51:18 2018
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1) 1060/       0 :                     	listing	on
(1) 1061/       0 : C0 00 00            	lbr	lcc1802Init
(1) 1062/       3 :                     	
(1) 1063/       3 :                     
      11/       3 :                     	listing on
      12/       3 :                     _PIN4:
      13/       3 : 00                  	db 0
      14/       4 :                     ;$$function start$$ _dump
      15/       4 :                     _dump:		;framesize=12
      16/       4 : (MACRO)             	pushr R1
      17/       8 : (MACRO)             	pushr R6
      18/       C : (MACRO)             	pushr R7
      19/      10 : (MACRO)             	reserve 4; save room for outgoing arguments
      20/      14 : (MACRO)             	cpy2 R7,R12; function(2055) 1
      21/      18 : (MACRO)             	cpy2 R6,R13; function(2054) 1
      22/      1C :                     ;void dump(unsigned char* data, unsigned int len){
      23/      1C :                     ;	for(i=0;i<len;i++){
      24/      1C : (MACRO)             	ld2z R1
      25/      20 : C0 00 20            	lbr L5
      26/      23 :                     L2:
      27/      23 :                     ;		if (0==(i%16)) printf("\n%x ",data);
      28/      23 : (MACRO)             	alu2I R11,R1,15,ani,ani ;removed copy;BANDU2(reg,con)  
      29/      2B : (MACRO)             	jnzU2 R11,L6; NE 0 
      30/      33 : (MACRO)             	ldaD R12,L8; reg:acon
      31/      39 : (MACRO)             	cpy2 R13,R7 ;LOADP2(reg)
      32/      3D : (MACRO)             	Ccall _printf
      33/      40 :                     L6:
      34/      40 :                     ;		printf("%cx ",*data++);
      35/      40 : (MACRO)             	ldaD R12,L9; reg:acon
      36/      46 : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
      37/      4A : (MACRO)             	incm R7,1
      38/      4B : (MACRO)             	ldn1 R13,R11	;opt14*
      39/      4D : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
      40/      50 : (MACRO)             	Ccall _printf
      41/      53 :                     ;	}
      42/      53 :                     L3:
      43/      53 :                     ;	for(i=0;i<len;i++){
      44/      53 : (MACRO)             	incm R1,1
      45/      54 :                     L5:
      46/      54 : (MACRO)             	jcU2 R1,R6,lbnf,L2; LT=lbnf i.e. subtract B from A and jump if borrow 
      47/      61 :                     ;	printf("\n");
      48/      61 : (MACRO)             	ldaD R12,L10; reg:acon
      49/      67 : (MACRO)             	Ccall _printf
      50/      6A :                     ;}
      51/      6A :                     L1:
      52/      6A : (MACRO)             	release 4; release room for outgoing arguments
      53/      6E : (MACRO)             	popf R7	;opt11.3
      54/      73 : (MACRO)             	popm R6	;opt11.4
      55/      77 : (MACRO)             	popl R1	;opt11.4
      56/      7B : (MACRO)             	Cretn
      57/      7C :                     
      58/      7C :                     ;$$function end$$ _dump
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 2 - 1/18/2018 14:51:19


      59/      7C :                     ;$$function start$$ _regdump
      60/      7C :                     _regdump:		;framesize=10
      61/      7C : (MACRO)             	pushr R6
      62/      80 : (MACRO)             	pushr R7
      63/      84 : (MACRO)             	reserve 4; save room for outgoing arguments
      64/      88 : (MACRO)             	cpy2 R7,R12; function(2055) 1
      65/      8C :                     ;void regdump(unsigned int* data){
      66/      8C :                     ;	for(i=0;i<16;i++){
      67/      8C : (MACRO)             	ld2z R6
      68/      90 : C0 00 90            	lbr L15
      69/      93 :                     L12:
      70/      93 :                     ;		if (0==(i%4)) printf("\nR%cx ",i);
      71/      93 : (MACRO)             	alu2I R11,R6,3,ani,ani ;removed copy;BANDU2(reg,con)  
      72/      9B : (MACRO)             	jnzU2 R11,L16; NE 0 
      73/      A3 : (MACRO)             	ldaD R12,L18; reg:acon
      74/      A9 : (MACRO)             	cpy2 R13,R6 ;LOADU2*(reg)
      75/      AD : (MACRO)             	Ccall _printf
      76/      B0 :                     L16:
      77/      B0 :                     ;		printf("%x ",*data++);
      78/      B0 : (MACRO)             	ldaD R12,L19; reg:acon
      79/      B6 : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
      80/      BA : (MACRO)             	incm R7,2
      81/      BC : (MACRO)             	ldn2 R13,R11	;opt9x
      82/      C1 : (MACRO)             	Ccall _printf
      83/      C4 :                     ;	}
      84/      C4 :                     L13:
      85/      C4 :                     ;	for(i=0;i<16;i++){
      86/      C4 : (MACRO)             	incm R6,1
      87/      C5 :                     L15:
      88/      C5 : (MACRO)             	jcU2I R6,16,lbnf,L12 ;LT=lbnf i.e. subtract immedB from A and jump if borrow
      89/      CE :                     ;	printf("\n");
      90/      CE : (MACRO)             	ldaD R12,L10; reg:acon
      91/      D4 : (MACRO)             	Ccall _printf
      92/      D7 :                     ;}
      93/      D7 :                     L11:
      94/      D7 : (MACRO)             	release 4; release room for outgoing arguments
      95/      DB : (MACRO)             	popf R7	;opt11.3
      96/      E0 : (MACRO)             	popl R6	;opt11.3
      97/      E4 : (MACRO)             	Cretn
      98/      E5 :                     
      99/      E5 :                     ;$$function end$$ _regdump
     100/      E5 :                     ;$$function start$$ _dispatch
     101/      E5 :                     _dispatch:		;framesize=2
     102/      E5 :                     ;void dispatch(unsigned char * addr){
     103/      E5 :                     ;	asm(" cpy2 r0,r12\n"	//copy target address to R0
     104/      E5 : (MACRO)              cpy2 r0,r12
     105/      E9 : E0                   sex 0
     106/      EA : D0                   sep 0
     107/      EB :                     ;}
     108/      EB :                     L20:
     109/      EB : (MACRO)             	Cretn
     110/      EC :                     
     111/      EC :                     ;$$function end$$ _dispatch
     112/      EC :                     ;$$function start$$ _gethexit
     113/      EC :                     _gethexit:		;framesize=6
     114/      EC : (MACRO)             	pushr R6
     115/      F0 : (MACRO)             	pushr R7
     116/      F4 :                     ;int gethexit(unsigned char cin){ //returns the corresponding hex value for 0-f, -1 otherwise
     117/      F4 :                     ;	if ((cin>='0') && (cin<='9')){
     118/      F4 : (MACRO)             	cpy1 R11,R12
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 3 - 1/18/2018 14:51:19


     119/      F6 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     120/      F9 : (MACRO)             	jcI2I R11,48,lbnf,L23  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     121/     10A : (MACRO)             	jnI2I R11,57,lbnf,L23; GT reverse  the subtraction
     122/     11B :                     ;		return cin-'0';
     123/     11B : (MACRO)             	cpy1 R11,R12
     124/     11D : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     125/     120 : (MACRO)             	alu2I R15,R11,48,smi,smbi
     126/     128 : C0 01 28            	lbr L22
     127/     12B :                     L23:
     128/     12B :                     ;	}else if ((cin>='a') & (cin<='f')){
     129/     12B : (MACRO)             	cpy1 R11,R12
     130/     12D : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     131/     130 : (MACRO)             	jcI2I R11,97,lbnf,L29  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     132/     141 : (MACRO)             	ldaD R7,1; reg:acon
     133/     147 : C0 01 47            	lbr L30
     134/     14A :                     L29:
     135/     14A : (MACRO)             	ld2z R7
     136/     14E :                     L30:
     137/     14E : (MACRO)             	cpy1 R11,R12
     138/     150 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     139/     153 : (MACRO)             	jnI2I R11,102,lbnf,L31; GT reverse  the subtraction
     140/     164 : (MACRO)             	ldaD R6,1; reg:acon
     141/     16A : C0 01 6A            	lbr L32
     142/     16D :                     L31:
     143/     16D : (MACRO)             	ld2z R6
     144/     171 :                     L32:
     145/     171 : (MACRO)             	alu2 R11,R7,R6,and,and
     146/     17B : (MACRO)             	jzU2 R11,L25; EQ 0
     147/     183 :                     ;		return cin-'a'+10;
     148/     183 : (MACRO)             	cpy1 R11,R12
     149/     185 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     150/     188 : (MACRO)             	alu2I R11,R11,97,smi,smbi
     151/     190 : (MACRO)             	ldA2 R15,'O',R11,(10); reg:addr
     152/     198 : C0 01 98            	lbr L22
     153/     19B :                     L25:
     154/     19B :                     ;	}else{
     155/     19B :                     ;		return -1;
     156/     19B : (MACRO)             	ldaD R15,-1; reg:acon
     157/     1A1 :                     L22:
     158/     1A1 : (MACRO)             	popf R7	;opt11.3
     159/     1A6 : (MACRO)             	popl R6	;opt11.3
     160/     1AA : (MACRO)             	Cretn
     161/     1AB :                     
     162/     1AB :                     ;$$function end$$ _gethexit
     163/     1AB :                     ;$$function start$$ _bootload
     164/     1AB :                     _bootload:		;framesize=8
     165/     1AB : (MACRO)             	reserve 6
     166/     1B1 :                     ;int bootload(){
     167/     1B1 :                     ;	int ret=XR(CODEADDR);
     168/     1B1 : (MACRO)             	ldaD R12,0x8000; reg:acon
     169/     1B7 : (MACRO)             	Ccall _XR; CALLI2(ar)
     170/     1BA : (MACRO)             	st2 R15,'O',sp,(4+1); ASGNI2(addr,reg)
     171/     1C7 :                     ;	if (ret==EOT){
     172/     1C7 : (MACRO)             	ld2 R11,'O',sp,(4+1) ;reg:INDIRI2(addr)
     173/     1D3 : (MACRO)             	jneU2I R11,4,L34; NE
     174/     1DF :                     ;		dispatch(CODEADDR);
     175/     1DF : (MACRO)             	ldaD R12,0x8000; reg:acon
     176/     1E5 : (MACRO)             	Ccall _dispatch
     177/     1E8 :                     ;	} else if(ret=='T'){//timeout flag
     178/     1E8 : C0 01 E8            	lbr L35
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 4 - 1/18/2018 14:51:19


     179/     1EB :                     L34:
     180/     1EB : (MACRO)             	ld2 R11,'O',sp,(4+1) ;reg:INDIRI2(addr)
     181/     1F7 : (MACRO)             	jneU2I R11,84,L36; NE
     182/     203 :                     ;		dispatch(CODEADDR);
     183/     203 : (MACRO)             	ldaD R12,0x8000; reg:acon
     184/     209 : (MACRO)             	Ccall _dispatch
     185/     20C :                     ;	} else{
     186/     20C : C0 02 0C            	lbr L37
     187/     20F :                     L36:
     188/     20F :                     ;		printf("Interrupt - starting monitor\n");
     189/     20F : (MACRO)             	ldaD R12,L38; reg:acon
     190/     215 : (MACRO)             	Ccall _printf
     191/     218 :                     ;	}
     192/     218 :                     L37:
     193/     218 :                     L35:
     194/     218 :                     ;	return 0;
     195/     218 : (MACRO)             	ld2z R15
     196/     21C :                     L33:
     197/     21C : (MACRO)             	release 6
     198/     222 : (MACRO)             	Cretn
     199/     223 :                     
     200/     223 :                     ;$$function end$$ _bootload
     201/     223 :                     ;$$function start$$ _main
     202/     223 :                     _main: ;copt is peeping your size 24 frame with oct 23 rules
     203/     223 : (MACRO)             	reserve 8; save room for local variables
     204/     22B : (MACRO)             	pushr R0
     205/     22F : (MACRO)             	pushr R1
     206/     233 : (MACRO)             	pushr R6
     207/     237 : (MACRO)             	pushr R7
     208/     23B : (MACRO)             	reserve 6; save room for outgoing arguments
     209/     241 :                     ;void main(){
     210/     241 :                     ;	unsigned char cin='?';
     211/     241 : (MACRO)             	ldaD R7,63; reg:acon
     212/     247 :                     ;	unsigned char seqop=0x7b, reqop=0x7a, brop=0x30;
     213/     247 : (MACRO)             	ldA2 R11,'O',sp,(19+1); reg:addr
     214/     24F : (MACRO)             	str1I 123,R11; ASGNU1(indaddr,acon)	DH
     215/     252 : (MACRO)             	ldA2 R11,'O',sp,(18+1); reg:addr
     216/     25A : (MACRO)             	str1I 122,R11; ASGNU1(indaddr,acon)	DH
     217/     25D : (MACRO)             	ldA2 R11,'O',sp,(17+1); reg:addr
     218/     265 : (MACRO)             	str1I 48,R11; ASGNU1(indaddr,acon)	DH
     219/     268 :                     ;	unsigned char * addr=0;
     220/     268 : (MACRO)             	ldaD R0,0; reg:acon
     221/     26E :                     ;	unsigned int caddr=0;
     222/     26E : (MACRO)             	ld2z R1
     223/     272 :                     ;	asm(" seq\n"); //make sure Q is high to start
     224/     272 :                     ;	printf("\nSerial Monitor Here - CODEADDR is %x. Baudrate 9600\n",CODEADDR);
     225/     272 : 7B                   seq
     226/     273 : (MACRO)             	ldaD R12,L41; reg:acon
     227/     279 : (MACRO)             	ldaD R13,0x8000; reg:acon
     228/     27F : (MACRO)             	Ccall _printf
     229/     282 : C0 02 82            	lbr L43
     230/     285 :                     L42:
     231/     285 :                     ;	while(1){
     232/     285 :                     ;		printf("> ");
     233/     285 : (MACRO)             	ldaD R12,L45; reg:acon
     234/     28B : (MACRO)             	Ccall _printf
     235/     28E :                     ;		cin=getc();
     236/     28E : (MACRO)             	Ccall _getcser; CALLI2(ar)
     237/     291 : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     238/     295 : (MACRO)             	cpy1 R7,R11;LOADU1(reg)
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 5 - 1/18/2018 14:51:19


     239/     297 :                     ;		hexval=gethexit(cin);
     240/     297 : (MACRO)             	cpy1 R12,R7
     241/     299 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     242/     29C : (MACRO)             	Ccall _gethexit; CALLI2(ar)
     243/     29F : (MACRO)             	cpy2 R6,R15 ;LOADI2(reg)
     244/     2A3 : C0 02 A3            	lbr L47
     245/     2A6 :                     L46:
     246/     2A6 :                     ;		while(hexval>=0){//accumulate address entries - non hex digit characters will return -1
     247/     2A6 :                     ;			printf("%c",cin);
     248/     2A6 : (MACRO)             	ldaD R12,L49; reg:acon
     249/     2AC : (MACRO)             	cpy1 R13,R7
     250/     2AE : (MACRO)             	zExt R13 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     251/     2B1 : (MACRO)             	Ccall _printf
     252/     2B4 :                     ;			caddr*=16;caddr+=hexval;
     253/     2B4 : (MACRO)             	shl2I R1,4
     254/     2CC : (MACRO)             	cpy2 R11,R6 ;LOADU2*(reg)
     255/     2D0 : (MACRO)             	alu2 R1,R1,R11,add,adc; ADDU2(r,r)
     256/     2DA :                     ;			cin=getc();
     257/     2DA : (MACRO)             	Ccall _getcser; CALLI2(ar)
     258/     2DD : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     259/     2E1 : (MACRO)             	cpy1 R7,R11;LOADU1(reg)
     260/     2E3 :                     ;			hexval=gethexit(cin);
     261/     2E3 : (MACRO)             	cpy1 R12,R7
     262/     2E5 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     263/     2E8 : (MACRO)             	Ccall _gethexit; CALLI2(ar)
     264/     2EB : (MACRO)             	cpy2 R6,R15 ;LOADI2(reg)
     265/     2EF :                     ;		}
     266/     2EF :                     L47:
     267/     2EF :                     ;		while(hexval>=0){//accumulate address entries - non hex digit characters will return -1
     268/     2EF : (MACRO)             	jcI2I R6,0,lbdf,L46; GE is flipped test from LT
     269/     300 :                     ;		switch (cin){
     270/     300 : (MACRO)             	cpy1 R11,R7
     271/     302 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     272/     305 : (MACRO)             	st2 R11,'O',sp,(15+1); ASGNI2(addr,reg)
     273/     312 : (MACRO)             	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
     274/     31E : (MACRO)             	ldaD R10,63; reg:acon
     275/     324 : (MACRO)             	jeqI2 R11,R10,L64; EQI2(reg,reg)
     276/     332 : (MACRO)             	jcI2 R10,R11,lbnf,L78 ;GT is reversed operands from LT
     277/     344 :                     L77:
     278/     344 : (MACRO)             	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
     279/     350 : (MACRO)             	ldaD R10,33; reg:acon
     280/     356 : (MACRO)             	jeqI2 R11,R10,L66; EQI2(reg,reg)
     281/     364 : (MACRO)             	jcI2 R10,R11,lbnf,L80 ;GT is reversed operands from LT
     282/     376 :                     L79:
     283/     376 : (MACRO)             	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
     284/     382 : (MACRO)             	jeqU2I R11,13,L62;EQI2(reg,con)
     285/     38E : C0 03 8E            	lbr L50
     286/     391 :                     L80:
     287/     391 : (MACRO)             	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
     288/     39D : (MACRO)             	jeqU2I R11,43,L72;EQI2(reg,con)
     289/     3A9 : (MACRO)             	jeqU2I R11,45,L74;EQI2(reg,con)
     290/     3B5 : C0 03 B5            	lbr L50
     291/     3B8 :                     L78:
     292/     3B8 : (MACRO)             	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
     293/     3C4 : (MACRO)             	ldaD R10,114; reg:acon
     294/     3CA : (MACRO)             	jeqI2 R11,R10,L70; EQI2(reg,reg)
     295/     3D8 : (MACRO)             	jcI2 R10,R11,lbnf,L82 ;GT is reversed operands from LT
     296/     3EA :                     L81:
     297/     3EA : (MACRO)             	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
     298/     3F6 : (MACRO)             	jeqU2I R11,103,L68;EQI2(reg,con)
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 6 - 1/18/2018 14:51:19


     299/     402 : C0 04 02            	lbr L50
     300/     405 :                     L82:
     301/     405 : (MACRO)             	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
     302/     411 : (MACRO)             	jeqU2I R11,120,L53;EQI2(reg,con)
     303/     41D : C0 04 1D            	lbr L50
     304/     420 :                     L53:
     305/     420 :                     ;				printf("\nCalling XR in 2 sec\n",ret);
     306/     420 : (MACRO)             	ldaD R12,L54; reg:acon
     307/     426 : (MACRO)             	ld2 R13,'O',sp,(20+1) ;reg:INDIRI2(addr)
     308/     432 : (MACRO)             	Ccall _printf
     309/     435 :                     ;				delay(2000);
     310/     435 : (MACRO)             	ldaD R12,2000; reg:acon
     311/     43B : (MACRO)             	Ccall _delay
     312/     43E :                     ;				ret=XR(addr);
     313/     43E : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     314/     442 : (MACRO)             	Ccall _XR; CALLI2(ar)
     315/     445 : (MACRO)             	st2 R15,'O',sp,(20+1); ASGNI2(addr,reg)
     316/     452 :                     ;				printf("XR returns %x\n",ret);
     317/     452 : (MACRO)             	ldaD R12,L55; reg:acon
     318/     458 : (MACRO)             	ld2 R13,'O',sp,(20+1) ;reg:INDIRI2(addr)
     319/     464 : (MACRO)             	Ccall _printf
     320/     467 :                     ;				if (ret==EOT){
     321/     467 : (MACRO)             	ld2 R11,'O',sp,(20+1) ;reg:INDIRI2(addr)
     322/     473 : (MACRO)             	jneU2I R11,4,L56; NE
     323/     47F :                     ;					dump(addr,256);
     324/     47F : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     325/     483 : (MACRO)             	ldaD R13,256; reg:acon
     326/     489 : (MACRO)             	Ccall _dump
     327/     48C :                     ;				} else if(ret=='T'){//timeout flag
     328/     48C : C0 04 8C            	lbr L51
     329/     48F :                     L56:
     330/     48F : (MACRO)             	ld2 R11,'O',sp,(20+1) ;reg:INDIRI2(addr)
     331/     49B : (MACRO)             	jneU2I R11,84,L58; NE
     332/     4A7 :                     ;					printf("Timeout - no transfer\n");
     333/     4A7 : (MACRO)             	ldaD R12,L60; reg:acon
     334/     4AD : (MACRO)             	Ccall _printf
     335/     4B0 :                     ;				} else{
     336/     4B0 : C0 04 B0            	lbr L51
     337/     4B3 :                     L58:
     338/     4B3 :                     ;					printf("Interrupt - no transfer\n");
     339/     4B3 : (MACRO)             	ldaD R12,L61; reg:acon
     340/     4B9 : (MACRO)             	Ccall _printf
     341/     4BC :                     ;				}
     342/     4BC :                     ;				break;
     343/     4BC : C0 04 BC            	lbr L51
     344/     4BF :                     L62:
     345/     4BF :                     ;				printf("->%x\n",caddr);
     346/     4BF : (MACRO)             	ldaD R12,L63; reg:acon
     347/     4C5 : (MACRO)             	cpy2 R13,R1 ;LOADU2*(reg)
     348/     4C9 : (MACRO)             	Ccall _printf
     349/     4CC :                     ;				addr=(unsigned char *)caddr;caddr=0;
     350/     4CC : (MACRO)             	cpy2 R0,R1 ;LOADP2(reg)
     351/     4D0 : (MACRO)             	ld2z R1
     352/     4D4 :                     ;				dump(addr,16);
     353/     4D4 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     354/     4D8 : (MACRO)             	ldaD R13,16; reg:acon
     355/     4DE : (MACRO)             	Ccall _dump
     356/     4E1 :                     ;				break;
     357/     4E1 : C0 04 E1            	lbr L51
     358/     4E4 :                     L64:
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 7 - 1/18/2018 14:51:19


     359/     4E4 :                     ;				printf("?\n");
     360/     4E4 : (MACRO)             	ldaD R12,L65; reg:acon
     361/     4EA : (MACRO)             	Ccall _printf
     362/     4ED :                     ;				dump(addr,16);
     363/     4ED : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     364/     4F1 : (MACRO)             	ldaD R13,16; reg:acon
     365/     4F7 : (MACRO)             	Ccall _dump
     366/     4FA :                     ;				break;
     367/     4FA : C0 04 FA            	lbr L51
     368/     4FD :                     L66:
     369/     4FD :                     ;				printf("!\n");
     370/     4FD : (MACRO)             	ldaD R12,L67; reg:acon
     371/     503 : (MACRO)             	Ccall _printf
     372/     506 :                     ;				*addr=seqop;*(addr+1)=reqop;*(addr+2)=brop;*(addr+3)=(unsigned char)((unsigned int)addr&255); //poke in a loop
     373/     506 : (MACRO)             	ld1 R11,'O',sp,(19+1)
     374/     510 : (MACRO)             	str1 R11,R0; ASGNU1(indaddr,reg)		DH
     375/     512 : (MACRO)             	cpy2 R11,R0
     376/     516 : (MACRO)             	incm R11,1
     377/     517 : (MACRO)             	ld1 R10,'O',sp,(18+1)
     378/     521 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     379/     523 : (MACRO)             	cpy2 R11,R0
     380/     527 : (MACRO)             	incm R11,2
     381/     529 : (MACRO)             	ld1 R10,'O',sp,(17+1)
     382/     533 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     383/     535 : (MACRO)             	cpy2 R11,R0
     384/     539 : (MACRO)             	incm R11,3
     385/     53C : (MACRO)             	cpy2 R10,R0 ;LOADU2*(reg)
     386/     540 : (MACRO)             	alu2I R10,R10,255,ani,ani ;removed copy;BANDU2(reg,con)  
     387/     548 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     388/     54A :                     ;				dump(addr,16);
     389/     54A : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     390/     54E : (MACRO)             	ldaD R13,16; reg:acon
     391/     554 : (MACRO)             	Ccall _dump
     392/     557 :                     ;				break;
     393/     557 : C0 05 57            	lbr L51
     394/     55A :                     L68:
     395/     55A :                     ;				printf("g\n");
     396/     55A : (MACRO)             	ldaD R12,L69; reg:acon
     397/     560 : (MACRO)             	Ccall _printf
     398/     563 :                     ;				dispatch(addr);
     399/     563 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     400/     567 : (MACRO)             	Ccall _dispatch
     401/     56A :                     ;				break;
     402/     56A : C0 05 6A            	lbr L51
     403/     56D :                     L70:
     404/     56D :                     ;				printf("r\n");
     405/     56D : (MACRO)             	ldaD R12,L71; reg:acon
     406/     573 : (MACRO)             	Ccall _printf
     407/     576 :                     ;				regdump(REGADDR);
     408/     576 : (MACRO)             	ldaD R12,0xff00; reg:acon
     409/     57C : (MACRO)             	Ccall _regdump
     410/     57F :                     ;				break;
     411/     57F : C0 05 7F            	lbr L51
     412/     582 :                     L72:
     413/     582 :                     ;				printf("+\n");
     414/     582 : (MACRO)             	ldaD R12,L73; reg:acon
     415/     588 : (MACRO)             	Ccall _printf
     416/     58B :                     ;				addr+=16;
     417/     58B : (MACRO)             	ldA2 R0,'O',R0,(16); reg:addr
     418/     593 :                     ;				dump(addr,16);
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 8 - 1/18/2018 14:51:19


     419/     593 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     420/     597 : (MACRO)             	ldaD R13,16; reg:acon
     421/     59D : (MACRO)             	Ccall _dump
     422/     5A0 :                     ;				break;
     423/     5A0 : C0 05 A0            	lbr L51
     424/     5A3 :                     L74:
     425/     5A3 :                     ;				printf("-\n");
     426/     5A3 : (MACRO)             	ldaD R12,L75; reg:acon
     427/     5A9 : (MACRO)             	Ccall _printf
     428/     5AC :                     ;				addr-=16;
     429/     5AC : (MACRO)             	ldA2 R0,'O',R0,(-16); reg:addr
     430/     5B4 :                     ;				dump(addr,16);
     431/     5B4 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     432/     5B8 : (MACRO)             	ldaD R13,16; reg:acon
     433/     5BE : (MACRO)             	Ccall _dump
     434/     5C1 :                     ;				break;
     435/     5C1 : C0 05 C1            	lbr L51
     436/     5C4 :                     L50:
     437/     5C4 :                     ;				printf("%c/%cx unrecognized\n",cin,cin);
     438/     5C4 : (MACRO)             	ldaD R12,L76; reg:acon
     439/     5CA : (MACRO)             	cpy1 R11,R7
     440/     5CC : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     441/     5CF : (MACRO)             	cpy2 R13,R11 ;LOADI2(reg)
     442/     5D3 : (MACRO)             	st2 R11,'O',sp,(4+1); arg+f**
     443/     5E0 : (MACRO)             	Ccall _printf
     444/     5E3 :                     ;				break;
     445/     5E3 :                     L51:
     446/     5E3 :                     ;	}
     447/     5E3 :                     L43:
     448/     5E3 :                     ;	while(1){
     449/     5E3 : C0 02 85            	lbr L42
     450/     5E6 :                     ;}
     451/     5E6 :                     L39:
     452/     5E6 : (MACRO)             	release 6; release room for outgoing arguments
     453/     5EC : (MACRO)             	popf R7	;opt11.3
     454/     5F1 : (MACRO)             	popm R6	;opt11.4
     455/     5F5 : (MACRO)             	popm R1	;opt11.4
     456/     5F9 : (MACRO)             	popl R0	;opt11.4
     457/     5FD : (MACRO)             	release 8; release room for local variables 
     458/     605 : (MACRO)             	Cretn
     459/     606 :                     
     460/     606 :                     ;$$function end$$ _main
     461/     606 :                     ;$$function start$$ _includeser2
     462/     606 :                     _includeser2:		;framesize=2
     463/     606 :                     ;void includeser2(){
     464/     606 :                     ;	asm("BAUDRATE EQU 	9600\n");
     465/     606 :                     ;	asm(" include xrwjrT3.inc\n");
     466/     606 :                     ;	asm(" include serwjrT3.inc\n");
     467/     606 : =2580H              BAUDRATE EQU 	9600
     468/     606 :                      include xrwjrT3.inc
(1)    1/     606 : =15H                NAK:	EQU 0x15
(1)    2/     606 : =1H                 SOH:	EQU 0x01
(1)    3/     606 : =4H                 EOT:	EQU 0x04
(1)    4/     606 : =6H                 ACK:	EQU 0x06
(1)    5/     606 : =18H                CAN:	EQU 0x18
(1)    6/     606 : =8H                 Rrcv:	EQU 8
(1)    7/     606 : =9H                 Rsnd:	EQU 9
(1)    8/     606 : =80H                blksize:	EQU 128
(1)    9/     606 :                     ; XMODEM receiver based on xr.asm by Michael H Riley and serial routines by Josh Bensadon   
(1)   10/     606 :                     ; See bottom of file for full acknowledgements and links.
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(xrwjrT3.inc) - page 9 - 1/18/2018 14:51:19


(1)   11/     606 :                     ; On entry R12 points to memory where received data will go
(1)   12/     606 :                     ; On exit R15 =EOT for success, 'T' for timeout, or ffxx where xx is the first char received if other than SOH or EOT
(1)   13/     606 :                     
(1)   14/     606 :                     	align 64
(1)   15/     640 : (MACRO)             _XR:	ldaD	Rsnd,serout
(1)   16/     646 : (MACRO)             	ldaD    Rrcv,serinT
(1)   17/     64C : (MACRO)             	ld2z	R15	;clear the return code
(1)   18/     650 :                     
(1)   19/     650 :                     
(1)   20/     650 : F8 15               initNAK: ldi    NAK	; need to send NAK to start
(1)   21/     652 : D9                  	sep     Rsnd
(1)   22/     653 : D8                  	sep     Rrcv  	; wait for next incoming character
(1)   23/     654 : 3B 54               	bnf     ckeot	;continue if no timeout
(1)   24/     656 :                     
(1)   25/     656 : F8 15               	ldi     NAK	; resend NAK to start
(1)   26/     658 : D9                        	sep     Rsnd
(1)   27/     659 : D8                        	sep     Rrcv    ; wait for next incoming character
(1)   28/     65A : 3B 5A                       bnf     ckeot	;continue if no timeout
(1)   29/     65C :                     
(1)   30/     65C : F8 15               	ldi     NAK	; resend NAK to start
(1)   31/     65E : D9                        	sep     Rsnd
(1)   32/     65F : D8                        	sep     Rrcv    ; wait for next incoming character
(1)   33/     660 : 3B 60                       bnf     ckeot	;continue if no timeout
(1)   34/     662 :                     
(1)   35/     662 : F8 54               	ldi	'T'	;set return value to 'T'
(1)   36/     664 : AF                  	plo	R15
(1)   37/     665 : (MACRO)             	cretn
(1)   38/     666 :                     
(1)   39/     666 :                     filelp:    ;receive address is in R12
(1)   40/     666 :                     
(1)   41/     666 :                     ;begining of block read. returns to filelp or exits to filedn   				
(1)   42/     666 : D8                             sep     Rrcv               ; wait for next incoming character(will not time out)
(1)   43/     667 :                     
(1)   44/     667 : AF                  ckeot:    plo	   R15		; save char received
(1)   45/     668 : FB 04               	   xri     EOT          ; check for EOT
(1)   46/     66A : C2 06 6A                       lbz     filedn       ; jump if so
(1)   47/     66D : 8F                             glo	   R15		;
(1)   48/     66E : FB 01                          xri	   SOH		; check for SOH   
(1)   49/     670 : CA 06 70                       lbnz	   interrupt	; interrupted transmission - return interrupting character
(1)   50/     673 :                     
(1)   51/     673 : D8                  	   sep     Rrcv               ; read block number
(1)   52/     674 : D8                             sep     Rrcv               ; read inverted block number
(1)   53/     675 :                     
(1)   54/     675 : F8 80                          ldi     blksize             ; 128 bytes to receive
(1)   55/     677 : AB                             plo     r11
(1)   56/     678 :                     
(1)   57/     678 : D8                  readlp:    sep     Rrcv               ; read data byte
(1)   58/     679 : 5C                             str     r12                  ; store into output buffer
(1)   59/     67A : 1C                             inc     r12                  ; point to next position
(1)   60/     67B : 2B                             dec     r11                  ; decrement block count
(1)   61/     67C : 8B                             glo     r11                  ; see if done
(1)   62/     67D : 3A 78                          bnz     readlp              ; loop back if not
(1)   63/     67F :                     ;end of block read
(1)   64/     67F : D8                             sep     Rrcv               ; read checksum byte
(1)   65/     680 :                     
(1)   66/     680 :                     
(1)   67/     680 : F8 06                          ldi     ACK                  ; send an ACK
(1)   68/     682 : D9                             sep     Rsnd
(1)   69/     683 : C0 06 66                       lbr     filelp              ; loop back for more
(1)   70/     686 :                     
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(xrwjrT3.inc) - page 10 - 1/18/2018 14:51:19


(1)   71/     686 :                     filedn:    
(1)   72/     686 : F8 06                          ldi     ACK                  ; acknowledge end of transmission
(1)   73/     688 : D9                             sep     Rsnd
(1)   74/     689 : (MACRO)                        cretn	           	; and return to caller - R15 contains EOT
(1)   75/     68A :                     
(1)   76/     68A :                     interrupt:    
(1)   77/     68A : F8 18                          ldi     CAN                  ; invalid char received - try to cancel the session
(1)   78/     68C : D9                             sep     Rsnd
(1)   79/     68D : F8 FF                          ldi	   0xff			;make sure R15 isn't 0
(1)   80/     68F : BF                             phi     R15
(1)   81/     690 : (MACRO)                        cretn	           	; and return to caller - R15 contains interrupting character
(1)   82/     691 :                     
(1)   83/     691 :                     
(1)   84/     691 :                     ; *******************************************************************
(1)   85/     691 :                     ; *** This software is copyright 2005 by Michael H Riley          ***
(1)   86/     691 :                     ; *** You have permission to use, modify, copy, and distribute    ***
(1)   87/     691 :                     ; *** this software so long as this copyright notice is retained. ***
(1)   88/     691 :                     ; *** This software may not be used in commercial applications    ***
(1)   89/     691 :                     ; *** without express written permission from the author.         ***
(1)   90/     691 :                     ; *******************************************************************
(1)   91/     691 :                     ; *********************************************************************
(1)   92/     691 :                     ; *** xmodem code based on xr.asm copyright 2005 by Michael H Riley ***
(1)   93/     691 :                     ; *** You have permission to use, modify, copy, and distribute      ***
(1)   94/     691 :                     ; *** this software so long as this copyright notice is retained.   ***
(1)   95/     691 :                     ; *** This software may not be used in commercial applications      ***
(1)   96/     691 :                     ; *** without express written permission from the author.           ***
(1)   97/     691 :                     ; *********************************************************************
(1)   98/     691 :                     ;http://www.elf-emulation.com/software.html
(1)   99/     691 :                     
     469/     691 :                      include serwjrT3.inc
(1)    1/     691 :                     ;bit-bang Serial routines adapted from Josh Bensadon's VELFbios-v3.1.asm
(1)    2/     691 :                     ;https://groups.yahoo.com/neo/groups/cosmacelf/files/Member-JoshBensadon/
(1)    3/     691 :                     ;Transmit Byte via Q connected to RS232 driver
(1)    4/     691 :                     ;call via sep, returns via sep R3
(1)    5/     691 :                     ;Byte to send in D
(1)    6/     691 :                     ;Destroys r14
(1)    7/     691 :                     ;17-12-08 this version times out on the first call only - approx .6 sec
(1)    8/     691 :                     ;----------------------------------------------------------------------
(1)    9/     691 : =>DEFINED            	IFNDEF 	CPUSPEED
(1)   10/     691 :                     CPUSPEED EQU 4000000
(1)   11/     691 : [9]                  	ENDIF
(1)   12/     691 : =>DEFINED            	IFNDEF 	BAUDRATE
(1)   13/     691 :                     BAUDRATE EQU 9600
(1)   14/     691 : [12]                 	ENDIF
> > >serwjrT3.inc(15): warning: deprecated instruction
> > > use MACEXP_DFT
(1)   15/     691 :                      	MACEXP ON
(1)   16/     691 :                     ;
(1)   17/     691 :                     bitdelay: MACRO baudrate,cpuspeed,baseline,xreg
(1)   18/     691 :                     	rept ((cpuspeed/(baudrate*8)-baseline))/3
(1)   19/     691 :                     	NOP
(1)   20/     691 :                     	endm
(1)   21/     691 :                     	rept (((cpuspeed/(baudrate*8)-baseline)#3))>=1
(1)   22/     691 :                     	sex xreg
(1)   23/     691 :                     	endm
(1)   24/     691 :                     	ENDM
(1)   25/     691 :                     
(1)   26/     691 :                     	align 128
(1)   27/     700 :                     serout:			;entry from assembly with char in D
(1)   28/     700 : BE                  	phi R14		;save char in R14.1
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(serwjrT3.inc) - page 11 - 1/18/2018 14:51:19


(1)   29/     701 : F8 09               	ldi 9		;9 bits to transmit (1 start + 8 data)
(1)   30/     703 : AE                  	plo r14
(1)   31/     704 : 9E                  	ghi R14
(1)   32/     705 : FE                  	shl		;set start bit
(1)   33/     706 : 76                  	rshr		;DF=0
(1)   34/     707 :                     
(1)   35/     707 :                     .txcloop:
(1)   36/     707 : 33 0C               	bdf $+5		;10.5   jump to seq to send a 1 bit
(1)   37/     709 : 7A                  	req		;11.5   send a 0 bit
(1)   38/     70A : 30 0F               	br $+5		;1      jump +5 to next shift
(1)   39/     70C : 7B                  	seq		;11.5   send a 1 bit
(1)   40/     70D : 30 0F               	br $+2		;1      jump +2 to next shift (NOP for timing)
(1)   41/     70F : 76                  	rshr		;2      shift next bit to DF flag
(1)   42/     710 : BE                  	phi r14		;3      save D in r14.1
(1)   43/     711 : 2E                  	DEC r14		;4      dec bit count
(1)   44/     712 : 8E                  	glo r14		;5      get bit count
(1)   45/     713 : 32 13               	bz .txcret	;6      if 0 then all 9 bits (start and data) sent
(1)   46/     715 : 9E                  	ghi r14		;7      restore D
(1)   47/     716 : (MACRO)             	bitdelay BAUDRATE,CPUSPEED,20,2,{EXPAND}
(1)   47/     716 :                             rept ((CPUSPEED/(BAUDRATE*8)-20))/3
(1)   47/     716 :                             NOP
(1)   47/     716 :                             endm
(1)   47/     716 : C4                          NOP
(1)   47/     717 : C4                          NOP
(1)   47/     718 : C4                          NOP
(1)   47/     719 : C4                          NOP
(1)   47/     71A : C4                          NOP
(1)   47/     71B : C4                          NOP
(1)   47/     71C : C4                          NOP
(1)   47/     71D : C4                          NOP
(1)   47/     71E : C4                          NOP
(1)   47/     71F : C4                          NOP
(1)   47/     720 : C4                          NOP
(1)   47/     721 : C4                          NOP
(1)   47/     722 : C4                          NOP
(1)   47/     723 : C4                          NOP
(1)   47/     724 : C4                          NOP
(1)   47/     725 : C4                          NOP
(1)   47/     726 : C4                          NOP
(1)   47/     727 : C4                          NOP
(1)   47/     728 : C4                          NOP
(1)   47/     729 : C4                          NOP
(1)   47/     72A : C4                          NOP
(1)   47/     72B : C4                          NOP
(1)   47/     72C : C4                          NOP
(1)   47/     72D : C4                          NOP
(1)   47/     72E : C4                          NOP
(1)   47/     72F : C4                          NOP
(1)   47/     730 : C4                          NOP
(1)   47/     731 : C4                          NOP
(1)   47/     732 : C4                          NOP
(1)   47/     733 : C4                          NOP
(1)   47/     734 : C4                          NOP
(1)   47/     735 : C4                          NOP
(1)   47/     736 : C4                          NOP
(1)   47/     737 : C4                          NOP
(1)   47/     738 : C4                          NOP
(1)   47/     739 : C4                          NOP
(1)   47/     73A : C4                          NOP
(1)   47/     73B : C4                          NOP
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(serwjrT3.inc) - page 12 - 1/18/2018 14:51:19


(1)   47/     73C : C4                          NOP
(1)   47/     73D : C4                          NOP
(1)   47/     73E : C4                          NOP
(1)   47/     73F : C4                          NOP
(1)   47/     740 : C4                          NOP
(1)   47/     741 : C4                          NOP
(1)   47/     742 : C4                          NOP
(1)   47/     743 :                             rept (((CPUSPEED/(BAUDRATE*8)-20)#3))>=1
(1)   47/     743 :                             sex 2
(1)   47/     743 :                             endm
(1)   47/     743 : E2                          sex 2
(1)   48/     744 : 30 07               	br .txcloop	;9.5    loop back to send next bit
(1)   49/     746 : 9E                  .txcret: ghi r14		;7
(1)   50/     747 : (MACRO)             	bitdelay BAUDRATE,CPUSPEED,16,2
(1)   50/     747 :                             rept ((CPUSPEED/(BAUDRATE*8)-16))/3
(1)   50/     747 :                             NOP
(1)   50/     747 :                             endm
(1)   50/     747 : C4                          NOP
(1)   50/     748 : C4                          NOP
(1)   50/     749 : C4                          NOP
(1)   50/     74A : C4                          NOP
(1)   50/     74B : C4                          NOP
(1)   50/     74C : C4                          NOP
(1)   50/     74D : C4                          NOP
(1)   50/     74E : C4                          NOP
(1)   50/     74F : C4                          NOP
(1)   50/     750 : C4                          NOP
(1)   50/     751 : C4                          NOP
(1)   50/     752 : C4                          NOP
(1)   50/     753 : C4                          NOP
(1)   50/     754 : C4                          NOP
(1)   50/     755 : C4                          NOP
(1)   50/     756 : C4                          NOP
(1)   50/     757 : C4                          NOP
(1)   50/     758 : C4                          NOP
(1)   50/     759 : C4                          NOP
(1)   50/     75A : C4                          NOP
(1)   50/     75B : C4                          NOP
(1)   50/     75C : C4                          NOP
(1)   50/     75D : C4                          NOP
(1)   50/     75E : C4                          NOP
(1)   50/     75F : C4                          NOP
(1)   50/     760 : C4                          NOP
(1)   50/     761 : C4                          NOP
(1)   50/     762 : C4                          NOP
(1)   50/     763 : C4                          NOP
(1)   50/     764 : C4                          NOP
(1)   50/     765 : C4                          NOP
(1)   50/     766 : C4                          NOP
(1)   50/     767 : C4                          NOP
(1)   50/     768 : C4                          NOP
(1)   50/     769 : C4                          NOP
(1)   50/     76A : C4                          NOP
(1)   50/     76B : C4                          NOP
(1)   50/     76C : C4                          NOP
(1)   50/     76D : C4                          NOP
(1)   50/     76E : C4                          NOP
(1)   50/     76F : C4                          NOP
(1)   50/     770 : C4                          NOP
(1)   50/     771 : C4                          NOP
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(serwjrT3.inc) - page 13 - 1/18/2018 14:51:19


(1)   50/     772 : C4                          NOP
(1)   50/     773 : C4                          NOP
(1)   50/     774 : C4                          NOP
(1)   50/     775 :                             rept (((CPUSPEED/(BAUDRATE*8)-16)#3))>=1
(1)   50/     775 :                             sex 2
(1)   50/     775 :                             endm
(1)   50/     775 : E2                          sex 2
(1)   51/     776 : 7B                  	seq		;11.5 stop bit
(1)   52/     777 : (MACRO)             	bitdelay BAUDRATE,CPUSPEED,4,2
(1)   52/     777 :                             rept ((CPUSPEED/(BAUDRATE*8)-4))/3
(1)   52/     777 :                             NOP
(1)   52/     777 :                             endm
(1)   52/     777 : C4                          NOP
(1)   52/     778 : C4                          NOP
(1)   52/     779 : C4                          NOP
(1)   52/     77A : C4                          NOP
(1)   52/     77B : C4                          NOP
(1)   52/     77C : C4                          NOP
(1)   52/     77D : C4                          NOP
(1)   52/     77E : C4                          NOP
(1)   52/     77F : C4                          NOP
(1)   52/     780 : C4                          NOP
(1)   52/     781 : C4                          NOP
(1)   52/     782 : C4                          NOP
(1)   52/     783 : C4                          NOP
(1)   52/     784 : C4                          NOP
(1)   52/     785 : C4                          NOP
(1)   52/     786 : C4                          NOP
(1)   52/     787 : C4                          NOP
(1)   52/     788 : C4                          NOP
(1)   52/     789 : C4                          NOP
(1)   52/     78A : C4                          NOP
(1)   52/     78B : C4                          NOP
(1)   52/     78C : C4                          NOP
(1)   52/     78D : C4                          NOP
(1)   52/     78E : C4                          NOP
(1)   52/     78F : C4                          NOP
(1)   52/     790 : C4                          NOP
(1)   52/     791 : C4                          NOP
(1)   52/     792 : C4                          NOP
(1)   52/     793 : C4                          NOP
(1)   52/     794 : C4                          NOP
(1)   52/     795 : C4                          NOP
(1)   52/     796 : C4                          NOP
(1)   52/     797 : C4                          NOP
(1)   52/     798 : C4                          NOP
(1)   52/     799 : C4                          NOP
(1)   52/     79A : C4                          NOP
(1)   52/     79B : C4                          NOP
(1)   52/     79C : C4                          NOP
(1)   52/     79D : C4                          NOP
(1)   52/     79E : C4                          NOP
(1)   52/     79F : C4                          NOP
(1)   52/     7A0 : C4                          NOP
(1)   52/     7A1 : C4                          NOP
(1)   52/     7A2 : C4                          NOP
(1)   52/     7A3 : C4                          NOP
(1)   52/     7A4 : C4                          NOP
(1)   52/     7A5 : C4                          NOP
(1)   52/     7A6 : C4                          NOP
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(serwjrT3.inc) - page 14 - 1/18/2018 14:51:19


(1)   52/     7A7 : C4                          NOP
(1)   52/     7A8 : C4                          NOP
(1)   52/     7A9 :                             rept (((CPUSPEED/(BAUDRATE*8)-4)#3))>=1
(1)   52/     7A9 :                             sex 2
(1)   52/     7A9 :                             endm
(1)   52/     7A9 : E2                          sex 2
(1)   53/     7AA : D3                  	sep R3		;return 
(1)   54/     7AB : 30 00               	br serout	;reset for next time
(1)   55/     7AD :                     ;**********************************************************************
(1)   56/     7AD :                     ;serinT
(1)   57/     7AD :                     ;Receive Byte via EF3 connected to RS232 receiver
(1)   58/     7AD :                     ;Receives 8 bits
(1)   59/     7AD :                     ;call via sep
(1)   60/     7AD :                     ;Returns with Byte received in D, DF is set if the start bit is never seen
(1)   61/     7AD :                     ;Destroys r14
(1)   62/     7AD :                     ;----------------------------------------------------------------------
(1)   63/     7AD :                     	align 64
(1)   64/     7C0 :                     serinT:	;serial input with timeout of  approx .6 sec - scales with CPU speed as much as possible
(1)   65/     7C0 : =120H               toct	set  (CPUSPEED/1000000)*24
(1)   66/     7C0 : =>TRUE              	if toct>255
(1)   67/     7C0 : =FFH                toct set 255
(1)   68/     7C0 : [66]                	endif
(1)   69/     7C0 : F8 FF               	ldi toct
(1)   70/     7C2 : BE                  	phi 14
(1)   71/     7C3 : AE                  	plo 14
(1)   72/     7C4 : 36 C4               .rxcw:	b3 .okgo	;check for start bit after each instruction
(1)   73/     7C6 : 2E                  	dec 14
(1)   74/     7C7 : 36 C7               	b3 .okgo	;check for start bit after each instruction
(1)   75/     7C9 : 9E                  	ghi 14
(1)   76/     7CA : 36 CA               	b3 .okgo	;check for start bit after each instruction
(1)   77/     7CC : 3A C4               	bnz .rxcw
(1)   78/     7CE :                     ;here we've had a timeout - set DF and return
(1)   79/     7CE : F8 01               	ldi 1
(1)   80/     7D0 : F6                  	shr
(1)   81/     7D1 : D3                  	sep R3		;return
(1)   82/     7D2 : 30 C0               	br  serinT	;for next time
(1)   83/     7D4 : 3E D4               .serinN: bn3 .serinN	;serial input without timeout	
(1)   84/     7D6 :                     .okgo:			;here we know the start bit is present
(1)   85/     7D6 : F8 08                	ldi 8		;start bit +7 bits from loop, last bit on returning
(1)   86/     7D8 : AE                  	plo r14
(1)   87/     7D9 : F8 00               	ldi 0
(1)   88/     7DB : C4                  	NOP		;delay to center samples
(1)   89/     7DC :                     
(1)   90/     7DC :                     .rxcloop:
(1)   91/     7DC : (MACRO)             	bitdelay BAUDRATE,CPUSPEED,20,2
(1)   91/     7DC :                             rept ((CPUSPEED/(BAUDRATE*8)-20))/3
(1)   91/     7DC :                             NOP
(1)   91/     7DC :                             endm
(1)   91/     7DC : C4                          NOP
(1)   91/     7DD : C4                          NOP
(1)   91/     7DE : C4                          NOP
(1)   91/     7DF : C4                          NOP
(1)   91/     7E0 : C4                          NOP
(1)   91/     7E1 : C4                          NOP
(1)   91/     7E2 : C4                          NOP
(1)   91/     7E3 : C4                          NOP
(1)   91/     7E4 : C4                          NOP
(1)   91/     7E5 : C4                          NOP
(1)   91/     7E6 : C4                          NOP
(1)   91/     7E7 : C4                          NOP
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(serwjrT3.inc) - page 15 - 1/18/2018 14:51:19


(1)   91/     7E8 : C4                          NOP
(1)   91/     7E9 : C4                          NOP
(1)   91/     7EA : C4                          NOP
(1)   91/     7EB : C4                          NOP
(1)   91/     7EC : C4                          NOP
(1)   91/     7ED : C4                          NOP
(1)   91/     7EE : C4                          NOP
(1)   91/     7EF : C4                          NOP
(1)   91/     7F0 : C4                          NOP
(1)   91/     7F1 : C4                          NOP
(1)   91/     7F2 : C4                          NOP
(1)   91/     7F3 : C4                          NOP
(1)   91/     7F4 : C4                          NOP
(1)   91/     7F5 : C4                          NOP
(1)   91/     7F6 : C4                          NOP
(1)   91/     7F7 : C4                          NOP
(1)   91/     7F8 : C4                          NOP
(1)   91/     7F9 : C4                          NOP
(1)   91/     7FA : C4                          NOP
(1)   91/     7FB : C4                          NOP
(1)   91/     7FC : C4                          NOP
(1)   91/     7FD : C4                          NOP
(1)   91/     7FE : C4                          NOP
(1)   91/     7FF : C4                          NOP
(1)   91/     800 : C4                          NOP
(1)   91/     801 : C4                          NOP
(1)   91/     802 : C4                          NOP
(1)   91/     803 : C4                          NOP
(1)   91/     804 : C4                          NOP
(1)   91/     805 : C4                          NOP
(1)   91/     806 : C4                          NOP
(1)   91/     807 : C4                          NOP
(1)   91/     808 : C4                          NOP
(1)   91/     809 :                             rept (((CPUSPEED/(BAUDRATE*8)-20)#3))>=1
(1)   91/     809 :                             sex 2
(1)   91/     809 :                             endm
(1)   91/     809 : E2                          sex 2
(1)   92/     80A : 36 10               	b3 $+6		;11.5 sample rx input bit
(1)   93/     80C : F9 80               	ori 80h		;1
(1)   94/     80E : 30 12               	br $+4		;2
(1)   95/     810 : BE                  	phi r14		;1
(1)   96/     811 : BE                  	phi r14		;2
(1)   97/     812 : F6                  	shr		;3
(1)   98/     813 : BE                  	phi r14		;4
(1)   99/     814 : 2E                  	DEC r14		;5
(1)  100/     815 : 8E                  	glo r14		;6
(1)  101/     816 : 32 16               	bz .rxcret	;7
(1)  102/     818 : 9E                  	ghi r14		;8
> > >serwjrT3.inc(103): error: jump target not on same page
(1)  103/     819 :                     	br  .rxcloop	;9
(1)  104/     819 : 9E                  .rxcret: ghi r14	;8
(1)  105/     81A : 9E                  	ghi r14		;9
(1)  106/     81B : (MACRO)             	bitdelay BAUDRATE,CPUSPEED,20,2
(1)  106/     81B :                             rept ((CPUSPEED/(BAUDRATE*8)-20))/3
(1)  106/     81B :                             NOP
(1)  106/     81B :                             endm
(1)  106/     81B : C4                          NOP
(1)  106/     81C : C4                          NOP
(1)  106/     81D : C4                          NOP
(1)  106/     81E : C4                          NOP
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(serwjrT3.inc) - page 16 - 1/18/2018 14:51:19


(1)  106/     81F : C4                          NOP
(1)  106/     820 : C4                          NOP
(1)  106/     821 : C4                          NOP
(1)  106/     822 : C4                          NOP
(1)  106/     823 : C4                          NOP
(1)  106/     824 : C4                          NOP
(1)  106/     825 : C4                          NOP
(1)  106/     826 : C4                          NOP
(1)  106/     827 : C4                          NOP
(1)  106/     828 : C4                          NOP
(1)  106/     829 : C4                          NOP
(1)  106/     82A : C4                          NOP
(1)  106/     82B : C4                          NOP
(1)  106/     82C : C4                          NOP
(1)  106/     82D : C4                          NOP
(1)  106/     82E : C4                          NOP
(1)  106/     82F : C4                          NOP
(1)  106/     830 : C4                          NOP
(1)  106/     831 : C4                          NOP
(1)  106/     832 : C4                          NOP
(1)  106/     833 : C4                          NOP
(1)  106/     834 : C4                          NOP
(1)  106/     835 : C4                          NOP
(1)  106/     836 : C4                          NOP
(1)  106/     837 : C4                          NOP
(1)  106/     838 : C4                          NOP
(1)  106/     839 : C4                          NOP
(1)  106/     83A : C4                          NOP
(1)  106/     83B : C4                          NOP
(1)  106/     83C : C4                          NOP
(1)  106/     83D : C4                          NOP
(1)  106/     83E : C4                          NOP
(1)  106/     83F : C4                          NOP
(1)  106/     840 : C4                          NOP
(1)  106/     841 : C4                          NOP
(1)  106/     842 : C4                          NOP
(1)  106/     843 : C4                          NOP
(1)  106/     844 : C4                          NOP
(1)  106/     845 : C4                          NOP
(1)  106/     846 : C4                          NOP
(1)  106/     847 : C4                          NOP
(1)  106/     848 :                             rept (((CPUSPEED/(BAUDRATE*8)-20)#3))>=1
(1)  106/     848 :                             sex 2
(1)  106/     848 :                             endm
(1)  106/     848 : E2                          sex 2
(1)  107/     849 : 36 4D               	b3 $+4		;11.5 sample last rx input bit
(1)  108/     84B : F9 80               	ori 80h		; for a 1 bit
(1)  109/     84D : FC 00               	adi 0		;clear the DF flag because no timeout
(1)  110/     84F : D3                  	sep R3		;return
> > >serwjrT3.inc(111): error: jump target not on same page
(1)  111/     850 :                     	br  .serinN	;for next time - only timeout on first call
(1)  112/     850 :                     ;
(1)  113/     850 : =7D4H               serinN equ .serinN
(1)  114/     850 :                     _getcser:
(1)  115/     850 : (MACRO)             	ldad Rrcv,serinN
(1)  115/     850 : =>FALSE              if MOMCPU=$1805
(1)  115/     850 :                             RLDI    RRCV,SERINN
(1)  115/     850 : =>TRUE               else
(1)  115/     850 : F8 D4                       ldi     (SERINN)&255
(1)  115/     852 : A8                          plo     RRCV
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(serwjrT3.inc) - page 17 - 1/18/2018 14:51:19


(1)  115/     853 : F8 07                       ldi     (SERINN)>>8; was/256
(1)  115/     855 : B8                          phi     RRCV
(1)  115/     856 : [115]                endif
(1)  116/     856 : D8                  	sep Rrcv
(1)  117/     857 : AF                  	plo R15
(1)  118/     858 : F8 00               	ldi 0
(1)  119/     85A : BF                  	phi R15
(1)  120/     85B : (MACRO)             	cretn
(1)  120/     85B : =>FALSE              if MOMCPU=$1805
(1)  120/     85B :                             sret    6
(1)  120/     85B : =>TRUE               else
(1)  120/     85B : D5                          sep     RRET
(1)  120/     85C : [120]                endif
(1)  121/     85C :                     _putcser:
(1)  122/     85C : (MACRO)             	ldad Rsnd,serout
(1)  122/     85C : =>FALSE              if MOMCPU=$1805
(1)  122/     85C :                             RLDI    RSND,SEROUT
(1)  122/     85C : =>TRUE               else
(1)  122/     85C : F8 00                       ldi     (SEROUT)&255
(1)  122/     85E : A9                          plo     RSND
(1)  122/     85F : F8 07                       ldi     (SEROUT)>>8; was/256
(1)  122/     861 : B9                          phi     RSND
(1)  122/     862 : [122]                endif
(1)  123/     862 : 8C                  	glo R12
(1)  124/     863 : D9                  	sep Rsnd
(1)  125/     864 : (MACRO)             	cretn
(1)  125/     864 : =>FALSE              if MOMCPU=$1805
(1)  125/     864 :                             sret    6
(1)  125/     864 : =>TRUE               else
(1)  125/     864 : D5                          sep     RRET
(1)  125/     865 : [125]                endif
(1)  126/     865 :                     	
(1)  127/     865 :                     
     470/     865 :                     ;}
     471/     865 :                     L83:
     472/     865 : (MACRO)             	Cretn
     472/     865 : =>FALSE              if MOMCPU=$1805
     472/     865 :                             sret    6
     472/     865 : =>TRUE               else
     472/     865 : D5                          sep     RRET
     472/     866 : [472]                endif
     473/     866 :                     
     474/     866 :                     ;$$function end$$ _includeser2
     475/     866 :                     ;$$function start$$ _delay
     476/     866 :                     _delay:		;framesize=10
     477/     866 : (MACRO)             	pushr R6
     477/     866 : =>FALSE              if MOMCPU=$1805
     477/     866 :                             RSXD    R6
     477/     866 : =>TRUE               else
     477/     866 : 86                          glo     R6
     477/     867 : 73                          stxd
     477/     868 : 96                          ghi     R6
     477/     869 : 73                          stxd
     477/     86A : [477]                endif
     478/     86A : (MACRO)             	pushr R7
     478/     86A : =>FALSE              if MOMCPU=$1805
     478/     86A :                             RSXD    R7
     478/     86A : =>TRUE               else
     478/     86A : 87                          glo     R7
     478/     86B : 73                          stxd
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 18 - 1/18/2018 14:51:19


     478/     86C : 97                          ghi     R7
     478/     86D : 73                          stxd
     478/     86E : [478]                endif
     479/     86E : (MACRO)             	reserve 4; save room for outgoing arguments
     479/     86E : =>TRUE                      if (4<9)
     479/     86E :  (MACRO-2)                      reserveS 4  ;use dec for small amounts
     479/     86E :                             rept    4
     479/     86E :                             dec sp
     479/     86E :                             endm
     479/     86E : 22                          dec sp
     479/     86F : 22                          dec sp
     479/     870 : 22                          dec sp
     479/     871 : 22                          dec sp
     479/     872 : =>FALSE                     else
     479/     872 :                                 reserveL 4  ;use subtract for large amounts
     479/     872 : [479]                       endif
     480/     872 : (MACRO)             	cpy2 R7,R12; function(2054) 1
     480/     872 : 8C                          glo     R12
     480/     873 : A7                          plo     R7
     480/     874 : 9C                          ghi     R12
     480/     875 : B7                          phi     R7
     481/     876 :                     ;void delay(unsigned int howlong){
     482/     876 :                     ;	for (i=1;i!=howlong;i++){
     483/     876 : (MACRO)             	ldaD R6,1; reg:acon
     483/     876 : =>FALSE              if MOMCPU=$1805
     483/     876 :                             RLDI    R6,1
     483/     876 : =>TRUE               else
     483/     876 : F8 01                       ldi     (1)&255
     483/     878 : A6                          plo     R6
     483/     879 : F8 00                       ldi     (1)>>8; was/256
     483/     87B : B6                          phi     R6
     483/     87C : [483]                endif
     484/     87C : C0 08 7C            	lbr L91
     485/     87F :                     L88:
     486/     87F :                     ;		oneMs();
     487/     87F : (MACRO)             	Ccall _oneMs; CALLI2(ar)
     487/     87F : =>FALSE              if MOMCPU=$1805
     487/     87F :                             SCAL    6
     487/     87F :                             dw      _ONEMS
     487/     87F : =>TRUE               else
     487/     87F : D4                          sep     RCALL
     487/     880 : 08 80                       dw      _ONEMS
     487/     882 : [487]                endif
     488/     882 :                     ;	}
     489/     882 :                     L89:
     490/     882 :                     ;	for (i=1;i!=howlong;i++){
     491/     882 : (MACRO)             	incm R6,1
     491/     882 :                             rept    1
     491/     882 :                             inc     R6
     491/     882 :                             endm
     491/     882 : 16                          inc     R6
     492/     883 :                     L91:
     493/     883 : (MACRO)             	jneU2 R6,R7,L88; NE
     493/     883 : 22                          dec     sp
     493/     884 : 87                          glo     R7
     493/     885 : 52                          str     sp
     493/     886 : 86                          glo     R6
     493/     887 : F7                          sm
     493/     888 : 12                          inc     sp
     493/     889 : CA 08 7F                    lbnz    L88
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 19 - 1/18/2018 14:51:19


     493/     88C : 22                          dec     sp
     493/     88D : 97                          ghi     R7
     493/     88E : 52                          str     sp
     493/     88F : 96                          ghi     R6
     493/     890 : 77                          smb
     493/     891 : 12                          inc     sp
     493/     892 : CA 08 7F                    lbnz    L88
     494/     895 :                     ;}
     495/     895 :                     L87:
     496/     895 : (MACRO)             	release 4; release room for outgoing arguments
     496/     895 : =>TRUE                      if (4<9)
     496/     895 :  (MACRO-2)                      releaseS 4  ;use dec for small amounts
     496/     895 :                             rept    4
     496/     895 :                             inc sp
     496/     895 :                             endm
     496/     895 : 12                          inc sp
     496/     896 : 12                          inc sp
     496/     897 : 12                          inc sp
     496/     898 : 12                          inc sp
     496/     899 : =>FALSE                     else
     496/     899 :                                 releaseL 4  ;use subtract for large amounts
     496/     899 : [496]                       endif
     497/     899 : (MACRO)             	popf R7	;opt11.3
     497/     899 : =>FALSE              if MOMCPU=$1805
     497/     899 :                             inc     sp
     497/     899 :                             RLXA    R7
     497/     899 : =>TRUE               else
     497/     899 : 12                          inc     sp
     497/     89A : 42                          lda     sp
     497/     89B : B7                          phi     R7
     497/     89C : 42                          lda     sp
     497/     89D : A7                          plo     R7
     497/     89E : [497]                endif
     498/     89E : (MACRO)             	popl R6	;opt11.3
     498/     89E : 42                          lda     sp
     498/     89F : B6                          phi     R6
     498/     8A0 : 02                          ldn     sp
     498/     8A1 : A6                          plo     R6
     499/     8A2 : (MACRO)             	Cretn
     499/     8A2 : =>FALSE              if MOMCPU=$1805
     499/     8A2 :                             sret    6
     499/     8A2 : =>TRUE               else
     499/     8A2 : D5                          sep     RRET
     499/     8A3 : [499]                endif
     500/     8A3 :                     
     501/     8A3 :                     ;$$function end$$ _delay
     502/     8A3 :                     ;$$function start$$ _olduinoincluder
     503/     8A3 :                     _olduinoincluder:		;framesize=2
     504/     8A3 :                     ;void olduinoincluder(){
     505/     8A3 :                     ;	asm("\tinclude olduino.inc\n");
     506/     8A3 :                     	include olduino.inc
(1)    1/     8A3 :                     ;Feb 8 2013, first version of assembler routines for olduino support	
(1)    2/     8A3 :                     ;may 31 - incredibly, there's an error in digitalWrite.  lda2 changed to ldAD
(1)    3/     8A3 :                     ;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
(1)    4/     8A3 :                     	align 64	;needed to make sure all on same page
(1)    5/     8C0 :                     _digitalWrite:
(1)    6/     8C0 : 8C                  	glo regArg1	;get the bit number
(1)    7/     8C1 : FC C1               	adi $$bvtable&255	;add the table offset
(1)    8/     8C3 : AE                  	plo memaddr
(1)    9/     8C4 : 93                  	ghi RPC		;get the top byte of the current page
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(olduino.inc) - page 20 - 1/18/2018 14:51:19


(1)   10/     8C5 : BE                  	phi memaddr	
(1)   11/     8C6 : 0E                  	ldn memaddr	;pick up the bit pattern
(1)   12/     8C7 : A8                  	plo rt1		;save it in a temp
(1)   13/     8C8 : (MACRO)             	ldAD memaddr,_PIN4 ;address the current port value
(1)   13/     8C8 : =>FALSE              if MOMCPU=$1805
(1)   13/     8C8 :                             RLDI    MEMADDR,_PIN4
(1)   13/     8C8 : =>TRUE               else
(1)   13/     8C8 : F8 03                       ldi     (_PIN4)&255
(1)   13/     8CA : AE                          plo     MEMADDR
(1)   13/     8CB : F8 00                       ldi     (_PIN4)>>8; was/256
(1)   13/     8CD : BE                          phi     MEMADDR
(1)   13/     8CE : [13]                 endif
(1)   14/     8CE : EE                  	sex memaddr	;prepare to change it
(1)   15/     8CF : 8D                  	glo regArg2	;get on/off switch
(1)   16/     8D0 : 32 D0               	bz $$setbitoff
(1)   17/     8D2 :                     ; here we have the bit pattern in rt1 and we're ready to apply it with OR
(1)   18/     8D2 : 88                  	glo rt1		;get the bit value back
(1)   19/     8D3 : F1                  	or		;apply it
(1)   20/     8D4 : 5E                  	str memaddr	;and save it
(1)   21/     8D5 : 30 D5               	br $$outit	;go fnish up
(1)   22/     8D7 :                     $$setbitoff:
(1)   23/     8D7 : 88                  	glo rt1		;get the bit pattern
(1)   24/     8D8 : FB FF               	xri 0xff	;reverse it
(1)   25/     8DA : F2                  	and		;combine it with the existing pin value
(1)   26/     8DB : 5E                  	str memaddr	;and save it
(1)   27/     8DC :                     ;here we gave set/reset the correct bit in PIN4 and we just have to send it out
(1)   28/     8DC :                     $$outit:
(1)   29/     8DC : 64                  	out 4		;X was already set to memaddr
(1)   30/     8DD : E2                  	sex sp		;reset X
(1)   31/     8DE : (MACRO)             	cretn
(1)   31/     8DE : =>FALSE              if MOMCPU=$1805
(1)   31/     8DE :                             sret    6
(1)   31/     8DE : =>TRUE               else
(1)   31/     8DE : D5                          sep     RRET
(1)   31/     8DF : [31]                 endif
(1)   32/     8DF : 01 02 04 08 10 20   $$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
                    40 80 
(1)   33/     8E7 :                     ;int digitalRead(unsigned char pin){//for now this will always read ef3
(1)   34/     8E7 :                     	align 8	;protect jump boundary
(1)   35/     8E8 :                     _digitalRead:
(1)   36/     8E8 : F8 00               	ldi 0		;default is false
(1)   37/     8EA : AF                  	plo R15
(1)   38/     8EB : BF                  	phi R15
(1)   39/     8EC : 36 EC               	b3 +		;i have to reverse the sense of the external line
(1)   40/     8EE : 1F                  	inc R15		;if external line is high, supply a 1
(1)   41/     8EF : (MACRO)             +	cretn
(1)   41/     8EF : =>FALSE              if MOMCPU=$1805
(1)   41/     8EF :                             sret    6
(1)   41/     8EF : =>TRUE               else
(1)   41/     8EF : D5                          sep     RRET
(1)   41/     8F0 : [41]                 endif
(1)   42/     8F0 :                     
     507/     8F0 :                     ;}
     508/     8F0 :                     L92:
     509/     8F0 : (MACRO)             	Cretn
     509/     8F0 : =>FALSE              if MOMCPU=$1805
     509/     8F0 :                             sret    6
     509/     8F0 : =>TRUE               else
     509/     8F0 : D5                          sep     RRET
     509/     8F1 : [509]                endif
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 21 - 1/18/2018 14:51:19


     510/     8F1 :                     
     511/     8F1 :                     ;$$function end$$ _olduinoincluder
     512/     8F1 :                     ;$$function start$$ _strncmp
     513/     8F1 :                     _strncmp:		;framesize=6
     514/     8F1 : (MACRO)             	pushr R6
     514/     8F1 : =>FALSE              if MOMCPU=$1805
     514/     8F1 :                             RSXD    R6
     514/     8F1 : =>TRUE               else
     514/     8F1 : 86                          glo     R6
     514/     8F2 : 73                          stxd
     514/     8F3 : 96                          ghi     R6
     514/     8F4 : 73                          stxd
     514/     8F5 : [514]                endif
     515/     8F5 : (MACRO)             	pushr R7
     515/     8F5 : =>FALSE              if MOMCPU=$1805
     515/     8F5 :                             RSXD    R7
     515/     8F5 : =>TRUE               else
     515/     8F5 : 87                          glo     R7
     515/     8F6 : 73                          stxd
     515/     8F7 : 97                          ghi     R7
     515/     8F8 : 73                          stxd
     515/     8F9 : [515]                endif
     516/     8F9 : (MACRO)             	ld2 R7,'O',sp,(10+1) ;reg:INDIRU2(addr)
     516/     8F9 : =>TRUE                      if      ('O'='O')
     516/     8F9 :  (MACRO-2)                          ldAX    memAddr,SP,(10+1)
     516/     8F9 : 82                          glo     SP
     516/     8FA : FC 0B                       adi     ((10+1))#256
     516/     8FC : AE                          plo     MEMADDR
     516/     8FD : 92                          ghi     SP
     516/     8FE : 7C 00                       adci    ((10+1))>>8; was/256
     516/     900 : BE                          phi     MEMADDR
     516/     901 : =>FALSE                     else
     516/     901 :                                     ldAD    memAddr,SP
     516/     901 : [516]                       endif
     516/     901 : 4E                          lda     memAddr
     516/     902 : B7                          phi     R7
     516/     903 : 0E                          ldn     memAddr
     516/     904 : A7                          plo     R7
     517/     905 :                     ;{
     518/     905 :                     ;    for ( ; n > 0; s1++, s2++, --n)
     519/     905 : C0 09 05            	lbr L98
     520/     908 :                     L95:
     521/     908 :                     ;	if (*s1 != *s2)
     522/     908 : (MACRO)             	ldn1 R11,R12	;opt14*
     522/     908 : 0C                          ldn     R12
     522/     909 : AB                          plo     R11
     523/     90A : (MACRO)             	ldn1 R10,R13	;opt14*
     523/     90A : 0D                          ldn     R13
     523/     90B : AA                          plo     R10
     524/     90C : (MACRO)             	jeqI1 R11,R10,L99	;opt21
     524/     90C : 8A                          glo     R10
     524/     90D : 52                          str     sp
     524/     90E : 8B                          glo     R11
     524/     90F : F7                          sm
     524/     910 : C2 09 10                    lbz     L99
     525/     913 :                     ;	    return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1);
     526/     913 : (MACRO)             	ldn1 R11,R12	;opt14*
     526/     913 : 0C                          ldn     R12
     526/     914 : AB                          plo     R11
     527/     915 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 22 - 1/18/2018 14:51:19


     527/     915 : F8 00                       ldi     0
     527/     917 : BB                          phi     R11
     528/     918 : (MACRO)             	ldn1 R10,R13	;opt14*
     528/     918 : 0D                          ldn     R13
     528/     919 : AA                          plo     R10
     529/     91A : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     529/     91A : F8 00                       ldi     0
     529/     91C : BA                          phi     R10
     530/     91D : (MACRO)             	jcI2 R11,R10,lbdf,L102; GE is flipped test from LT
     530/     91D : 8A                          glo     R10
     530/     91E : 52                          str     sp 
     530/     91F : 8B                          glo     R11
     530/     920 : F7                          sm
     530/     921 : 9A                          ghi     R10
     530/     922 : 52                          str     sp
     530/     923 : 9B                          ghi     R11
     530/     924 : 77                          smb          ;that's a standard signed subtraction
     530/     925 : 9B                          ghi     R11 ;
     530/     926 : F3                          xor           ;sets the top bit if the signs are different
     530/     927 : 7E                          shlc          ;the original df is now in bit 0 and df=1 if signs were different
     530/     928 : C7                          lsnf    ;bypass the flip if signs were the same
     530/     929 : FB 01                       xri     01     ;invert original df if signs were different
     530/     92B : 76                          shrc           ;put it back in df
     530/     92C : C3 09 2C                    LBDF    L102  ;execute 
     531/     92F : (MACRO)             	ldaD R6,-1; reg:acon
     531/     92F : =>FALSE              if MOMCPU=$1805
     531/     92F :                             RLDI    R6,-1
     531/     92F : =>TRUE               else
     531/     92F : F8 FF                       ldi     (-1)&255
     531/     931 : A6                          plo     R6
     531/     932 : F8 FF                       ldi     (-1)>>8; was/256
     531/     934 : B6                          phi     R6
     531/     935 : [531]                endif
     532/     935 : C0 09 35            	lbr L103
     533/     938 :                     L102:
     534/     938 : (MACRO)             	ldaD R6,1; reg:acon
     534/     938 : =>FALSE              if MOMCPU=$1805
     534/     938 :                             RLDI    R6,1
     534/     938 : =>TRUE               else
     534/     938 : F8 01                       ldi     (1)&255
     534/     93A : A6                          plo     R6
     534/     93B : F8 00                       ldi     (1)>>8; was/256
     534/     93D : B6                          phi     R6
     534/     93E : [534]                endif
     535/     93E :                     L103:
     536/     93E : (MACRO)             	cpy2 R15,R6 ;LOADI2(reg)
     536/     93E : 86                          glo     R6
     536/     93F : AF                          plo     R15
     536/     940 : 96                          ghi     R6
     536/     941 : BF                          phi     R15
     537/     942 : C0 09 42            	lbr L94
     538/     945 :                     L99:
     539/     945 :                     ;	else if (*s1 == '\0')
     540/     945 : (MACRO)             	ldn1 R11,R12;reg:  INDIRU1(indaddr)
     540/     945 : 0C                          ldn     R12
     540/     946 : AB                          plo     R11
     541/     947 : (MACRO)             	jnzU1 R11,L104; NEI2(CVUI2(reg),con0)
     541/     947 : 8B                          glo     R11
     541/     948 : CA 09 48                    lbnz    L104
     542/     94B :                     ;	    return 0;
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 23 - 1/18/2018 14:51:19


     543/     94B : (MACRO)             	ld2z R15
     543/     94B : F8 00                       ldi     0
     543/     94D : AF                          plo     R15
     543/     94E : BF                          phi     R15
     544/     94F : C0 09 4F            	lbr L94
     545/     952 :                     L104:
     546/     952 :                     L96:
     547/     952 :                     ;    for ( ; n > 0; s1++, s2++, --n)
     548/     952 : (MACRO)             	incm R12,1
     548/     952 :                             rept    1
     548/     952 :                             inc     R12
     548/     952 :                             endm
     548/     952 : 1C                          inc     R12
     549/     953 : (MACRO)             	incm R13,1
     549/     953 :                             rept    1
     549/     953 :                             inc     R13
     549/     953 :                             endm
     549/     953 : 1D                          inc     R13
     550/     954 : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
     550/     954 :                             rept    1
     550/     954 :                             dec     R7
     550/     954 :                             endm
     550/     954 : 27                          dec     R7
     551/     955 :                     L98:
     552/     955 : (MACRO)             	jnzU2 R7,L95; NE 0 
     552/     955 : 87                          glo     R7
     552/     956 : CA 09 08                    lbnz    L95
     552/     959 : 97                          ghi     R7
     552/     95A : CA 09 08                    lbnz    L95
     553/     95D :                     ;    return 0;
     554/     95D : (MACRO)             	ld2z R15
     554/     95D : F8 00                       ldi     0
     554/     95F : AF                          plo     R15
     554/     960 : BF                          phi     R15
     555/     961 :                     L94:
     556/     961 : (MACRO)             	popf R7	;opt11.3
     556/     961 : =>FALSE              if MOMCPU=$1805
     556/     961 :                             inc     sp
     556/     961 :                             RLXA    R7
     556/     961 : =>TRUE               else
     556/     961 : 12                          inc     sp
     556/     962 : 42                          lda     sp
     556/     963 : B7                          phi     R7
     556/     964 : 42                          lda     sp
     556/     965 : A7                          plo     R7
     556/     966 : [556]                endif
     557/     966 : (MACRO)             	popl R6	;opt11.3
     557/     966 : 42                          lda     sp
     557/     967 : B6                          phi     R6
     557/     968 : 02                          ldn     sp
     557/     969 : A6                          plo     R6
     558/     96A : (MACRO)             	Cretn
     558/     96A : =>FALSE              if MOMCPU=$1805
     558/     96A :                             sret    6
     558/     96A : =>TRUE               else
     558/     96A : D5                          sep     RRET
     558/     96B : [558]                endif
     559/     96B :                     
     560/     96B :                     ;$$function end$$ _strncmp
     561/     96B :                     ;$$function start$$ _strlen
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 24 - 1/18/2018 14:51:19


     562/     96B :                     _strlen:		;framesize=4
     563/     96B : (MACRO)             	pushr R7
     563/     96B : =>FALSE              if MOMCPU=$1805
     563/     96B :                             RSXD    R7
     563/     96B : =>TRUE               else
     563/     96B : 87                          glo     R7
     563/     96C : 73                          stxd
     563/     96D : 97                          ghi     R7
     563/     96E : 73                          stxd
     563/     96F : [563]                endif
     564/     96F :                     ;{
     565/     96F :                     ;	unsigned int slen = 0 ;
     566/     96F : (MACRO)             	ld2z R7
     566/     96F : F8 00                       ldi     0
     566/     971 : A7                          plo     R7
     566/     972 : B7                          phi     R7
     567/     973 : C0 09 73            	lbr L108
     568/     976 :                     L107:
     569/     976 :                     ;	while (*str != 0) {
     570/     976 :                     ;      slen++ ;
     571/     976 : (MACRO)             	incm R7,1
     571/     976 :                             rept    1
     571/     976 :                             inc     R7
     571/     976 :                             endm
     571/     976 : 17                          inc     R7
     572/     977 :                     ;      str++ ;
     573/     977 : (MACRO)             	incm R12,1
     573/     977 :                             rept    1
     573/     977 :                             inc     R12
     573/     977 :                             endm
     573/     977 : 1C                          inc     R12
     574/     978 :                     ;   }
     575/     978 :                     L108:
     576/     978 :                     ;	while (*str != 0) {
     577/     978 : (MACRO)             	ldn1 R11,R12;reg:  INDIRU1(indaddr)
     577/     978 : 0C                          ldn     R12
     577/     979 : AB                          plo     R11
     578/     97A : (MACRO)             	jnzU1 R11,L107; NEI2(CVUI2(reg),con0)
     578/     97A : 8B                          glo     R11
     578/     97B : CA 09 76                    lbnz    L107
     579/     97E :                     ;   return slen;
     580/     97E : (MACRO)             	cpy2 R15,R7 ;LOADU2*(reg)
     580/     97E : 87                          glo     R7
     580/     97F : AF                          plo     R15
     580/     980 : 97                          ghi     R7
     580/     981 : BF                          phi     R15
     581/     982 :                     L106:
     582/     982 : (MACRO)             	popr R7
     582/     982 : 12                          inc     sp
     582/     983 : 42                          lda     sp
     582/     984 : B7                          phi     R7
     582/     985 : 02                          ldn     sp
     582/     986 : A7                          plo     R7
     583/     987 : (MACRO)             	Cretn
     583/     987 : =>FALSE              if MOMCPU=$1805
     583/     987 :                             sret    6
     583/     987 : =>TRUE               else
     583/     987 : D5                          sep     RRET
     583/     988 : [583]                endif
     584/     988 :                     
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 25 - 1/18/2018 14:51:19


     585/     988 :                     ;$$function end$$ _strlen
     586/     988 :                     ;$$function start$$ _printstr
     587/     988 :                     _printstr:		;framesize=8
     588/     988 : (MACRO)             	pushr R7
     588/     988 : =>FALSE              if MOMCPU=$1805
     588/     988 :                             RSXD    R7
     588/     988 : =>TRUE               else
     588/     988 : 87                          glo     R7
     588/     989 : 73                          stxd
     588/     98A : 97                          ghi     R7
     588/     98B : 73                          stxd
     588/     98C : [588]                endif
     589/     98C : (MACRO)             	reserve 4; save room for outgoing arguments
     589/     98C : =>TRUE                      if (4<9)
     589/     98C :  (MACRO-2)                      reserveS 4  ;use dec for small amounts
     589/     98C :                             rept    4
     589/     98C :                             dec sp
     589/     98C :                             endm
     589/     98C : 22                          dec sp
     589/     98D : 22                          dec sp
     589/     98E : 22                          dec sp
     589/     98F : 22                          dec sp
     589/     990 : =>FALSE                     else
     589/     990 :                                 reserveL 4  ;use subtract for large amounts
     589/     990 : [589]                       endif
     590/     990 : (MACRO)             	cpy2 R7,R12; function(2055) 1
     590/     990 : 8C                          glo     R12
     590/     991 : A7                          plo     R7
     590/     992 : 9C                          ghi     R12
     590/     993 : B7                          phi     R7
     591/     994 :                     ;void printstr(char *ptr){
     592/     994 : C0 09 94            	lbr L112
     593/     997 :                     L111:
     594/     997 :                     ;    while(*ptr){
     595/     997 :                     ;		putc(*ptr++); //jan 29
     596/     997 : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
     596/     997 : 87                          glo     R7
     596/     998 : AB                          plo     R11
     596/     999 : 97                          ghi     R7
     596/     99A : BB                          phi     R11
     597/     99B : (MACRO)             	incm R7,1
     597/     99B :                             rept    1
     597/     99B :                             inc     R7
     597/     99B :                             endm
     597/     99B : 17                          inc     R7
     598/     99C : (MACRO)             	ldn1 R12,R11	;opt14*
     598/     99C : 0B                          ldn     R11
     598/     99D : AC                          plo     R12
     599/     99E : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     599/     99E : F8 00                       ldi     0
     599/     9A0 : BC                          phi     R12
     600/     9A1 : (MACRO)             	Ccall _putcser
     600/     9A1 : =>FALSE              if MOMCPU=$1805
     600/     9A1 :                             SCAL    6
     600/     9A1 :                             dw      _PUTCSER
     600/     9A1 : =>TRUE               else
     600/     9A1 : D4                          sep     RCALL
     600/     9A2 : 08 5C                       dw      _PUTCSER
     600/     9A4 : [600]                endif
     601/     9A4 :                     ;		asm(" nop1806\n nop1806\n nop1806\n"); //17-03-09
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 26 - 1/18/2018 14:51:19


     602/     9A4 : (MACRO)              nop1806
     602/     9A4 : =>FALSE              if MOMCPU=$1805
     602/     9A4 :                             nop     ;waste 1.5 instruction times
     602/     9A4 : [602]                endif
     603/     9A4 : (MACRO)              nop1806
     603/     9A4 : =>FALSE              if MOMCPU=$1805
     603/     9A4 :                             nop     ;waste 1.5 instruction times
     603/     9A4 : [603]                endif
     604/     9A4 : (MACRO)              nop1806
     604/     9A4 : =>FALSE              if MOMCPU=$1805
     604/     9A4 :                             nop     ;waste 1.5 instruction times
     604/     9A4 : [604]                endif
     605/     9A4 :                     ;	}
     606/     9A4 :                     L112:
     607/     9A4 :                     ;    while(*ptr){
     608/     9A4 : (MACRO)             	ldn1 R11,R7;reg:  INDIRU1(indaddr)
     608/     9A4 : 07                          ldn     R7
     608/     9A5 : AB                          plo     R11
     609/     9A6 : (MACRO)             	jnzU1 R11,L111; NEI2(CVUI2(reg),con0)
     609/     9A6 : 8B                          glo     R11
     609/     9A7 : CA 09 97                    lbnz    L111
     610/     9AA :                     ;}
     611/     9AA :                     L110:
     612/     9AA : (MACRO)             	release 4; release room for outgoing arguments
     612/     9AA : =>TRUE                      if (4<9)
     612/     9AA :  (MACRO-2)                      releaseS 4  ;use dec for small amounts
     612/     9AA :                             rept    4
     612/     9AA :                             inc sp
     612/     9AA :                             endm
     612/     9AA : 12                          inc sp
     612/     9AB : 12                          inc sp
     612/     9AC : 12                          inc sp
     612/     9AD : 12                          inc sp
     612/     9AE : =>FALSE                     else
     612/     9AE :                                 releaseL 4  ;use subtract for large amounts
     612/     9AE : [612]                       endif
     613/     9AE : (MACRO)             	popr R7
     613/     9AE : 12                          inc     sp
     613/     9AF : 42                          lda     sp
     613/     9B0 : B7                          phi     R7
     613/     9B1 : 02                          ldn     sp
     613/     9B2 : A7                          plo     R7
     614/     9B3 : (MACRO)             	Cretn
     614/     9B3 : =>FALSE              if MOMCPU=$1805
     614/     9B3 :                             sret    6
     614/     9B3 : =>TRUE               else
     614/     9B3 : D5                          sep     RRET
     614/     9B4 : [614]                endif
     615/     9B4 :                     
     616/     9B4 :                     ;$$function end$$ _printstr
     617/     9B4 :                     	align 4
     618/     9B4 :                     _round_nums:
     619/     9B4 : 00 00 00 3F         	dd 0x3f000000
     620/     9B8 : CD CC 4C 3D         	dd 0x3d4ccccd
     621/     9BC : 0A D7 A3 3B         	dd 0x3ba3d70a
     622/     9C0 : 6F 12 03 3A         	dd 0x3a03126f
     623/     9C4 : 17 B7 51 38         	dd 0x3851b717
     624/     9C8 : AC C5 A7 36         	dd 0x36a7c5ac
     625/     9CC : BD 37 06 35         	dd 0x350637bd
     626/     9D0 : 95 BF 56 33         	dd 0x3356bf95
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 27 - 1/18/2018 14:51:19


     627/     9D4 :                     	align 4
     628/     9D4 :                     _mult_nums:
     629/     9D4 : 00 00 80 3F         	dd 0x3f800000
     630/     9D8 : 00 00 20 41         	dd 0x41200000
     631/     9DC : 00 00 C8 42         	dd 0x42c80000
     632/     9E0 : 00 00 7A 44         	dd 0x447a0000
     633/     9E4 : 00 40 1C 46         	dd 0x461c4000
     634/     9E8 : 00 50 C3 47         	dd 0x47c35000
     635/     9EC : 00 24 74 49         	dd 0x49742400
     636/     9F0 : 80 96 18 4B         	dd 0x4b189680
     637/     9F4 :                     ;$$function start$$ _ftoa
     638/     9F4 :                     _ftoa:		;framesize=80
     639/     9F4 : (MACRO)             	reserve 62; save room for local variables
     639/     9F4 : =>FALSE                     if (62<9)
     639/     9F4 :                                 reserveS 62  ;use dec for small amounts
     639/     9F4 : =>TRUE                      else
     639/     9F4 :  (MACRO-2)                      reserveL 62  ;use subtract for large amounts
     639/     9F4 :                     ;this calculation looks awkward but we're adjusting the top byte of sp first 
     639/     9F4 :                     ;so if there's an interrupt in mid calculation the sp will be pointing to free memory
     639/     9F4 : 82                          glo sp          ;grab low byte of stack pointer
     639/     9F5 : FF 3E                       smi 62&255 ;claculate new low byte
     639/     9F7 : AE                          plo memAddr     ;save it for a moment
     639/     9F8 : 92                          ghi sp          ;grab high byte
     639/     9F9 : 7F 00                       smbi (62>>8)&255 ;calculate the new page
     639/     9FB : B2                          phi sp          ;adjust page first
     639/     9FC : 8E                          glo memAddr     ;get new low byte
     639/     9FD : A2                          plo sp          ;finish adjusting the stack pointer
     639/     9FE : [639]                       endif
     640/     9FE : (MACRO)             	pushr R0
     640/     9FE : =>FALSE              if MOMCPU=$1805
     640/     9FE :                             RSXD    R0
     640/     9FE : =>TRUE               else
     640/     9FE : 80                          glo     R0
     640/     9FF : 73                          stxd
     640/     A00 : 90                          ghi     R0
     640/     A01 : 73                          stxd
     640/     A02 : [640]                endif
     641/     A02 : (MACRO)             	pushr R1
     641/     A02 : =>FALSE              if MOMCPU=$1805
     641/     A02 :                             RSXD    R1
     641/     A02 : =>TRUE               else
     641/     A02 : 81                          glo     R1
     641/     A03 : 73                          stxd
     641/     A04 : 91                          ghi     R1
     641/     A05 : 73                          stxd
     641/     A06 : [641]                endif
     642/     A06 : (MACRO)             	pushr R6
     642/     A06 : =>FALSE              if MOMCPU=$1805
     642/     A06 :                             RSXD    R6
     642/     A06 : =>TRUE               else
     642/     A06 : 86                          glo     R6
     642/     A07 : 73                          stxd
     642/     A08 : 96                          ghi     R6
     642/     A09 : 73                          stxd
     642/     A0A : [642]                endif
     643/     A0A : (MACRO)             	pushr R7
     643/     A0A : =>FALSE              if MOMCPU=$1805
     643/     A0A :                             RSXD    R7
     643/     A0A : =>TRUE               else
     643/     A0A : 87                          glo     R7
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 28 - 1/18/2018 14:51:19


     643/     A0B : 73                          stxd
     643/     A0C : 97                          ghi     R7
     643/     A0D : 73                          stxd
     643/     A0E : [643]                endif
     644/     A0E : (MACRO)             	reserve 8; save room for outgoing arguments
     644/     A0E : =>TRUE                      if (8<9)
     644/     A0E :  (MACRO-2)                      reserveS 8  ;use dec for small amounts
     644/     A0E :                             rept    8
     644/     A0E :                             dec sp
     644/     A0E :                             endm
     644/     A0E : 22                          dec sp
     644/     A0F : 22                          dec sp
     644/     A10 : 22                          dec sp
     644/     A11 : 22                          dec sp
     644/     A12 : 22                          dec sp
     644/     A13 : 22                          dec sp
     644/     A14 : 22                          dec sp
     644/     A15 : 22                          dec sp
     644/     A16 : =>FALSE                     else
     644/     A16 :                                 reserveL 8  ;use subtract for large amounts
     644/     A16 : [644]                       endif
     645/     A16 : (MACRO)             	cpy4 RL6,RL12; halfbaked&floaty
     645/     A16 :  (MACRO-2)                  cpy2    RL6,RL12 ;long reg pairs are addressed as the low order pair
     645/     A16 : 8D                          glo     RL12
     645/     A17 : A7                          plo     RL6
     645/     A18 : 9D                          ghi     RL12
     645/     A19 : B7                          phi     RL6
     645/     A1A :  (MACRO-2)                  cpy2    RL6-1,RL12-1
     645/     A1A : 8C                          glo     RL12-1
     645/     A1B : A6                          plo     RL6-1
     645/     A1C : 9C                          ghi     RL12-1
     645/     A1D : B6                          phi     RL6-1
     646/     A1E : (MACRO)             	ld2 R1,'O',sp,(86+1) ;reg:INDIRU2(addr)
     646/     A1E : =>TRUE                      if      ('O'='O')
     646/     A1E :  (MACRO-2)                          ldAX    memAddr,SP,(86+1)
     646/     A1E : 82                          glo     SP
     646/     A1F : FC 57                       adi     ((86+1))#256
     646/     A21 : AE                          plo     MEMADDR
     646/     A22 : 92                          ghi     SP
     646/     A23 : 7C 00                       adci    ((86+1))>>8; was/256
     646/     A25 : BE                          phi     MEMADDR
     646/     A26 : =>FALSE                     else
     646/     A26 :                                     ldAD    memAddr,SP
     646/     A26 : [646]                       endif
     646/     A26 : 4E                          lda     memAddr
     646/     A27 : B1                          phi     R1
     646/     A28 : 0E                          ldn     memAddr
     646/     A29 : A1                          plo     R1
     647/     A2A :                     ;{
     648/     A2A :                     ;   char *output = outbfr ;
     649/     A2A : (MACRO)             	ld2 R0,'O',sp,(84+1) ;reg:INDIRP2(addr)
     649/     A2A : =>TRUE                      if      ('O'='O')
     649/     A2A :  (MACRO-2)                          ldAX    memAddr,SP,(84+1)
     649/     A2A : 82                          glo     SP
     649/     A2B : FC 55                       adi     ((84+1))#256
     649/     A2D : AE                          plo     MEMADDR
     649/     A2E : 92                          ghi     SP
     649/     A2F : 7C 00                       adci    ((84+1))>>8; was/256
     649/     A31 : BE                          phi     MEMADDR
     649/     A32 : =>FALSE                     else
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 29 - 1/18/2018 14:51:19


     649/     A32 :                                     ldAD    memAddr,SP
     649/     A32 : [649]                       endif
     649/     A32 : 4E                          lda     memAddr
     649/     A33 : B0                          phi     R0
     649/     A34 : 0E                          ldn     memAddr
     649/     A35 : A0                          plo     R0
     650/     A36 :                     ;   if (flt < 0.0) {
     651/     A36 : (MACRO)             	ld4 RL10,'D',(L118),0;INDIRF4(addr)
     651/     A36 : =>FALSE                     if      ('D'='O')
     651/     A36 :                                     ldAX    memAddr,(L118),0
     651/     A36 : =>TRUE                      else
     651/     A36 :  (MACRO-2)                          ldAD    memAddr,(L118)
     651/     A36 : =>FALSE              if MOMCPU=$1805
     651/     A36 :                             RLDI    MEMADDR,(L118)
     651/     A36 : =>TRUE               else
     651/     A36 : F8 36                       ldi     ((L118))&255
     651/     A38 : AE                          plo     MEMADDR
     651/     A39 : F8 0A                       ldi     ((L118))>>8; was/256
     651/     A3B : BE                          phi     MEMADDR
     651/     A3C : [651]                endif
     651/     A3C : [651]                       endif
     651/     A3C : 4E                          lda     memAddr
     651/     A3D : BA                          phi     RL10-1   ;long register pairs are addressed by their second member
     651/     A3E : 4E                          lda     memAddr ;but load and store start with the 1st
     651/     A3F : AA                          plo     RL10-1
     651/     A40 : 4E                          lda     memAddr
     651/     A41 : BB                          phi     RL10
     651/     A42 : 0E                          ldn     memAddr
     651/     A43 : AB                          plo     RL10
     652/     A44 : (MACRO)             	jcF4 RL6,RL10,lbdf,L116;GEF4(reg,reg) - reverse test
     652/     A44 : 96                          ghi     RL6-1          ;see if first arg is -v
     652/     A45 : FE                          shl
     652/     A46 : CB 0A 46                    lbnf    $$comp          ;if at least 1 reg positive, just compare
     652/     A49 : 9A                          ghi     RL10-1          ;check 2nd reg
     652/     A4A : FE                          shl
     652/     A4B : C3 0A 4B                    lbdf    $$rcomp
     652/     A4E :  (MACRO-2)          $$comp: jcI4    RL6,RL10,LBDF,L116    ;as long as one register is +v
     652/     A4E : 22                          dec     sp ;make a work area
     652/     A4F : 8B                          glo     RL10    ;lowest order byte
     652/     A50 : 52                          str     sp 
     652/     A51 : 87                          glo     RL6
     652/     A52 : F7                          sm
     652/     A53 : 9B                          ghi     RL10
     652/     A54 : 52                          str     sp
     652/     A55 : 97                          ghi     RL6
     652/     A56 : 77                          smb          ;that's a standard signed subtraction of one reg
     652/     A57 : 8A                          glo     RL10-1  ;lowest order byte of the top register
     652/     A58 : 52                          str     sp 
     652/     A59 : 86                          glo     RL6-1
     652/     A5A : 77                          smb
     652/     A5B : 9A                          ghi     RL10-1
     652/     A5C : 52                          str     sp
     652/     A5D : 96                          ghi     RL6-1
     652/     A5E : 77                          smb          ;that's a standard signed subtraction of a double register
     652/     A5F : 96                          ghi     RL6-1 ;
     652/     A60 : F3                          xor           ;sets the top bit if the signs are different
     652/     A61 : 12                          inc     sp ;release the work area
     652/     A62 : 7E                          shlc          ;the original df is now in bit 0 and df=1 if signs were different
     652/     A63 : C7                          lsnf    ;bypass the flip if signs were the same
     652/     A64 : FB 01                       xri     01     ;invert original df if signs were different
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 30 - 1/18/2018 14:51:19


     652/     A66 : 76                          shrc           ;put it back in df
     652/     A67 : C3 0A 67                    LBDF    L116  ;execute 
     652/     A6A : C0 0A 6A                    lbr     $$done
     652/     A6D :  (MACRO-2)          $$rcomp: jcI4   RL10,RL6,LBDF,L116    ;reverse the order of the operands
     652/     A6D : 22                          dec     sp ;make a work area
     652/     A6E : 87                          glo     RL6    ;lowest order byte
     652/     A6F : 52                          str     sp 
     652/     A70 : 8B                          glo     RL10
     652/     A71 : F7                          sm
     652/     A72 : 97                          ghi     RL6
     652/     A73 : 52                          str     sp
     652/     A74 : 9B                          ghi     RL10
     652/     A75 : 77                          smb          ;that's a standard signed subtraction of one reg
     652/     A76 : 86                          glo     RL6-1  ;lowest order byte of the top register
     652/     A77 : 52                          str     sp 
     652/     A78 : 8A                          glo     RL10-1
     652/     A79 : 77                          smb
     652/     A7A : 96                          ghi     RL6-1
     652/     A7B : 52                          str     sp
     652/     A7C : 9A                          ghi     RL10-1
     652/     A7D : 77                          smb          ;that's a standard signed subtraction of a double register
     652/     A7E : 9A                          ghi     RL10-1 ;
     652/     A7F : F3                          xor           ;sets the top bit if the signs are different
     652/     A80 : 12                          inc     sp ;release the work area
     652/     A81 : 7E                          shlc          ;the original df is now in bit 0 and df=1 if signs were different
     652/     A82 : C7                          lsnf    ;bypass the flip if signs were the same
     652/     A83 : FB 01                       xri     01     ;invert original df if signs were different
     652/     A85 : 76                          shrc           ;put it back in df
     652/     A86 : C3 0A 86                    LBDF    L116  ;execute 
     652/     A89 :                     $$done:
     653/     A89 :                     ;      *output++ = '-' ;
     654/     A89 : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
     654/     A89 : 80                          glo     R0
     654/     A8A : AB                          plo     R11
     654/     A8B : 90                          ghi     R0
     654/     A8C : BB                          phi     R11
     655/     A8D : (MACRO)             	incm R0,1
     655/     A8D :                             rept    1
     655/     A8D :                             inc     R0
     655/     A8D :                             endm
     655/     A8D : 10                          inc     R0
     656/     A8E : (MACRO)             	str1I 45,R11; ASGNU1(indaddr,acon)	DH
     656/     A8E : F8 2D                       ldi     45
     656/     A90 : 5B                          str     R11
     657/     A91 :                     ;      flt *= -1.0 ;
     658/     A91 : (MACRO)             	ld4 RL8,'D',(L119),0;INDIRF4(addr)
     658/     A91 : =>FALSE                     if      ('D'='O')
     658/     A91 :                                     ldAX    memAddr,(L119),0
     658/     A91 : =>TRUE                      else
     658/     A91 :  (MACRO-2)                          ldAD    memAddr,(L119)
     658/     A91 : =>FALSE              if MOMCPU=$1805
     658/     A91 :                             RLDI    MEMADDR,(L119)
     658/     A91 : =>TRUE               else
     658/     A91 : F8 91                       ldi     ((L119))&255
     658/     A93 : AE                          plo     MEMADDR
     658/     A94 : F8 0A                       ldi     ((L119))>>8; was/256
     658/     A96 : BE                          phi     MEMADDR
     658/     A97 : [658]                endif
     658/     A97 : [658]                       endif
     658/     A97 : 4E                          lda     memAddr
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 31 - 1/18/2018 14:51:19


     658/     A98 : B8                          phi     RL8-1   ;long register pairs are addressed by their second member
     658/     A99 : 4E                          lda     memAddr ;but load and store start with the 1st
     658/     A9A : A8                          plo     RL8-1
     658/     A9B : 4E                          lda     memAddr
     658/     A9C : B9                          phi     RL8
     658/     A9D : 0E                          ldn     memAddr
     658/     A9E : A9                          plo     RL8
     659/     A9F : (MACRO)             	cpy4 RL10,RL6; LOADU4(reg)
     659/     A9F :  (MACRO-2)                  cpy2    RL10,RL6 ;long reg pairs are addressed as the low order pair
     659/     A9F : 87                          glo     RL6
     659/     AA0 : AB                          plo     RL10
     659/     AA1 : 97                          ghi     RL6
     659/     AA2 : BB                          phi     RL10
     659/     AA3 :  (MACRO-2)                  cpy2    RL10-1,RL6-1
     659/     AA3 : 86                          glo     RL6-1
     659/     AA4 : AA                          plo     RL10-1
     659/     AA5 : 96                          ghi     RL6-1
     659/     AA6 : BA                          phi     RL10-1
     660/     AA7 : (MACRO)             	Ccall fp_mul ;MULF4(reg,reg)
     660/     AA7 : =>FALSE              if MOMCPU=$1805
     660/     AA7 :                             SCAL    6
     660/     AA7 :                             dw      FP_MUL
     660/     AA7 : =>TRUE               else
     660/     AA7 : D4                          sep     RCALL
     660/     AA8 : 0A A8                       dw      FP_MUL
     660/     AAA : [660]                endif
     661/     AAA : (MACRO)             	cpy4 RL6,RL8; LOADU4(reg)
     661/     AAA :  (MACRO-2)                  cpy2    RL6,RL8 ;long reg pairs are addressed as the low order pair
     661/     AAA : 89                          glo     RL8
     661/     AAB : A7                          plo     RL6
     661/     AAC : 99                          ghi     RL8
     661/     AAD : B7                          phi     RL6
     661/     AAE :  (MACRO-2)                  cpy2    RL6-1,RL8-1
     661/     AAE : 88                          glo     RL8-1
     661/     AAF : A6                          plo     RL6-1
     661/     AB0 : 98                          ghi     RL8-1
     661/     AB1 : B6                          phi     RL6-1
     662/     AB2 :                     ;   } else {
     663/     AB2 : C0 0A B2            	lbr L117
     664/     AB5 :                     L116:
     665/     AB5 :                     ;      if (use_leading_plus) {
     666/     AB5 : C0 0A B5            	lbr L120
     667/     AB8 :                     ;         *output++ = '+' ;
     668/     AB8 : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
     668/     AB8 : 80                          glo     R0
     668/     AB9 : AB                          plo     R11
     668/     ABA : 90                          ghi     R0
     668/     ABB : BB                          phi     R11
     669/     ABC : (MACRO)             	incm R0,1
     669/     ABC :                             rept    1
     669/     ABC :                             inc     R0
     669/     ABC :                             endm
     669/     ABC : 10                          inc     R0
     670/     ABD : (MACRO)             	str1I 43,R11; ASGNU1(indaddr,acon)	DH
     670/     ABD : F8 2B                       ldi     43
     670/     ABF : 5B                          str     R11
     671/     AC0 :                     ;      }
     672/     AC0 :                     L120:
     673/     AC0 :                     ;   }
     674/     AC0 :                     L117:
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 32 - 1/18/2018 14:51:19


     675/     AC0 :                     ;   if (dec_digits < 8) {
     676/     AC0 : (MACRO)             	jcI2I R1,8,lbdf,L122; GE is flipped test from LT
     676/     AC0 : 81                          glo     R1
     676/     AC1 : FF 08                       smi     (8)#256
     676/     AC3 : 91                          ghi     R1
     676/     AC4 : 7F 00                       smbi    (8)>>8; was/256      ;that's a standard signed subtraction
     676/     AC6 : 91                          ghi     R1 ;
     676/     AC7 : FB 00                       xri     (8)>>8; was/256      ;sets the top bit if the signs are different
     676/     AC9 : 7E                          shlc          ;the original df is now in bit 0 and df=1 if signs were different
     676/     ACA : C7                          lsnf    ;bypass the df flip if signs were the same
     676/     ACB : FB 01                       xri     01     ;invert original df if signs were different
     676/     ACD : 76                          shrc           ;put it back in df
     676/     ACE : C3 0A CE                    LBDF    L122  ;execute 
     677/     AD1 :                     ;      flt += round_nums[dec_digits] ;
     678/     AD1 : (MACRO)             	cpy4 RL8,RL6; LOADU4(reg)
     678/     AD1 :  (MACRO-2)                  cpy2    RL8,RL6 ;long reg pairs are addressed as the low order pair
     678/     AD1 : 87                          glo     RL6
     678/     AD2 : A9                          plo     RL8
     678/     AD3 : 97                          ghi     RL6
     678/     AD4 : B9                          phi     RL8
     678/     AD5 :  (MACRO-2)                  cpy2    RL8-1,RL6-1
     678/     AD5 : 86                          glo     RL6-1
     678/     AD6 : A8                          plo     RL8-1
     678/     AD7 : 96                          ghi     RL6-1
     678/     AD8 : B8                          phi     RL8-1
     679/     AD9 : (MACRO)             	shlR2R	R11,R1	;opt6.1
     679/     AD9 : 81                          glo     R1
     679/     ADA : FE                          shl
     679/     ADB : AB                          plo     R11
     679/     ADC : 91                          ghi     R1
     679/     ADD : 7E                          shlc
     679/     ADE : BB                          phi     R11
     680/     ADF : (MACRO)             	shl2I 	R11,1	;opt6.1
     680/     ADF :                             rept    1
     680/     ADF :                             shl2    R11
     680/     ADF :                             endm
     680/     ADF :  (MACRO-2)                  shl2    R11
     680/     ADF : 8B                          glo     R11
     680/     AE0 : FE                          shl
     680/     AE1 : AB                          plo     R11
     680/     AE2 : 9B                          ghi     R11
     680/     AE3 : 7E                          shlc
     680/     AE4 : BB                          phi     R11
     681/     AE5 : (MACRO)             	ld4 RL10,'O',R11,(_round_nums);INDIRF4(addr)
     681/     AE5 : =>TRUE                      if      ('O'='O')
     681/     AE5 :  (MACRO-2)                          ldAX    memAddr,R11,(_ROUND_NUMS)
     681/     AE5 : 8B                          glo     R11
     681/     AE6 : FC B4                       adi     ((_ROUND_NUMS))#256
     681/     AE8 : AE                          plo     MEMADDR
     681/     AE9 : 9B                          ghi     R11
     681/     AEA : 7C 09                       adci    ((_ROUND_NUMS))>>8; was/256
     681/     AEC : BE                          phi     MEMADDR
     681/     AED : =>FALSE                     else
     681/     AED :                                     ldAD    memAddr,R11
     681/     AED : [681]                       endif
     681/     AED : 4E                          lda     memAddr
     681/     AEE : BA                          phi     RL10-1   ;long register pairs are addressed by their second member
     681/     AEF : 4E                          lda     memAddr ;but load and store start with the 1st
     681/     AF0 : AA                          plo     RL10-1
     681/     AF1 : 4E                          lda     memAddr
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 33 - 1/18/2018 14:51:19


     681/     AF2 : BB                          phi     RL10
     681/     AF3 : 0E                          ldn     memAddr
     681/     AF4 : AB                          plo     RL10
     682/     AF5 : (MACRO)             	Ccall fp_add ;ADDF4(reg,reg)
     682/     AF5 : =>FALSE              if MOMCPU=$1805
     682/     AF5 :                             SCAL    6
     682/     AF5 :                             dw      FP_ADD
     682/     AF5 : =>TRUE               else
     682/     AF5 : D4                          sep     RCALL
     682/     AF6 : 0A F6                       dw      FP_ADD
     682/     AF8 : [682]                endif
     683/     AF8 : (MACRO)             	cpy4 RL6,RL8; LOADU4(reg)
     683/     AF8 :  (MACRO-2)                  cpy2    RL6,RL8 ;long reg pairs are addressed as the low order pair
     683/     AF8 : 89                          glo     RL8
     683/     AF9 : A7                          plo     RL6
     683/     AFA : 99                          ghi     RL8
     683/     AFB : B7                          phi     RL6
     683/     AFC :  (MACRO-2)                  cpy2    RL6-1,RL8-1
     683/     AFC : 88                          glo     RL8-1
     683/     AFD : A6                          plo     RL6-1
     683/     AFE : 98                          ghi     RL8-1
     683/     AFF : B6                          phi     RL6-1
     684/     B00 :                     ;   }
     685/     B00 :                     L122:
     686/     B00 :                     ;	mult=mult_nums[dec_digits];
     687/     B00 : (MACRO)             	shlR2R	R11,R1	;opt6.1
     687/     B00 : 81                          glo     R1
     687/     B01 : FE                          shl
     687/     B02 : AB                          plo     R11
     687/     B03 : 91                          ghi     R1
     687/     B04 : 7E                          shlc
     687/     B05 : BB                          phi     R11
     688/     B06 : (MACRO)             	shl2I 	R11,1	;opt6.1
     688/     B06 :                             rept    1
     688/     B06 :                             shl2    R11
     688/     B06 :                             endm
     688/     B06 :  (MACRO-2)                  shl2    R11
     688/     B06 : 8B                          glo     R11
     688/     B07 : FE                          shl
     688/     B08 : AB                          plo     R11
     688/     B09 : 9B                          ghi     R11
     688/     B0A : 7E                          shlc
     688/     B0B : BB                          phi     R11
     689/     B0C : (MACRO)             	ld4 RL10,'O',R11,(_mult_nums);INDIRF4(addr)
     689/     B0C : =>TRUE                      if      ('O'='O')
     689/     B0C :  (MACRO-2)                          ldAX    memAddr,R11,(_MULT_NUMS)
     689/     B0C : 8B                          glo     R11
     689/     B0D : FC D4                       adi     ((_MULT_NUMS))#256
     689/     B0F : AE                          plo     MEMADDR
     689/     B10 : 9B                          ghi     R11
     689/     B11 : 7C 09                       adci    ((_MULT_NUMS))>>8; was/256
     689/     B13 : BE                          phi     MEMADDR
     689/     B14 : =>FALSE                     else
     689/     B14 :                                     ldAD    memAddr,R11
     689/     B14 : [689]                       endif
     689/     B14 : 4E                          lda     memAddr
     689/     B15 : BA                          phi     RL10-1   ;long register pairs are addressed by their second member
     689/     B16 : 4E                          lda     memAddr ;but load and store start with the 1st
     689/     B17 : AA                          plo     RL10-1
     689/     B18 : 4E                          lda     memAddr
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 34 - 1/18/2018 14:51:19


     689/     B19 : BB                          phi     RL10
     689/     B1A : 0E                          ldn     memAddr
     689/     B1B : AB                          plo     RL10
     690/     B1C : (MACRO)             	st4 RL10,'O',sp,(68+1); ASGNF4(addr,reg)
     690/     B1C : =>TRUE                      if      ('O'='O')
     690/     B1C :  (MACRO-2)                          ldAX    memAddr,SP,(68+1)
     690/     B1C : 82                          glo     SP
     690/     B1D : FC 45                       adi     ((68+1))#256
     690/     B1F : AE                          plo     MEMADDR
     690/     B20 : 92                          ghi     SP
     690/     B21 : 7C 00                       adci    ((68+1))>>8; was/256
     690/     B23 : BE                          phi     MEMADDR
     690/     B24 : =>FALSE                     else
     690/     B24 :                                     ldAD    memAddr,SP
     690/     B24 : [690]                       endif
     690/     B24 : 9A                          ghi     RL10-1   ;long register pairs are addressed by their second member
     690/     B25 : 5E                          str     memAddr ;but load and store start with the 1st
     690/     B26 : 1E                          inc     memAddr
     690/     B27 : 8A                          glo     RL10-1
     690/     B28 : 5E                          str     memAddr
     690/     B29 : 1E                          inc     memAddr
     690/     B2A : 9B                          ghi     RL10
     690/     B2B : 5E                          str     memAddr
     690/     B2C : 1E                          inc     memAddr
     690/     B2D : 8B                          glo     RL10
     690/     B2E : 5E                          str     memAddr
     691/     B2F :                     ;   wholeNum = flt;
     692/     B2F : (MACRO)             	cpy4 RL8,RL6; LOADU4(reg)
     692/     B2F :  (MACRO-2)                  cpy2    RL8,RL6 ;long reg pairs are addressed as the low order pair
     692/     B2F : 87                          glo     RL6
     692/     B30 : A9                          plo     RL8
     692/     B31 : 97                          ghi     RL6
     692/     B32 : B9                          phi     RL8
     692/     B33 :  (MACRO-2)                  cpy2    RL8-1,RL6-1
     692/     B33 : 86                          glo     RL6-1
     692/     B34 : A8                          plo     RL8-1
     692/     B35 : 96                          ghi     RL6-1
     692/     B36 : B8                          phi     RL8-1
     693/     B37 : (MACRO)             	ccall cvfi4; CVFI4(reg) convert float to long
     693/     B37 : =>FALSE              if MOMCPU=$1805
     693/     B37 :                             SCAL    6
     693/     B37 :                             dw      CVFI4
     693/     B37 : =>TRUE               else
     693/     B37 : D4                          sep     RCALL
     693/     B38 : 0B 38                       dw      CVFI4
     693/     B3A : [693]                endif
     694/     B3A : (MACRO)             	st4 RL8,'O',sp,(72+1)
     694/     B3A : =>TRUE                      if      ('O'='O')
     694/     B3A :  (MACRO-2)                          ldAX    memAddr,SP,(72+1)
     694/     B3A : 82                          glo     SP
     694/     B3B : FC 49                       adi     ((72+1))#256
     694/     B3D : AE                          plo     MEMADDR
     694/     B3E : 92                          ghi     SP
     694/     B3F : 7C 00                       adci    ((72+1))>>8; was/256
     694/     B41 : BE                          phi     MEMADDR
     694/     B42 : =>FALSE                     else
     694/     B42 :                                     ldAD    memAddr,SP
     694/     B42 : [694]                       endif
     694/     B42 : 98                          ghi     RL8-1   ;long register pairs are addressed by their second member
     694/     B43 : 5E                          str     memAddr ;but load and store start with the 1st
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 35 - 1/18/2018 14:51:19


     694/     B44 : 1E                          inc     memAddr
     694/     B45 : 88                          glo     RL8-1
     694/     B46 : 5E                          str     memAddr
     694/     B47 : 1E                          inc     memAddr
     694/     B48 : 99                          ghi     RL8
     694/     B49 : 5E                          str     memAddr
     694/     B4A : 1E                          inc     memAddr
     694/     B4B : 89                          glo     RL8
     694/     B4C : 5E                          str     memAddr
     695/     B4D :                     ;   decimalNum = ((flt - wholeNum) * mult);
     696/     B4D : (MACRO)             	cpy4 RL8,RL6; LOADU4(reg)
     696/     B4D :  (MACRO-2)                  cpy2    RL8,RL6 ;long reg pairs are addressed as the low order pair
     696/     B4D : 87                          glo     RL6
     696/     B4E : A9                          plo     RL8
     696/     B4F : 97                          ghi     RL6
     696/     B50 : B9                          phi     RL8
     696/     B51 :  (MACRO-2)                  cpy2    RL8-1,RL6-1
     696/     B51 : 86                          glo     RL6-1
     696/     B52 : A8                          plo     RL8-1
     696/     B53 : 96                          ghi     RL6-1
     696/     B54 : B8                          phi     RL8-1
     697/     B55 : (MACRO)             	st4 RL8,'O',sp,(16+1); ASGNF4(addr,reg)
     697/     B55 : =>TRUE                      if      ('O'='O')
     697/     B55 :  (MACRO-2)                          ldAX    memAddr,SP,(16+1)
     697/     B55 : 82                          glo     SP
     697/     B56 : FC 11                       adi     ((16+1))#256
     697/     B58 : AE                          plo     MEMADDR
     697/     B59 : 92                          ghi     SP
     697/     B5A : 7C 00                       adci    ((16+1))>>8; was/256
     697/     B5C : BE                          phi     MEMADDR
     697/     B5D : =>FALSE                     else
     697/     B5D :                                     ldAD    memAddr,SP
     697/     B5D : [697]                       endif
     697/     B5D : 98                          ghi     RL8-1   ;long register pairs are addressed by their second member
     697/     B5E : 5E                          str     memAddr ;but load and store start with the 1st
     697/     B5F : 1E                          inc     memAddr
     697/     B60 : 88                          glo     RL8-1
     697/     B61 : 5E                          str     memAddr
     697/     B62 : 1E                          inc     memAddr
     697/     B63 : 99                          ghi     RL8
     697/     B64 : 5E                          str     memAddr
     697/     B65 : 1E                          inc     memAddr
     697/     B66 : 89                          glo     RL8
     697/     B67 : 5E                          str     memAddr
     698/     B68 : (MACRO)             	ld4 RL8,'O',sp,(72+1);reg:  INDIRI4(addr)
     698/     B68 : =>TRUE                      if      ('O'='O')
     698/     B68 :  (MACRO-2)                          ldAX    memAddr,SP,(72+1)
     698/     B68 : 82                          glo     SP
     698/     B69 : FC 49                       adi     ((72+1))#256
     698/     B6B : AE                          plo     MEMADDR
     698/     B6C : 92                          ghi     SP
     698/     B6D : 7C 00                       adci    ((72+1))>>8; was/256
     698/     B6F : BE                          phi     MEMADDR
     698/     B70 : =>FALSE                     else
     698/     B70 :                                     ldAD    memAddr,SP
     698/     B70 : [698]                       endif
     698/     B70 : 4E                          lda     memAddr
     698/     B71 : B8                          phi     RL8-1   ;long register pairs are addressed by their second member
     698/     B72 : 4E                          lda     memAddr ;but load and store start with the 1st
     698/     B73 : A8                          plo     RL8-1
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 36 - 1/18/2018 14:51:20


     698/     B74 : 4E                          lda     memAddr
     698/     B75 : B9                          phi     RL8
     698/     B76 : 0E                          ldn     memAddr
     698/     B77 : A9                          plo     RL8
     699/     B78 : (MACRO)             	Ccall cvif4; emit2
     699/     B78 : =>FALSE              if MOMCPU=$1805
     699/     B78 :                             SCAL    6
     699/     B78 :                             dw      CVIF4
     699/     B78 : =>TRUE               else
     699/     B78 : D4                          sep     RCALL
     699/     B79 : 0B 79                       dw      CVIF4
     699/     B7B : [699]                endif
     700/     B7B : (MACRO)             	cpy4 RL10,RL8; LOADU4(reg)
     700/     B7B :  (MACRO-2)                  cpy2    RL10,RL8 ;long reg pairs are addressed as the low order pair
     700/     B7B : 89                          glo     RL8
     700/     B7C : AB                          plo     RL10
     700/     B7D : 99                          ghi     RL8
     700/     B7E : BB                          phi     RL10
     700/     B7F :  (MACRO-2)                  cpy2    RL10-1,RL8-1
     700/     B7F : 88                          glo     RL8-1
     700/     B80 : AA                          plo     RL10-1
     700/     B81 : 98                          ghi     RL8-1
     700/     B82 : BA                          phi     RL10-1
     701/     B83 : (MACRO)             	ld4 RL8,'O',sp,(16+1);INDIRF4(addr)
     701/     B83 : =>TRUE                      if      ('O'='O')
     701/     B83 :  (MACRO-2)                          ldAX    memAddr,SP,(16+1)
     701/     B83 : 82                          glo     SP
     701/     B84 : FC 11                       adi     ((16+1))#256
     701/     B86 : AE                          plo     MEMADDR
     701/     B87 : 92                          ghi     SP
     701/     B88 : 7C 00                       adci    ((16+1))>>8; was/256
     701/     B8A : BE                          phi     MEMADDR
     701/     B8B : =>FALSE                     else
     701/     B8B :                                     ldAD    memAddr,SP
     701/     B8B : [701]                       endif
     701/     B8B : 4E                          lda     memAddr
     701/     B8C : B8                          phi     RL8-1   ;long register pairs are addressed by their second member
     701/     B8D : 4E                          lda     memAddr ;but load and store start with the 1st
     701/     B8E : A8                          plo     RL8-1
     701/     B8F : 4E                          lda     memAddr
     701/     B90 : B9                          phi     RL8
     701/     B91 : 0E                          ldn     memAddr
     701/     B92 : A9                          plo     RL8
     702/     B93 : (MACRO)             	Ccall fp_sub ;SUBF4(reg,reg)
     702/     B93 : =>FALSE              if MOMCPU=$1805
     702/     B93 :                             SCAL    6
     702/     B93 :                             dw      FP_SUB
     702/     B93 : =>TRUE               else
     702/     B93 : D4                          sep     RCALL
     702/     B94 : 0B 94                       dw      FP_SUB
     702/     B96 : [702]                endif
     703/     B96 : (MACRO)             	ld4 RL10,'O',sp,(68+1);INDIRF4(addr)
     703/     B96 : =>TRUE                      if      ('O'='O')
     703/     B96 :  (MACRO-2)                          ldAX    memAddr,SP,(68+1)
     703/     B96 : 82                          glo     SP
     703/     B97 : FC 45                       adi     ((68+1))#256
     703/     B99 : AE                          plo     MEMADDR
     703/     B9A : 92                          ghi     SP
     703/     B9B : 7C 00                       adci    ((68+1))>>8; was/256
     703/     B9D : BE                          phi     MEMADDR
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 37 - 1/18/2018 14:51:20


     703/     B9E : =>FALSE                     else
     703/     B9E :                                     ldAD    memAddr,SP
     703/     B9E : [703]                       endif
     703/     B9E : 4E                          lda     memAddr
     703/     B9F : BA                          phi     RL10-1   ;long register pairs are addressed by their second member
     703/     BA0 : 4E                          lda     memAddr ;but load and store start with the 1st
     703/     BA1 : AA                          plo     RL10-1
     703/     BA2 : 4E                          lda     memAddr
     703/     BA3 : BB                          phi     RL10
     703/     BA4 : 0E                          ldn     memAddr
     703/     BA5 : AB                          plo     RL10
     704/     BA6 : (MACRO)             	Ccall fp_mul ;MULF4(reg,reg)
     704/     BA6 : =>FALSE              if MOMCPU=$1805
     704/     BA6 :                             SCAL    6
     704/     BA6 :                             dw      FP_MUL
     704/     BA6 : =>TRUE               else
     704/     BA6 : D4                          sep     RCALL
     704/     BA7 : 0B A7                       dw      FP_MUL
     704/     BA9 : [704]                endif
     705/     BA9 : (MACRO)             	ccall cvfi4; CVFI4(reg) convert float to long
     705/     BA9 : =>FALSE              if MOMCPU=$1805
     705/     BA9 :                             SCAL    6
     705/     BA9 :                             dw      CVFI4
     705/     BA9 : =>TRUE               else
     705/     BA9 : D4                          sep     RCALL
     705/     BAA : 0B AA                       dw      CVFI4
     705/     BAC : [705]                endif
     706/     BAC : (MACRO)             	st4 RL8,'O',sp,(64+1)
     706/     BAC : =>TRUE                      if      ('O'='O')
     706/     BAC :  (MACRO-2)                          ldAX    memAddr,SP,(64+1)
     706/     BAC : 82                          glo     SP
     706/     BAD : FC 41                       adi     ((64+1))#256
     706/     BAF : AE                          plo     MEMADDR
     706/     BB0 : 92                          ghi     SP
     706/     BB1 : 7C 00                       adci    ((64+1))>>8; was/256
     706/     BB3 : BE                          phi     MEMADDR
     706/     BB4 : =>FALSE                     else
     706/     BB4 :                                     ldAD    memAddr,SP
     706/     BB4 : [706]                       endif
     706/     BB4 : 98                          ghi     RL8-1   ;long register pairs are addressed by their second member
     706/     BB5 : 5E                          str     memAddr ;but load and store start with the 1st
     706/     BB6 : 1E                          inc     memAddr
     706/     BB7 : 88                          glo     RL8-1
     706/     BB8 : 5E                          str     memAddr
     706/     BB9 : 1E                          inc     memAddr
     706/     BBA : 99                          ghi     RL8
     706/     BBB : 5E                          str     memAddr
     706/     BBC : 1E                          inc     memAddr
     706/     BBD : 89                          glo     RL8
     706/     BBE : 5E                          str     memAddr
     707/     BBF :                     ;   strcpy(output,dubdabx(wholeNum,output,1));
     708/     BBF : (MACRO)             	ld4 Rp1p2,'O',sp,(72+1);reg:  INDIRI4(addr)
     708/     BBF : =>TRUE                      if      ('O'='O')
     708/     BBF :  (MACRO-2)                          ldAX    memAddr,SP,(72+1)
     708/     BBF : 82                          glo     SP
     708/     BC0 : FC 49                       adi     ((72+1))#256
     708/     BC2 : AE                          plo     MEMADDR
     708/     BC3 : 92                          ghi     SP
     708/     BC4 : 7C 00                       adci    ((72+1))>>8; was/256
     708/     BC6 : BE                          phi     MEMADDR
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 38 - 1/18/2018 14:51:20


     708/     BC7 : =>FALSE                     else
     708/     BC7 :                                     ldAD    memAddr,SP
     708/     BC7 : [708]                       endif
     708/     BC7 : 4E                          lda     memAddr
     708/     BC8 : BC                          phi     RP1P2-1   ;long register pairs are addressed by their second member
     708/     BC9 : 4E                          lda     memAddr ;but load and store start with the 1st
     708/     BCA : AC                          plo     RP1P2-1
     708/     BCB : 4E                          lda     memAddr
     708/     BCC : BD                          phi     RP1P2
     708/     BCD : 0E                          ldn     memAddr
     708/     BCE : AD                          plo     RP1P2
     709/     BCF : (MACRO)             	st2 R0,'O',sp,(4+1); arg+f**
     709/     BCF : =>TRUE                      if      ('O'='O')
     709/     BCF :  (MACRO-2)                          ldAX    memAddr,SP,(4+1)
     709/     BCF : 82                          glo     SP
     709/     BD0 : FC 05                       adi     ((4+1))#256
     709/     BD2 : AE                          plo     MEMADDR
     709/     BD3 : 92                          ghi     SP
     709/     BD4 : 7C 00                       adci    ((4+1))>>8; was/256
     709/     BD6 : BE                          phi     MEMADDR
     709/     BD7 : =>FALSE                     else
     709/     BD7 :                                     ldAD    memAddr,SP
     709/     BD7 : [709]                       endif
     709/     BD7 : 90                          ghi     R0
     709/     BD8 : 5E                          str     memAddr
     709/     BD9 : 1E                          inc     memAddr
     709/     BDA : 80                          glo     R0
     709/     BDB : 5E                          str     memAddr
     710/     BDC : (MACRO)             	ldaD R11,1; reg:acon
     710/     BDC : =>FALSE              if MOMCPU=$1805
     710/     BDC :                             RLDI    R11,1
     710/     BDC : =>TRUE               else
     710/     BDC : F8 01                       ldi     (1)&255
     710/     BDE : AB                          plo     R11
     710/     BDF : F8 00                       ldi     (1)>>8; was/256
     710/     BE1 : BB                          phi     R11
     710/     BE2 : [710]                endif
     711/     BE2 : (MACRO)             	st2 R11,'O',sp,(6+1); arg+f**
     711/     BE2 : =>TRUE                      if      ('O'='O')
     711/     BE2 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     711/     BE2 : 82                          glo     SP
     711/     BE3 : FC 07                       adi     ((6+1))#256
     711/     BE5 : AE                          plo     MEMADDR
     711/     BE6 : 92                          ghi     SP
     711/     BE7 : 7C 00                       adci    ((6+1))>>8; was/256
     711/     BE9 : BE                          phi     MEMADDR
     711/     BEA : =>FALSE                     else
     711/     BEA :                                     ldAD    memAddr,SP
     711/     BEA : [711]                       endif
     711/     BEA : 9B                          ghi     R11
     711/     BEB : 5E                          str     memAddr
     711/     BEC : 1E                          inc     memAddr
     711/     BED : 8B                          glo     R11
     711/     BEE : 5E                          str     memAddr
     712/     BEF : (MACRO)             	Ccall _dubdabx
     712/     BEF : =>FALSE              if MOMCPU=$1805
     712/     BEF :                             SCAL    6
     712/     BEF :                             dw      _DUBDABX
     712/     BEF : =>TRUE               else
     712/     BEF : D4                          sep     RCALL
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 39 - 1/18/2018 14:51:20


     712/     BF0 : 0B F0                       dw      _DUBDABX
     712/     BF2 : [712]                endif
     713/     BF2 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     713/     BF2 : 8F                          glo     R15
     713/     BF3 : AB                          plo     R11
     713/     BF4 : 9F                          ghi     R15
     713/     BF5 : BB                          phi     R11
     714/     BF6 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     714/     BF6 : 80                          glo     R0
     714/     BF7 : AC                          plo     R12
     714/     BF8 : 90                          ghi     R0
     714/     BF9 : BC                          phi     R12
     715/     BFA : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     715/     BFA : 8B                          glo     R11
     715/     BFB : AD                          plo     R13
     715/     BFC : 9B                          ghi     R11
     715/     BFD : BD                          phi     R13
     716/     BFE : (MACRO)             	Ccall _strcpy
     716/     BFE : =>FALSE              if MOMCPU=$1805
     716/     BFE :                             SCAL    6
     716/     BFE :                             dw      _STRCPY
     716/     BFE : =>TRUE               else
     716/     BFE : D4                          sep     RCALL
     716/     BFF : 0B FF                       dw      _STRCPY
     716/     C01 : [716]                endif
     717/     C01 :                     ;   output+=strlen(output);
     718/     C01 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     718/     C01 : 80                          glo     R0
     718/     C02 : AC                          plo     R12
     718/     C03 : 90                          ghi     R0
     718/     C04 : BC                          phi     R12
     719/     C05 : (MACRO)             	Ccall _strlen;CALLU2(ar)*
     719/     C05 : =>FALSE              if MOMCPU=$1805
     719/     C05 :                             SCAL    6
     719/     C05 :                             dw      _STRLEN
     719/     C05 : =>TRUE               else
     719/     C05 : D4                          sep     RCALL
     719/     C06 : 09 6B                       dw      _STRLEN
     719/     C08 : [719]                endif
     720/     C08 : (MACRO)             	alu2 R0,R15,R0,add,adc	;ADDP2(reg,reg)
     720/     C08 : 80                          glo     R0
     720/     C09 : 52                          str     sp
     720/     C0A : 8F                          glo     R15
     720/     C0B : F4                          ADD             ;calculate the low order byte
     720/     C0C : A0                          plo     R0
     720/     C0D : 90                          ghi     R0
     720/     C0E : 52                          str     sp
     720/     C0F : 9F                          ghi     R15
     720/     C10 : 74                          ADC             ;calculate the high byte
     720/     C11 : B0                          phi     R0
     721/     C12 :                     ;   if (dec_digits > 0) {
     722/     C12 : (MACRO)             	jzU2 R1,L124; EQ 0
     722/     C12 : 81                          glo     R1
     722/     C13 : CA 0C 13                    lbnz    +
     722/     C16 : 91                          ghi     R1
     722/     C17 : C2 0C 17                    lbz     L124
     722/     C1A :                     +
     723/     C1A :                     ;		*output++ = '.' ;
     724/     C1A : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
     724/     C1A : 80                          glo     R0
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 40 - 1/18/2018 14:51:20


     724/     C1B : AB                          plo     R11
     724/     C1C : 90                          ghi     R0
     724/     C1D : BB                          phi     R11
     725/     C1E : (MACRO)             	incm R0,1
     725/     C1E :                             rept    1
     725/     C1E :                             inc     R0
     725/     C1E :                             endm
     725/     C1E : 10                          inc     R0
     726/     C1F : (MACRO)             	str1I 46,R11; ASGNU1(indaddr,acon)	DH
     726/     C1F : F8 2E                       ldi     46
     726/     C21 : 5B                          str     R11
     727/     C22 :                     ;		strcpy(output,dubdabx(decimalNum,output,dec_digits));
     728/     C22 : (MACRO)             	ld4 Rp1p2,'O',sp,(64+1);reg:  INDIRI4(addr)
     728/     C22 : =>TRUE                      if      ('O'='O')
     728/     C22 :  (MACRO-2)                          ldAX    memAddr,SP,(64+1)
     728/     C22 : 82                          glo     SP
     728/     C23 : FC 41                       adi     ((64+1))#256
     728/     C25 : AE                          plo     MEMADDR
     728/     C26 : 92                          ghi     SP
     728/     C27 : 7C 00                       adci    ((64+1))>>8; was/256
     728/     C29 : BE                          phi     MEMADDR
     728/     C2A : =>FALSE                     else
     728/     C2A :                                     ldAD    memAddr,SP
     728/     C2A : [728]                       endif
     728/     C2A : 4E                          lda     memAddr
     728/     C2B : BC                          phi     RP1P2-1   ;long register pairs are addressed by their second member
     728/     C2C : 4E                          lda     memAddr ;but load and store start with the 1st
     728/     C2D : AC                          plo     RP1P2-1
     728/     C2E : 4E                          lda     memAddr
     728/     C2F : BD                          phi     RP1P2
     728/     C30 : 0E                          ldn     memAddr
     728/     C31 : AD                          plo     RP1P2
     729/     C32 : (MACRO)             	st2 R0,'O',sp,(4+1); arg+f**
     729/     C32 : =>TRUE                      if      ('O'='O')
     729/     C32 :  (MACRO-2)                          ldAX    memAddr,SP,(4+1)
     729/     C32 : 82                          glo     SP
     729/     C33 : FC 05                       adi     ((4+1))#256
     729/     C35 : AE                          plo     MEMADDR
     729/     C36 : 92                          ghi     SP
     729/     C37 : 7C 00                       adci    ((4+1))>>8; was/256
     729/     C39 : BE                          phi     MEMADDR
     729/     C3A : =>FALSE                     else
     729/     C3A :                                     ldAD    memAddr,SP
     729/     C3A : [729]                       endif
     729/     C3A : 90                          ghi     R0
     729/     C3B : 5E                          str     memAddr
     729/     C3C : 1E                          inc     memAddr
     729/     C3D : 80                          glo     R0
     729/     C3E : 5E                          str     memAddr
     730/     C3F : (MACRO)             	cpy2 R11,R1 ;LOADI2(reg)
     730/     C3F : 81                          glo     R1
     730/     C40 : AB                          plo     R11
     730/     C41 : 91                          ghi     R1
     730/     C42 : BB                          phi     R11
     731/     C43 : (MACRO)             	st2 R11,'O',sp,(6+1); arg+f**
     731/     C43 : =>TRUE                      if      ('O'='O')
     731/     C43 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     731/     C43 : 82                          glo     SP
     731/     C44 : FC 07                       adi     ((6+1))#256
     731/     C46 : AE                          plo     MEMADDR
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 41 - 1/18/2018 14:51:20


     731/     C47 : 92                          ghi     SP
     731/     C48 : 7C 00                       adci    ((6+1))>>8; was/256
     731/     C4A : BE                          phi     MEMADDR
     731/     C4B : =>FALSE                     else
     731/     C4B :                                     ldAD    memAddr,SP
     731/     C4B : [731]                       endif
     731/     C4B : 9B                          ghi     R11
     731/     C4C : 5E                          str     memAddr
     731/     C4D : 1E                          inc     memAddr
     731/     C4E : 8B                          glo     R11
     731/     C4F : 5E                          str     memAddr
     732/     C50 : (MACRO)             	Ccall _dubdabx
     732/     C50 : =>FALSE              if MOMCPU=$1805
     732/     C50 :                             SCAL    6
     732/     C50 :                             dw      _DUBDABX
     732/     C50 : =>TRUE               else
     732/     C50 : D4                          sep     RCALL
     732/     C51 : 0C 51                       dw      _DUBDABX
     732/     C53 : [732]                endif
     733/     C53 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     733/     C53 : 8F                          glo     R15
     733/     C54 : AB                          plo     R11
     733/     C55 : 9F                          ghi     R15
     733/     C56 : BB                          phi     R11
     734/     C57 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     734/     C57 : 80                          glo     R0
     734/     C58 : AC                          plo     R12
     734/     C59 : 90                          ghi     R0
     734/     C5A : BC                          phi     R12
     735/     C5B : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     735/     C5B : 8B                          glo     R11
     735/     C5C : AD                          plo     R13
     735/     C5D : 9B                          ghi     R11
     735/     C5E : BD                          phi     R13
     736/     C5F : (MACRO)             	Ccall _strcpy
     736/     C5F : =>FALSE              if MOMCPU=$1805
     736/     C5F :                             SCAL    6
     736/     C5F :                             dw      _STRCPY
     736/     C5F : =>TRUE               else
     736/     C5F : D4                          sep     RCALL
     736/     C60 : 0C 60                       dw      _STRCPY
     736/     C62 : [736]                endif
     737/     C62 :                     ;	}
     738/     C62 :                     L124:
     739/     C62 :                     ;   return outbfr;
     740/     C62 : (MACRO)             	ld2 R15,'O',sp,(84+1) ;reg:INDIRP2(addr)
     740/     C62 : =>TRUE                      if      ('O'='O')
     740/     C62 :  (MACRO-2)                          ldAX    memAddr,SP,(84+1)
     740/     C62 : 82                          glo     SP
     740/     C63 : FC 55                       adi     ((84+1))#256
     740/     C65 : AE                          plo     MEMADDR
     740/     C66 : 92                          ghi     SP
     740/     C67 : 7C 00                       adci    ((84+1))>>8; was/256
     740/     C69 : BE                          phi     MEMADDR
     740/     C6A : =>FALSE                     else
     740/     C6A :                                     ldAD    memAddr,SP
     740/     C6A : [740]                       endif
     740/     C6A : 4E                          lda     memAddr
     740/     C6B : BF                          phi     R15
     740/     C6C : 0E                          ldn     memAddr
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 42 - 1/18/2018 14:51:20


     740/     C6D : AF                          plo     R15
     741/     C6E :                     L115:
     742/     C6E : (MACRO)             	release 8; release room for outgoing arguments
     742/     C6E : =>TRUE                      if (8<9)
     742/     C6E :  (MACRO-2)                      releaseS 8  ;use dec for small amounts
     742/     C6E :                             rept    8
     742/     C6E :                             inc sp
     742/     C6E :                             endm
     742/     C6E : 12                          inc sp
     742/     C6F : 12                          inc sp
     742/     C70 : 12                          inc sp
     742/     C71 : 12                          inc sp
     742/     C72 : 12                          inc sp
     742/     C73 : 12                          inc sp
     742/     C74 : 12                          inc sp
     742/     C75 : 12                          inc sp
     742/     C76 : =>FALSE                     else
     742/     C76 :                                 releaseL 8  ;use subtract for large amounts
     742/     C76 : [742]                       endif
     743/     C76 : (MACRO)             	popf R7	;opt11.3
     743/     C76 : =>FALSE              if MOMCPU=$1805
     743/     C76 :                             inc     sp
     743/     C76 :                             RLXA    R7
     743/     C76 : =>TRUE               else
     743/     C76 : 12                          inc     sp
     743/     C77 : 42                          lda     sp
     743/     C78 : B7                          phi     R7
     743/     C79 : 42                          lda     sp
     743/     C7A : A7                          plo     R7
     743/     C7B : [743]                endif
     744/     C7B : (MACRO)             	popm R6	;opt11.4
     744/     C7B : =>FALSE              if MOMCPU=$1805
     744/     C7B :                             RLXA    R6
     744/     C7B : =>TRUE               else
     744/     C7B : 42                          lda     sp
     744/     C7C : B6                          phi     R6
     744/     C7D : 42                          lda     sp
     744/     C7E : A6                          plo     R6
     744/     C7F : [744]                endif
     745/     C7F : (MACRO)             	popm R1	;opt11.4
     745/     C7F : =>FALSE              if MOMCPU=$1805
     745/     C7F :                             RLXA    R1
     745/     C7F : =>TRUE               else
     745/     C7F : 42                          lda     sp
     745/     C80 : B1                          phi     R1
     745/     C81 : 42                          lda     sp
     745/     C82 : A1                          plo     R1
     745/     C83 : [745]                endif
     746/     C83 : (MACRO)             	popl R0	;opt11.4
     746/     C83 : 42                          lda     sp
     746/     C84 : B0                          phi     R0
     746/     C85 : 02                          ldn     sp
     746/     C86 : A0                          plo     R0
     747/     C87 : (MACRO)             	release 62; release room for local variables 
     747/     C87 : =>FALSE                     if (62<9)
     747/     C87 :                                 releaseS 62  ;use dec for small amounts
     747/     C87 : =>TRUE                      else
     747/     C87 :  (MACRO-2)                      releaseL 62  ;use subtract for large amounts
     747/     C87 :                     ;for release we adjust the low byte first 
     747/     C87 :                     ;so if there's an interrupt in mid calculation the sp will be pointing to free memory
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 43 - 1/18/2018 14:51:20


     747/     C87 :   (MACRO-3)                 alu2i sp,sp,62,adi,adci
     747/     C87 : 82                          glo     SP
     747/     C88 : FC 3E                       ADI     (62)#256
     747/     C8A : A2                          plo     SP
     747/     C8B : 92                          ghi     SP
     747/     C8C : 7C 00                       ADCI     (62)>>8; was/256
     747/     C8E : B2                          phi     SP
     747/     C8F : [747]                       endif
     748/     C8F : (MACRO)             	Cretn
     748/     C8F : =>FALSE              if MOMCPU=$1805
     748/     C8F :                             sret    6
     748/     C8F : =>TRUE               else
     748/     C8F : D5                          sep     RRET
     748/     C90 : [748]                endif
     749/     C90 :                     
     750/     C90 :                     ;$$function end$$ _ftoa
     751/     C90 :                     ;$$function start$$ _itoa
     752/     C90 :                     _itoa:		;framesize=16
     753/     C90 : (MACRO)             	reserve 2; save room for local variables
     753/     C90 : =>TRUE                      if (2<9)
     753/     C90 :  (MACRO-2)                      reserveS 2  ;use dec for small amounts
     753/     C90 :                             rept    2
     753/     C90 :                             dec sp
     753/     C90 :                             endm
     753/     C90 : 22                          dec sp
     753/     C91 : 22                          dec sp
     753/     C92 : =>FALSE                     else
     753/     C92 :                                 reserveL 2  ;use subtract for large amounts
     753/     C92 : [753]                       endif
     754/     C92 : (MACRO)             	pushr R0
     754/     C92 : =>FALSE              if MOMCPU=$1805
     754/     C92 :                             RSXD    R0
     754/     C92 : =>TRUE               else
     754/     C92 : 80                          glo     R0
     754/     C93 : 73                          stxd
     754/     C94 : 90                          ghi     R0
     754/     C95 : 73                          stxd
     754/     C96 : [754]                endif
     755/     C96 : (MACRO)             	pushr R1
     755/     C96 : =>FALSE              if MOMCPU=$1805
     755/     C96 :                             RSXD    R1
     755/     C96 : =>TRUE               else
     755/     C96 : 81                          glo     R1
     755/     C97 : 73                          stxd
     755/     C98 : 91                          ghi     R1
     755/     C99 : 73                          stxd
     755/     C9A : [755]                endif
     756/     C9A : (MACRO)             	pushr R6
     756/     C9A : =>FALSE              if MOMCPU=$1805
     756/     C9A :                             RSXD    R6
     756/     C9A : =>TRUE               else
     756/     C9A : 86                          glo     R6
     756/     C9B : 73                          stxd
     756/     C9C : 96                          ghi     R6
     756/     C9D : 73                          stxd
     756/     C9E : [756]                endif
     757/     C9E : (MACRO)             	pushr R7
     757/     C9E : =>FALSE              if MOMCPU=$1805
     757/     C9E :                             RSXD    R7
     757/     C9E : =>TRUE               else
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 44 - 1/18/2018 14:51:20


     757/     C9E : 87                          glo     R7
     757/     C9F : 73                          stxd
     757/     CA0 : 97                          ghi     R7
     757/     CA1 : 73                          stxd
     757/     CA2 : [757]                endif
     758/     CA2 : (MACRO)             	reserve 4; save room for outgoing arguments
     758/     CA2 : =>TRUE                      if (4<9)
     758/     CA2 :  (MACRO-2)                      reserveS 4  ;use dec for small amounts
     758/     CA2 :                             rept    4
     758/     CA2 :                             dec sp
     758/     CA2 :                             endm
     758/     CA2 : 22                          dec sp
     758/     CA3 : 22                          dec sp
     758/     CA4 : 22                          dec sp
     758/     CA5 : 22                          dec sp
     758/     CA6 : =>FALSE                     else
     758/     CA6 :                                 reserveL 4  ;use subtract for large amounts
     758/     CA6 : [758]                       endif
     759/     CA6 : (MACRO)             	st2 R12,'O',sp,(16+1)			
     759/     CA6 : =>TRUE                      if      ('O'='O')
     759/     CA6 :  (MACRO-2)                          ldAX    memAddr,SP,(16+1)
     759/     CA6 : 82                          glo     SP
     759/     CA7 : FC 11                       adi     ((16+1))#256
     759/     CA9 : AE                          plo     MEMADDR
     759/     CAA : 92                          ghi     SP
     759/     CAB : 7C 00                       adci    ((16+1))>>8; was/256
     759/     CAD : BE                          phi     MEMADDR
     759/     CAE : =>FALSE                     else
     759/     CAE :                                     ldAD    memAddr,SP
     759/     CAE : [759]                       endif
     759/     CAE : 9C                          ghi     R12
     759/     CAF : 5E                          str     memAddr
     759/     CB0 : 1E                          inc     memAddr
     759/     CB1 : 8C                          glo     R12
     759/     CB2 : 5E                          str     memAddr
     760/     CB3 : 1E                  	inc memaddr				;opt16.1
     761/     CB4 : (MACRO)             	str2 R13,memaddr			
     761/     CB4 : 9D                          ghi     R13
     761/     CB5 : 5E                          str     MEMADDR
     761/     CB6 : 8D                          glo     R13
     761/     CB7 : 1E                          inc     MEMADDR
     761/     CB8 : 5E                          str     MEMADDR
     761/     CB9 : 2E                          dec     MEMADDR
     762/     CBA :                     ;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
     763/     CBA :                     ;	unsigned int flag=0;
     764/     CBA : (MACRO)             	ld2z R0
     764/     CBA : F8 00                       ldi     0
     764/     CBC : A0                          plo     R0
     764/     CBD : B0                          phi     R0
     765/     CBE :                     ;	char * bptr; bptr=buffer;
     766/     CBE : (MACRO)             	ld2 R11,'O',sp,(18+1) ;reg:INDIRP2(addr)
     766/     CBE : =>TRUE                      if      ('O'='O')
     766/     CBE :  (MACRO-2)                          ldAX    memAddr,SP,(18+1)
     766/     CBE : 82                          glo     SP
     766/     CBF : FC 13                       adi     ((18+1))#256
     766/     CC1 : AE                          plo     MEMADDR
     766/     CC2 : 92                          ghi     SP
     766/     CC3 : 7C 00                       adci    ((18+1))>>8; was/256
     766/     CC5 : BE                          phi     MEMADDR
     766/     CC6 : =>FALSE                     else
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 45 - 1/18/2018 14:51:20


     766/     CC6 :                                     ldAD    memAddr,SP
     766/     CC6 : [766]                       endif
     766/     CC6 : 4E                          lda     memAddr
     766/     CC7 : BB                          phi     R11
     766/     CC8 : 0E                          ldn     memAddr
     766/     CC9 : AB                          plo     R11
     767/     CCA : (MACRO)             	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
     767/     CCA : =>TRUE                      if      ('O'='O')
     767/     CCA :  (MACRO-2)                          ldAX    memAddr,SP,(12+1)
     767/     CCA : 82                          glo     SP
     767/     CCB : FC 0D                       adi     ((12+1))#256
     767/     CCD : AE                          plo     MEMADDR
     767/     CCE : 92                          ghi     SP
     767/     CCF : 7C 00                       adci    ((12+1))>>8; was/256
     767/     CD1 : BE                          phi     MEMADDR
     767/     CD2 : =>FALSE                     else
     767/     CD2 :                                     ldAD    memAddr,SP
     767/     CD2 : [767]                       endif
     767/     CD2 : 9B                          ghi     R11
     767/     CD3 : 5E                          str     memAddr
     767/     CD4 : 1E                          inc     memAddr
     767/     CD5 : 8B                          glo     R11
     767/     CD6 : 5E                          str     memAddr
     768/     CD7 :                     ;	if (s<0){
     769/     CD7 : (MACRO)             	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
     769/     CD7 : =>TRUE                      if      ('O'='O')
     769/     CD7 :  (MACRO-2)                          ldAX    memAddr,SP,(16+1)
     769/     CD7 : 82                          glo     SP
     769/     CD8 : FC 11                       adi     ((16+1))#256
     769/     CDA : AE                          plo     MEMADDR
     769/     CDB : 92                          ghi     SP
     769/     CDC : 7C 00                       adci    ((16+1))>>8; was/256
     769/     CDE : BE                          phi     MEMADDR
     769/     CDF : =>FALSE                     else
     769/     CDF :                                     ldAD    memAddr,SP
     769/     CDF : [769]                       endif
     769/     CDF : 4E                          lda     memAddr
     769/     CE0 : BB                          phi     R11
     769/     CE1 : 0E                          ldn     memAddr
     769/     CE2 : AB                          plo     R11
     770/     CE3 : (MACRO)             	jcI2I R11,0,lbdf,L127; GE is flipped test from LT
     770/     CE3 : 8B                          glo     R11
     770/     CE4 : FF 00                       smi     (0)#256
     770/     CE6 : 9B                          ghi     R11
     770/     CE7 : 7F 00                       smbi    (0)>>8; was/256      ;that's a standard signed subtraction
     770/     CE9 : 9B                          ghi     R11 ;
     770/     CEA : FB 00                       xri     (0)>>8; was/256      ;sets the top bit if the signs are different
     770/     CEC : 7E                          shlc          ;the original df is now in bit 0 and df=1 if signs were different
     770/     CED : C7                          lsnf    ;bypass the df flip if signs were the same
     770/     CEE : FB 01                       xri     01     ;invert original df if signs were different
     770/     CF0 : 76                          shrc           ;put it back in df
     770/     CF1 : C3 0C F1                    LBDF    L127  ;execute 
     771/     CF4 :                     ;		*bptr='-';bptr++;
     772/     CF4 : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
     772/     CF4 : =>TRUE                      if      ('O'='O')
     772/     CF4 :  (MACRO-2)                          ldAX    memAddr,SP,(12+1)
     772/     CF4 : 82                          glo     SP
     772/     CF5 : FC 0D                       adi     ((12+1))#256
     772/     CF7 : AE                          plo     MEMADDR
     772/     CF8 : 92                          ghi     SP
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 46 - 1/18/2018 14:51:20


     772/     CF9 : 7C 00                       adci    ((12+1))>>8; was/256
     772/     CFB : BE                          phi     MEMADDR
     772/     CFC : =>FALSE                     else
     772/     CFC :                                     ldAD    memAddr,SP
     772/     CFC : [772]                       endif
     772/     CFC : 4E                          lda     memAddr
     772/     CFD : BB                          phi     R11
     772/     CFE : 0E                          ldn     memAddr
     772/     CFF : AB                          plo     R11
     773/     D00 : (MACRO)             	str1I 45,R11; ASGNU1(indaddr,acon)	DH
     773/     D00 : F8 2D                       ldi     45
     773/     D02 : 5B                          str     R11
     774/     D03 : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
     774/     D03 : =>TRUE                      if      ('O'='O')
     774/     D03 :  (MACRO-2)                          ldAX    memAddr,SP,(12+1)
     774/     D03 : 82                          glo     SP
     774/     D04 : FC 0D                       adi     ((12+1))#256
     774/     D06 : AE                          plo     MEMADDR
     774/     D07 : 92                          ghi     SP
     774/     D08 : 7C 00                       adci    ((12+1))>>8; was/256
     774/     D0A : BE                          phi     MEMADDR
     774/     D0B : =>FALSE                     else
     774/     D0B :                                     ldAD    memAddr,SP
     774/     D0B : [774]                       endif
     774/     D0B : 4E                          lda     memAddr
     774/     D0C : BB                          phi     R11
     774/     D0D : 0E                          ldn     memAddr
     774/     D0E : AB                          plo     R11
     775/     D0F : (MACRO)             	incm R11,1
     775/     D0F :                             rept    1
     775/     D0F :                             inc     R11
     775/     D0F :                             endm
     775/     D0F : 1B                          inc     R11
     776/     D10 : (MACRO)             	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
     776/     D10 : =>TRUE                      if      ('O'='O')
     776/     D10 :  (MACRO-2)                          ldAX    memAddr,SP,(12+1)
     776/     D10 : 82                          glo     SP
     776/     D11 : FC 0D                       adi     ((12+1))#256
     776/     D13 : AE                          plo     MEMADDR
     776/     D14 : 92                          ghi     SP
     776/     D15 : 7C 00                       adci    ((12+1))>>8; was/256
     776/     D17 : BE                          phi     MEMADDR
     776/     D18 : =>FALSE                     else
     776/     D18 :                                     ldAD    memAddr,SP
     776/     D18 : [776]                       endif
     776/     D18 : 9B                          ghi     R11
     776/     D19 : 5E                          str     memAddr
     776/     D1A : 1E                          inc     memAddr
     776/     D1B : 8B                          glo     R11
     776/     D1C : 5E                          str     memAddr
     777/     D1D :                     ;		n=-s;
     778/     D1D : (MACRO)             	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
     778/     D1D : =>TRUE                      if      ('O'='O')
     778/     D1D :  (MACRO-2)                          ldAX    memAddr,SP,(16+1)
     778/     D1D : 82                          glo     SP
     778/     D1E : FC 11                       adi     ((16+1))#256
     778/     D20 : AE                          plo     MEMADDR
     778/     D21 : 92                          ghi     SP
     778/     D22 : 7C 00                       adci    ((16+1))>>8; was/256
     778/     D24 : BE                          phi     MEMADDR
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 47 - 1/18/2018 14:51:20


     778/     D25 : =>FALSE                     else
     778/     D25 :                                     ldAD    memAddr,SP
     778/     D25 : [778]                       endif
     778/     D25 : 4E                          lda     memAddr
     778/     D26 : BB                          phi     R11
     778/     D27 : 0E                          ldn     memAddr
     778/     D28 : AB                          plo     R11
     779/     D29 : (MACRO)             	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
     779/     D29 : 8B                          glo     R11                     ;(flip all the bits and add 1)
     779/     D2A : FB FF                       xri     0xff
     779/     D2C : AB                          plo     R11
     779/     D2D : 9B                          ghi     R11
     779/     D2E : FB FF                       xri     0xff
     779/     D30 : BB                          phi     R11
     779/     D31 : 1B                          inc     R11
     780/     D32 : (MACRO)             	cpy2 R6,R11 ;LOADU2*(reg)
     780/     D32 : 8B                          glo     R11
     780/     D33 : A6                          plo     R6
     780/     D34 : 9B                          ghi     R11
     780/     D35 : B6                          phi     R6
     781/     D36 :                     ;	} else{
     782/     D36 : C0 0D 36            	lbr L128
     783/     D39 :                     L127:
     784/     D39 :                     ;		n=s;
     785/     D39 : (MACRO)             	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
     785/     D39 : =>TRUE                      if      ('O'='O')
     785/     D39 :  (MACRO-2)                          ldAX    memAddr,SP,(16+1)
     785/     D39 : 82                          glo     SP
     785/     D3A : FC 11                       adi     ((16+1))#256
     785/     D3C : AE                          plo     MEMADDR
     785/     D3D : 92                          ghi     SP
     785/     D3E : 7C 00                       adci    ((16+1))>>8; was/256
     785/     D40 : BE                          phi     MEMADDR
     785/     D41 : =>FALSE                     else
     785/     D41 :                                     ldAD    memAddr,SP
     785/     D41 : [785]                       endif
     785/     D41 : 4E                          lda     memAddr
     785/     D42 : BB                          phi     R11
     785/     D43 : 0E                          ldn     memAddr
     785/     D44 : AB                          plo     R11
     786/     D45 : (MACRO)             	cpy2 R6,R11 ;LOADU2*(reg)
     786/     D45 : 8B                          glo     R11
     786/     D46 : A6                          plo     R6
     786/     D47 : 9B                          ghi     R11
     786/     D48 : B6                          phi     R6
     787/     D49 :                     ;	}
     788/     D49 :                     L128:
     789/     D49 :                     ;	k=10000;
     790/     D49 : (MACRO)             	ldaD R7,10000; reg:acon
     790/     D49 : =>FALSE              if MOMCPU=$1805
     790/     D49 :                             RLDI    R7,10000
     790/     D49 : =>TRUE               else
     790/     D49 : F8 10                       ldi     (10000)&255
     790/     D4B : A7                          plo     R7
     790/     D4C : F8 27                       ldi     (10000)>>8; was/256
     790/     D4E : B7                          phi     R7
     790/     D4F : [790]                endif
     791/     D4F : C0 0D 4F            	lbr L130
     792/     D52 :                     L129:
     793/     D52 :                     ;	while(k>0){
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 48 - 1/18/2018 14:51:20


     794/     D52 :                     ;		for(r=0;k<=n;r++,n-=k); // was r=n/k
     795/     D52 : (MACRO)             	ld2z R1
     795/     D52 : F8 00                       ldi     0
     795/     D54 : A1                          plo     R1
     795/     D55 : B1                          phi     R1
     796/     D56 : C0 0D 56            	lbr L135
     797/     D59 :                     L132:
     798/     D59 :                     L133:
     799/     D59 : (MACRO)             	incm R1,1
     799/     D59 :                             rept    1
     799/     D59 :                             inc     R1
     799/     D59 :                             endm
     799/     D59 : 11                          inc     R1
     800/     D5A : (MACRO)             	alu2 R6,R6,R7,sm,smb
     800/     D5A : 87                          glo     R7
     800/     D5B : 52                          str     sp
     800/     D5C : 86                          glo     R6
     800/     D5D : F7                          SM             ;calculate the low order byte
     800/     D5E : A6                          plo     R6
     800/     D5F : 97                          ghi     R7
     800/     D60 : 52                          str     sp
     800/     D61 : 96                          ghi     R6
     800/     D62 : 77                          SMB             ;calculate the high byte
     800/     D63 : B6                          phi     R6
     801/     D64 :                     L135:
     802/     D64 : (MACRO)             	jcU2 R6,R7,lbdf,L132 ;LE is flipped test & operands
     802/     D64 : 22                          dec     sp
     802/     D65 : 87                          glo     R7
     802/     D66 : 52                          str     sp
     802/     D67 : 86                          glo     R6
     802/     D68 : F7                          sm
     802/     D69 : 97                          ghi     R7
     802/     D6A : 52                          str     sp
     802/     D6B : 96                          ghi     R6
     802/     D6C : 77                          smb
     802/     D6D : 12                          inc     sp
     802/     D6E : C3 0D 59                    LBDF    L132
     803/     D71 :                     ;		if (flag || r>0||k==1){
     804/     D71 : (MACRO)             	jnzU2 R0,L139; NE 0 
     804/     D71 : 80                          glo     R0
     804/     D72 : CA 0D 72                    lbnz    L139
     804/     D75 : 90                          ghi     R0
     804/     D76 : CA 0D 76                    lbnz    L139
     805/     D79 : (MACRO)             	jnzU2 R1,L139; NE 0 
     805/     D79 : 81                          glo     R1
     805/     D7A : CA 0D 7A                    lbnz    L139
     805/     D7D : 91                          ghi     R1
     805/     D7E : CA 0D 7E                    lbnz    L139
     806/     D81 : (MACRO)             	jneU2I R7,1,L136; NE
     806/     D81 : 87                          glo     R7
     806/     D82 : FF 01                       smi     (1)#256
     806/     D84 : CA 0D 84                    lbnz    L136
     806/     D87 : 97                          ghi     R7
     806/     D88 : 7F 00                       smbi    (1)>>8; was/256
     806/     D8A : CA 0D 8A                    lbnz    L136
     807/     D8D :                     L139:
     808/     D8D :                     ;			*bptr=('0'+r);bptr++;
     809/     D8D : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
     809/     D8D : =>TRUE                      if      ('O'='O')
     809/     D8D :  (MACRO-2)                          ldAX    memAddr,SP,(12+1)
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 49 - 1/18/2018 14:51:20


     809/     D8D : 82                          glo     SP
     809/     D8E : FC 0D                       adi     ((12+1))#256
     809/     D90 : AE                          plo     MEMADDR
     809/     D91 : 92                          ghi     SP
     809/     D92 : 7C 00                       adci    ((12+1))>>8; was/256
     809/     D94 : BE                          phi     MEMADDR
     809/     D95 : =>FALSE                     else
     809/     D95 :                                     ldAD    memAddr,SP
     809/     D95 : [809]                       endif
     809/     D95 : 4E                          lda     memAddr
     809/     D96 : BB                          phi     R11
     809/     D97 : 0E                          ldn     memAddr
     809/     D98 : AB                          plo     R11
     810/     D99 : (MACRO)             	ldA2 R10,'O',R1,(48); reg:addr
     810/     D99 :                     ;Oct 13 (48) added to ldAD call
     810/     D99 : =>TRUE                      if      ('O'='O')
     810/     D99 :  (MACRO-2)                          ldAX    R10,R1,(48)
     810/     D99 : 81                          glo     R1
     810/     D9A : FC 30                       adi     ((48))#256
     810/     D9C : AA                          plo     R10
     810/     D9D : 91                          ghi     R1
     810/     D9E : 7C 00                       adci    ((48))>>8; was/256
     810/     DA0 : BA                          phi     R10
     810/     DA1 : =>FALSE                     else
     810/     DA1 :                                     ldAD    R10,R1+(48)
     810/     DA1 : [810]                       endif
     811/     DA1 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     811/     DA1 : 8A                          glo     R10
     811/     DA2 : 5B                          str     R11
     812/     DA3 : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
     812/     DA3 : =>TRUE                      if      ('O'='O')
     812/     DA3 :  (MACRO-2)                          ldAX    memAddr,SP,(12+1)
     812/     DA3 : 82                          glo     SP
     812/     DA4 : FC 0D                       adi     ((12+1))#256
     812/     DA6 : AE                          plo     MEMADDR
     812/     DA7 : 92                          ghi     SP
     812/     DA8 : 7C 00                       adci    ((12+1))>>8; was/256
     812/     DAA : BE                          phi     MEMADDR
     812/     DAB : =>FALSE                     else
     812/     DAB :                                     ldAD    memAddr,SP
     812/     DAB : [812]                       endif
     812/     DAB : 4E                          lda     memAddr
     812/     DAC : BB                          phi     R11
     812/     DAD : 0E                          ldn     memAddr
     812/     DAE : AB                          plo     R11
     813/     DAF : (MACRO)             	incm R11,1
     813/     DAF :                             rept    1
     813/     DAF :                             inc     R11
     813/     DAF :                             endm
     813/     DAF : 1B                          inc     R11
     814/     DB0 : (MACRO)             	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
     814/     DB0 : =>TRUE                      if      ('O'='O')
     814/     DB0 :  (MACRO-2)                          ldAX    memAddr,SP,(12+1)
     814/     DB0 : 82                          glo     SP
     814/     DB1 : FC 0D                       adi     ((12+1))#256
     814/     DB3 : AE                          plo     MEMADDR
     814/     DB4 : 92                          ghi     SP
     814/     DB5 : 7C 00                       adci    ((12+1))>>8; was/256
     814/     DB7 : BE                          phi     MEMADDR
     814/     DB8 : =>FALSE                     else
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 50 - 1/18/2018 14:51:20


     814/     DB8 :                                     ldAD    memAddr,SP
     814/     DB8 : [814]                       endif
     814/     DB8 : 9B                          ghi     R11
     814/     DB9 : 5E                          str     memAddr
     814/     DBA : 1E                          inc     memAddr
     814/     DBB : 8B                          glo     R11
     814/     DBC : 5E                          str     memAddr
     815/     DBD :                     ;			flag='y';
     816/     DBD : (MACRO)             	ldaD R0,121; reg:acon
     816/     DBD : =>FALSE              if MOMCPU=$1805
     816/     DBD :                             RLDI    R0,121
     816/     DBD : =>TRUE               else
     816/     DBD : F8 79                       ldi     (121)&255
     816/     DBF : A0                          plo     R0
     816/     DC0 : F8 00                       ldi     (121)>>8; was/256
     816/     DC2 : B0                          phi     R0
     816/     DC3 : [816]                endif
     817/     DC3 :                     ;		}
     818/     DC3 :                     L136:
     819/     DC3 :                     ;		k=k/10;
     820/     DC3 : (MACRO)             	cpy2 R12,R7 ;LOADU2*(reg)
     820/     DC3 : 87                          glo     R7
     820/     DC4 : AC                          plo     R12
     820/     DC5 : 97                          ghi     R7
     820/     DC6 : BC                          phi     R12
     821/     DC7 : (MACRO)             	ldaD R13,10; reg:acon
     821/     DC7 : =>FALSE              if MOMCPU=$1805
     821/     DC7 :                             RLDI    R13,10
     821/     DC7 : =>TRUE               else
     821/     DC7 : F8 0A                       ldi     (10)&255
     821/     DC9 : AD                          plo     R13
     821/     DCA : F8 00                       ldi     (10)>>8; was/256
     821/     DCC : BD                          phi     R13
     821/     DCD : [821]                endif
     822/     DCD : (MACRO)             	Ccall _divu2
     822/     DCD : =>FALSE              if MOMCPU=$1805
     822/     DCD :                             SCAL    6
     822/     DCD :                             dw      _DIVU2
     822/     DCD : =>TRUE               else
     822/     DCD : D4                          sep     RCALL
     822/     DCE : 0D CE                       dw      _DIVU2
     822/     DD0 : [822]                endif
     823/     DD0 : (MACRO)             	cpy2 R7,R15 ;LOADU2*(reg)
     823/     DD0 : 8F                          glo     R15
     823/     DD1 : A7                          plo     R7
     823/     DD2 : 9F                          ghi     R15
     823/     DD3 : B7                          phi     R7
     824/     DD4 :                     ;	}
     825/     DD4 :                     L130:
     826/     DD4 :                     ;	while(k>0){
     827/     DD4 : (MACRO)             	jnzU2 R7,L129; NE 0 
     827/     DD4 : 87                          glo     R7
     827/     DD5 : CA 0D 52                    lbnz    L129
     827/     DD8 : 97                          ghi     R7
     827/     DD9 : CA 0D 52                    lbnz    L129
     828/     DDC :                     ;	*bptr='\0';
     829/     DDC : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
     829/     DDC : =>TRUE                      if      ('O'='O')
     829/     DDC :  (MACRO-2)                          ldAX    memAddr,SP,(12+1)
     829/     DDC : 82                          glo     SP
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 51 - 1/18/2018 14:51:20


     829/     DDD : FC 0D                       adi     ((12+1))#256
     829/     DDF : AE                          plo     MEMADDR
     829/     DE0 : 92                          ghi     SP
     829/     DE1 : 7C 00                       adci    ((12+1))>>8; was/256
     829/     DE3 : BE                          phi     MEMADDR
     829/     DE4 : =>FALSE                     else
     829/     DE4 :                                     ldAD    memAddr,SP
     829/     DE4 : [829]                       endif
     829/     DE4 : 4E                          lda     memAddr
     829/     DE5 : BB                          phi     R11
     829/     DE6 : 0E                          ldn     memAddr
     829/     DE7 : AB                          plo     R11
     830/     DE8 : (MACRO)             	str1I 0,R11; ASGNU1(indaddr,acon)	DH
     830/     DE8 : F8 00                       ldi     0
     830/     DEA : 5B                          str     R11
     831/     DEB :                     ;	return buffer;
     832/     DEB : (MACRO)             	ld2 R15,'O',sp,(18+1) ;reg:INDIRP2(addr)
     832/     DEB : =>TRUE                      if      ('O'='O')
     832/     DEB :  (MACRO-2)                          ldAX    memAddr,SP,(18+1)
     832/     DEB : 82                          glo     SP
     832/     DEC : FC 13                       adi     ((18+1))#256
     832/     DEE : AE                          plo     MEMADDR
     832/     DEF : 92                          ghi     SP
     832/     DF0 : 7C 00                       adci    ((18+1))>>8; was/256
     832/     DF2 : BE                          phi     MEMADDR
     832/     DF3 : =>FALSE                     else
     832/     DF3 :                                     ldAD    memAddr,SP
     832/     DF3 : [832]                       endif
     832/     DF3 : 4E                          lda     memAddr
     832/     DF4 : BF                          phi     R15
     832/     DF5 : 0E                          ldn     memAddr
     832/     DF6 : AF                          plo     R15
     833/     DF7 :                     L126:
     834/     DF7 : (MACRO)             	release 4; release room for outgoing arguments
     834/     DF7 : =>TRUE                      if (4<9)
     834/     DF7 :  (MACRO-2)                      releaseS 4  ;use dec for small amounts
     834/     DF7 :                             rept    4
     834/     DF7 :                             inc sp
     834/     DF7 :                             endm
     834/     DF7 : 12                          inc sp
     834/     DF8 : 12                          inc sp
     834/     DF9 : 12                          inc sp
     834/     DFA : 12                          inc sp
     834/     DFB : =>FALSE                     else
     834/     DFB :                                 releaseL 4  ;use subtract for large amounts
     834/     DFB : [834]                       endif
     835/     DFB : (MACRO)             	popf R7	;opt11.3
     835/     DFB : =>FALSE              if MOMCPU=$1805
     835/     DFB :                             inc     sp
     835/     DFB :                             RLXA    R7
     835/     DFB : =>TRUE               else
     835/     DFB : 12                          inc     sp
     835/     DFC : 42                          lda     sp
     835/     DFD : B7                          phi     R7
     835/     DFE : 42                          lda     sp
     835/     DFF : A7                          plo     R7
     835/     E00 : [835]                endif
     836/     E00 : (MACRO)             	popm R6	;opt11.4
     836/     E00 : =>FALSE              if MOMCPU=$1805
     836/     E00 :                             RLXA    R6
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 52 - 1/18/2018 14:51:20


     836/     E00 : =>TRUE               else
     836/     E00 : 42                          lda     sp
     836/     E01 : B6                          phi     R6
     836/     E02 : 42                          lda     sp
     836/     E03 : A6                          plo     R6
     836/     E04 : [836]                endif
     837/     E04 : (MACRO)             	popm R1	;opt11.4
     837/     E04 : =>FALSE              if MOMCPU=$1805
     837/     E04 :                             RLXA    R1
     837/     E04 : =>TRUE               else
     837/     E04 : 42                          lda     sp
     837/     E05 : B1                          phi     R1
     837/     E06 : 42                          lda     sp
     837/     E07 : A1                          plo     R1
     837/     E08 : [837]                endif
     838/     E08 : (MACRO)             	popl R0	;opt11.4
     838/     E08 : 42                          lda     sp
     838/     E09 : B0                          phi     R0
     838/     E0A : 02                          ldn     sp
     838/     E0B : A0                          plo     R0
     839/     E0C : (MACRO)             	release 2; release room for local variables 
     839/     E0C : =>TRUE                      if (2<9)
     839/     E0C :  (MACRO-2)                      releaseS 2  ;use dec for small amounts
     839/     E0C :                             rept    2
     839/     E0C :                             inc sp
     839/     E0C :                             endm
     839/     E0C : 12                          inc sp
     839/     E0D : 12                          inc sp
     839/     E0E : =>FALSE                     else
     839/     E0E :                                 releaseL 2  ;use subtract for large amounts
     839/     E0E : [839]                       endif
     840/     E0E : (MACRO)             	Cretn
     840/     E0E : =>FALSE              if MOMCPU=$1805
     840/     E0E :                             sret    6
     840/     E0E : =>TRUE               else
     840/     E0E : D5                          sep     RRET
     840/     E0F : [840]                endif
     841/     E0F :                     
     842/     E0F :                     ;$$function end$$ _itoa
     843/     E0F :                     ;$$function start$$ _ltoa
     844/     E0F :                     _ltoa:		;framesize=16
     845/     E0F : (MACRO)             	pushr R1
     845/     E0F : =>FALSE              if MOMCPU=$1805
     845/     E0F :                             RSXD    R1
     845/     E0F : =>TRUE               else
     845/     E0F : 81                          glo     R1
     845/     E10 : 73                          stxd
     845/     E11 : 91                          ghi     R1
     845/     E12 : 73                          stxd
     845/     E13 : [845]                endif
     846/     E13 : (MACRO)             	pushr R6
     846/     E13 : =>FALSE              if MOMCPU=$1805
     846/     E13 :                             RSXD    R6
     846/     E13 : =>TRUE               else
     846/     E13 : 86                          glo     R6
     846/     E14 : 73                          stxd
     846/     E15 : 96                          ghi     R6
     846/     E16 : 73                          stxd
     846/     E17 : [846]                endif
     847/     E17 : (MACRO)             	pushr R7
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 53 - 1/18/2018 14:51:20


     847/     E17 : =>FALSE              if MOMCPU=$1805
     847/     E17 :                             RSXD    R7
     847/     E17 : =>TRUE               else
     847/     E17 : 87                          glo     R7
     847/     E18 : 73                          stxd
     847/     E19 : 97                          ghi     R7
     847/     E1A : 73                          stxd
     847/     E1B : [847]                endif
     848/     E1B : (MACRO)             	reserve 8; save room for outgoing arguments
     848/     E1B : =>TRUE                      if (8<9)
     848/     E1B :  (MACRO-2)                      reserveS 8  ;use dec for small amounts
     848/     E1B :                             rept    8
     848/     E1B :                             dec sp
     848/     E1B :                             endm
     848/     E1B : 22                          dec sp
     848/     E1C : 22                          dec sp
     848/     E1D : 22                          dec sp
     848/     E1E : 22                          dec sp
     848/     E1F : 22                          dec sp
     848/     E20 : 22                          dec sp
     848/     E21 : 22                          dec sp
     848/     E22 : 22                          dec sp
     848/     E23 : =>FALSE                     else
     848/     E23 :                                 reserveL 8  ;use subtract for large amounts
     848/     E23 : [848]                       endif
     849/     E23 : (MACRO)             	cpy4 RL6,RL12; halfbaked
     849/     E23 :  (MACRO-2)                  cpy2    RL6,RL12 ;long reg pairs are addressed as the low order pair
     849/     E23 : 8D                          glo     RL12
     849/     E24 : A7                          plo     RL6
     849/     E25 : 9D                          ghi     RL12
     849/     E26 : B7                          phi     RL6
     849/     E27 :  (MACRO-2)                  cpy2    RL6-1,RL12-1
     849/     E27 : 8C                          glo     RL12-1
     849/     E28 : A6                          plo     RL6-1
     849/     E29 : 9C                          ghi     RL12-1
     849/     E2A : B6                          phi     RL6-1
     850/     E2B :                     ;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
     851/     E2B :                     ;	char* bptr=buffer;
     852/     E2B : (MACRO)             	ld2 R1,'O',sp,(20+1) ;reg:INDIRP2(addr)
     852/     E2B : =>TRUE                      if      ('O'='O')
     852/     E2B :  (MACRO-2)                          ldAX    memAddr,SP,(20+1)
     852/     E2B : 82                          glo     SP
     852/     E2C : FC 15                       adi     ((20+1))#256
     852/     E2E : AE                          plo     MEMADDR
     852/     E2F : 92                          ghi     SP
     852/     E30 : 7C 00                       adci    ((20+1))>>8; was/256
     852/     E32 : BE                          phi     MEMADDR
     852/     E33 : =>FALSE                     else
     852/     E33 :                                     ldAD    memAddr,SP
     852/     E33 : [852]                       endif
     852/     E33 : 4E                          lda     memAddr
     852/     E34 : B1                          phi     R1
     852/     E35 : 0E                          ldn     memAddr
     852/     E36 : A1                          plo     R1
     853/     E37 :                     ;	if (s<0){
     854/     E37 : (MACRO)             	ldI4 RL10,0 ;loading a long integer constant
     854/     E37 : F8 00                       ldi     (0)&255
     854/     E39 : AB                          plo     RL10
     854/     E3A : F8 00                       ldi     ((0)>>8)&255; 
     854/     E3C : BB                          phi     RL10
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 54 - 1/18/2018 14:51:20


     854/     E3D : F8 00                       ldi     ((0)>>16)&255; 
     854/     E3F : AA                          plo     RL10-1
     854/     E40 : F8 00                       ldi     ((0)>>24)&255; 
     854/     E42 : BA                          phi     RL10-1
     855/     E43 : (MACRO)             	jcI4 RL6,RL10,lbdf,L141; GE is flipped test from LT
     855/     E43 : 22                          dec     sp ;make a work area
     855/     E44 : 8B                          glo     RL10    ;lowest order byte
     855/     E45 : 52                          str     sp 
     855/     E46 : 87                          glo     RL6
     855/     E47 : F7                          sm
     855/     E48 : 9B                          ghi     RL10
     855/     E49 : 52                          str     sp
     855/     E4A : 97                          ghi     RL6
     855/     E4B : 77                          smb          ;that's a standard signed subtraction of one reg
     855/     E4C : 8A                          glo     RL10-1  ;lowest order byte of the top register
     855/     E4D : 52                          str     sp 
     855/     E4E : 86                          glo     RL6-1
     855/     E4F : 77                          smb
     855/     E50 : 9A                          ghi     RL10-1
     855/     E51 : 52                          str     sp
     855/     E52 : 96                          ghi     RL6-1
     855/     E53 : 77                          smb          ;that's a standard signed subtraction of a double register
     855/     E54 : 96                          ghi     RL6-1 ;
     855/     E55 : F3                          xor           ;sets the top bit if the signs are different
     855/     E56 : 12                          inc     sp ;release the work area
     855/     E57 : 7E                          shlc          ;the original df is now in bit 0 and df=1 if signs were different
     855/     E58 : C7                          lsnf    ;bypass the flip if signs were the same
     855/     E59 : FB 01                       xri     01     ;invert original df if signs were different
     855/     E5B : 76                          shrc           ;put it back in df
     855/     E5C : C3 0E 5C                    LBDF    L141  ;execute 
     856/     E5F :                     ;		*bptr++='-';
     857/     E5F : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     857/     E5F : 81                          glo     R1
     857/     E60 : AB                          plo     R11
     857/     E61 : 91                          ghi     R1
     857/     E62 : BB                          phi     R11
     858/     E63 : (MACRO)             	incm R1,1
     858/     E63 :                             rept    1
     858/     E63 :                             inc     R1
     858/     E63 :                             endm
     858/     E63 : 11                          inc     R1
     859/     E64 : (MACRO)             	str1I 45,R11; ASGNU1(indaddr,acon)	DH
     859/     E64 : F8 2D                       ldi     45
     859/     E66 : 5B                          str     R11
     860/     E67 :                     ;		s=-s;
     861/     E67 : (MACRO)             	negI4 RL6,RL6 ;was alu4I RL6,RL6,0,sdi,sdbi
     861/     E67 :  (MACRO-2)                  alu4I   RL6,RL6,0xffffffff,xri,xri      ;flip all the bits
     861/     E67 : 87                          glo     RL6    ;long regs are equated to the second reg which has the low order word 
     861/     E68 : FB FF                       XRI     (0XFFFFFFFF)&255
     861/     E6A : A7                          plo     RL6
     861/     E6B : 97                          ghi     RL6
     861/     E6C : FB FF                       XRI     ((0XFFFFFFFF)>>8)&255; 
     861/     E6E : B7                          phi     RL6
     861/     E6F : 86                          glo     RL6-1
     861/     E70 : FB FF                       XRI     ((0XFFFFFFFF)>>16)&255; 
     861/     E72 : A6                          plo     RL6-1
     861/     E73 : 96                          ghi     RL6-1
     861/     E74 : FB FF                       XRI     ((0XFFFFFFFF)>>24)&255; 
     861/     E76 : B6                          phi     RL6-1
     861/     E77 :  (MACRO-2)                  alu4i   RL6,RL6,1,adi,adci              ;and add 1
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 55 - 1/18/2018 14:51:20


     861/     E77 : 87                          glo     RL6    ;long regs are equated to the second reg which has the low order word 
     861/     E78 : FC 01                       ADI     (1)&255
     861/     E7A : A7                          plo     RL6
     861/     E7B : 97                          ghi     RL6
     861/     E7C : 7C 00                       ADCI     ((1)>>8)&255; 
     861/     E7E : B7                          phi     RL6
     861/     E7F : 86                          glo     RL6-1
     861/     E80 : 7C 00                       ADCI     ((1)>>16)&255; 
     861/     E82 : A6                          plo     RL6-1
     861/     E83 : 96                          ghi     RL6-1
     861/     E84 : 7C 00                       ADCI     ((1)>>24)&255; 
     861/     E86 : B6                          phi     RL6-1
     862/     E87 :                     ;	}
     863/     E87 :                     L141:
     864/     E87 :                     ;	strcpy(bptr,dubdabx(s,bptr,1)); //uses assembler double-dabble routine
     865/     E87 : (MACRO)             	cpy4 Rp1p2,RL6; LOADI4*
     865/     E87 :  (MACRO-2)                  cpy2    RP1P2,RL6 ;long reg pairs are addressed as the low order pair
     865/     E87 : 87                          glo     RL6
     865/     E88 : AD                          plo     RP1P2
     865/     E89 : 97                          ghi     RL6
     865/     E8A : BD                          phi     RP1P2
     865/     E8B :  (MACRO-2)                  cpy2    RP1P2-1,RL6-1
     865/     E8B : 86                          glo     RL6-1
     865/     E8C : AC                          plo     RP1P2-1
     865/     E8D : 96                          ghi     RL6-1
     865/     E8E : BC                          phi     RP1P2-1
     866/     E8F : (MACRO)             	st2 R1,'O',sp,(4+1); arg+f**
     866/     E8F : =>TRUE                      if      ('O'='O')
     866/     E8F :  (MACRO-2)                          ldAX    memAddr,SP,(4+1)
     866/     E8F : 82                          glo     SP
     866/     E90 : FC 05                       adi     ((4+1))#256
     866/     E92 : AE                          plo     MEMADDR
     866/     E93 : 92                          ghi     SP
     866/     E94 : 7C 00                       adci    ((4+1))>>8; was/256
     866/     E96 : BE                          phi     MEMADDR
     866/     E97 : =>FALSE                     else
     866/     E97 :                                     ldAD    memAddr,SP
     866/     E97 : [866]                       endif
     866/     E97 : 91                          ghi     R1
     866/     E98 : 5E                          str     memAddr
     866/     E99 : 1E                          inc     memAddr
     866/     E9A : 81                          glo     R1
     866/     E9B : 5E                          str     memAddr
     867/     E9C : (MACRO)             	ldaD R11,1; reg:acon
     867/     E9C : =>FALSE              if MOMCPU=$1805
     867/     E9C :                             RLDI    R11,1
     867/     E9C : =>TRUE               else
     867/     E9C : F8 01                       ldi     (1)&255
     867/     E9E : AB                          plo     R11
     867/     E9F : F8 00                       ldi     (1)>>8; was/256
     867/     EA1 : BB                          phi     R11
     867/     EA2 : [867]                endif
     868/     EA2 : (MACRO)             	st2 R11,'O',sp,(6+1); arg+f**
     868/     EA2 : =>TRUE                      if      ('O'='O')
     868/     EA2 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     868/     EA2 : 82                          glo     SP
     868/     EA3 : FC 07                       adi     ((6+1))#256
     868/     EA5 : AE                          plo     MEMADDR
     868/     EA6 : 92                          ghi     SP
     868/     EA7 : 7C 00                       adci    ((6+1))>>8; was/256
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 56 - 1/18/2018 14:51:20


     868/     EA9 : BE                          phi     MEMADDR
     868/     EAA : =>FALSE                     else
     868/     EAA :                                     ldAD    memAddr,SP
     868/     EAA : [868]                       endif
     868/     EAA : 9B                          ghi     R11
     868/     EAB : 5E                          str     memAddr
     868/     EAC : 1E                          inc     memAddr
     868/     EAD : 8B                          glo     R11
     868/     EAE : 5E                          str     memAddr
     869/     EAF : (MACRO)             	Ccall _dubdabx
     869/     EAF : =>FALSE              if MOMCPU=$1805
     869/     EAF :                             SCAL    6
     869/     EAF :                             dw      _DUBDABX
     869/     EAF : =>TRUE               else
     869/     EAF : D4                          sep     RCALL
     869/     EB0 : 0E B0                       dw      _DUBDABX
     869/     EB2 : [869]                endif
     870/     EB2 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     870/     EB2 : 8F                          glo     R15
     870/     EB3 : AB                          plo     R11
     870/     EB4 : 9F                          ghi     R15
     870/     EB5 : BB                          phi     R11
     871/     EB6 : (MACRO)             	cpy2 R12,R1 ;LOADP2(reg)
     871/     EB6 : 81                          glo     R1
     871/     EB7 : AC                          plo     R12
     871/     EB8 : 91                          ghi     R1
     871/     EB9 : BC                          phi     R12
     872/     EBA : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     872/     EBA : 8B                          glo     R11
     872/     EBB : AD                          plo     R13
     872/     EBC : 9B                          ghi     R11
     872/     EBD : BD                          phi     R13
     873/     EBE : (MACRO)             	Ccall _strcpy
     873/     EBE : =>FALSE              if MOMCPU=$1805
     873/     EBE :                             SCAL    6
     873/     EBE :                             dw      _STRCPY
     873/     EBE : =>TRUE               else
     873/     EBE : D4                          sep     RCALL
     873/     EBF : 0E BF                       dw      _STRCPY
     873/     EC1 : [873]                endif
     874/     EC1 :                     ;	return buffer;
     875/     EC1 : (MACRO)             	ld2 R15,'O',sp,(20+1) ;reg:INDIRP2(addr)
     875/     EC1 : =>TRUE                      if      ('O'='O')
     875/     EC1 :  (MACRO-2)                          ldAX    memAddr,SP,(20+1)
     875/     EC1 : 82                          glo     SP
     875/     EC2 : FC 15                       adi     ((20+1))#256
     875/     EC4 : AE                          plo     MEMADDR
     875/     EC5 : 92                          ghi     SP
     875/     EC6 : 7C 00                       adci    ((20+1))>>8; was/256
     875/     EC8 : BE                          phi     MEMADDR
     875/     EC9 : =>FALSE                     else
     875/     EC9 :                                     ldAD    memAddr,SP
     875/     EC9 : [875]                       endif
     875/     EC9 : 4E                          lda     memAddr
     875/     ECA : BF                          phi     R15
     875/     ECB : 0E                          ldn     memAddr
     875/     ECC : AF                          plo     R15
     876/     ECD :                     L140:
     877/     ECD : (MACRO)             	release 8; release room for outgoing arguments
     877/     ECD : =>TRUE                      if (8<9)
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 57 - 1/18/2018 14:51:20


     877/     ECD :  (MACRO-2)                      releaseS 8  ;use dec for small amounts
     877/     ECD :                             rept    8
     877/     ECD :                             inc sp
     877/     ECD :                             endm
     877/     ECD : 12                          inc sp
     877/     ECE : 12                          inc sp
     877/     ECF : 12                          inc sp
     877/     ED0 : 12                          inc sp
     877/     ED1 : 12                          inc sp
     877/     ED2 : 12                          inc sp
     877/     ED3 : 12                          inc sp
     877/     ED4 : 12                          inc sp
     877/     ED5 : =>FALSE                     else
     877/     ED5 :                                 releaseL 8  ;use subtract for large amounts
     877/     ED5 : [877]                       endif
     878/     ED5 : (MACRO)             	popf R7	;opt11.3
     878/     ED5 : =>FALSE              if MOMCPU=$1805
     878/     ED5 :                             inc     sp
     878/     ED5 :                             RLXA    R7
     878/     ED5 : =>TRUE               else
     878/     ED5 : 12                          inc     sp
     878/     ED6 : 42                          lda     sp
     878/     ED7 : B7                          phi     R7
     878/     ED8 : 42                          lda     sp
     878/     ED9 : A7                          plo     R7
     878/     EDA : [878]                endif
     879/     EDA : (MACRO)             	popm R6	;opt11.4
     879/     EDA : =>FALSE              if MOMCPU=$1805
     879/     EDA :                             RLXA    R6
     879/     EDA : =>TRUE               else
     879/     EDA : 42                          lda     sp
     879/     EDB : B6                          phi     R6
     879/     EDC : 42                          lda     sp
     879/     EDD : A6                          plo     R6
     879/     EDE : [879]                endif
     880/     EDE : (MACRO)             	popl R1	;opt11.4
     880/     EDE : 42                          lda     sp
     880/     EDF : B1                          phi     R1
     880/     EE0 : 02                          ldn     sp
     880/     EE1 : A1                          plo     R1
     881/     EE2 : (MACRO)             	Cretn
     881/     EE2 : =>FALSE              if MOMCPU=$1805
     881/     EE2 :                             sret    6
     881/     EE2 : =>TRUE               else
     881/     EE2 : D5                          sep     RRET
     881/     EE3 : [881]                endif
     882/     EE3 :                     
     883/     EE3 :                     ;$$function end$$ _ltoa
     884/     EE3 :                     ;$$function start$$ _printint
     885/     EE3 :                     _printint:		;framesize=14
     886/     EE3 : (MACRO)             	reserve 12
     886/     EE3 : =>FALSE                     if (12<9)
     886/     EE3 :                                 reserveS 12  ;use dec for small amounts
     886/     EE3 : =>TRUE                      else
     886/     EE3 :  (MACRO-2)                      reserveL 12  ;use subtract for large amounts
     886/     EE3 :                     ;this calculation looks awkward but we're adjusting the top byte of sp first 
     886/     EE3 :                     ;so if there's an interrupt in mid calculation the sp will be pointing to free memory
     886/     EE3 : 82                          glo sp          ;grab low byte of stack pointer
     886/     EE4 : FF 0C                       smi 12&255 ;claculate new low byte
     886/     EE6 : AE                          plo memAddr     ;save it for a moment
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 58 - 1/18/2018 14:51:20


     886/     EE7 : 92                          ghi sp          ;grab high byte
     886/     EE8 : 7F 00                       smbi (12>>8)&255 ;calculate the new page
     886/     EEA : B2                          phi sp          ;adjust page first
     886/     EEB : 8E                          glo memAddr     ;get new low byte
     886/     EEC : A2                          plo sp          ;finish adjusting the stack pointer
     886/     EED : [886]                       endif
     887/     EED : (MACRO)             	st2 R12,'O',sp,(14+1); flag1 
     887/     EED : =>TRUE                      if      ('O'='O')
     887/     EED :  (MACRO-2)                          ldAX    memAddr,SP,(14+1)
     887/     EED : 82                          glo     SP
     887/     EEE : FC 0F                       adi     ((14+1))#256
     887/     EF0 : AE                          plo     MEMADDR
     887/     EF1 : 92                          ghi     SP
     887/     EF2 : 7C 00                       adci    ((14+1))>>8; was/256
     887/     EF4 : BE                          phi     MEMADDR
     887/     EF5 : =>FALSE                     else
     887/     EF5 :                                     ldAD    memAddr,SP
     887/     EF5 : [887]                       endif
     887/     EF5 : 9C                          ghi     R12
     887/     EF6 : 5E                          str     memAddr
     887/     EF7 : 1E                          inc     memAddr
     887/     EF8 : 8C                          glo     R12
     887/     EF9 : 5E                          str     memAddr
     888/     EFA :                     ;void printint(int s){ //print an integer
     889/     EFA :                     ;	itoa(s,buffer);
     890/     EFA : (MACRO)             	ld2 R12,'O',sp,(14+1) ;reg:INDIRI2(addr)
     890/     EFA : =>TRUE                      if      ('O'='O')
     890/     EFA :  (MACRO-2)                          ldAX    memAddr,SP,(14+1)
     890/     EFA : 82                          glo     SP
     890/     EFB : FC 0F                       adi     ((14+1))#256
     890/     EFD : AE                          plo     MEMADDR
     890/     EFE : 92                          ghi     SP
     890/     EFF : 7C 00                       adci    ((14+1))>>8; was/256
     890/     F01 : BE                          phi     MEMADDR
     890/     F02 : =>FALSE                     else
     890/     F02 :                                     ldAD    memAddr,SP
     890/     F02 : [890]                       endif
     890/     F02 : 4E                          lda     memAddr
     890/     F03 : BC                          phi     R12
     890/     F04 : 0E                          ldn     memAddr
     890/     F05 : AC                          plo     R12
     891/     F06 : (MACRO)             	ldA2 R13,'O',sp,(4+1); reg:addr
     891/     F06 :                     ;Oct 13 (4+1) added to ldAD call
     891/     F06 : =>TRUE                      if      ('O'='O')
     891/     F06 :  (MACRO-2)                          ldAX    R13,SP,(4+1)
     891/     F06 : 82                          glo     SP
     891/     F07 : FC 05                       adi     ((4+1))#256
     891/     F09 : AD                          plo     R13
     891/     F0A : 92                          ghi     SP
     891/     F0B : 7C 00                       adci    ((4+1))>>8; was/256
     891/     F0D : BD                          phi     R13
     891/     F0E : =>FALSE                     else
     891/     F0E :                                     ldAD    R13,SP+(4+1)
     891/     F0E : [891]                       endif
     892/     F0E : (MACRO)             	Ccall _itoa
     892/     F0E : =>FALSE              if MOMCPU=$1805
     892/     F0E :                             SCAL    6
     892/     F0E :                             dw      _ITOA
     892/     F0E : =>TRUE               else
     892/     F0E : D4                          sep     RCALL
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 59 - 1/18/2018 14:51:20


     892/     F0F : 0C 90                       dw      _ITOA
     892/     F11 : [892]                endif
     893/     F11 :                     ;	printstr(buffer);
     894/     F11 : (MACRO)             	ldA2 R12,'O',sp,(4+1); reg:addr
     894/     F11 :                     ;Oct 13 (4+1) added to ldAD call
     894/     F11 : =>TRUE                      if      ('O'='O')
     894/     F11 :  (MACRO-2)                          ldAX    R12,SP,(4+1)
     894/     F11 : 82                          glo     SP
     894/     F12 : FC 05                       adi     ((4+1))#256
     894/     F14 : AC                          plo     R12
     894/     F15 : 92                          ghi     SP
     894/     F16 : 7C 00                       adci    ((4+1))>>8; was/256
     894/     F18 : BC                          phi     R12
     894/     F19 : =>FALSE                     else
     894/     F19 :                                     ldAD    R12,SP+(4+1)
     894/     F19 : [894]                       endif
     895/     F19 : (MACRO)             	Ccall _printstr
     895/     F19 : =>FALSE              if MOMCPU=$1805
     895/     F19 :                             SCAL    6
     895/     F19 :                             dw      _PRINTSTR
     895/     F19 : =>TRUE               else
     895/     F19 : D4                          sep     RCALL
     895/     F1A : 09 88                       dw      _PRINTSTR
     895/     F1C : [895]                endif
     896/     F1C :                     ;}
     897/     F1C :                     L143:
     898/     F1C : (MACRO)             	release 12
     898/     F1C : =>FALSE                     if (12<9)
     898/     F1C :                                 releaseS 12  ;use dec for small amounts
     898/     F1C : =>TRUE                      else
     898/     F1C :  (MACRO-2)                      releaseL 12  ;use subtract for large amounts
     898/     F1C :                     ;for release we adjust the low byte first 
     898/     F1C :                     ;so if there's an interrupt in mid calculation the sp will be pointing to free memory
     898/     F1C :   (MACRO-3)                 alu2i sp,sp,12,adi,adci
     898/     F1C : 82                          glo     SP
     898/     F1D : FC 0C                       ADI     (12)#256
     898/     F1F : A2                          plo     SP
     898/     F20 : 92                          ghi     SP
     898/     F21 : 7C 00                       ADCI     (12)>>8; was/256
     898/     F23 : B2                          phi     SP
     898/     F24 : [898]                       endif
     899/     F24 : (MACRO)             	Cretn
     899/     F24 : =>FALSE              if MOMCPU=$1805
     899/     F24 :                             sret    6
     899/     F24 : =>TRUE               else
     899/     F24 : D5                          sep     RRET
     899/     F25 : [899]                endif
     900/     F25 :                     
     901/     F25 :                     ;$$function end$$ _printint
     902/     F25 :                     ;$$function start$$ _printlint
     903/     F25 :                     _printlint:		;framesize=20
     904/     F25 : (MACRO)             	reserve 18
     904/     F25 : =>FALSE                     if (18<9)
     904/     F25 :                                 reserveS 18  ;use dec for small amounts
     904/     F25 : =>TRUE                      else
     904/     F25 :  (MACRO-2)                      reserveL 18  ;use subtract for large amounts
     904/     F25 :                     ;this calculation looks awkward but we're adjusting the top byte of sp first 
     904/     F25 :                     ;so if there's an interrupt in mid calculation the sp will be pointing to free memory
     904/     F25 : 82                          glo sp          ;grab low byte of stack pointer
     904/     F26 : FF 12                       smi 18&255 ;claculate new low byte
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 60 - 1/18/2018 14:51:20


     904/     F28 : AE                          plo memAddr     ;save it for a moment
     904/     F29 : 92                          ghi sp          ;grab high byte
     904/     F2A : 7F 00                       smbi (18>>8)&255 ;calculate the new page
     904/     F2C : B2                          phi sp          ;adjust page first
     904/     F2D : 8E                          glo memAddr     ;get new low byte
     904/     F2E : A2                          plo sp          ;finish adjusting the stack pointer
     904/     F2F : [904]                       endif
     905/     F2F : (MACRO)             	st2 R12,'O',sp,(20+1)			
     905/     F2F : =>TRUE                      if      ('O'='O')
     905/     F2F :  (MACRO-2)                          ldAX    memAddr,SP,(20+1)
     905/     F2F : 82                          glo     SP
     905/     F30 : FC 15                       adi     ((20+1))#256
     905/     F32 : AE                          plo     MEMADDR
     905/     F33 : 92                          ghi     SP
     905/     F34 : 7C 00                       adci    ((20+1))>>8; was/256
     905/     F36 : BE                          phi     MEMADDR
     905/     F37 : =>FALSE                     else
     905/     F37 :                                     ldAD    memAddr,SP
     905/     F37 : [905]                       endif
     905/     F37 : 9C                          ghi     R12
     905/     F38 : 5E                          str     memAddr
     905/     F39 : 1E                          inc     memAddr
     905/     F3A : 8C                          glo     R12
     905/     F3B : 5E                          str     memAddr
     906/     F3C : 1E                  	inc memaddr				;opt16.1
     907/     F3D : (MACRO)             	str2 R13,memaddr			
     907/     F3D : 9D                          ghi     R13
     907/     F3E : 5E                          str     MEMADDR
     907/     F3F : 8D                          glo     R13
     907/     F40 : 1E                          inc     MEMADDR
     907/     F41 : 5E                          str     MEMADDR
     907/     F42 : 2E                          dec     MEMADDR
     908/     F43 :                     ;void printlint(long s){ //print a long integer
     909/     F43 :                     ;	printstr(ltoa(s,buffer));
     910/     F43 : (MACRO)             	ld4 Rp1p2,'O',sp,(20+1);reg:  INDIRI4(addr)
     910/     F43 : =>TRUE                      if      ('O'='O')
     910/     F43 :  (MACRO-2)                          ldAX    memAddr,SP,(20+1)
     910/     F43 : 82                          glo     SP
     910/     F44 : FC 15                       adi     ((20+1))#256
     910/     F46 : AE                          plo     MEMADDR
     910/     F47 : 92                          ghi     SP
     910/     F48 : 7C 00                       adci    ((20+1))>>8; was/256
     910/     F4A : BE                          phi     MEMADDR
     910/     F4B : =>FALSE                     else
     910/     F4B :                                     ldAD    memAddr,SP
     910/     F4B : [910]                       endif
     910/     F4B : 4E                          lda     memAddr
     910/     F4C : BC                          phi     RP1P2-1   ;long register pairs are addressed by their second member
     910/     F4D : 4E                          lda     memAddr ;but load and store start with the 1st
     910/     F4E : AC                          plo     RP1P2-1
     910/     F4F : 4E                          lda     memAddr
     910/     F50 : BD                          phi     RP1P2
     910/     F51 : 0E                          ldn     memAddr
     910/     F52 : AD                          plo     RP1P2
     911/     F53 : (MACRO)             	ldA2 R11,'O',sp,(6+1); reg:addr
     911/     F53 :                     ;Oct 13 (6+1) added to ldAD call
     911/     F53 : =>TRUE                      if      ('O'='O')
     911/     F53 :  (MACRO-2)                          ldAX    R11,SP,(6+1)
     911/     F53 : 82                          glo     SP
     911/     F54 : FC 07                       adi     ((6+1))#256
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 61 - 1/18/2018 14:51:20


     911/     F56 : AB                          plo     R11
     911/     F57 : 92                          ghi     SP
     911/     F58 : 7C 00                       adci    ((6+1))>>8; was/256
     911/     F5A : BB                          phi     R11
     911/     F5B : =>FALSE                     else
     911/     F5B :                                     ldAD    R11,SP+(6+1)
     911/     F5B : [911]                       endif
     912/     F5B : (MACRO)             	st2 R11,'O',sp,(4+1); arg+f**
     912/     F5B : =>TRUE                      if      ('O'='O')
     912/     F5B :  (MACRO-2)                          ldAX    memAddr,SP,(4+1)
     912/     F5B : 82                          glo     SP
     912/     F5C : FC 05                       adi     ((4+1))#256
     912/     F5E : AE                          plo     MEMADDR
     912/     F5F : 92                          ghi     SP
     912/     F60 : 7C 00                       adci    ((4+1))>>8; was/256
     912/     F62 : BE                          phi     MEMADDR
     912/     F63 : =>FALSE                     else
     912/     F63 :                                     ldAD    memAddr,SP
     912/     F63 : [912]                       endif
     912/     F63 : 9B                          ghi     R11
     912/     F64 : 5E                          str     memAddr
     912/     F65 : 1E                          inc     memAddr
     912/     F66 : 8B                          glo     R11
     912/     F67 : 5E                          str     memAddr
     913/     F68 : (MACRO)             	Ccall _ltoa
     913/     F68 : =>FALSE              if MOMCPU=$1805
     913/     F68 :                             SCAL    6
     913/     F68 :                             dw      _LTOA
     913/     F68 : =>TRUE               else
     913/     F68 : D4                          sep     RCALL
     913/     F69 : 0E 0F                       dw      _LTOA
     913/     F6B : [913]                endif
     914/     F6B : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     914/     F6B : 8F                          glo     R15
     914/     F6C : AB                          plo     R11
     914/     F6D : 9F                          ghi     R15
     914/     F6E : BB                          phi     R11
     915/     F6F : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     915/     F6F : 8B                          glo     R11
     915/     F70 : AC                          plo     R12
     915/     F71 : 9B                          ghi     R11
     915/     F72 : BC                          phi     R12
     916/     F73 : (MACRO)             	Ccall _printstr
     916/     F73 : =>FALSE              if MOMCPU=$1805
     916/     F73 :                             SCAL    6
     916/     F73 :                             dw      _PRINTSTR
     916/     F73 : =>TRUE               else
     916/     F73 : D4                          sep     RCALL
     916/     F74 : 09 88                       dw      _PRINTSTR
     916/     F76 : [916]                endif
     917/     F76 :                     ;}
     918/     F76 :                     L144:
     919/     F76 : (MACRO)             	release 18
     919/     F76 : =>FALSE                     if (18<9)
     919/     F76 :                                 releaseS 18  ;use dec for small amounts
     919/     F76 : =>TRUE                      else
     919/     F76 :  (MACRO-2)                      releaseL 18  ;use subtract for large amounts
     919/     F76 :                     ;for release we adjust the low byte first 
     919/     F76 :                     ;so if there's an interrupt in mid calculation the sp will be pointing to free memory
     919/     F76 :   (MACRO-3)                 alu2i sp,sp,18,adi,adci
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 62 - 1/18/2018 14:51:20


     919/     F76 : 82                          glo     SP
     919/     F77 : FC 12                       ADI     (18)#256
     919/     F79 : A2                          plo     SP
     919/     F7A : 92                          ghi     SP
     919/     F7B : 7C 00                       ADCI     (18)>>8; was/256
     919/     F7D : B2                          phi     SP
     919/     F7E : [919]                       endif
     920/     F7E : (MACRO)             	Cretn
     920/     F7E : =>FALSE              if MOMCPU=$1805
     920/     F7E :                             sret    6
     920/     F7E : =>TRUE               else
     920/     F7E : D5                          sep     RRET
     920/     F7F : [920]                endif
     921/     F7F :                     
     922/     F7F :                     ;$$function end$$ _printlint
     923/     F7F :                     ;$$function start$$ _printflt
     924/     F7F :                     _printflt:		;framesize=30
     925/     F7F : (MACRO)             	reserve 28
     925/     F7F : =>FALSE                     if (28<9)
     925/     F7F :                                 reserveS 28  ;use dec for small amounts
     925/     F7F : =>TRUE                      else
     925/     F7F :  (MACRO-2)                      reserveL 28  ;use subtract for large amounts
     925/     F7F :                     ;this calculation looks awkward but we're adjusting the top byte of sp first 
     925/     F7F :                     ;so if there's an interrupt in mid calculation the sp will be pointing to free memory
     925/     F7F : 82                          glo sp          ;grab low byte of stack pointer
     925/     F80 : FF 1C                       smi 28&255 ;claculate new low byte
     925/     F82 : AE                          plo memAddr     ;save it for a moment
     925/     F83 : 92                          ghi sp          ;grab high byte
     925/     F84 : 7F 00                       smbi (28>>8)&255 ;calculate the new page
     925/     F86 : B2                          phi sp          ;adjust page first
     925/     F87 : 8E                          glo memAddr     ;get new low byte
     925/     F88 : A2                          plo sp          ;finish adjusting the stack pointer
     925/     F89 : [925]                       endif
     926/     F89 : (MACRO)             	st2 R12,'O',sp,(30+1)			
     926/     F89 : =>TRUE                      if      ('O'='O')
     926/     F89 :  (MACRO-2)                          ldAX    memAddr,SP,(30+1)
     926/     F89 : 82                          glo     SP
     926/     F8A : FC 1F                       adi     ((30+1))#256
     926/     F8C : AE                          plo     MEMADDR
     926/     F8D : 92                          ghi     SP
     926/     F8E : 7C 00                       adci    ((30+1))>>8; was/256
     926/     F90 : BE                          phi     MEMADDR
     926/     F91 : =>FALSE                     else
     926/     F91 :                                     ldAD    memAddr,SP
     926/     F91 : [926]                       endif
     926/     F91 : 9C                          ghi     R12
     926/     F92 : 5E                          str     memAddr
     926/     F93 : 1E                          inc     memAddr
     926/     F94 : 8C                          glo     R12
     926/     F95 : 5E                          str     memAddr
     927/     F96 : 1E                  	inc memaddr				;opt16.1
     928/     F97 : (MACRO)             	str2 R13,memaddr			
     928/     F97 : 9D                          ghi     R13
     928/     F98 : 5E                          str     MEMADDR
     928/     F99 : 8D                          glo     R13
     928/     F9A : 1E                          inc     MEMADDR
     928/     F9B : 5E                          str     MEMADDR
     928/     F9C : 2E                          dec     MEMADDR
     929/     F9D :                     ;void printflt(float s){ //print a float
     930/     F9D :                     ;	printstr(ftoa(s,buffer,3));
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 63 - 1/18/2018 14:51:20


     931/     F9D : (MACRO)             	ld4 Rp1p2,'O',sp,(30+1);INDIRF4(addr)
     931/     F9D : =>TRUE                      if      ('O'='O')
     931/     F9D :  (MACRO-2)                          ldAX    memAddr,SP,(30+1)
     931/     F9D : 82                          glo     SP
     931/     F9E : FC 1F                       adi     ((30+1))#256
     931/     FA0 : AE                          plo     MEMADDR
     931/     FA1 : 92                          ghi     SP
     931/     FA2 : 7C 00                       adci    ((30+1))>>8; was/256
     931/     FA4 : BE                          phi     MEMADDR
     931/     FA5 : =>FALSE                     else
     931/     FA5 :                                     ldAD    memAddr,SP
     931/     FA5 : [931]                       endif
     931/     FA5 : 4E                          lda     memAddr
     931/     FA6 : BC                          phi     RP1P2-1   ;long register pairs are addressed by their second member
     931/     FA7 : 4E                          lda     memAddr ;but load and store start with the 1st
     931/     FA8 : AC                          plo     RP1P2-1
     931/     FA9 : 4E                          lda     memAddr
     931/     FAA : BD                          phi     RP1P2
     931/     FAB : 0E                          ldn     memAddr
     931/     FAC : AD                          plo     RP1P2
     932/     FAD : (MACRO)             	ldA2 R11,'O',sp,(8+1); reg:addr
     932/     FAD :                     ;Oct 13 (8+1) added to ldAD call
     932/     FAD : =>TRUE                      if      ('O'='O')
     932/     FAD :  (MACRO-2)                          ldAX    R11,SP,(8+1)
     932/     FAD : 82                          glo     SP
     932/     FAE : FC 09                       adi     ((8+1))#256
     932/     FB0 : AB                          plo     R11
     932/     FB1 : 92                          ghi     SP
     932/     FB2 : 7C 00                       adci    ((8+1))>>8; was/256
     932/     FB4 : BB                          phi     R11
     932/     FB5 : =>FALSE                     else
     932/     FB5 :                                     ldAD    R11,SP+(8+1)
     932/     FB5 : [932]                       endif
     933/     FB5 : (MACRO)             	st2 R11,'O',sp,(4+1); arg+f**
     933/     FB5 : =>TRUE                      if      ('O'='O')
     933/     FB5 :  (MACRO-2)                          ldAX    memAddr,SP,(4+1)
     933/     FB5 : 82                          glo     SP
     933/     FB6 : FC 05                       adi     ((4+1))#256
     933/     FB8 : AE                          plo     MEMADDR
     933/     FB9 : 92                          ghi     SP
     933/     FBA : 7C 00                       adci    ((4+1))>>8; was/256
     933/     FBC : BE                          phi     MEMADDR
     933/     FBD : =>FALSE                     else
     933/     FBD :                                     ldAD    memAddr,SP
     933/     FBD : [933]                       endif
     933/     FBD : 9B                          ghi     R11
     933/     FBE : 5E                          str     memAddr
     933/     FBF : 1E                          inc     memAddr
     933/     FC0 : 8B                          glo     R11
     933/     FC1 : 5E                          str     memAddr
     934/     FC2 : (MACRO)             	ldaD R11,3; reg:acon
     934/     FC2 : =>FALSE              if MOMCPU=$1805
     934/     FC2 :                             RLDI    R11,3
     934/     FC2 : =>TRUE               else
     934/     FC2 : F8 03                       ldi     (3)&255
     934/     FC4 : AB                          plo     R11
     934/     FC5 : F8 00                       ldi     (3)>>8; was/256
     934/     FC7 : BB                          phi     R11
     934/     FC8 : [934]                endif
     935/     FC8 : (MACRO)             	st2 R11,'O',sp,(6+1); arg+f**
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 64 - 1/18/2018 14:51:20


     935/     FC8 : =>TRUE                      if      ('O'='O')
     935/     FC8 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     935/     FC8 : 82                          glo     SP
     935/     FC9 : FC 07                       adi     ((6+1))#256
     935/     FCB : AE                          plo     MEMADDR
     935/     FCC : 92                          ghi     SP
     935/     FCD : 7C 00                       adci    ((6+1))>>8; was/256
     935/     FCF : BE                          phi     MEMADDR
     935/     FD0 : =>FALSE                     else
     935/     FD0 :                                     ldAD    memAddr,SP
     935/     FD0 : [935]                       endif
     935/     FD0 : 9B                          ghi     R11
     935/     FD1 : 5E                          str     memAddr
     935/     FD2 : 1E                          inc     memAddr
     935/     FD3 : 8B                          glo     R11
     935/     FD4 : 5E                          str     memAddr
     936/     FD5 : (MACRO)             	Ccall _ftoa
     936/     FD5 : =>FALSE              if MOMCPU=$1805
     936/     FD5 :                             SCAL    6
     936/     FD5 :                             dw      _FTOA
     936/     FD5 : =>TRUE               else
     936/     FD5 : D4                          sep     RCALL
     936/     FD6 : 09 F4                       dw      _FTOA
     936/     FD8 : [936]                endif
     937/     FD8 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     937/     FD8 : 8F                          glo     R15
     937/     FD9 : AB                          plo     R11
     937/     FDA : 9F                          ghi     R15
     937/     FDB : BB                          phi     R11
     938/     FDC : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     938/     FDC : 8B                          glo     R11
     938/     FDD : AC                          plo     R12
     938/     FDE : 9B                          ghi     R11
     938/     FDF : BC                          phi     R12
     939/     FE0 : (MACRO)             	Ccall _printstr
     939/     FE0 : =>FALSE              if MOMCPU=$1805
     939/     FE0 :                             SCAL    6
     939/     FE0 :                             dw      _PRINTSTR
     939/     FE0 : =>TRUE               else
     939/     FE0 : D4                          sep     RCALL
     939/     FE1 : 09 88                       dw      _PRINTSTR
     939/     FE3 : [939]                endif
     940/     FE3 :                     ;}
     941/     FE3 :                     L145:
     942/     FE3 : (MACRO)             	release 28
     942/     FE3 : =>FALSE                     if (28<9)
     942/     FE3 :                                 releaseS 28  ;use dec for small amounts
     942/     FE3 : =>TRUE                      else
     942/     FE3 :  (MACRO-2)                      releaseL 28  ;use subtract for large amounts
     942/     FE3 :                     ;for release we adjust the low byte first 
     942/     FE3 :                     ;so if there's an interrupt in mid calculation the sp will be pointing to free memory
     942/     FE3 :   (MACRO-3)                 alu2i sp,sp,28,adi,adci
     942/     FE3 : 82                          glo     SP
     942/     FE4 : FC 1C                       ADI     (28)#256
     942/     FE6 : A2                          plo     SP
     942/     FE7 : 92                          ghi     SP
     942/     FE8 : 7C 00                       ADCI     (28)>>8; was/256
     942/     FEA : B2                          phi     SP
     942/     FEB : [942]                       endif
     943/     FEB : (MACRO)             	Cretn
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 65 - 1/18/2018 14:51:20


     943/     FEB : =>FALSE              if MOMCPU=$1805
     943/     FEB :                             sret    6
     943/     FEB : =>TRUE               else
     943/     FEB : D5                          sep     RRET
     943/     FEC : [943]                endif
     944/     FEC :                     
     945/     FEC :                     ;$$function end$$ _printflt
     946/     FEC :                     ;$$function start$$ _putxn
     947/     FEC :                     _putxn:		;framesize=6
     948/     FEC : (MACRO)             	reserve 4
     948/     FEC : =>TRUE                      if (4<9)
     948/     FEC :  (MACRO-2)                      reserveS 4  ;use dec for small amounts
     948/     FEC :                             rept    4
     948/     FEC :                             dec sp
     948/     FEC :                             endm
     948/     FEC : 22                          dec sp
     948/     FED : 22                          dec sp
     948/     FEE : 22                          dec sp
     948/     FEF : 22                          dec sp
     948/     FF0 : =>FALSE                     else
     948/     FF0 :                                 reserveL 4  ;use subtract for large amounts
     948/     FF0 : [948]                       endif
     949/     FF0 : (MACRO)             	st2 R12,'O',sp,(6+1); flag1 
     949/     FF0 : =>TRUE                      if      ('O'='O')
     949/     FF0 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     949/     FF0 : 82                          glo     SP
     949/     FF1 : FC 07                       adi     ((6+1))#256
     949/     FF3 : AE                          plo     MEMADDR
     949/     FF4 : 92                          ghi     SP
     949/     FF5 : 7C 00                       adci    ((6+1))>>8; was/256
     949/     FF7 : BE                          phi     MEMADDR
     949/     FF8 : =>FALSE                     else
     949/     FF8 :                                     ldAD    memAddr,SP
     949/     FF8 : [949]                       endif
     949/     FF8 : 9C                          ghi     R12
     949/     FF9 : 5E                          str     memAddr
     949/     FFA : 1E                          inc     memAddr
     949/     FFB : 8C                          glo     R12
     949/     FFC : 5E                          str     memAddr
     950/     FFD : (MACRO)             	ldA2 R11,'O',sp,(6+1); reg:addr
     950/     FFD :                     ;Oct 13 (6+1) added to ldAD call
     950/     FFD : =>TRUE                      if      ('O'='O')
     950/     FFD :  (MACRO-2)                          ldAX    R11,SP,(6+1)
     950/     FFD : 82                          glo     SP
     950/     FFE : FC 07                       adi     ((6+1))#256
     950/    1000 : AB                          plo     R11
     950/    1001 : 92                          ghi     SP
     950/    1002 : 7C 00                       adci    ((6+1))>>8; was/256
     950/    1004 : BB                          phi     R11
     950/    1005 : =>FALSE                     else
     950/    1005 :                                     ldAD    R11,SP+(6+1)
     950/    1005 : [950]                       endif
     951/    1005 : (MACRO)             	ld2 R10,'O',sp,(6+1) ;reg:INDIRI2(addr)
     951/    1005 : =>TRUE                      if      ('O'='O')
     951/    1005 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     951/    1005 : 82                          glo     SP
     951/    1006 : FC 07                       adi     ((6+1))#256
     951/    1008 : AE                          plo     MEMADDR
     951/    1009 : 92                          ghi     SP
     951/    100A : 7C 00                       adci    ((6+1))>>8; was/256
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 66 - 1/18/2018 14:51:20


     951/    100C : BE                          phi     MEMADDR
     951/    100D : =>FALSE                     else
     951/    100D :                                     ldAD    memAddr,SP
     951/    100D : [951]                       endif
     951/    100D : 4E                          lda     memAddr
     951/    100E : BA                          phi     R10
     951/    100F : 0E                          ldn     memAddr
     951/    1010 : AA                          plo     R10
     952/    1011 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     952/    1011 : 8A                          glo     R10
     952/    1012 : 5B                          str     R11
     953/    1013 :                     ;void putxn(unsigned char x){ //print a nibble as ascii hex
     954/    1013 :                     ;	if (x<10){
     955/    1013 : (MACRO)             	ld1 R11,'O',sp,(6+1)
     955/    1013 : =>TRUE                      if      ('O'='O')
     955/    1013 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     955/    1013 : 82                          glo     SP
     955/    1014 : FC 07                       adi     ((6+1))#256
     955/    1016 : AE                          plo     MEMADDR
     955/    1017 : 92                          ghi     SP
     955/    1018 : 7C 00                       adci    ((6+1))>>8; was/256
     955/    101A : BE                          phi     MEMADDR
     955/    101B : =>FALSE                     else
     955/    101B :                                     ldAD    memAddr,SP
     955/    101B : [955]                       endif
     955/    101B : 0E                          ldn     memAddr
     955/    101C : AB                          plo     R11
     956/    101D : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     956/    101D : F8 00                       ldi     0
     956/    101F : BB                          phi     R11
     957/    1020 : (MACRO)             	jcI2I R11,10,lbdf,L147; GE is flipped test from LT
     957/    1020 : 8B                          glo     R11
     957/    1021 : FF 0A                       smi     (10)#256
     957/    1023 : 9B                          ghi     R11
     957/    1024 : 7F 00                       smbi    (10)>>8; was/256      ;that's a standard signed subtraction
     957/    1026 : 9B                          ghi     R11 ;
     957/    1027 : FB 00                       xri     (10)>>8; was/256      ;sets the top bit if the signs are different
     957/    1029 : 7E                          shlc          ;the original df is now in bit 0 and df=1 if signs were different
     957/    102A : C7                          lsnf    ;bypass the df flip if signs were the same
     957/    102B : FB 01                       xri     01     ;invert original df if signs were different
     957/    102D : 76                          shrc           ;put it back in df
     957/    102E : C3 10 2E                    LBDF    L147  ;execute 
     958/    1031 :                     ;		putc(x+'0');
     959/    1031 : (MACRO)             	ld1 R11,'O',sp,(6+1)
     959/    1031 : =>TRUE                      if      ('O'='O')
     959/    1031 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     959/    1031 : 82                          glo     SP
     959/    1032 : FC 07                       adi     ((6+1))#256
     959/    1034 : AE                          plo     MEMADDR
     959/    1035 : 92                          ghi     SP
     959/    1036 : 7C 00                       adci    ((6+1))>>8; was/256
     959/    1038 : BE                          phi     MEMADDR
     959/    1039 : =>FALSE                     else
     959/    1039 :                                     ldAD    memAddr,SP
     959/    1039 : [959]                       endif
     959/    1039 : 0E                          ldn     memAddr
     959/    103A : AB                          plo     R11
     960/    103B : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     960/    103B : F8 00                       ldi     0
     960/    103D : BB                          phi     R11
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 67 - 1/18/2018 14:51:20


     961/    103E : (MACRO)             	ldA2 R11,'O',R11,(48); reg:addr
     961/    103E :                     ;Oct 13 (48) added to ldAD call
     961/    103E : =>TRUE                      if      ('O'='O')
     961/    103E :  (MACRO-2)                          ldAX    R11,R11,(48)
     961/    103E : 8B                          glo     R11
     961/    103F : FC 30                       adi     ((48))#256
     961/    1041 : AB                          plo     R11
     961/    1042 : 9B                          ghi     R11
     961/    1043 : 7C 00                       adci    ((48))>>8; was/256
     961/    1045 : BB                          phi     R11
     961/    1046 : =>FALSE                     else
     961/    1046 :                                     ldAD    R11,R11+(48)
     961/    1046 : [961]                       endif
     962/    1046 : (MACRO)             	cpy1 R12,R11
     962/    1046 : 8B                          glo     R11
     962/    1047 : AC                          plo     R12
     963/    1048 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     963/    1048 : F8 00                       ldi     0
     963/    104A : BC                          phi     R12
     964/    104B : (MACRO)             	Ccall _putcser
     964/    104B : =>FALSE              if MOMCPU=$1805
     964/    104B :                             SCAL    6
     964/    104B :                             dw      _PUTCSER
     964/    104B : =>TRUE               else
     964/    104B : D4                          sep     RCALL
     964/    104C : 08 5C                       dw      _PUTCSER
     964/    104E : [964]                endif
     965/    104E :                     ;	} else {
     966/    104E : C0 10 4E            	lbr L148
     967/    1051 :                     L147:
     968/    1051 :                     ;		putc(x+'A'-10);
     969/    1051 : (MACRO)             	ld1 R11,'O',sp,(6+1)
     969/    1051 : =>TRUE                      if      ('O'='O')
     969/    1051 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     969/    1051 : 82                          glo     SP
     969/    1052 : FC 07                       adi     ((6+1))#256
     969/    1054 : AE                          plo     MEMADDR
     969/    1055 : 92                          ghi     SP
     969/    1056 : 7C 00                       adci    ((6+1))>>8; was/256
     969/    1058 : BE                          phi     MEMADDR
     969/    1059 : =>FALSE                     else
     969/    1059 :                                     ldAD    memAddr,SP
     969/    1059 : [969]                       endif
     969/    1059 : 0E                          ldn     memAddr
     969/    105A : AB                          plo     R11
     970/    105B : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     970/    105B : F8 00                       ldi     0
     970/    105D : BB                          phi     R11
     971/    105E : (MACRO)             	ldA2 R11,'O',R11,(65); reg:addr
     971/    105E :                     ;Oct 13 (65) added to ldAD call
     971/    105E : =>TRUE                      if      ('O'='O')
     971/    105E :  (MACRO-2)                          ldAX    R11,R11,(65)
     971/    105E : 8B                          glo     R11
     971/    105F : FC 41                       adi     ((65))#256
     971/    1061 : AB                          plo     R11
     971/    1062 : 9B                          ghi     R11
     971/    1063 : 7C 00                       adci    ((65))>>8; was/256
     971/    1065 : BB                          phi     R11
     971/    1066 : =>FALSE                     else
     971/    1066 :                                     ldAD    R11,R11+(65)
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 68 - 1/18/2018 14:51:20


     971/    1066 : [971]                       endif
     972/    1066 : (MACRO)             	alu2I R11,R11,10,smi,smbi
     972/    1066 : 8B                          glo     R11
     972/    1067 : FF 0A                       SMI     (10)#256
     972/    1069 : AB                          plo     R11
     972/    106A : 9B                          ghi     R11
     972/    106B : 7F 00                       SMBI     (10)>>8; was/256
     972/    106D : BB                          phi     R11
     973/    106E : (MACRO)             	cpy1 R12,R11
     973/    106E : 8B                          glo     R11
     973/    106F : AC                          plo     R12
     974/    1070 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     974/    1070 : F8 00                       ldi     0
     974/    1072 : BC                          phi     R12
     975/    1073 : (MACRO)             	Ccall _putcser
     975/    1073 : =>FALSE              if MOMCPU=$1805
     975/    1073 :                             SCAL    6
     975/    1073 :                             dw      _PUTCSER
     975/    1073 : =>TRUE               else
     975/    1073 : D4                          sep     RCALL
     975/    1074 : 08 5C                       dw      _PUTCSER
     975/    1076 : [975]                endif
     976/    1076 :                     ;	}
     977/    1076 :                     L148:
     978/    1076 :                     ;}
     979/    1076 :                     L146:
     980/    1076 : (MACRO)             	release 4
     980/    1076 : =>TRUE                      if (4<9)
     980/    1076 :  (MACRO-2)                      releaseS 4  ;use dec for small amounts
     980/    1076 :                             rept    4
     980/    1076 :                             inc sp
     980/    1076 :                             endm
     980/    1076 : 12                          inc sp
     980/    1077 : 12                          inc sp
     980/    1078 : 12                          inc sp
     980/    1079 : 12                          inc sp
     980/    107A : =>FALSE                     else
     980/    107A :                                 releaseL 4  ;use subtract for large amounts
     980/    107A : [980]                       endif
     981/    107A : (MACRO)             	Cretn
     981/    107A : =>FALSE              if MOMCPU=$1805
     981/    107A :                             sret    6
     981/    107A : =>TRUE               else
     981/    107A : D5                          sep     RRET
     981/    107B : [981]                endif
     982/    107B :                     
     983/    107B :                     ;$$function end$$ _putxn
     984/    107B :                     ;$$function start$$ _putx
     985/    107B :                     _putx:		;framesize=6
     986/    107B : (MACRO)             	reserve 4
     986/    107B : =>TRUE                      if (4<9)
     986/    107B :  (MACRO-2)                      reserveS 4  ;use dec for small amounts
     986/    107B :                             rept    4
     986/    107B :                             dec sp
     986/    107B :                             endm
     986/    107B : 22                          dec sp
     986/    107C : 22                          dec sp
     986/    107D : 22                          dec sp
     986/    107E : 22                          dec sp
     986/    107F : =>FALSE                     else
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 69 - 1/18/2018 14:51:20


     986/    107F :                                 reserveL 4  ;use subtract for large amounts
     986/    107F : [986]                       endif
     987/    107F : (MACRO)             	st2 R12,'O',sp,(6+1); flag1 
     987/    107F : =>TRUE                      if      ('O'='O')
     987/    107F :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     987/    107F : 82                          glo     SP
     987/    1080 : FC 07                       adi     ((6+1))#256
     987/    1082 : AE                          plo     MEMADDR
     987/    1083 : 92                          ghi     SP
     987/    1084 : 7C 00                       adci    ((6+1))>>8; was/256
     987/    1086 : BE                          phi     MEMADDR
     987/    1087 : =>FALSE                     else
     987/    1087 :                                     ldAD    memAddr,SP
     987/    1087 : [987]                       endif
     987/    1087 : 9C                          ghi     R12
     987/    1088 : 5E                          str     memAddr
     987/    1089 : 1E                          inc     memAddr
     987/    108A : 8C                          glo     R12
     987/    108B : 5E                          str     memAddr
     988/    108C : (MACRO)             	ldA2 R11,'O',sp,(6+1); reg:addr
     988/    108C :                     ;Oct 13 (6+1) added to ldAD call
     988/    108C : =>TRUE                      if      ('O'='O')
     988/    108C :  (MACRO-2)                          ldAX    R11,SP,(6+1)
     988/    108C : 82                          glo     SP
     988/    108D : FC 07                       adi     ((6+1))#256
     988/    108F : AB                          plo     R11
     988/    1090 : 92                          ghi     SP
     988/    1091 : 7C 00                       adci    ((6+1))>>8; was/256
     988/    1093 : BB                          phi     R11
     988/    1094 : =>FALSE                     else
     988/    1094 :                                     ldAD    R11,SP+(6+1)
     988/    1094 : [988]                       endif
     989/    1094 : (MACRO)             	ld2 R10,'O',sp,(6+1) ;reg:INDIRI2(addr)
     989/    1094 : =>TRUE                      if      ('O'='O')
     989/    1094 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     989/    1094 : 82                          glo     SP
     989/    1095 : FC 07                       adi     ((6+1))#256
     989/    1097 : AE                          plo     MEMADDR
     989/    1098 : 92                          ghi     SP
     989/    1099 : 7C 00                       adci    ((6+1))>>8; was/256
     989/    109B : BE                          phi     MEMADDR
     989/    109C : =>FALSE                     else
     989/    109C :                                     ldAD    memAddr,SP
     989/    109C : [989]                       endif
     989/    109C : 4E                          lda     memAddr
     989/    109D : BA                          phi     R10
     989/    109E : 0E                          ldn     memAddr
     989/    109F : AA                          plo     R10
     990/    10A0 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     990/    10A0 : 8A                          glo     R10
     990/    10A1 : 5B                          str     R11
     991/    10A2 :                     ;void putx(unsigned char x){ //print a unsigned char as ascii hex
     992/    10A2 :                     ;	putxn(x>>4);
     993/    10A2 : (MACRO)             	ld1 R11,'O',sp,(6+1)
     993/    10A2 : =>TRUE                      if      ('O'='O')
     993/    10A2 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
     993/    10A2 : 82                          glo     SP
     993/    10A3 : FC 07                       adi     ((6+1))#256
     993/    10A5 : AE                          plo     MEMADDR
     993/    10A6 : 92                          ghi     SP
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 70 - 1/18/2018 14:51:20


     993/    10A7 : 7C 00                       adci    ((6+1))>>8; was/256
     993/    10A9 : BE                          phi     MEMADDR
     993/    10AA : =>FALSE                     else
     993/    10AA :                                     ldAD    memAddr,SP
     993/    10AA : [993]                       endif
     993/    10AA : 0E                          ldn     memAddr
     993/    10AB : AB                          plo     R11
     994/    10AC : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     994/    10AC : F8 00                       ldi     0
     994/    10AE : BB                          phi     R11
     995/    10AF : (MACRO)             	shrI2I R11,4
     995/    10AF :                             rept    4
     995/    10AF :                             shrI2   R11
     995/    10AF :                             endm
     995/    10AF :  (MACRO-2)                  shrI2   R11
     995/    10AF : 9B                          ghi     R11
     995/    10B0 : FE                          shl             ;set DF to the sign
     995/    10B1 : 9B                          ghi     R11     ;get the top byte back
     995/    10B2 : 76                          shrc            ;shift one bit extending the sign
     995/    10B3 : BB                          phi     R11
     995/    10B4 : 8B                          glo     R11
     995/    10B5 : 76                          shrc
     995/    10B6 : AB                          plo     R11
     995/    10B7 :  (MACRO-2)                  shrI2   R11
     995/    10B7 : 9B                          ghi     R11
     995/    10B8 : FE                          shl             ;set DF to the sign
     995/    10B9 : 9B                          ghi     R11     ;get the top byte back
     995/    10BA : 76                          shrc            ;shift one bit extending the sign
     995/    10BB : BB                          phi     R11
     995/    10BC : 8B                          glo     R11
     995/    10BD : 76                          shrc
     995/    10BE : AB                          plo     R11
     995/    10BF :  (MACRO-2)                  shrI2   R11
     995/    10BF : 9B                          ghi     R11
     995/    10C0 : FE                          shl             ;set DF to the sign
     995/    10C1 : 9B                          ghi     R11     ;get the top byte back
     995/    10C2 : 76                          shrc            ;shift one bit extending the sign
     995/    10C3 : BB                          phi     R11
     995/    10C4 : 8B                          glo     R11
     995/    10C5 : 76                          shrc
     995/    10C6 : AB                          plo     R11
     995/    10C7 :  (MACRO-2)                  shrI2   R11
     995/    10C7 : 9B                          ghi     R11
     995/    10C8 : FE                          shl             ;set DF to the sign
     995/    10C9 : 9B                          ghi     R11     ;get the top byte back
     995/    10CA : 76                          shrc            ;shift one bit extending the sign
     995/    10CB : BB                          phi     R11
     995/    10CC : 8B                          glo     R11
     995/    10CD : 76                          shrc
     995/    10CE : AB                          plo     R11
     996/    10CF : (MACRO)             	cpy1 R12,R11
     996/    10CF : 8B                          glo     R11
     996/    10D0 : AC                          plo     R12
     997/    10D1 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     997/    10D1 : F8 00                       ldi     0
     997/    10D3 : BC                          phi     R12
     998/    10D4 : (MACRO)             	Ccall _putxn
     998/    10D4 : =>FALSE              if MOMCPU=$1805
     998/    10D4 :                             SCAL    6
     998/    10D4 :                             dw      _PUTXN
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 71 - 1/18/2018 14:51:20


     998/    10D4 : =>TRUE               else
     998/    10D4 : D4                          sep     RCALL
     998/    10D5 : 0F EC                       dw      _PUTXN
     998/    10D7 : [998]                endif
     999/    10D7 :                     ;	putxn(x & 0x0F);
    1000/    10D7 : (MACRO)             	ld1 R11,'O',sp,(6+1)
    1000/    10D7 : =>TRUE                      if      ('O'='O')
    1000/    10D7 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
    1000/    10D7 : 82                          glo     SP
    1000/    10D8 : FC 07                       adi     ((6+1))#256
    1000/    10DA : AE                          plo     MEMADDR
    1000/    10DB : 92                          ghi     SP
    1000/    10DC : 7C 00                       adci    ((6+1))>>8; was/256
    1000/    10DE : BE                          phi     MEMADDR
    1000/    10DF : =>FALSE                     else
    1000/    10DF :                                     ldAD    memAddr,SP
    1000/    10DF : [1000]                      endif
    1000/    10DF : 0E                          ldn     memAddr
    1000/    10E0 : AB                          plo     R11
    1001/    10E1 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
    1001/    10E1 : F8 00                       ldi     0
    1001/    10E3 : BB                          phi     R11
    1002/    10E4 : (MACRO)             	alu2I R11,R11,15,ani,ani
    1002/    10E4 : 8B                          glo     R11
    1002/    10E5 : FA 0F                       ANI     (15)#256
    1002/    10E7 : AB                          plo     R11
    1002/    10E8 : 9B                          ghi     R11
    1002/    10E9 : FA 00                       ANI     (15)>>8; was/256
    1002/    10EB : BB                          phi     R11
    1003/    10EC :                     	;removed ?	cpy2 R11,R11
    1004/    10EC : (MACRO)             	cpy1 R12,R11
    1004/    10EC : 8B                          glo     R11
    1004/    10ED : AC                          plo     R12
    1005/    10EE : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1005/    10EE : F8 00                       ldi     0
    1005/    10F0 : BC                          phi     R12
    1006/    10F1 : (MACRO)             	Ccall _putxn
    1006/    10F1 : =>FALSE              if MOMCPU=$1805
    1006/    10F1 :                             SCAL    6
    1006/    10F1 :                             dw      _PUTXN
    1006/    10F1 : =>TRUE               else
    1006/    10F1 : D4                          sep     RCALL
    1006/    10F2 : 0F EC                       dw      _PUTXN
    1006/    10F4 : [1006]               endif
    1007/    10F4 :                     ;}
    1008/    10F4 :                     L149:
    1009/    10F4 : (MACRO)             	release 4
    1009/    10F4 : =>TRUE                      if (4<9)
    1009/    10F4 :  (MACRO-2)                      releaseS 4  ;use dec for small amounts
    1009/    10F4 :                             rept    4
    1009/    10F4 :                             inc sp
    1009/    10F4 :                             endm
    1009/    10F4 : 12                          inc sp
    1009/    10F5 : 12                          inc sp
    1009/    10F6 : 12                          inc sp
    1009/    10F7 : 12                          inc sp
    1009/    10F8 : =>FALSE                     else
    1009/    10F8 :                                 releaseL 4  ;use subtract for large amounts
    1009/    10F8 : [1009]                      endif
    1010/    10F8 : (MACRO)             	Cretn
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 72 - 1/18/2018 14:51:20


    1010/    10F8 : =>FALSE              if MOMCPU=$1805
    1010/    10F8 :                             sret    6
    1010/    10F8 : =>TRUE               else
    1010/    10F8 : D5                          sep     RRET
    1010/    10F9 : [1010]               endif
    1011/    10F9 :                     
    1012/    10F9 :                     ;$$function end$$ _putx
    1013/    10F9 :                     ;$$function start$$ _printf
    1014/    10F9 :                     _printf:		;framesize=18
    1015/    10F9 : (MACRO)             	reserve 4; save room for local variables
    1015/    10F9 : =>TRUE                      if (4<9)
    1015/    10F9 :  (MACRO-2)                      reserveS 4  ;use dec for small amounts
    1015/    10F9 :                             rept    4
    1015/    10F9 :                             dec sp
    1015/    10F9 :                             endm
    1015/    10F9 : 22                          dec sp
    1015/    10FA : 22                          dec sp
    1015/    10FB : 22                          dec sp
    1015/    10FC : 22                          dec sp
    1015/    10FD : =>FALSE                     else
    1015/    10FD :                                 reserveL 4  ;use subtract for large amounts
    1015/    10FD : [1015]                      endif
    1016/    10FD : (MACRO)             	pushr R0
    1016/    10FD : =>FALSE              if MOMCPU=$1805
    1016/    10FD :                             RSXD    R0
    1016/    10FD : =>TRUE               else
    1016/    10FD : 80                          glo     R0
    1016/    10FE : 73                          stxd
    1016/    10FF : 90                          ghi     R0
    1016/    1100 : 73                          stxd
    1016/    1101 : [1016]               endif
    1017/    1101 : (MACRO)             	pushr R1
    1017/    1101 : =>FALSE              if MOMCPU=$1805
    1017/    1101 :                             RSXD    R1
    1017/    1101 : =>TRUE               else
    1017/    1101 : 81                          glo     R1
    1017/    1102 : 73                          stxd
    1017/    1103 : 91                          ghi     R1
    1017/    1104 : 73                          stxd
    1017/    1105 : [1017]               endif
    1018/    1105 : (MACRO)             	pushr R6
    1018/    1105 : =>FALSE              if MOMCPU=$1805
    1018/    1105 :                             RSXD    R6
    1018/    1105 : =>TRUE               else
    1018/    1105 : 86                          glo     R6
    1018/    1106 : 73                          stxd
    1018/    1107 : 96                          ghi     R6
    1018/    1108 : 73                          stxd
    1018/    1109 : [1018]               endif
    1019/    1109 : (MACRO)             	pushr R7
    1019/    1109 : =>FALSE              if MOMCPU=$1805
    1019/    1109 :                             RSXD    R7
    1019/    1109 : =>TRUE               else
    1019/    1109 : 87                          glo     R7
    1019/    110A : 73                          stxd
    1019/    110B : 97                          ghi     R7
    1019/    110C : 73                          stxd
    1019/    110D : [1019]               endif
    1020/    110D : (MACRO)             	reserve 4; save room for outgoing arguments
    1020/    110D : =>TRUE                      if (4<9)
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 73 - 1/18/2018 14:51:20


    1020/    110D :  (MACRO-2)                      reserveS 4  ;use dec for small amounts
    1020/    110D :                             rept    4
    1020/    110D :                             dec sp
    1020/    110D :                             endm
    1020/    110D : 22                          dec sp
    1020/    110E : 22                          dec sp
    1020/    110F : 22                          dec sp
    1020/    1110 : 22                          dec sp
    1020/    1111 : =>FALSE                     else
    1020/    1111 :                                 reserveL 4  ;use subtract for large amounts
    1020/    1111 : [1020]                      endif
    1021/    1111 : (MACRO)             	st2 R12,'O',sp,(18+1)			
    1021/    1111 : =>TRUE                      if      ('O'='O')
    1021/    1111 :  (MACRO-2)                          ldAX    memAddr,SP,(18+1)
    1021/    1111 : 82                          glo     SP
    1021/    1112 : FC 13                       adi     ((18+1))#256
    1021/    1114 : AE                          plo     MEMADDR
    1021/    1115 : 92                          ghi     SP
    1021/    1116 : 7C 00                       adci    ((18+1))>>8; was/256
    1021/    1118 : BE                          phi     MEMADDR
    1021/    1119 : =>FALSE                     else
    1021/    1119 :                                     ldAD    memAddr,SP
    1021/    1119 : [1021]                      endif
    1021/    1119 : 9C                          ghi     R12
    1021/    111A : 5E                          str     memAddr
    1021/    111B : 1E                          inc     memAddr
    1021/    111C : 8C                          glo     R12
    1021/    111D : 5E                          str     memAddr
    1022/    111E : 1E                  	inc memaddr				;opt16
    1023/    111F : (MACRO)             	str2 R13,memaddr			
    1023/    111F : 9D                          ghi     R13
    1023/    1120 : 5E                          str     MEMADDR
    1023/    1121 : 8D                          glo     R13
    1023/    1122 : 1E                          inc     MEMADDR
    1023/    1123 : 5E                          str     MEMADDR
    1023/    1124 : 2E                          dec     MEMADDR
    1024/    1125 :                     ;void printf(char *pptr,...){ //limited implementation of printf
    1025/    1125 :                     ;	register char* ptr=pptr; //try to save on loads/spills
    1026/    1125 : (MACRO)             	ld2 R7,'O',sp,(18+1) ;reg:INDIRP2(addr)
    1026/    1125 : =>TRUE                      if      ('O'='O')
    1026/    1125 :  (MACRO-2)                          ldAX    memAddr,SP,(18+1)
    1026/    1125 : 82                          glo     SP
    1026/    1126 : FC 13                       adi     ((18+1))#256
    1026/    1128 : AE                          plo     MEMADDR
    1026/    1129 : 92                          ghi     SP
    1026/    112A : 7C 00                       adci    ((18+1))>>8; was/256
    1026/    112C : BE                          phi     MEMADDR
    1026/    112D : =>FALSE                     else
    1026/    112D :                                     ldAD    memAddr,SP
    1026/    112D : [1026]                      endif
    1026/    112D : 4E                          lda     memAddr
    1026/    112E : B7                          phi     R7
    1026/    112F : 0E                          ldn     memAddr
    1026/    1130 : A7                          plo     R7
    1027/    1131 :                     ;	int argslot=0;	//used to align longs
    1028/    1131 : (MACRO)             	ld2z R0
    1028/    1131 : F8 00                       ldi     0
    1028/    1133 : A0                          plo     R0
    1028/    1134 : B0                          phi     R0
    1029/    1135 :                     ;	int * this=(int *)&pptr;
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 74 - 1/18/2018 14:51:20


    1030/    1135 : (MACRO)             	ldA2 R1,'O',sp,(18+1); reg:addr
    1030/    1135 :                     ;Oct 13 (18+1) added to ldAD call
    1030/    1135 : =>TRUE                      if      ('O'='O')
    1030/    1135 :  (MACRO-2)                          ldAX    R1,SP,(18+1)
    1030/    1135 : 82                          glo     SP
    1030/    1136 : FC 13                       adi     ((18+1))#256
    1030/    1138 : A1                          plo     R1
    1030/    1139 : 92                          ghi     SP
    1030/    113A : 7C 00                       adci    ((18+1))>>8; was/256
    1030/    113C : B1                          phi     R1
    1030/    113D : =>FALSE                     else
    1030/    113D :                                     ldAD    R1,SP+(18+1)
    1030/    113D : [1030]                      endif
    1031/    113D :                     ;	this++; argslot++; //advance argument pointer and slot #
    1032/    113D : (MACRO)             	incm R1,2
    1032/    113D :                             rept    2
    1032/    113D :                             inc     R1
    1032/    113D :                             endm
    1032/    113D : 11                          inc     R1
    1032/    113E : 11                          inc     R1
    1033/    113F : (MACRO)             	incm R0,1
    1033/    113F :                             rept    1
    1033/    113F :                             inc     R0
    1033/    113F :                             endm
    1033/    113F : 10                          inc     R0
    1034/    1140 : C0 11 40            	lbr L152
    1035/    1143 :                     L151:
    1036/    1143 :                     ;    while(*ptr) {
    1037/    1143 :                     ;		c=*ptr; ptr++;
    1038/    1143 : (MACRO)             	ldn1 R6,R7;reg:  INDIRU1(indaddr)
    1038/    1143 : 07                          ldn     R7
    1038/    1144 : A6                          plo     R6
    1039/    1145 : (MACRO)             	incm R7,1
    1039/    1145 :                             rept    1
    1039/    1145 :                             inc     R7
    1039/    1145 :                             endm
    1039/    1145 : 17                          inc     R7
    1040/    1146 :                     ;		if (c!='%'){
    1041/    1146 : (MACRO)             	jeqU1I R6,37,L154;EQI2(CVUI2(reg),con8bit)**
    1041/    1146 : 86                          glo     R6
    1041/    1147 : FF 25                       smi     (37)#256
    1041/    1149 : C2 11 49                    lbz     L154
    1042/    114C :                     ;			putc(c);
    1043/    114C : (MACRO)             	cpy1 R12,R6
    1043/    114C : 86                          glo     R6
    1043/    114D : AC                          plo     R12
    1044/    114E : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1044/    114E : F8 00                       ldi     0
    1044/    1150 : BC                          phi     R12
    1045/    1151 : (MACRO)             	Ccall _putcser
    1045/    1151 : =>FALSE              if MOMCPU=$1805
    1045/    1151 :                             SCAL    6
    1045/    1151 :                             dw      _PUTCSER
    1045/    1151 : =>TRUE               else
    1045/    1151 : D4                          sep     RCALL
    1045/    1152 : 08 5C                       dw      _PUTCSER
    1045/    1154 : [1045]               endif
    1046/    1154 :                     ;			asm(" nop1806\n nop1806\n nop1806\n"); //17-03-13
    1047/    1154 : (MACRO)              nop1806
    1047/    1154 : =>FALSE              if MOMCPU=$1805
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 75 - 1/18/2018 14:51:20


    1047/    1154 :                             nop     ;waste 1.5 instruction times
    1047/    1154 : [1047]               endif
    1048/    1154 : (MACRO)              nop1806
    1048/    1154 : =>FALSE              if MOMCPU=$1805
    1048/    1154 :                             nop     ;waste 1.5 instruction times
    1048/    1154 : [1048]               endif
    1049/    1154 : (MACRO)              nop1806
    1049/    1154 : =>FALSE              if MOMCPU=$1805
    1049/    1154 :                             nop     ;waste 1.5 instruction times
    1049/    1154 : [1049]               endif
    1050/    1154 :                     ;		} else{
    1051/    1154 : C0 11 54            	lbr L155
    1052/    1157 :                     L154:
    1053/    1157 :                     ;			c=*ptr;ptr++;
    1054/    1157 : (MACRO)             	ldn1 R6,R7;reg:  INDIRU1(indaddr)
    1054/    1157 : 07                          ldn     R7
    1054/    1158 : A6                          plo     R6
    1055/    1159 : (MACRO)             	incm R7,1
    1055/    1159 :                             rept    1
    1055/    1159 :                             inc     R7
    1055/    1159 :                             endm
    1055/    1159 : 17                          inc     R7
    1056/    115A :                     ;			switch (c){
    1057/    115A : (MACRO)             	cpy1 R11,R6
    1057/    115A : 86                          glo     R6
    1057/    115B : AB                          plo     R11
    1058/    115C : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1058/    115C : F8 00                       ldi     0
    1058/    115E : BB                          phi     R11
    1059/    115F : (MACRO)             	st2 R11,'O',sp,(13+1); ASGNI2(addr,reg)
    1059/    115F : =>TRUE                      if      ('O'='O')
    1059/    115F :  (MACRO-2)                          ldAX    memAddr,SP,(13+1)
    1059/    115F : 82                          glo     SP
    1059/    1160 : FC 0E                       adi     ((13+1))#256
    1059/    1162 : AE                          plo     MEMADDR
    1059/    1163 : 92                          ghi     SP
    1059/    1164 : 7C 00                       adci    ((13+1))>>8; was/256
    1059/    1166 : BE                          phi     MEMADDR
    1059/    1167 : =>FALSE                     else
    1059/    1167 :                                     ldAD    memAddr,SP
    1059/    1167 : [1059]                      endif
    1059/    1167 : 9B                          ghi     R11
    1059/    1168 : 5E                          str     memAddr
    1059/    1169 : 1E                          inc     memAddr
    1059/    116A : 8B                          glo     R11
    1059/    116B : 5E                          str     memAddr
    1060/    116C : (MACRO)             	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
    1060/    116C : =>TRUE                      if      ('O'='O')
    1060/    116C :  (MACRO-2)                          ldAX    memAddr,SP,(13+1)
    1060/    116C : 82                          glo     SP
    1060/    116D : FC 0E                       adi     ((13+1))#256
    1060/    116F : AE                          plo     MEMADDR
    1060/    1170 : 92                          ghi     SP
    1060/    1171 : 7C 00                       adci    ((13+1))>>8; was/256
    1060/    1173 : BE                          phi     MEMADDR
    1060/    1174 : =>FALSE                     else
    1060/    1174 :                                     ldAD    memAddr,SP
    1060/    1174 : [1060]                      endif
    1060/    1174 : 4E                          lda     memAddr
    1060/    1175 : BB                          phi     R11
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 76 - 1/18/2018 14:51:20


    1060/    1176 : 0E                          ldn     memAddr
    1060/    1177 : AB                          plo     R11
    1061/    1178 : (MACRO)             	jcI2I R11,99,lbnf,L178  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
    1061/    1178 : 8B                          glo     R11
    1061/    1179 : FF 63                       smi     (99)#256
    1061/    117B : 9B                          ghi     R11
    1061/    117C : 7F 00                       smbi    (99)>>8; was/256      ;that's a standard signed subtraction
    1061/    117E : 9B                          ghi     R11 ;
    1061/    117F : FB 00                       xri     (99)>>8; was/256      ;sets the top bit if the signs are different
    1061/    1181 : 7E                          shlc          ;the original df is now in bit 0 and df=1 if signs were different
    1061/    1182 : C7                          lsnf    ;bypass the df flip if signs were the same
    1061/    1183 : FB 01                       xri     01     ;invert original df if signs were different
    1061/    1185 : 76                          shrc           ;put it back in df
    1061/    1186 : CB 11 86                    LBNF    L178  ;execute 
    1062/    1189 : (MACRO)             	jnI2I R11,108,lbnf,L179; GT reverse  the subtraction
    1062/    1189 : 8B                          glo     R11
    1062/    118A : FD 6C                       sdi     (108)#256      ;subtract d FROM immediate value
    1062/    118C : 9B                          ghi     R11
    1062/    118D : 7D 00                       sdbi    (108)>>8; was/256      ;that's a standard signed subtraction (of register FROM immediate)
    1062/    118F : 9B                          ghi     R11 ;
    1062/    1190 : FB 00                       xri     (108)>>8; was/256      ;sets the top bit if the signs are different
    1062/    1192 : 7E                          shlc          ;the original df is now in bit 0 and df=1 if signs were different
    1062/    1193 : C7                          lsnf    ;bypass the df flip if signs were the same
    1062/    1194 : FB 01                       xri     01     ;invert original df if signs were different
    1062/    1196 : 76                          shrc           ;put it back in df
    1062/    1197 : CB 11 97                    LBNF    L179  ;execute 
    1063/    119A : (MACRO)             	shl2I R11,1
    1063/    119A :                             rept    1
    1063/    119A :                             shl2    R11
    1063/    119A :                             endm
    1063/    119A :  (MACRO-2)                  shl2    R11
    1063/    119A : 8B                          glo     R11
    1063/    119B : FE                          shl
    1063/    119C : AB                          plo     R11
    1063/    119D : 9B                          ghi     R11
    1063/    119E : 7E                          shlc
    1063/    119F : BB                          phi     R11
    1064/    11A0 : (MACRO)             	ld2 R11,'O',R11,(L180-198) ;reg:INDIRP2(addr)
    1064/    11A0 : =>TRUE                      if      ('O'='O')
    1064/    11A0 :  (MACRO-2)                          ldAX    memAddr,R11,(L180-198)
    1064/    11A0 : 8B                          glo     R11
    1064/    11A1 : FC DB                       adi     ((L180-198))#256
    1064/    11A3 : AE                          plo     MEMADDR
    1064/    11A4 : 9B                          ghi     R11
    1064/    11A5 : 7C 10                       adci    ((L180-198))>>8; was/256
    1064/    11A7 : BE                          phi     MEMADDR
    1064/    11A8 : =>FALSE                     else
    1064/    11A8 :                                     ldAD    memAddr,R11
    1064/    11A8 : [1064]                      endif
    1064/    11A8 : 4E                          lda     memAddr
    1064/    11A9 : BB                          phi     R11
    1064/    11AA : 0E                          ldn     memAddr
    1064/    11AB : AB                          plo     R11
    1065/    11AC : (MACRO)             	jumpv R11; JUMPV(reg)
    1065/    11AC :  (MACRO-2)                  pushr   r6      ;save the real return address
    1065/    11AC : =>FALSE              if MOMCPU=$1805
    1065/    11AC :                             RSXD    R6
    1065/    11AC : =>TRUE               else
    1065/    11AC : 86                          glo     R6
    1065/    11AD : 73                          stxd
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 77 - 1/18/2018 14:51:20


    1065/    11AE : 96                          ghi     R6
    1065/    11AF : 73                          stxd
    1065/    11B0 : [1065]               endif
    1065/    11B0 :  (MACRO-2)                  cpy2    r6,R11      ;put the jump address into R6
    1065/    11B0 : 8B                          glo     R11
    1065/    11B1 : A6                          plo     R6
    1065/    11B2 : 9B                          ghi     R11
    1065/    11B3 : B6                          phi     R6
    1065/    11B4 :  (MACRO-2)                  Cretn           ;and "return" to it
    1065/    11B4 : =>FALSE              if MOMCPU=$1805
    1065/    11B4 :                             sret    6
    1065/    11B4 : =>TRUE               else
    1065/    11B4 : D5                          sep     RRET
    1065/    11B5 : [1065]               endif
    1066/    11B5 :                     L180:
    1067/    11B5 : 11 B5               	dw L162
    1068/    11B7 : 11 B7               	dw L160
    1069/    11B9 : 11 B9               	dw L157
    1070/    11BB : 11 BB               	dw L173
    1071/    11BD : 11 BD               	dw L157
    1072/    11BF : 11 BF               	dw L157
    1073/    11C1 : 11 C1               	dw L160
    1074/    11C3 : 11 C3               	dw L157
    1075/    11C5 : 11 C5               	dw L157
    1076/    11C7 : 11 C7               	dw L166
    1077/    11C9 :                     L178:
    1078/    11C9 : (MACRO)             	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
    1078/    11C9 : =>TRUE                      if      ('O'='O')
    1078/    11C9 :  (MACRO-2)                          ldAX    memAddr,SP,(13+1)
    1078/    11C9 : 82                          glo     SP
    1078/    11CA : FC 0E                       adi     ((13+1))#256
    1078/    11CC : AE                          plo     MEMADDR
    1078/    11CD : 92                          ghi     SP
    1078/    11CE : 7C 00                       adci    ((13+1))>>8; was/256
    1078/    11D0 : BE                          phi     MEMADDR
    1078/    11D1 : =>FALSE                     else
    1078/    11D1 :                                     ldAD    memAddr,SP
    1078/    11D1 : [1078]                      endif
    1078/    11D1 : 4E                          lda     memAddr
    1078/    11D2 : BB                          phi     R11
    1078/    11D3 : 0E                          ldn     memAddr
    1078/    11D4 : AB                          plo     R11
    1079/    11D5 : (MACRO)             	jeqU2I R11,88,L165;EQI2(reg,con)
    1079/    11D5 : 8B                          glo     R11
    1079/    11D6 : FF 58                       smi     (88)#256
    1079/    11D8 : CA 11 D8                    lbnz    $$nobr
    1079/    11DB : 9B                          ghi     R11
    1079/    11DC : 7F 00                       smbi    (88)>>8; was/256
    1079/    11DE : C2 11 DE                    lbz     L165
    1079/    11E1 :                     $$nobr:
    1080/    11E1 : C0 11 E1            	lbr L157
    1081/    11E4 :                     L179:
    1082/    11E4 : (MACRO)             	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
    1082/    11E4 : =>TRUE                      if      ('O'='O')
    1082/    11E4 :  (MACRO-2)                          ldAX    memAddr,SP,(13+1)
    1082/    11E4 : 82                          glo     SP
    1082/    11E5 : FC 0E                       adi     ((13+1))#256
    1082/    11E7 : AE                          plo     MEMADDR
    1082/    11E8 : 92                          ghi     SP
    1082/    11E9 : 7C 00                       adci    ((13+1))>>8; was/256
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 78 - 1/18/2018 14:51:20


    1082/    11EB : BE                          phi     MEMADDR
    1082/    11EC : =>FALSE                     else
    1082/    11EC :                                     ldAD    memAddr,SP
    1082/    11EC : [1082]                      endif
    1082/    11EC : 4E                          lda     memAddr
    1082/    11ED : BB                          phi     R11
    1082/    11EE : 0E                          ldn     memAddr
    1082/    11EF : AB                          plo     R11
    1083/    11F0 : (MACRO)             	ldaD R10,115; reg:acon
    1083/    11F0 : =>FALSE              if MOMCPU=$1805
    1083/    11F0 :                             RLDI    R10,115
    1083/    11F0 : =>TRUE               else
    1083/    11F0 : F8 73                       ldi     (115)&255
    1083/    11F2 : AA                          plo     R10
    1083/    11F3 : F8 00                       ldi     (115)>>8; was/256
    1083/    11F5 : BA                          phi     R10
    1083/    11F6 : [1083]               endif
    1084/    11F6 : (MACRO)             	jeqI2 R11,R10,L161; EQI2(reg,reg)
    1084/    11F6 : 8A                          glo     R10
    1084/    11F7 : 52                          str     sp
    1084/    11F8 : 8B                          glo     R11
    1084/    11F9 : F7                          sm
    1084/    11FA : CA 11 FA                    lbnz    $$nobr
    1084/    11FD : 9A                          ghi     R10
    1084/    11FE : 52                          str     sp
    1084/    11FF : 9B                          ghi     R11
    1084/    1200 : 77                          smb
    1084/    1201 : C2 12 01                    lbz     L161
    1084/    1204 :                     $$nobr:
    1085/    1204 : (MACRO)             	jcI2 R11,R10,lbnf,L157; LT=lbnf i.e. subtract B from A and jump if borrow 
    1085/    1204 : 8A                          glo     R10
    1085/    1205 : 52                          str     sp 
    1085/    1206 : 8B                          glo     R11
    1085/    1207 : F7                          sm
    1085/    1208 : 9A                          ghi     R10
    1085/    1209 : 52                          str     sp
    1085/    120A : 9B                          ghi     R11
    1085/    120B : 77                          smb          ;that's a standard signed subtraction
    1085/    120C : 9B                          ghi     R11 ;
    1085/    120D : F3                          xor           ;sets the top bit if the signs are different
    1085/    120E : 7E                          shlc          ;the original df is now in bit 0 and df=1 if signs were different
    1085/    120F : C7                          lsnf    ;bypass the flip if signs were the same
    1085/    1210 : FB 01                       xri     01     ;invert original df if signs were different
    1085/    1212 : 76                          shrc           ;put it back in df
    1085/    1213 : CB 12 13                    LBNF    L157  ;execute 
    1086/    1216 :                     L182:
    1087/    1216 : (MACRO)             	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
    1087/    1216 : =>TRUE                      if      ('O'='O')
    1087/    1216 :  (MACRO-2)                          ldAX    memAddr,SP,(13+1)
    1087/    1216 : 82                          glo     SP
    1087/    1217 : FC 0E                       adi     ((13+1))#256
    1087/    1219 : AE                          plo     MEMADDR
    1087/    121A : 92                          ghi     SP
    1087/    121B : 7C 00                       adci    ((13+1))>>8; was/256
    1087/    121D : BE                          phi     MEMADDR
    1087/    121E : =>FALSE                     else
    1087/    121E :                                     ldAD    memAddr,SP
    1087/    121E : [1087]                      endif
    1087/    121E : 4E                          lda     memAddr
    1087/    121F : BB                          phi     R11
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 79 - 1/18/2018 14:51:20


    1087/    1220 : 0E                          ldn     memAddr
    1087/    1221 : AB                          plo     R11
    1088/    1222 : (MACRO)             	jeqU2I R11,120,L165;EQI2(reg,con)
    1088/    1222 : 8B                          glo     R11
    1088/    1223 : FF 78                       smi     (120)#256
    1088/    1225 : CA 12 25                    lbnz    $$nobr
    1088/    1228 : 9B                          ghi     R11
    1088/    1229 : 7F 00                       smbi    (120)>>8; was/256
    1088/    122B : C2 12 2B                    lbz     L165
    1088/    122E :                     $$nobr:
    1089/    122E : C0 12 2E            	lbr L157
    1090/    1231 :                     L160:
    1091/    1231 :                     ;					printint(*this++);
    1092/    1231 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
    1092/    1231 : 81                          glo     R1
    1092/    1232 : AB                          plo     R11
    1092/    1233 : 91                          ghi     R1
    1092/    1234 : BB                          phi     R11
    1093/    1235 : (MACRO)             	incm R1,2
    1093/    1235 :                             rept    2
    1093/    1235 :                             inc     R1
    1093/    1235 :                             endm
    1093/    1235 : 11                          inc     R1
    1093/    1236 : 11                          inc     R1
    1094/    1237 : (MACRO)             	ldn2 R12,R11	;opt9x
    1094/    1237 :                             ;not safe to use for same register
    1094/    1237 : 4B                          lda     R11 ;get 1st byte
    1094/    1238 : BC                          phi     R12     ;to destination
    1094/    1239 : 0B                          ldn     R11 ;second byte
    1094/    123A : 2B                          dec     R11 ;restore address R12
    1094/    123B : AC                          plo     R12     ;2nd byte to dest (5 instructions vs 10)
    1095/    123C : (MACRO)             	Ccall _printint
    1095/    123C : =>FALSE              if MOMCPU=$1805
    1095/    123C :                             SCAL    6
    1095/    123C :                             dw      _PRINTINT
    1095/    123C : =>TRUE               else
    1095/    123C : D4                          sep     RCALL
    1095/    123D : 0E E3                       dw      _PRINTINT
    1095/    123F : [1095]               endif
    1096/    123F :                     ;					argslot+=1; //next argument slot
    1097/    123F : (MACRO)             	incm R0,1
    1097/    123F :                             rept    1
    1097/    123F :                             inc     R0
    1097/    123F :                             endm
    1097/    123F : 10                          inc     R0
    1098/    1240 :                     ;					break;
    1099/    1240 : C0 12 40            	lbr L158
    1100/    1243 :                     L161:
    1101/    1243 :                     ;					printstr((char*) *this++);
    1102/    1243 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
    1102/    1243 : 81                          glo     R1
    1102/    1244 : AB                          plo     R11
    1102/    1245 : 91                          ghi     R1
    1102/    1246 : BB                          phi     R11
    1103/    1247 : (MACRO)             	incm R1,2
    1103/    1247 :                             rept    2
    1103/    1247 :                             inc     R1
    1103/    1247 :                             endm
    1103/    1247 : 11                          inc     R1
    1103/    1248 : 11                          inc     R1
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 80 - 1/18/2018 14:51:20


    1104/    1249 : (MACRO)             	ldn2s R11,R11	;opt9xs
    1104/    1249 :                             ;safe to use for same register
    1104/    1249 : 4B                          lda     R11 ;get 1st byte
    1104/    124A : BE                          phi     memaddr ;save it
    1104/    124B : 0B                          ldn     R11 ;second byte
    1104/    124C : 2B                          dec     R11 ;restore address R11
    1104/    124D : AB                          plo     R11     ;1st byte to dest
    1104/    124E : 9E                          ghi     memaddr ;2nd byte
    1104/    124F : BB                          phi     R11     ;to destination (7 instructions vs 10)
    1105/    1250 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
    1105/    1250 : 8B                          glo     R11
    1105/    1251 : AC                          plo     R12
    1105/    1252 : 9B                          ghi     R11
    1105/    1253 : BC                          phi     R12
    1106/    1254 : (MACRO)             	Ccall _printstr
    1106/    1254 : =>FALSE              if MOMCPU=$1805
    1106/    1254 :                             SCAL    6
    1106/    1254 :                             dw      _PRINTSTR
    1106/    1254 : =>TRUE               else
    1106/    1254 : D4                          sep     RCALL
    1106/    1255 : 09 88                       dw      _PRINTSTR
    1106/    1257 : [1106]               endif
    1107/    1257 :                     ;					argslot+=1; //next argument slot
    1108/    1257 : (MACRO)             	incm R0,1
    1108/    1257 :                             rept    1
    1108/    1257 :                             inc     R0
    1108/    1257 :                             endm
    1108/    1257 : 10                          inc     R0
    1109/    1258 :                     ;					break;
    1110/    1258 : C0 12 58            	lbr L158
    1111/    125B :                     L162:
    1112/    125B :                     ;					if (*ptr=='x'){ //if there's an x
    1113/    125B : (MACRO)             	ldn1 R11,R7;reg:  INDIRU1(indaddr)
    1113/    125B : 07                          ldn     R7
    1113/    125C : AB                          plo     R11
    1114/    125D : (MACRO)             	jneU1I R11,120,L163	; DH 4
    1114/    125D : 8B                          glo     R11
    1114/    125E : FF 78                       smi     120
    1114/    1260 : CA 12 60                    lbnz    L163
    1115/    1263 :                     ;						ptr++; //skip over the x
    1116/    1263 : (MACRO)             	incm R7,1
    1116/    1263 :                             rept    1
    1116/    1263 :                             inc     R7
    1116/    1263 :                             endm
    1116/    1263 : 17                          inc     R7
    1117/    1264 :                     ;						putx(((unsigned int) *this++)&255); //print 1 byte as hex
    1118/    1264 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
    1118/    1264 : 81                          glo     R1
    1118/    1265 : AB                          plo     R11
    1118/    1266 : 91                          ghi     R1
    1118/    1267 : BB                          phi     R11
    1119/    1268 : (MACRO)             	incm R1,2
    1119/    1268 :                             rept    2
    1119/    1268 :                             inc     R1
    1119/    1268 :                             endm
    1119/    1268 : 11                          inc     R1
    1119/    1269 : 11                          inc     R1
    1120/    126A : (MACRO)             	ldn2s R11,R11	;opt9xs
    1120/    126A :                             ;safe to use for same register
    1120/    126A : 4B                          lda     R11 ;get 1st byte
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 81 - 1/18/2018 14:51:20


    1120/    126B : BE                          phi     memaddr ;save it
    1120/    126C : 0B                          ldn     R11 ;second byte
    1120/    126D : 2B                          dec     R11 ;restore address R11
    1120/    126E : AB                          plo     R11     ;1st byte to dest
    1120/    126F : 9E                          ghi     memaddr ;2nd byte
    1120/    1270 : BB                          phi     R11     ;to destination (7 instructions vs 10)
    1121/    1271 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
    1121/    1271 : 8B                          glo     R11
    1121/    1272 : FA FF                       ANI     (255)#256
    1121/    1274 : AB                          plo     R11
    1121/    1275 : 9B                          ghi     R11
    1121/    1276 : FA 00                       ANI     (255)>>8; was/256
    1121/    1278 : BB                          phi     R11
    1122/    1279 : (MACRO)             	cpy1 R12,R11
    1122/    1279 : 8B                          glo     R11
    1122/    127A : AC                          plo     R12
    1123/    127B : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1123/    127B : F8 00                       ldi     0
    1123/    127D : BC                          phi     R12
    1124/    127E : (MACRO)             	Ccall _putx
    1124/    127E : =>FALSE              if MOMCPU=$1805
    1124/    127E :                             SCAL    6
    1124/    127E :                             dw      _PUTX
    1124/    127E : =>TRUE               else
    1124/    127E : D4                          sep     RCALL
    1124/    127F : 10 7B                       dw      _PUTX
    1124/    1281 : [1124]               endif
    1125/    1281 :                     ;					} else{
    1126/    1281 : C0 12 81            	lbr L164
    1127/    1284 :                     L163:
    1128/    1284 :                     ;						putc((unsigned int) *this++);		//print as char
    1129/    1284 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
    1129/    1284 : 81                          glo     R1
    1129/    1285 : AB                          plo     R11
    1129/    1286 : 91                          ghi     R1
    1129/    1287 : BB                          phi     R11
    1130/    1288 : (MACRO)             	incm R1,2
    1130/    1288 :                             rept    2
    1130/    1288 :                             inc     R1
    1130/    1288 :                             endm
    1130/    1288 : 11                          inc     R1
    1130/    1289 : 11                          inc     R1
    1131/    128A : (MACRO)             	ldn2s R11,R11	;opt9xs
    1131/    128A :                             ;safe to use for same register
    1131/    128A : 4B                          lda     R11 ;get 1st byte
    1131/    128B : BE                          phi     memaddr ;save it
    1131/    128C : 0B                          ldn     R11 ;second byte
    1131/    128D : 2B                          dec     R11 ;restore address R11
    1131/    128E : AB                          plo     R11     ;1st byte to dest
    1131/    128F : 9E                          ghi     memaddr ;2nd byte
    1131/    1290 : BB                          phi     R11     ;to destination (7 instructions vs 10)
    1132/    1291 : (MACRO)             	cpy1 R12,R11
    1132/    1291 : 8B                          glo     R11
    1132/    1292 : AC                          plo     R12
    1133/    1293 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1133/    1293 : F8 00                       ldi     0
    1133/    1295 : BC                          phi     R12
    1134/    1296 : (MACRO)             	Ccall _putcser
    1134/    1296 : =>FALSE              if MOMCPU=$1805
    1134/    1296 :                             SCAL    6
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 82 - 1/18/2018 14:51:20


    1134/    1296 :                             dw      _PUTCSER
    1134/    1296 : =>TRUE               else
    1134/    1296 : D4                          sep     RCALL
    1134/    1297 : 08 5C                       dw      _PUTCSER
    1134/    1299 : [1134]               endif
    1135/    1299 :                     ;					}
    1136/    1299 :                     L164:
    1137/    1299 :                     ;					argslot+=1; //next argument slot
    1138/    1299 : (MACRO)             	incm R0,1
    1138/    1299 :                             rept    1
    1138/    1299 :                             inc     R0
    1138/    1299 :                             endm
    1138/    1299 : 10                          inc     R0
    1139/    129A :                     ;					break;
    1140/    129A : C0 12 9A            	lbr L158
    1141/    129D :                     L165:
    1142/    129D :                     ;					putx(((unsigned int) *this)>>8);
    1143/    129D : (MACRO)             	ldn2 R11,R1	;opt9x
    1143/    129D :                             ;not safe to use for same register
    1143/    129D : 41                          lda     R1 ;get 1st byte
    1143/    129E : BB                          phi     R11     ;to destination
    1143/    129F : 01                          ldn     R1 ;second byte
    1143/    12A0 : 21                          dec     R1 ;restore address R11
    1143/    12A1 : AB                          plo     R11     ;2nd byte to dest (5 instructions vs 10)
    1144/    12A2 : 9B                  	ghi	R11	;opt2
    1145/    12A3 : AB                  	plo	R11
    1146/    12A4 : F8 00               	ldi	0
    1147/    12A6 : BB                  	phi	R11	
    1148/    12A7 : (MACRO)             	cpy1 R12,R11
    1148/    12A7 : 8B                          glo     R11
    1148/    12A8 : AC                          plo     R12
    1149/    12A9 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1149/    12A9 : F8 00                       ldi     0
    1149/    12AB : BC                          phi     R12
    1150/    12AC : (MACRO)             	Ccall _putx
    1150/    12AC : =>FALSE              if MOMCPU=$1805
    1150/    12AC :                             SCAL    6
    1150/    12AC :                             dw      _PUTX
    1150/    12AC : =>TRUE               else
    1150/    12AC : D4                          sep     RCALL
    1150/    12AD : 10 7B                       dw      _PUTX
    1150/    12AF : [1150]               endif
    1151/    12AF :                     ;					putx(((unsigned int) *this++)&255);
    1152/    12AF : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
    1152/    12AF : 81                          glo     R1
    1152/    12B0 : AB                          plo     R11
    1152/    12B1 : 91                          ghi     R1
    1152/    12B2 : BB                          phi     R11
    1153/    12B3 : (MACRO)             	incm R1,2
    1153/    12B3 :                             rept    2
    1153/    12B3 :                             inc     R1
    1153/    12B3 :                             endm
    1153/    12B3 : 11                          inc     R1
    1153/    12B4 : 11                          inc     R1
    1154/    12B5 : (MACRO)             	ldn2s R11,R11	;opt9xs
    1154/    12B5 :                             ;safe to use for same register
    1154/    12B5 : 4B                          lda     R11 ;get 1st byte
    1154/    12B6 : BE                          phi     memaddr ;save it
    1154/    12B7 : 0B                          ldn     R11 ;second byte
    1154/    12B8 : 2B                          dec     R11 ;restore address R11
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 83 - 1/18/2018 14:51:20


    1154/    12B9 : AB                          plo     R11     ;1st byte to dest
    1154/    12BA : 9E                          ghi     memaddr ;2nd byte
    1154/    12BB : BB                          phi     R11     ;to destination (7 instructions vs 10)
    1155/    12BC : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
    1155/    12BC : 8B                          glo     R11
    1155/    12BD : FA FF                       ANI     (255)#256
    1155/    12BF : AB                          plo     R11
    1155/    12C0 : 9B                          ghi     R11
    1155/    12C1 : FA 00                       ANI     (255)>>8; was/256
    1155/    12C3 : BB                          phi     R11
    1156/    12C4 : (MACRO)             	cpy1 R12,R11
    1156/    12C4 : 8B                          glo     R11
    1156/    12C5 : AC                          plo     R12
    1157/    12C6 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1157/    12C6 : F8 00                       ldi     0
    1157/    12C8 : BC                          phi     R12
    1158/    12C9 : (MACRO)             	Ccall _putx
    1158/    12C9 : =>FALSE              if MOMCPU=$1805
    1158/    12C9 :                             SCAL    6
    1158/    12C9 :                             dw      _PUTX
    1158/    12C9 : =>TRUE               else
    1158/    12C9 : D4                          sep     RCALL
    1158/    12CA : 10 7B                       dw      _PUTX
    1158/    12CC : [1158]               endif
    1159/    12CC :                     ;					argslot+=1; //next argument slot
    1160/    12CC : (MACRO)             	incm R0,1
    1160/    12CC :                             rept    1
    1160/    12CC :                             inc     R0
    1160/    12CC :                             endm
    1160/    12CC : 10                          inc     R0
    1161/    12CD :                     ;					break;
    1162/    12CD : C0 12 CD            	lbr L158
    1163/    12D0 :                     L166:
    1164/    12D0 :                     ;					if (*ptr){ //as long as there's something there
    1165/    12D0 : (MACRO)             	ldn1 R11,R7	;opt14*
    1165/    12D0 : 07                          ldn     R7
    1165/    12D1 : AB                          plo     R11
    1166/    12D2 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
    1166/    12D2 : F8 00                       ldi     0
    1166/    12D4 : BB                          phi     R11
    1167/    12D5 : (MACRO)             	jzU2 R11,L167; EQ 0
    1167/    12D5 : 8B                          glo     R11
    1167/    12D6 : CA 12 D6                    lbnz    +
    1167/    12D9 : 9B                          ghi     R11
    1167/    12DA : C2 12 DA                    lbz     L167
    1167/    12DD :                     +
    1168/    12DD :                     ;						xord=*ptr++;
    1169/    12DD : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
    1169/    12DD : 87                          glo     R7
    1169/    12DE : AB                          plo     R11
    1169/    12DF : 97                          ghi     R7
    1169/    12E0 : BB                          phi     R11
    1170/    12E1 : (MACRO)             	incm R7,1
    1170/    12E1 :                             rept    1
    1170/    12E1 :                             inc     R7
    1170/    12E1 :                             endm
    1170/    12E1 : 17                          inc     R7
    1171/    12E2 : (MACRO)             	ldA2 R10,'O',sp,(15+1); reg:addr
    1171/    12E2 :                     ;Oct 13 (15+1) added to ldAD call
    1171/    12E2 : =>TRUE                      if      ('O'='O')
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 84 - 1/18/2018 14:51:20


    1171/    12E2 :  (MACRO-2)                          ldAX    R10,SP,(15+1)
    1171/    12E2 : 82                          glo     SP
    1171/    12E3 : FC 10                       adi     ((15+1))#256
    1171/    12E5 : AA                          plo     R10
    1171/    12E6 : 92                          ghi     SP
    1171/    12E7 : 7C 00                       adci    ((15+1))>>8; was/256
    1171/    12E9 : BA                          phi     R10
    1171/    12EA : =>FALSE                     else
    1171/    12EA :                                     ldAD    R10,SP+(15+1)
    1171/    12EA : [1171]                      endif
    1172/    12EA : (MACRO)             	ldn1 R11,R11;reg:  INDIRU1(indaddr)
    1172/    12EA : 0B                          ldn     R11
    1172/    12EB : AB                          plo     R11
    1173/    12EC : (MACRO)             	str1 R11,R10; ASGNU1(indaddr,reg)		DH
    1173/    12EC : 8B                          glo     R11
    1173/    12ED : 5A                          str     R10
    1174/    12EE :                     ;						if (argslot&1) {
    1175/    12EE : (MACRO)             	alu2I R11,R0,1,ani,ani
    1175/    12EE : 80                          glo     R0
    1175/    12EF : FA 01                       ANI     (1)#256
    1175/    12F1 : AB                          plo     R11
    1175/    12F2 : 90                          ghi     R0
    1175/    12F3 : FA 00                       ANI     (1)>>8; was/256
    1175/    12F5 : BB                          phi     R11
    1176/    12F6 :                     	;removed ?	cpy2 R11,R0
    1177/    12F6 : (MACRO)             	jzU2 R11,L169; EQ 0
    1177/    12F6 : 8B                          glo     R11
    1177/    12F7 : CA 12 F7                    lbnz    +
    1177/    12FA : 9B                          ghi     R11
    1177/    12FB : C2 12 FB                    lbz     L169
    1177/    12FE :                     +
    1178/    12FE :                     ;							this++;
    1179/    12FE : (MACRO)             	incm R1,2
    1179/    12FE :                             rept    2
    1179/    12FE :                             inc     R1
    1179/    12FE :                             endm
    1179/    12FE : 11                          inc     R1
    1179/    12FF : 11                          inc     R1
    1180/    1300 :                     ;							argslot++;
    1181/    1300 : (MACRO)             	incm R0,1
    1181/    1300 :                             rept    1
    1181/    1300 :                             inc     R0
    1181/    1300 :                             endm
    1181/    1300 : 10                          inc     R0
    1182/    1301 :                     ;						}
    1183/    1301 :                     L169:
    1184/    1301 :                     ;						if(xord=='d'){
    1185/    1301 : (MACRO)             	ld1 R11,'O',sp,(15+1)
    1185/    1301 : =>TRUE                      if      ('O'='O')
    1185/    1301 :  (MACRO-2)                          ldAX    memAddr,SP,(15+1)
    1185/    1301 : 82                          glo     SP
    1185/    1302 : FC 10                       adi     ((15+1))#256
    1185/    1304 : AE                          plo     MEMADDR
    1185/    1305 : 92                          ghi     SP
    1185/    1306 : 7C 00                       adci    ((15+1))>>8; was/256
    1185/    1308 : BE                          phi     MEMADDR
    1185/    1309 : =>FALSE                     else
    1185/    1309 :                                     ldAD    memAddr,SP
    1185/    1309 : [1185]                      endif
    1185/    1309 : 0E                          ldn     memAddr
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 85 - 1/18/2018 14:51:20


    1185/    130A : AB                          plo     R11
    1186/    130B : (MACRO)             	jneU1I R11,100,L171	; DH 4
    1186/    130B : 8B                          glo     R11
    1186/    130C : FF 64                       smi     100
    1186/    130E : CA 13 0E                    lbnz    L171
    1187/    1311 :                     ;							printlint(*(long *)this);//treats "this" as a pointer to long
    1188/    1311 : (MACRO)             	ld4 Rp1p2,'O',R1,0;reg:  INDIRI4(addr)
    1188/    1311 : =>TRUE                      if      ('O'='O')
    1188/    1311 :  (MACRO-2)                          ldAX    memAddr,R1,0
    1188/    1311 : 81                          glo     R1
    1188/    1312 : FC 00                       adi     (0)#256
    1188/    1314 : AE                          plo     MEMADDR
    1188/    1315 : 91                          ghi     R1
    1188/    1316 : 7C 00                       adci    (0)>>8; was/256
    1188/    1318 : BE                          phi     MEMADDR
    1188/    1319 : =>FALSE                     else
    1188/    1319 :                                     ldAD    memAddr,R1
    1188/    1319 : [1188]                      endif
    1188/    1319 : 4E                          lda     memAddr
    1188/    131A : BC                          phi     RP1P2-1   ;long register pairs are addressed by their second member
    1188/    131B : 4E                          lda     memAddr ;but load and store start with the 1st
    1188/    131C : AC                          plo     RP1P2-1
    1188/    131D : 4E                          lda     memAddr
    1188/    131E : BD                          phi     RP1P2
    1188/    131F : 0E                          ldn     memAddr
    1188/    1320 : AD                          plo     RP1P2
    1189/    1321 : (MACRO)             	Ccall _printlint
    1189/    1321 : =>FALSE              if MOMCPU=$1805
    1189/    1321 :                             SCAL    6
    1189/    1321 :                             dw      _PRINTLINT
    1189/    1321 : =>TRUE               else
    1189/    1321 : D4                          sep     RCALL
    1189/    1322 : 0F 25                       dw      _PRINTLINT
    1189/    1324 : [1189]               endif
    1190/    1324 :                     ;							this+=2;				// and advances it 4 bytes
    1191/    1324 : (MACRO)             	incm R1,4
    1191/    1324 :                             rept    4
    1191/    1324 :                             inc     R1
    1191/    1324 :                             endm
    1191/    1324 : 11                          inc     R1
    1191/    1325 : 11                          inc     R1
    1191/    1326 : 11                          inc     R1
    1191/    1327 : 11                          inc     R1
    1192/    1328 :                     ;						} else{
    1193/    1328 : C0 13 28            	lbr L172
    1194/    132B :                     L171:
    1195/    132B :                     ;							putx(((unsigned int) *this)>>8);
    1196/    132B : (MACRO)             	ldn2 R11,R1	;opt9x
    1196/    132B :                             ;not safe to use for same register
    1196/    132B : 41                          lda     R1 ;get 1st byte
    1196/    132C : BB                          phi     R11     ;to destination
    1196/    132D : 01                          ldn     R1 ;second byte
    1196/    132E : 21                          dec     R1 ;restore address R11
    1196/    132F : AB                          plo     R11     ;2nd byte to dest (5 instructions vs 10)
    1197/    1330 : 9B                  	ghi	R11	;opt2
    1198/    1331 : AB                  	plo	R11
    1199/    1332 : F8 00               	ldi	0
    1200/    1334 : BB                  	phi	R11	
    1201/    1335 : (MACRO)             	cpy1 R12,R11
    1201/    1335 : 8B                          glo     R11
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 86 - 1/18/2018 14:51:20


    1201/    1336 : AC                          plo     R12
    1202/    1337 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1202/    1337 : F8 00                       ldi     0
    1202/    1339 : BC                          phi     R12
    1203/    133A : (MACRO)             	Ccall _putx
    1203/    133A : =>FALSE              if MOMCPU=$1805
    1203/    133A :                             SCAL    6
    1203/    133A :                             dw      _PUTX
    1203/    133A : =>TRUE               else
    1203/    133A : D4                          sep     RCALL
    1203/    133B : 10 7B                       dw      _PUTX
    1203/    133D : [1203]               endif
    1204/    133D :                     ;							putx(((unsigned int) *this++)&255);
    1205/    133D : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
    1205/    133D : 81                          glo     R1
    1205/    133E : AB                          plo     R11
    1205/    133F : 91                          ghi     R1
    1205/    1340 : BB                          phi     R11
    1206/    1341 : (MACRO)             	incm R1,2
    1206/    1341 :                             rept    2
    1206/    1341 :                             inc     R1
    1206/    1341 :                             endm
    1206/    1341 : 11                          inc     R1
    1206/    1342 : 11                          inc     R1
    1207/    1343 : (MACRO)             	ldn2s R11,R11	;opt9xs
    1207/    1343 :                             ;safe to use for same register
    1207/    1343 : 4B                          lda     R11 ;get 1st byte
    1207/    1344 : BE                          phi     memaddr ;save it
    1207/    1345 : 0B                          ldn     R11 ;second byte
    1207/    1346 : 2B                          dec     R11 ;restore address R11
    1207/    1347 : AB                          plo     R11     ;1st byte to dest
    1207/    1348 : 9E                          ghi     memaddr ;2nd byte
    1207/    1349 : BB                          phi     R11     ;to destination (7 instructions vs 10)
    1208/    134A : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
    1208/    134A : 8B                          glo     R11
    1208/    134B : FA FF                       ANI     (255)#256
    1208/    134D : AB                          plo     R11
    1208/    134E : 9B                          ghi     R11
    1208/    134F : FA 00                       ANI     (255)>>8; was/256
    1208/    1351 : BB                          phi     R11
    1209/    1352 : (MACRO)             	cpy1 R12,R11
    1209/    1352 : 8B                          glo     R11
    1209/    1353 : AC                          plo     R12
    1210/    1354 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1210/    1354 : F8 00                       ldi     0
    1210/    1356 : BC                          phi     R12
    1211/    1357 : (MACRO)             	Ccall _putx
    1211/    1357 : =>FALSE              if MOMCPU=$1805
    1211/    1357 :                             SCAL    6
    1211/    1357 :                             dw      _PUTX
    1211/    1357 : =>TRUE               else
    1211/    1357 : D4                          sep     RCALL
    1211/    1358 : 10 7B                       dw      _PUTX
    1211/    135A : [1211]               endif
    1212/    135A :                     ;							putx(((unsigned int) *this)>>8);
    1213/    135A : (MACRO)             	ldn2 R11,R1	;opt9x
    1213/    135A :                             ;not safe to use for same register
    1213/    135A : 41                          lda     R1 ;get 1st byte
    1213/    135B : BB                          phi     R11     ;to destination
    1213/    135C : 01                          ldn     R1 ;second byte
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 87 - 1/18/2018 14:51:20


    1213/    135D : 21                          dec     R1 ;restore address R11
    1213/    135E : AB                          plo     R11     ;2nd byte to dest (5 instructions vs 10)
    1214/    135F : 9B                  	ghi	R11	;opt2
    1215/    1360 : AB                  	plo	R11
    1216/    1361 : F8 00               	ldi	0
    1217/    1363 : BB                  	phi	R11	
    1218/    1364 : (MACRO)             	cpy1 R12,R11
    1218/    1364 : 8B                          glo     R11
    1218/    1365 : AC                          plo     R12
    1219/    1366 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1219/    1366 : F8 00                       ldi     0
    1219/    1368 : BC                          phi     R12
    1220/    1369 : (MACRO)             	Ccall _putx
    1220/    1369 : =>FALSE              if MOMCPU=$1805
    1220/    1369 :                             SCAL    6
    1220/    1369 :                             dw      _PUTX
    1220/    1369 : =>TRUE               else
    1220/    1369 : D4                          sep     RCALL
    1220/    136A : 10 7B                       dw      _PUTX
    1220/    136C : [1220]               endif
    1221/    136C :                     ;							putx(((unsigned int) *this++)&255);
    1222/    136C : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
    1222/    136C : 81                          glo     R1
    1222/    136D : AB                          plo     R11
    1222/    136E : 91                          ghi     R1
    1222/    136F : BB                          phi     R11
    1223/    1370 : (MACRO)             	incm R1,2
    1223/    1370 :                             rept    2
    1223/    1370 :                             inc     R1
    1223/    1370 :                             endm
    1223/    1370 : 11                          inc     R1
    1223/    1371 : 11                          inc     R1
    1224/    1372 : (MACRO)             	ldn2s R11,R11	;opt9xs
    1224/    1372 :                             ;safe to use for same register
    1224/    1372 : 4B                          lda     R11 ;get 1st byte
    1224/    1373 : BE                          phi     memaddr ;save it
    1224/    1374 : 0B                          ldn     R11 ;second byte
    1224/    1375 : 2B                          dec     R11 ;restore address R11
    1224/    1376 : AB                          plo     R11     ;1st byte to dest
    1224/    1377 : 9E                          ghi     memaddr ;2nd byte
    1224/    1378 : BB                          phi     R11     ;to destination (7 instructions vs 10)
    1225/    1379 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
    1225/    1379 : 8B                          glo     R11
    1225/    137A : FA FF                       ANI     (255)#256
    1225/    137C : AB                          plo     R11
    1225/    137D : 9B                          ghi     R11
    1225/    137E : FA 00                       ANI     (255)>>8; was/256
    1225/    1380 : BB                          phi     R11
    1226/    1381 : (MACRO)             	cpy1 R12,R11
    1226/    1381 : 8B                          glo     R11
    1226/    1382 : AC                          plo     R12
    1227/    1383 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1227/    1383 : F8 00                       ldi     0
    1227/    1385 : BC                          phi     R12
    1228/    1386 : (MACRO)             	Ccall _putx
    1228/    1386 : =>FALSE              if MOMCPU=$1805
    1228/    1386 :                             SCAL    6
    1228/    1386 :                             dw      _PUTX
    1228/    1386 : =>TRUE               else
    1228/    1386 : D4                          sep     RCALL
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 88 - 1/18/2018 14:51:20


    1228/    1387 : 10 7B                       dw      _PUTX
    1228/    1389 : [1228]               endif
    1229/    1389 :                     ;						}
    1230/    1389 :                     L172:
    1231/    1389 :                     ;						argslot+=2;
    1232/    1389 : (MACRO)             	incm R0,2
    1232/    1389 :                             rept    2
    1232/    1389 :                             inc     R0
    1232/    1389 :                             endm
    1232/    1389 : 10                          inc     R0
    1232/    138A : 10                          inc     R0
    1233/    138B :                     ;						break;
    1234/    138B : C0 13 8B            	lbr L158
    1235/    138E :                     L167:
    1236/    138E :                     L173:
    1237/    138E :                     ;					if (*ptr){ //as long as there's something there
    1238/    138E : (MACRO)             	ldn1 R11,R7	;opt14*
    1238/    138E : 07                          ldn     R7
    1238/    138F : AB                          plo     R11
    1239/    1390 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
    1239/    1390 : F8 00                       ldi     0
    1239/    1392 : BB                          phi     R11
    1240/    1393 : (MACRO)             	jzU2 R11,L174; EQ 0
    1240/    1393 : 8B                          glo     R11
    1240/    1394 : CA 13 94                    lbnz    +
    1240/    1397 : 9B                          ghi     R11
    1240/    1398 : C2 13 98                    lbz     L174
    1240/    139B :                     +
    1241/    139B :                     ;						if (argslot&1) { //adjust alignment
    1242/    139B : (MACRO)             	alu2I R11,R0,1,ani,ani
    1242/    139B : 80                          glo     R0
    1242/    139C : FA 01                       ANI     (1)#256
    1242/    139E : AB                          plo     R11
    1242/    139F : 90                          ghi     R0
    1242/    13A0 : FA 00                       ANI     (1)>>8; was/256
    1242/    13A2 : BB                          phi     R11
    1243/    13A3 :                     	;removed ?	cpy2 R11,R0
    1244/    13A3 : (MACRO)             	jzU2 R11,L176; EQ 0
    1244/    13A3 : 8B                          glo     R11
    1244/    13A4 : CA 13 A4                    lbnz    +
    1244/    13A7 : 9B                          ghi     R11
    1244/    13A8 : C2 13 A8                    lbz     L176
    1244/    13AB :                     +
    1245/    13AB :                     ;							this++;
    1246/    13AB : (MACRO)             	incm R1,2
    1246/    13AB :                             rept    2
    1246/    13AB :                             inc     R1
    1246/    13AB :                             endm
    1246/    13AB : 11                          inc     R1
    1246/    13AC : 11                          inc     R1
    1247/    13AD :                     ;							argslot++;
    1248/    13AD : (MACRO)             	incm R0,1
    1248/    13AD :                             rept    1
    1248/    13AD :                             inc     R0
    1248/    13AD :                             endm
    1248/    13AD : 10                          inc     R0
    1249/    13AE :                     ;						}
    1250/    13AE :                     L176:
    1251/    13AE :                     ;						printflt(*(float *)this);//treats "this" as a pointer to float
    1252/    13AE : (MACRO)             	ld4 Rp1p2,'O',R1,0;INDIRF4(addr)
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 89 - 1/18/2018 14:51:20


    1252/    13AE : =>TRUE                      if      ('O'='O')
    1252/    13AE :  (MACRO-2)                          ldAX    memAddr,R1,0
    1252/    13AE : 81                          glo     R1
    1252/    13AF : FC 00                       adi     (0)#256
    1252/    13B1 : AE                          plo     MEMADDR
    1252/    13B2 : 91                          ghi     R1
    1252/    13B3 : 7C 00                       adci    (0)>>8; was/256
    1252/    13B5 : BE                          phi     MEMADDR
    1252/    13B6 : =>FALSE                     else
    1252/    13B6 :                                     ldAD    memAddr,R1
    1252/    13B6 : [1252]                      endif
    1252/    13B6 : 4E                          lda     memAddr
    1252/    13B7 : BC                          phi     RP1P2-1   ;long register pairs are addressed by their second member
    1252/    13B8 : 4E                          lda     memAddr ;but load and store start with the 1st
    1252/    13B9 : AC                          plo     RP1P2-1
    1252/    13BA : 4E                          lda     memAddr
    1252/    13BB : BD                          phi     RP1P2
    1252/    13BC : 0E                          ldn     memAddr
    1252/    13BD : AD                          plo     RP1P2
    1253/    13BE : (MACRO)             	Ccall _printflt
    1253/    13BE : =>FALSE              if MOMCPU=$1805
    1253/    13BE :                             SCAL    6
    1253/    13BE :                             dw      _PRINTFLT
    1253/    13BE : =>TRUE               else
    1253/    13BE : D4                          sep     RCALL
    1253/    13BF : 0F 7F                       dw      _PRINTFLT
    1253/    13C1 : [1253]               endif
    1254/    13C1 :                     ;						this+=2;				// and advances it 4 bytes
    1255/    13C1 : (MACRO)             	incm R1,4
    1255/    13C1 :                             rept    4
    1255/    13C1 :                             inc     R1
    1255/    13C1 :                             endm
    1255/    13C1 : 11                          inc     R1
    1255/    13C2 : 11                          inc     R1
    1255/    13C3 : 11                          inc     R1
    1255/    13C4 : 11                          inc     R1
    1256/    13C5 :                     ;						argslot+=2;
    1257/    13C5 : (MACRO)             	incm R0,2
    1257/    13C5 :                             rept    2
    1257/    13C5 :                             inc     R0
    1257/    13C5 :                             endm
    1257/    13C5 : 10                          inc     R0
    1257/    13C6 : 10                          inc     R0
    1258/    13C7 :                     ;						break;
    1259/    13C7 : C0 13 C7            	lbr L158
    1260/    13CA :                     L174:
    1261/    13CA :                     L157:
    1262/    13CA :                     ;					putc('%');putc(c);
    1263/    13CA : (MACRO)             	ldaD R12,37; reg:acon
    1263/    13CA : =>FALSE              if MOMCPU=$1805
    1263/    13CA :                             RLDI    R12,37
    1263/    13CA : =>TRUE               else
    1263/    13CA : F8 25                       ldi     (37)&255
    1263/    13CC : AC                          plo     R12
    1263/    13CD : F8 00                       ldi     (37)>>8; was/256
    1263/    13CF : BC                          phi     R12
    1263/    13D0 : [1263]               endif
    1264/    13D0 : (MACRO)             	Ccall _putcser
    1264/    13D0 : =>FALSE              if MOMCPU=$1805
    1264/    13D0 :                             SCAL    6
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 90 - 1/18/2018 14:51:20


    1264/    13D0 :                             dw      _PUTCSER
    1264/    13D0 : =>TRUE               else
    1264/    13D0 : D4                          sep     RCALL
    1264/    13D1 : 08 5C                       dw      _PUTCSER
    1264/    13D3 : [1264]               endif
    1265/    13D3 : (MACRO)             	cpy1 R12,R6
    1265/    13D3 : 86                          glo     R6
    1265/    13D4 : AC                          plo     R12
    1266/    13D5 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1266/    13D5 : F8 00                       ldi     0
    1266/    13D7 : BC                          phi     R12
    1267/    13D8 : (MACRO)             	Ccall _putcser
    1267/    13D8 : =>FALSE              if MOMCPU=$1805
    1267/    13D8 :                             SCAL    6
    1267/    13D8 :                             dw      _PUTCSER
    1267/    13D8 : =>TRUE               else
    1267/    13D8 : D4                          sep     RCALL
    1267/    13D9 : 08 5C                       dw      _PUTCSER
    1267/    13DB : [1267]               endif
    1268/    13DB :                     ;			} //switch
    1269/    13DB :                     L158:
    1270/    13DB :                     ;		} //%
    1271/    13DB :                     L155:
    1272/    13DB :                     ;	} //while
    1273/    13DB :                     L152:
    1274/    13DB :                     ;    while(*ptr) {
    1275/    13DB : (MACRO)             	ldn1 R11,R7;reg:  INDIRU1(indaddr)
    1275/    13DB : 07                          ldn     R7
    1275/    13DC : AB                          plo     R11
    1276/    13DD : (MACRO)             	jnzU1 R11,L151; NEI2(CVUI2(reg),con0)
    1276/    13DD : 8B                          glo     R11
    1276/    13DE : CA 11 43                    lbnz    L151
    1277/    13E1 :                     ;} //prtf
    1278/    13E1 :                     L150:
    1279/    13E1 : (MACRO)             	release 4; release room for outgoing arguments
    1279/    13E1 : =>TRUE                      if (4<9)
    1279/    13E1 :  (MACRO-2)                      releaseS 4  ;use dec for small amounts
    1279/    13E1 :                             rept    4
    1279/    13E1 :                             inc sp
    1279/    13E1 :                             endm
    1279/    13E1 : 12                          inc sp
    1279/    13E2 : 12                          inc sp
    1279/    13E3 : 12                          inc sp
    1279/    13E4 : 12                          inc sp
    1279/    13E5 : =>FALSE                     else
    1279/    13E5 :                                 releaseL 4  ;use subtract for large amounts
    1279/    13E5 : [1279]                      endif
    1280/    13E5 : (MACRO)             	popf R7	;opt11.3
    1280/    13E5 : =>FALSE              if MOMCPU=$1805
    1280/    13E5 :                             inc     sp
    1280/    13E5 :                             RLXA    R7
    1280/    13E5 : =>TRUE               else
    1280/    13E5 : 12                          inc     sp
    1280/    13E6 : 42                          lda     sp
    1280/    13E7 : B7                          phi     R7
    1280/    13E8 : 42                          lda     sp
    1280/    13E9 : A7                          plo     R7
    1280/    13EA : [1280]               endif
    1281/    13EA : (MACRO)             	popm R6	;opt11.4
    1281/    13EA : =>FALSE              if MOMCPU=$1805
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 91 - 1/18/2018 14:51:20


    1281/    13EA :                             RLXA    R6
    1281/    13EA : =>TRUE               else
    1281/    13EA : 42                          lda     sp
    1281/    13EB : B6                          phi     R6
    1281/    13EC : 42                          lda     sp
    1281/    13ED : A6                          plo     R6
    1281/    13EE : [1281]               endif
    1282/    13EE : (MACRO)             	popm R1	;opt11.4
    1282/    13EE : =>FALSE              if MOMCPU=$1805
    1282/    13EE :                             RLXA    R1
    1282/    13EE : =>TRUE               else
    1282/    13EE : 42                          lda     sp
    1282/    13EF : B1                          phi     R1
    1282/    13F0 : 42                          lda     sp
    1282/    13F1 : A1                          plo     R1
    1282/    13F2 : [1282]               endif
    1283/    13F2 : (MACRO)             	popl R0	;opt11.4
    1283/    13F2 : 42                          lda     sp
    1283/    13F3 : B0                          phi     R0
    1283/    13F4 : 02                          ldn     sp
    1283/    13F5 : A0                          plo     R0
    1284/    13F6 : (MACRO)             	release 4; release room for local variables 
    1284/    13F6 : =>TRUE                      if (4<9)
    1284/    13F6 :  (MACRO-2)                      releaseS 4  ;use dec for small amounts
    1284/    13F6 :                             rept    4
    1284/    13F6 :                             inc sp
    1284/    13F6 :                             endm
    1284/    13F6 : 12                          inc sp
    1284/    13F7 : 12                          inc sp
    1284/    13F8 : 12                          inc sp
    1284/    13F9 : 12                          inc sp
    1284/    13FA : =>FALSE                     else
    1284/    13FA :                                 releaseL 4  ;use subtract for large amounts
    1284/    13FA : [1284]                      endif
    1285/    13FA : (MACRO)             	Cretn
    1285/    13FA : =>FALSE              if MOMCPU=$1805
    1285/    13FA :                             sret    6
    1285/    13FA : =>TRUE               else
    1285/    13FA : D5                          sep     RRET
    1285/    13FB : [1285]               endif
    1286/    13FB :                     
    1287/    13FB :                     ;$$function end$$ _printf
    1288/    13FB :                     ;$$function start$$ _exit
    1289/    13FB :                     _exit:		;framesize=6
    1290/    13FB : (MACRO)             	reserve 4
    1290/    13FB : =>TRUE                      if (4<9)
    1290/    13FB :  (MACRO-2)                      reserveS 4  ;use dec for small amounts
    1290/    13FB :                             rept    4
    1290/    13FB :                             dec sp
    1290/    13FB :                             endm
    1290/    13FB : 22                          dec sp
    1290/    13FC : 22                          dec sp
    1290/    13FD : 22                          dec sp
    1290/    13FE : 22                          dec sp
    1290/    13FF : =>FALSE                     else
    1290/    13FF :                                 reserveL 4  ;use subtract for large amounts
    1290/    13FF : [1290]                      endif
    1291/    13FF : (MACRO)             	st2 R12,'O',sp,(6+1); flag1 
    1291/    13FF : =>TRUE                      if      ('O'='O')
    1291/    13FF :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 92 - 1/18/2018 14:51:20


    1291/    13FF : 82                          glo     SP
    1291/    1400 : FC 07                       adi     ((6+1))#256
    1291/    1402 : AE                          plo     MEMADDR
    1291/    1403 : 92                          ghi     SP
    1291/    1404 : 7C 00                       adci    ((6+1))>>8; was/256
    1291/    1406 : BE                          phi     MEMADDR
    1291/    1407 : =>FALSE                     else
    1291/    1407 :                                     ldAD    memAddr,SP
    1291/    1407 : [1291]                      endif
    1291/    1407 : 9C                          ghi     R12
    1291/    1408 : 5E                          str     memAddr
    1291/    1409 : 1E                          inc     memAddr
    1291/    140A : 8C                          glo     R12
    1291/    140B : 5E                          str     memAddr
    1292/    140C :                     ;void exit(int code){
    1293/    140C :                     ;	printf("exit %d\n",code);
    1294/    140C : (MACRO)             	ldaD R12,L184; reg:acon
    1294/    140C : =>FALSE              if MOMCPU=$1805
    1294/    140C :                             RLDI    R12,L184
    1294/    140C : =>TRUE               else
    1294/    140C : F8 0C                       ldi     (L184)&255
    1294/    140E : AC                          plo     R12
    1294/    140F : F8 14                       ldi     (L184)>>8; was/256
    1294/    1411 : BC                          phi     R12
    1294/    1412 : [1294]               endif
    1295/    1412 : (MACRO)             	ld2 R13,'O',sp,(6+1) ;reg:INDIRI2(addr)
    1295/    1412 : =>TRUE                      if      ('O'='O')
    1295/    1412 :  (MACRO-2)                          ldAX    memAddr,SP,(6+1)
    1295/    1412 : 82                          glo     SP
    1295/    1413 : FC 07                       adi     ((6+1))#256
    1295/    1415 : AE                          plo     MEMADDR
    1295/    1416 : 92                          ghi     SP
    1295/    1417 : 7C 00                       adci    ((6+1))>>8; was/256
    1295/    1419 : BE                          phi     MEMADDR
    1295/    141A : =>FALSE                     else
    1295/    141A :                                     ldAD    memAddr,SP
    1295/    141A : [1295]                      endif
    1295/    141A : 4E                          lda     memAddr
    1295/    141B : BD                          phi     R13
    1295/    141C : 0E                          ldn     memAddr
    1295/    141D : AD                          plo     R13
    1296/    141E : (MACRO)             	Ccall _printf
    1296/    141E : =>FALSE              if MOMCPU=$1805
    1296/    141E :                             SCAL    6
    1296/    141E :                             dw      _PRINTF
    1296/    141E : =>TRUE               else
    1296/    141E : D4                          sep     RCALL
    1296/    141F : 10 F9                       dw      _PRINTF
    1296/    1421 : [1296]               endif
    1297/    1421 :                     L185:
    1298/    1421 :                     ;	while(1);
    1299/    1421 :                     L186:
    1300/    1421 : C0 14 21            	lbr L185
    1301/    1424 :                     ;}
    1302/    1424 :                     L183:
    1303/    1424 : (MACRO)             	release 4
    1303/    1424 : =>TRUE                      if (4<9)
    1303/    1424 :  (MACRO-2)                      releaseS 4  ;use dec for small amounts
    1303/    1424 :                             rept    4
    1303/    1424 :                             inc sp
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 93 - 1/18/2018 14:51:20


    1303/    1424 :                             endm
    1303/    1424 : 12                          inc sp
    1303/    1425 : 12                          inc sp
    1303/    1426 : 12                          inc sp
    1303/    1427 : 12                          inc sp
    1303/    1428 : =>FALSE                     else
    1303/    1428 :                                 releaseL 4  ;use subtract for large amounts
    1303/    1428 : [1303]                      endif
    1304/    1428 : (MACRO)             	Cretn
    1304/    1428 : =>FALSE              if MOMCPU=$1805
    1304/    1428 :                             sret    6
    1304/    1428 : =>TRUE               else
    1304/    1428 : D5                          sep     RRET
    1304/    1429 : [1304]               endif
    1305/    1429 :                     
    1306/    1429 :                     ;$$function end$$ _exit
    1307/    1429 :                     ;$$function start$$ _memcmp
    1308/    1429 :                     _memcmp:		;framesize=10
    1309/    1429 : (MACRO)             	pushr R0
    1309/    1429 : =>FALSE              if MOMCPU=$1805
    1309/    1429 :                             RSXD    R0
    1309/    1429 : =>TRUE               else
    1309/    1429 : 80                          glo     R0
    1309/    142A : 73                          stxd
    1309/    142B : 90                          ghi     R0
    1309/    142C : 73                          stxd
    1309/    142D : [1309]               endif
    1310/    142D : (MACRO)             	pushr R1
    1310/    142D : =>FALSE              if MOMCPU=$1805
    1310/    142D :                             RSXD    R1
    1310/    142D : =>TRUE               else
    1310/    142D : 81                          glo     R1
    1310/    142E : 73                          stxd
    1310/    142F : 91                          ghi     R1
    1310/    1430 : 73                          stxd
    1310/    1431 : [1310]               endif
    1311/    1431 : (MACRO)             	pushr R6
    1311/    1431 : =>FALSE              if MOMCPU=$1805
    1311/    1431 :                             RSXD    R6
    1311/    1431 : =>TRUE               else
    1311/    1431 : 86                          glo     R6
    1311/    1432 : 73                          stxd
    1311/    1433 : 96                          ghi     R6
    1311/    1434 : 73                          stxd
    1311/    1435 : [1311]               endif
    1312/    1435 : (MACRO)             	pushr R7
    1312/    1435 : =>FALSE              if MOMCPU=$1805
    1312/    1435 :                             RSXD    R7
    1312/    1435 : =>TRUE               else
    1312/    1435 : 87                          glo     R7
    1312/    1436 : 73                          stxd
    1312/    1437 : 97                          ghi     R7
    1312/    1438 : 73                          stxd
    1312/    1439 : [1312]               endif
    1313/    1439 : (MACRO)             	ld2 R7,'O',sp,(14+1) ;reg:INDIRU2(addr)
    1313/    1439 : =>TRUE                      if      ('O'='O')
    1313/    1439 :  (MACRO-2)                          ldAX    memAddr,SP,(14+1)
    1313/    1439 : 82                          glo     SP
    1313/    143A : FC 0F                       adi     ((14+1))#256
    1313/    143C : AE                          plo     MEMADDR
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 94 - 1/18/2018 14:51:20


    1313/    143D : 92                          ghi     SP
    1313/    143E : 7C 00                       adci    ((14+1))>>8; was/256
    1313/    1440 : BE                          phi     MEMADDR
    1313/    1441 : =>FALSE                     else
    1313/    1441 :                                     ldAD    memAddr,SP
    1313/    1441 : [1313]                      endif
    1313/    1441 : 4E                          lda     memAddr
    1313/    1442 : B7                          phi     R7
    1313/    1443 : 0E                          ldn     memAddr
    1313/    1444 : A7                          plo     R7
    1314/    1445 :                     ;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
    1315/    1445 :                     ;    int v = 0;
    1316/    1445 : (MACRO)             	ld2z R6
    1316/    1445 : F8 00                       ldi     0
    1316/    1447 : A6                          plo     R6
    1316/    1448 : B6                          phi     R6
    1317/    1449 :                     ;    p1 = (unsigned char *)Ptr1;
    1318/    1449 : (MACRO)             	cpy2 R1,R12 ;LOADP2(reg)
    1318/    1449 : 8C                          glo     R12
    1318/    144A : A1                          plo     R1
    1318/    144B : 9C                          ghi     R12
    1318/    144C : B1                          phi     R1
    1319/    144D :                     ;    p2 = (unsigned char *)Ptr2;
    1320/    144D : (MACRO)             	cpy2 R0,R13 ;LOADP2(reg)
    1320/    144D : 8D                          glo     R13
    1320/    144E : A0                          plo     R0
    1320/    144F : 9D                          ghi     R13
    1320/    1450 : B0                          phi     R0
    1321/    1451 : C0 14 51            	lbr L190
    1322/    1454 :                     L189:
    1323/    1454 :                     ;    while(Count-- > 0 && v == 0) {
    1324/    1454 :                     ;        v = *(p1++) - *(p2++);
    1325/    1454 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
    1325/    1454 : 81                          glo     R1
    1325/    1455 : AB                          plo     R11
    1325/    1456 : 91                          ghi     R1
    1325/    1457 : BB                          phi     R11
    1326/    1458 : (MACRO)             	incm R1,1
    1326/    1458 :                             rept    1
    1326/    1458 :                             inc     R1
    1326/    1458 :                             endm
    1326/    1458 : 11                          inc     R1
    1327/    1459 : (MACRO)             	cpy2 R10,R0 ;LOADP2(reg) ;opt1.1
    1327/    1459 : 80                          glo     R0
    1327/    145A : AA                          plo     R10
    1327/    145B : 90                          ghi     R0
    1327/    145C : BA                          phi     R10
    1328/    145D : (MACRO)             	incm R0,1
    1328/    145D :                             rept    1
    1328/    145D :                             inc     R0
    1328/    145D :                             endm
    1328/    145D : 10                          inc     R0
    1329/    145E : (MACRO)             	ldn1 R11,R11	;opt14*
    1329/    145E : 0B                          ldn     R11
    1329/    145F : AB                          plo     R11
    1330/    1460 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
    1330/    1460 : F8 00                       ldi     0
    1330/    1462 : BB                          phi     R11
    1331/    1463 : (MACRO)             	ldn1 R10,R10	;opt14*
    1331/    1463 : 0A                          ldn     R10
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 95 - 1/18/2018 14:51:20


    1331/    1464 : AA                          plo     R10
    1332/    1465 : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
    1332/    1465 : F8 00                       ldi     0
    1332/    1467 : BA                          phi     R10
    1333/    1468 : (MACRO)             	alu2 R6,R11,R10,sm,smb
    1333/    1468 : 8A                          glo     R10
    1333/    1469 : 52                          str     sp
    1333/    146A : 8B                          glo     R11
    1333/    146B : F7                          SM             ;calculate the low order byte
    1333/    146C : A6                          plo     R6
    1333/    146D : 9A                          ghi     R10
    1333/    146E : 52                          str     sp
    1333/    146F : 9B                          ghi     R11
    1333/    1470 : 77                          SMB             ;calculate the high byte
    1333/    1471 : B6                          phi     R6
    1334/    1472 :                     ;    }
    1335/    1472 :                     L190:
    1336/    1472 :                     ;    while(Count-- > 0 && v == 0) {
    1337/    1472 : (MACRO)             	cpy2 R11,R7 ;LOADU2*(reg)
    1337/    1472 : 87                          glo     R7
    1337/    1473 : AB                          plo     R11
    1337/    1474 : 97                          ghi     R7
    1337/    1475 : BB                          phi     R11
    1338/    1476 : (MACRO)             	cpy2 R7,R11	;SUBU2(reg,consm)
    1338/    1476 : 8B                          glo     R11
    1338/    1477 : A7                          plo     R7
    1338/    1478 : 9B                          ghi     R11
    1338/    1479 : B7                          phi     R7
    1339/    147A : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
    1339/    147A :                             rept    1
    1339/    147A :                             dec     R7
    1339/    147A :                             endm
    1339/    147A : 27                          dec     R7
    1340/    147B : (MACRO)             	jzU2 R11,L192; EQ 0
    1340/    147B : 8B                          glo     R11
    1340/    147C : CA 14 7C                    lbnz    +
    1340/    147F : 9B                          ghi     R11
    1340/    1480 : C2 14 80                    lbz     L192
    1340/    1483 :                     +
    1341/    1483 : (MACRO)             	jzU2 R6,L189; EQ 0
    1341/    1483 : 86                          glo     R6
    1341/    1484 : CA 14 84                    lbnz    +
    1341/    1487 : 96                          ghi     R6
    1341/    1488 : C2 14 54                    lbz     L189
    1341/    148B :                     +
    1342/    148B :                     L192:
    1343/    148B :                     ;    return v;
    1344/    148B : (MACRO)             	cpy2 R15,R6 ;LOADI2(reg)
    1344/    148B : 86                          glo     R6
    1344/    148C : AF                          plo     R15
    1344/    148D : 96                          ghi     R6
    1344/    148E : BF                          phi     R15
    1345/    148F :                     L188:
    1346/    148F : (MACRO)             	popf R7	;opt11.3
    1346/    148F : =>FALSE              if MOMCPU=$1805
    1346/    148F :                             inc     sp
    1346/    148F :                             RLXA    R7
    1346/    148F : =>TRUE               else
    1346/    148F : 12                          inc     sp
    1346/    1490 : 42                          lda     sp
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 96 - 1/18/2018 14:51:20


    1346/    1491 : B7                          phi     R7
    1346/    1492 : 42                          lda     sp
    1346/    1493 : A7                          plo     R7
    1346/    1494 : [1346]               endif
    1347/    1494 : (MACRO)             	popm R6	;opt11.4
    1347/    1494 : =>FALSE              if MOMCPU=$1805
    1347/    1494 :                             RLXA    R6
    1347/    1494 : =>TRUE               else
    1347/    1494 : 42                          lda     sp
    1347/    1495 : B6                          phi     R6
    1347/    1496 : 42                          lda     sp
    1347/    1497 : A6                          plo     R6
    1347/    1498 : [1347]               endif
    1348/    1498 : (MACRO)             	popm R1	;opt11.4
    1348/    1498 : =>FALSE              if MOMCPU=$1805
    1348/    1498 :                             RLXA    R1
    1348/    1498 : =>TRUE               else
    1348/    1498 : 42                          lda     sp
    1348/    1499 : B1                          phi     R1
    1348/    149A : 42                          lda     sp
    1348/    149B : A1                          plo     R1
    1348/    149C : [1348]               endif
    1349/    149C : (MACRO)             	popl R0	;opt11.4
    1349/    149C : 42                          lda     sp
    1349/    149D : B0                          phi     R0
    1349/    149E : 02                          ldn     sp
    1349/    149F : A0                          plo     R0
    1350/    14A0 : (MACRO)             	Cretn
    1350/    14A0 : =>FALSE              if MOMCPU=$1805
    1350/    14A0 :                             sret    6
    1350/    14A0 : =>TRUE               else
    1350/    14A0 : D5                          sep     RRET
    1350/    14A1 : [1350]               endif
    1351/    14A1 :                     
    1352/    14A1 :                     ;$$function end$$ _memcmp
    1353/    14A1 :                     ;$$function start$$ _memcpy
    1354/    14A1 :                     _memcpy:		;framesize=8
    1355/    14A1 : (MACRO)             	pushr R1
    1355/    14A1 : =>FALSE              if MOMCPU=$1805
    1355/    14A1 :                             RSXD    R1
    1355/    14A1 : =>TRUE               else
    1355/    14A1 : 81                          glo     R1
    1355/    14A2 : 73                          stxd
    1355/    14A3 : 91                          ghi     R1
    1355/    14A4 : 73                          stxd
    1355/    14A5 : [1355]               endif
    1356/    14A5 : (MACRO)             	pushr R6
    1356/    14A5 : =>FALSE              if MOMCPU=$1805
    1356/    14A5 :                             RSXD    R6
    1356/    14A5 : =>TRUE               else
    1356/    14A5 : 86                          glo     R6
    1356/    14A6 : 73                          stxd
    1356/    14A7 : 96                          ghi     R6
    1356/    14A8 : 73                          stxd
    1356/    14A9 : [1356]               endif
    1357/    14A9 : (MACRO)             	pushr R7
    1357/    14A9 : =>FALSE              if MOMCPU=$1805
    1357/    14A9 :                             RSXD    R7
    1357/    14A9 : =>TRUE               else
    1357/    14A9 : 87                          glo     R7
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 97 - 1/18/2018 14:51:20


    1357/    14AA : 73                          stxd
    1357/    14AB : 97                          ghi     R7
    1357/    14AC : 73                          stxd
    1357/    14AD : [1357]               endif
    1358/    14AD : (MACRO)             	ld2 R7,'O',sp,(12+1) ;reg:INDIRU2(addr)
    1358/    14AD : =>TRUE                      if      ('O'='O')
    1358/    14AD :  (MACRO-2)                          ldAX    memAddr,SP,(12+1)
    1358/    14AD : 82                          glo     SP
    1358/    14AE : FC 0D                       adi     ((12+1))#256
    1358/    14B0 : AE                          plo     MEMADDR
    1358/    14B1 : 92                          ghi     SP
    1358/    14B2 : 7C 00                       adci    ((12+1))>>8; was/256
    1358/    14B4 : BE                          phi     MEMADDR
    1358/    14B5 : =>FALSE                     else
    1358/    14B5 :                                     ldAD    memAddr,SP
    1358/    14B5 : [1358]                      endif
    1358/    14B5 : 4E                          lda     memAddr
    1358/    14B6 : B7                          phi     R7
    1358/    14B7 : 0E                          ldn     memAddr
    1358/    14B8 : A7                          plo     R7
    1359/    14B9 :                     ;void* memcpy(void* dest, const void* src, unsigned int count) {
    1360/    14B9 :                     ;        char* dst8 = (char*)dest;
    1361/    14B9 : (MACRO)             	cpy2 R6,R12 ;LOADP2(reg)
    1361/    14B9 : 8C                          glo     R12
    1361/    14BA : A6                          plo     R6
    1361/    14BB : 9C                          ghi     R12
    1361/    14BC : B6                          phi     R6
    1362/    14BD :                     ;        char* src8 = (char*)src;
    1363/    14BD : (MACRO)             	cpy2 R1,R13 ;LOADP2(reg)
    1363/    14BD : 8D                          glo     R13
    1363/    14BE : A1                          plo     R1
    1363/    14BF : 9D                          ghi     R13
    1363/    14C0 : B1                          phi     R1
    1364/    14C1 : C0 14 C1            	lbr L195
    1365/    14C4 :                     L194:
    1366/    14C4 :                     ;        while (count--) {
    1367/    14C4 :                     ;            *dst8++ = *src8++;
    1368/    14C4 : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
    1368/    14C4 : 86                          glo     R6
    1368/    14C5 : AB                          plo     R11
    1368/    14C6 : 96                          ghi     R6
    1368/    14C7 : BB                          phi     R11
    1369/    14C8 : (MACRO)             	incm R6,1
    1369/    14C8 :                             rept    1
    1369/    14C8 :                             inc     R6
    1369/    14C8 :                             endm
    1369/    14C8 : 16                          inc     R6
    1370/    14C9 : (MACRO)             	cpy2 R10,R1 ;LOADP2(reg) ;opt1.1
    1370/    14C9 : 81                          glo     R1
    1370/    14CA : AA                          plo     R10
    1370/    14CB : 91                          ghi     R1
    1370/    14CC : BA                          phi     R10
    1371/    14CD : (MACRO)             	incm R1,1
    1371/    14CD :                             rept    1
    1371/    14CD :                             inc     R1
    1371/    14CD :                             endm
    1371/    14CD : 11                          inc     R1
    1372/    14CE : (MACRO)             	ldn1 R10,R10;reg:  INDIRU1(indaddr)
    1372/    14CE : 0A                          ldn     R10
    1372/    14CF : AA                          plo     R10
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 98 - 1/18/2018 14:51:20


    1373/    14D0 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
    1373/    14D0 : 8A                          glo     R10
    1373/    14D1 : 5B                          str     R11
    1374/    14D2 :                     ;        }
    1375/    14D2 :                     L195:
    1376/    14D2 :                     ;        while (count--) {
    1377/    14D2 : (MACRO)             	cpy2 R11,R7 ;LOADU2*(reg)
    1377/    14D2 : 87                          glo     R7
    1377/    14D3 : AB                          plo     R11
    1377/    14D4 : 97                          ghi     R7
    1377/    14D5 : BB                          phi     R11
    1378/    14D6 : (MACRO)             	cpy2 R7,R11	;SUBU2(reg,consm)
    1378/    14D6 : 8B                          glo     R11
    1378/    14D7 : A7                          plo     R7
    1378/    14D8 : 9B                          ghi     R11
    1378/    14D9 : B7                          phi     R7
    1379/    14DA : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
    1379/    14DA :                             rept    1
    1379/    14DA :                             dec     R7
    1379/    14DA :                             endm
    1379/    14DA : 27                          dec     R7
    1380/    14DB : (MACRO)             	jnzU2 R11,L194; NE 0 
    1380/    14DB : 8B                          glo     R11
    1380/    14DC : CA 14 C4                    lbnz    L194
    1380/    14DF : 9B                          ghi     R11
    1380/    14E0 : CA 14 C4                    lbnz    L194
    1381/    14E3 :                     ;        return dest;
    1382/    14E3 : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
    1382/    14E3 : 8C                          glo     R12
    1382/    14E4 : AF                          plo     R15
    1382/    14E5 : 9C                          ghi     R12
    1382/    14E6 : BF                          phi     R15
    1383/    14E7 :                     L193:
    1384/    14E7 : (MACRO)             	popf R7	;opt11.3
    1384/    14E7 : =>FALSE              if MOMCPU=$1805
    1384/    14E7 :                             inc     sp
    1384/    14E7 :                             RLXA    R7
    1384/    14E7 : =>TRUE               else
    1384/    14E7 : 12                          inc     sp
    1384/    14E8 : 42                          lda     sp
    1384/    14E9 : B7                          phi     R7
    1384/    14EA : 42                          lda     sp
    1384/    14EB : A7                          plo     R7
    1384/    14EC : [1384]               endif
    1385/    14EC : (MACRO)             	popm R6	;opt11.4
    1385/    14EC : =>FALSE              if MOMCPU=$1805
    1385/    14EC :                             RLXA    R6
    1385/    14EC : =>TRUE               else
    1385/    14EC : 42                          lda     sp
    1385/    14ED : B6                          phi     R6
    1385/    14EE : 42                          lda     sp
    1385/    14EF : A6                          plo     R6
    1385/    14F0 : [1385]               endif
    1386/    14F0 : (MACRO)             	popl R1	;opt11.4
    1386/    14F0 : 42                          lda     sp
    1386/    14F1 : B1                          phi     R1
    1386/    14F2 : 02                          ldn     sp
    1386/    14F3 : A1                          plo     R1
    1387/    14F4 : (MACRO)             	Cretn
    1387/    14F4 : =>FALSE              if MOMCPU=$1805
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 99 - 1/18/2018 14:51:20


    1387/    14F4 :                             sret    6
    1387/    14F4 : =>TRUE               else
    1387/    14F4 : D5                          sep     RRET
    1387/    14F5 : [1387]               endif
    1388/    14F5 :                     
    1389/    14F5 :                     ;$$function end$$ _memcpy
    1390/    14F5 :                     ;$$function start$$ _memset
    1391/    14F5 :                     _memset:		;framesize=6
    1392/    14F5 : (MACRO)             	pushr R6
    1392/    14F5 : =>FALSE              if MOMCPU=$1805
    1392/    14F5 :                             RSXD    R6
    1392/    14F5 : =>TRUE               else
    1392/    14F5 : 86                          glo     R6
    1392/    14F6 : 73                          stxd
    1392/    14F7 : 96                          ghi     R6
    1392/    14F8 : 73                          stxd
    1392/    14F9 : [1392]               endif
    1393/    14F9 : (MACRO)             	pushr R7
    1393/    14F9 : =>FALSE              if MOMCPU=$1805
    1393/    14F9 :                             RSXD    R7
    1393/    14F9 : =>TRUE               else
    1393/    14F9 : 87                          glo     R7
    1393/    14FA : 73                          stxd
    1393/    14FB : 97                          ghi     R7
    1393/    14FC : 73                          stxd
    1393/    14FD : [1393]               endif
    1394/    14FD : (MACRO)             	ld2 R7,'O',sp,(10+1) ;reg:INDIRU2(addr)
    1394/    14FD : =>TRUE                      if      ('O'='O')
    1394/    14FD :  (MACRO-2)                          ldAX    memAddr,SP,(10+1)
    1394/    14FD : 82                          glo     SP
    1394/    14FE : FC 0B                       adi     ((10+1))#256
    1394/    1500 : AE                          plo     MEMADDR
    1394/    1501 : 92                          ghi     SP
    1394/    1502 : 7C 00                       adci    ((10+1))>>8; was/256
    1394/    1504 : BE                          phi     MEMADDR
    1394/    1505 : =>FALSE                     else
    1394/    1505 :                                     ldAD    memAddr,SP
    1394/    1505 : [1394]                      endif
    1394/    1505 : 4E                          lda     memAddr
    1394/    1506 : B7                          phi     R7
    1394/    1507 : 0E                          ldn     memAddr
    1394/    1508 : A7                          plo     R7
    1395/    1509 :                     ;{
    1396/    1509 :                     ;    unsigned char* p=s;
    1397/    1509 : (MACRO)             	cpy2 R6,R12 ;LOADP2(reg)
    1397/    1509 : 8C                          glo     R12
    1397/    150A : A6                          plo     R6
    1397/    150B : 9C                          ghi     R12
    1397/    150C : B6                          phi     R6
    1398/    150D : C0 15 0D            	lbr L199
    1399/    1510 :                     L198:
    1400/    1510 :                     ;        *p++ = (unsigned char)c;
    1401/    1510 : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
    1401/    1510 : 86                          glo     R6
    1401/    1511 : AB                          plo     R11
    1401/    1512 : 96                          ghi     R6
    1401/    1513 : BB                          phi     R11
    1402/    1514 : (MACRO)             	incm R6,1
    1402/    1514 :                             rept    1
    1402/    1514 :                             inc     R6
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 100 - 1/18/2018 14:51:20


    1402/    1514 :                             endm
    1402/    1514 : 16                          inc     R6
    1403/    1515 : (MACRO)             	cpy2 R10,R13 ;LOADU2*(reg)
    1403/    1515 : 8D                          glo     R13
    1403/    1516 : AA                          plo     R10
    1403/    1517 : 9D                          ghi     R13
    1403/    1518 : BA                          phi     R10
    1404/    1519 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
    1404/    1519 : 8A                          glo     R10
    1404/    151A : 5B                          str     R11
    1405/    151B :                     L199:
    1406/    151B :                     ;    while(n--)
    1407/    151B : (MACRO)             	cpy2 R11,R7 ;LOADU2*(reg)
    1407/    151B : 87                          glo     R7
    1407/    151C : AB                          plo     R11
    1407/    151D : 97                          ghi     R7
    1407/    151E : BB                          phi     R11
    1408/    151F : (MACRO)             	cpy2 R7,R11	;SUBU2(reg,consm)
    1408/    151F : 8B                          glo     R11
    1408/    1520 : A7                          plo     R7
    1408/    1521 : 9B                          ghi     R11
    1408/    1522 : B7                          phi     R7
    1409/    1523 : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
    1409/    1523 :                             rept    1
    1409/    1523 :                             dec     R7
    1409/    1523 :                             endm
    1409/    1523 : 27                          dec     R7
    1410/    1524 : (MACRO)             	jnzU2 R11,L198; NE 0 
    1410/    1524 : 8B                          glo     R11
    1410/    1525 : CA 15 10                    lbnz    L198
    1410/    1528 : 9B                          ghi     R11
    1410/    1529 : CA 15 10                    lbnz    L198
    1411/    152C :                     ;    return s;
    1412/    152C : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
    1412/    152C : 8C                          glo     R12
    1412/    152D : AF                          plo     R15
    1412/    152E : 9C                          ghi     R12
    1412/    152F : BF                          phi     R15
    1413/    1530 :                     L197:
    1414/    1530 : (MACRO)             	popf R7	;opt11.3
    1414/    1530 : =>FALSE              if MOMCPU=$1805
    1414/    1530 :                             inc     sp
    1414/    1530 :                             RLXA    R7
    1414/    1530 : =>TRUE               else
    1414/    1530 : 12                          inc     sp
    1414/    1531 : 42                          lda     sp
    1414/    1532 : B7                          phi     R7
    1414/    1533 : 42                          lda     sp
    1414/    1534 : A7                          plo     R7
    1414/    1535 : [1414]               endif
    1415/    1535 : (MACRO)             	popl R6	;opt11.3
    1415/    1535 : 42                          lda     sp
    1415/    1536 : B6                          phi     R6
    1415/    1537 : 02                          ldn     sp
    1415/    1538 : A6                          plo     R6
    1416/    1539 : (MACRO)             	Cretn
    1416/    1539 : =>FALSE              if MOMCPU=$1805
    1416/    1539 :                             sret    6
    1416/    1539 : =>TRUE               else
    1416/    1539 : D5                          sep     RRET
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 101 - 1/18/2018 14:51:20


    1416/    153A : [1416]               endif
    1417/    153A :                     
    1418/    153A :                     ;$$function end$$ _memset
    1419/    153A :                     ;$$function start$$ _nstdlibincluder
    1420/    153A :                     _nstdlibincluder:		;framesize=2
    1421/    153A :                     ;void nstdlibincluder(){
    1422/    153A :                     ;	asm("\tinclude nstdlib.inc\n"); //strcpy, strcmp
    1423/    153A :                     	include nstdlib.inc
(1)    1/    153A :                     ;nstdlib.inc includes assembly versions of nstdlib routines strcpy, strcmp
(1)    2/    153A :                     ;Oct 1 first test seems ok
(1)    3/    153A :                     ;char * strcpy(char * to, const char *from)
(1)    4/    153A :                     	align 64
(1)    5/    1540 :                     _strcpy:
(1)    6/    1540 :                     ;char *save = to; (to is R12, from is R13)
(1)    7/    1540 : 8C                  	glo R12	
(1)    8/    1541 : AF                  	plo R15
(1)    9/    1542 : 9C                  	ghi R12
(1)   10/    1543 : BF                  	phi R15
(1)   11/    1544 :                     ;for (; (*to = *from) != 0; ++from, ++to);
(1)   12/    1544 : 4D                  __strcpy: lda R13
(1)   13/    1545 : 5C                  	str R12
(1)   14/    1546 : 1C                  	inc R12
(1)   15/    1547 : 3A 44               	bnz __strcpy
(1)   16/    1549 :                     ;return(save);
(1)   17/    1549 : (MACRO)             	cretn
(1)   17/    1549 : =>FALSE              if MOMCPU=$1805
(1)   17/    1549 :                             sret    6
(1)   17/    1549 : =>TRUE               else
(1)   17/    1549 : D5                          sep     RRET
(1)   17/    154A : [17]                 endif
(1)   18/    154A :                     ;}
(1)   19/    154A :                     
(1)   20/    154A :                     
(1)   21/    154A :                     ;int strcmp(const char *s1, const char *s2){  s1 will be R12, s2 R13
(1)   22/    154A :                     _strcmp:	;entry point from C program
(1)   23/    154A :                     ;  int ret = 0;
(1)   24/    154A : (MACRO)             	ld2z	R15	;ret is R15
(1)   24/    154A : F8 00                       ldi     0
(1)   24/    154C : AF                          plo     R15
(1)   24/    154D : BF                          phi     R15
(1)   25/    154E :                     ;  while (!(ret = *(unsigned char *) s1 - *(unsigned char *) s2) && *s2) ++s1, ++s2;
(1)   26/    154E : 22                  	dec	sp	;make a work area
(1)   27/    154F :                     __strcmplp:
(1)   28/    154F : 4D                  	lda	R13	;get string 2 character
(1)   29/    1550 : 52                  	str	sp	;prep for compare
(1)   30/    1551 : 4C                  	lda	R12	;get string 1 character
(1)   31/    1552 : F7                  	sm		;subtract string 2 char from string 1
(1)   32/    1553 : 3A 53               	bnz	__strcmpne ;strings not equal quit
(1)   33/    1555 :                     	
(1)   34/    1555 : 02                  	ldn	sp	;check string 2 character
(1)   35/    1556 : 3A 4F               	bnz	__strcmplp ;back for more if not done
(1)   36/    1558 : 12                  	inc	sp	;release the work area
(1)   37/    1559 : (MACRO)             	cretn		;back to caler with 0 in R15
(1)   37/    1559 : =>FALSE              if MOMCPU=$1805
(1)   37/    1559 :                             sret    6
(1)   37/    1559 : =>TRUE               else
(1)   37/    1559 : D5                          sep     RRET
(1)   37/    155A : [37]                 endif
(1)   38/    155A :                     	
(1)   39/    155A :                     __strcmpne:	;here I know they're not equal
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(nstdlib.inc) - page 102 - 1/18/2018 14:51:20


(1)   40/    155A : 12                  	inc	sp		;release the work area
(1)   41/    155B : 33 5B               	bdf	__strcmpgt	;string1>string2
(1)   42/    155D : 2F                  	dec	R15		;string 1<string 2, return -1
(1)   43/    155E : (MACRO)             	cretn
(1)   43/    155E : =>FALSE              if MOMCPU=$1805
(1)   43/    155E :                             sret    6
(1)   43/    155E : =>TRUE               else
(1)   43/    155E : D5                          sep     RRET
(1)   43/    155F : [43]                 endif
(1)   44/    155F :                     __strcmpgt:
(1)   45/    155F : 1F                  	inc	R15		;string1>string2, return 1
(1)   46/    1560 : (MACRO)             	cretn
(1)   46/    1560 : =>FALSE              if MOMCPU=$1805
(1)   46/    1560 :                             sret    6
(1)   46/    1560 : =>TRUE               else
(1)   46/    1560 : D5                          sep     RRET
(1)   46/    1561 : [46]                 endif
(1)   47/    1561 :                     
    1424/    1561 :                     ;}
    1425/    1561 :                     L201:
    1426/    1561 : (MACRO)             	Cretn
    1426/    1561 : =>FALSE              if MOMCPU=$1805
    1426/    1561 :                             sret    6
    1426/    1561 : =>TRUE               else
    1426/    1561 : D5                          sep     RRET
    1426/    1562 : [1426]               endif
    1427/    1562 :                     
    1428/    1562 :                     ;$$function end$$ _nstdlibincluder
    1429/    1562 :                     ;$$function start$$ _saveregs
    1430/    1562 :                     _saveregs:		;framesize=2
    1431/    1562 :                     ;void saveregs(){asm("SAVEREGS: EQU 1\n");}
    1432/    1562 : =1H                 SAVEREGS: EQU 1
    1433/    1562 :                     L203:
    1434/    1562 : (MACRO)             	Cretn
    1434/    1562 : =>FALSE              if MOMCPU=$1805
    1434/    1562 :                             sret    6
    1434/    1562 : =>TRUE               else
    1434/    1562 : D5                          sep     RRET
    1434/    1563 : [1434]               endif
    1435/    1563 :                     
    1436/    1563 :                     ;$$function end$$ _saveregs
    1437/    1563 :                     L184:
    1438/    1563 : 65                  	db 101
    1439/    1564 : 78                  	db 120
    1440/    1565 : 69                  	db 105
    1441/    1566 : 74                  	db 116
    1442/    1567 : 20                  	db 32
    1443/    1568 : 25                  	db 37
    1444/    1569 : 64                  	db 100
    1445/    156A : 0A                  	db 10
    1446/    156B : 00                  	db 0
    1447/    156C :                     	align 4
    1448/    156C :                     L119:
    1449/    156C : 00 00 80 BF         	dd 0xbf800000
    1450/    1570 :                     	align 4
    1451/    1570 :                     L118:
    1452/    1570 : 00 00 00 00         	dd 0x0
    1453/    1574 :                     L76:
    1454/    1574 : 25                  	db 37
    1455/    1575 : 63                  	db 99
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 103 - 1/18/2018 14:51:20


    1456/    1576 : 2F                  	db 47
    1457/    1577 : 25                  	db 37
    1458/    1578 : 63                  	db 99
    1459/    1579 : 78                  	db 120
    1460/    157A : 20                  	db 32
    1461/    157B : 75                  	db 117
    1462/    157C : 6E                  	db 110
    1463/    157D : 72                  	db 114
    1464/    157E : 65                  	db 101
    1465/    157F : 63                  	db 99
    1466/    1580 : 6F                  	db 111
    1467/    1581 : 67                  	db 103
    1468/    1582 : 6E                  	db 110
    1469/    1583 : 69                  	db 105
    1470/    1584 : 7A                  	db 122
    1471/    1585 : 65                  	db 101
    1472/    1586 : 64                  	db 100
    1473/    1587 : 0A                  	db 10
    1474/    1588 : 00                  	db 0
    1475/    1589 :                     L75:
    1476/    1589 : 2D                  	db 45
    1477/    158A : 0A                  	db 10
    1478/    158B : 00                  	db 0
    1479/    158C :                     L73:
    1480/    158C : 2B                  	db 43
    1481/    158D : 0A                  	db 10
    1482/    158E : 00                  	db 0
    1483/    158F :                     L71:
    1484/    158F : 72                  	db 114
    1485/    1590 : 0A                  	db 10
    1486/    1591 : 00                  	db 0
    1487/    1592 :                     L69:
    1488/    1592 : 67                  	db 103
    1489/    1593 : 0A                  	db 10
    1490/    1594 : 00                  	db 0
    1491/    1595 :                     L67:
    1492/    1595 : 21                  	db 33
    1493/    1596 : 0A                  	db 10
    1494/    1597 : 00                  	db 0
    1495/    1598 :                     L65:
    1496/    1598 : 3F                  	db 63
    1497/    1599 : 0A                  	db 10
    1498/    159A : 00                  	db 0
    1499/    159B :                     L63:
    1500/    159B : 2D                  	db 45
    1501/    159C : 3E                  	db 62
    1502/    159D : 25                  	db 37
    1503/    159E : 78                  	db 120
    1504/    159F : 0A                  	db 10
    1505/    15A0 : 00                  	db 0
    1506/    15A1 :                     L61:
    1507/    15A1 : 49                  	db 73
    1508/    15A2 : 6E                  	db 110
    1509/    15A3 : 74                  	db 116
    1510/    15A4 : 65                  	db 101
    1511/    15A5 : 72                  	db 114
    1512/    15A6 : 72                  	db 114
    1513/    15A7 : 75                  	db 117
    1514/    15A8 : 70                  	db 112
    1515/    15A9 : 74                  	db 116
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 104 - 1/18/2018 14:51:20


    1516/    15AA : 20                  	db 32
    1517/    15AB : 2D                  	db 45
    1518/    15AC : 20                  	db 32
    1519/    15AD : 6E                  	db 110
    1520/    15AE : 6F                  	db 111
    1521/    15AF : 20                  	db 32
    1522/    15B0 : 74                  	db 116
    1523/    15B1 : 72                  	db 114
    1524/    15B2 : 61                  	db 97
    1525/    15B3 : 6E                  	db 110
    1526/    15B4 : 73                  	db 115
    1527/    15B5 : 66                  	db 102
    1528/    15B6 : 65                  	db 101
    1529/    15B7 : 72                  	db 114
    1530/    15B8 : 0A                  	db 10
    1531/    15B9 : 00                  	db 0
    1532/    15BA :                     L60:
    1533/    15BA : 54                  	db 84
    1534/    15BB : 69                  	db 105
    1535/    15BC : 6D                  	db 109
    1536/    15BD : 65                  	db 101
    1537/    15BE : 6F                  	db 111
    1538/    15BF : 75                  	db 117
    1539/    15C0 : 74                  	db 116
    1540/    15C1 : 20                  	db 32
    1541/    15C2 : 2D                  	db 45
    1542/    15C3 : 20                  	db 32
    1543/    15C4 : 6E                  	db 110
    1544/    15C5 : 6F                  	db 111
    1545/    15C6 : 20                  	db 32
    1546/    15C7 : 74                  	db 116
    1547/    15C8 : 72                  	db 114
    1548/    15C9 : 61                  	db 97
    1549/    15CA : 6E                  	db 110
    1550/    15CB : 73                  	db 115
    1551/    15CC : 66                  	db 102
    1552/    15CD : 65                  	db 101
    1553/    15CE : 72                  	db 114
    1554/    15CF : 0A                  	db 10
    1555/    15D0 : 00                  	db 0
    1556/    15D1 :                     L55:
    1557/    15D1 : 58                  	db 88
    1558/    15D2 : 52                  	db 82
    1559/    15D3 : 20                  	db 32
    1560/    15D4 : 72                  	db 114
    1561/    15D5 : 65                  	db 101
    1562/    15D6 : 74                  	db 116
    1563/    15D7 : 75                  	db 117
    1564/    15D8 : 72                  	db 114
    1565/    15D9 : 6E                  	db 110
    1566/    15DA : 73                  	db 115
    1567/    15DB : 20                  	db 32
    1568/    15DC : 25                  	db 37
    1569/    15DD : 78                  	db 120
    1570/    15DE : 0A                  	db 10
    1571/    15DF : 00                  	db 0
    1572/    15E0 :                     L54:
    1573/    15E0 : 0A                  	db 10
    1574/    15E1 : 43                  	db 67
    1575/    15E2 : 61                  	db 97
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 105 - 1/18/2018 14:51:20


    1576/    15E3 : 6C                  	db 108
    1577/    15E4 : 6C                  	db 108
    1578/    15E5 : 69                  	db 105
    1579/    15E6 : 6E                  	db 110
    1580/    15E7 : 67                  	db 103
    1581/    15E8 : 20                  	db 32
    1582/    15E9 : 58                  	db 88
    1583/    15EA : 52                  	db 82
    1584/    15EB : 20                  	db 32
    1585/    15EC : 69                  	db 105
    1586/    15ED : 6E                  	db 110
    1587/    15EE : 20                  	db 32
    1588/    15EF : 32                  	db 50
    1589/    15F0 : 20                  	db 32
    1590/    15F1 : 73                  	db 115
    1591/    15F2 : 65                  	db 101
    1592/    15F3 : 63                  	db 99
    1593/    15F4 : 0A                  	db 10
    1594/    15F5 : 00                  	db 0
    1595/    15F6 :                     L49:
    1596/    15F6 : 25                  	db 37
    1597/    15F7 : 63                  	db 99
    1598/    15F8 : 00                  	db 0
    1599/    15F9 :                     L45:
    1600/    15F9 : 3E                  	db 62
    1601/    15FA : 20                  	db 32
    1602/    15FB : 00                  	db 0
    1603/    15FC :                     L41:
    1604/    15FC : 0A                  	db 10
    1605/    15FD : 53                  	db 83
    1606/    15FE : 65                  	db 101
    1607/    15FF : 72                  	db 114
    1608/    1600 : 69                  	db 105
    1609/    1601 : 61                  	db 97
    1610/    1602 : 6C                  	db 108
    1611/    1603 : 20                  	db 32
    1612/    1604 : 4D                  	db 77
    1613/    1605 : 6F                  	db 111
    1614/    1606 : 6E                  	db 110
    1615/    1607 : 69                  	db 105
    1616/    1608 : 74                  	db 116
    1617/    1609 : 6F                  	db 111
    1618/    160A : 72                  	db 114
    1619/    160B : 20                  	db 32
    1620/    160C : 48                  	db 72
    1621/    160D : 65                  	db 101
    1622/    160E : 72                  	db 114
    1623/    160F : 65                  	db 101
    1624/    1610 : 20                  	db 32
    1625/    1611 : 2D                  	db 45
    1626/    1612 : 20                  	db 32
    1627/    1613 : 43                  	db 67
    1628/    1614 : 4F                  	db 79
    1629/    1615 : 44                  	db 68
    1630/    1616 : 45                  	db 69
    1631/    1617 : 41                  	db 65
    1632/    1618 : 44                  	db 68
    1633/    1619 : 44                  	db 68
    1634/    161A : 52                  	db 82
    1635/    161B : 20                  	db 32
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 106 - 1/18/2018 14:51:20


    1636/    161C : 69                  	db 105
    1637/    161D : 73                  	db 115
    1638/    161E : 20                  	db 32
    1639/    161F : 25                  	db 37
    1640/    1620 : 78                  	db 120
    1641/    1621 : 2E                  	db 46
    1642/    1622 : 20                  	db 32
    1643/    1623 : 42                  	db 66
    1644/    1624 : 61                  	db 97
    1645/    1625 : 75                  	db 117
    1646/    1626 : 64                  	db 100
    1647/    1627 : 72                  	db 114
    1648/    1628 : 61                  	db 97
    1649/    1629 : 74                  	db 116
    1650/    162A : 65                  	db 101
    1651/    162B : 20                  	db 32
    1652/    162C : 39                  	db 57
    1653/    162D : 36                  	db 54
    1654/    162E : 30                  	db 48
    1655/    162F : 30                  	db 48
    1656/    1630 : 0A                  	db 10
    1657/    1631 : 00                  	db 0
    1658/    1632 :                     L38:
    1659/    1632 : 49                  	db 73
    1660/    1633 : 6E                  	db 110
    1661/    1634 : 74                  	db 116
    1662/    1635 : 65                  	db 101
    1663/    1636 : 72                  	db 114
    1664/    1637 : 72                  	db 114
    1665/    1638 : 75                  	db 117
    1666/    1639 : 70                  	db 112
    1667/    163A : 74                  	db 116
    1668/    163B : 20                  	db 32
    1669/    163C : 2D                  	db 45
    1670/    163D : 20                  	db 32
    1671/    163E : 73                  	db 115
    1672/    163F : 74                  	db 116
    1673/    1640 : 61                  	db 97
    1674/    1641 : 72                  	db 114
    1675/    1642 : 74                  	db 116
    1676/    1643 : 69                  	db 105
    1677/    1644 : 6E                  	db 110
    1678/    1645 : 67                  	db 103
    1679/    1646 : 20                  	db 32
    1680/    1647 : 6D                  	db 109
    1681/    1648 : 6F                  	db 111
    1682/    1649 : 6E                  	db 110
    1683/    164A : 69                  	db 105
    1684/    164B : 74                  	db 116
    1685/    164C : 6F                  	db 111
    1686/    164D : 72                  	db 114
    1687/    164E : 0A                  	db 10
    1688/    164F : 00                  	db 0
    1689/    1650 :                     L19:
    1690/    1650 : 25                  	db 37
    1691/    1651 : 78                  	db 120
    1692/    1652 : 20                  	db 32
    1693/    1653 : 00                  	db 0
    1694/    1654 :                     L18:
    1695/    1654 : 0A                  	db 10
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 107 - 1/18/2018 14:51:20


    1696/    1655 : 52                  	db 82
    1697/    1656 : 25                  	db 37
    1698/    1657 : 63                  	db 99
    1699/    1658 : 78                  	db 120
    1700/    1659 : 20                  	db 32
    1701/    165A : 00                  	db 0
    1702/    165B :                     L10:
    1703/    165B : 0A                  	db 10
    1704/    165C : 00                  	db 0
    1705/    165D :                     L9:
    1706/    165D : 25                  	db 37
    1707/    165E : 63                  	db 99
    1708/    165F : 78                  	db 120
    1709/    1660 : 20                  	db 32
    1710/    1661 : 00                  	db 0
    1711/    1662 :                     L8:
    1712/    1662 : 0A                  	db 10
    1713/    1663 : 25                  	db 37
    1714/    1664 : 78                  	db 120
    1715/    1665 : 20                  	db 32
    1716/    1666 : 00                  	db 0
    1717/    1667 :                     	include lcc1802epiloNW.inc
(1)    1/    1667 :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/    1667 :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/    1667 :                     ;this is the version published with the lcc1802121229 release
(1)    4/    1667 :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/    1667 :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/    1667 :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/    1667 :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/    1667 :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/    1667 :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/    1667 :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/    1667 :                     ;feb 27 changed stack to start at 7fff
(1)   12/    1667 :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/    1667 :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/    1667 :                     ;april 4 adding digit count argument to dubdabx
(1)   15/    1667 :                     ;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
(1)   16/    1667 :                     ;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
(1)   17/    1667 :                     ;16-09-20 allow stack relocation 
(1)   18/    1667 :                     ;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
(1)   19/    1667 :                     ;17-03-07 adjusting stack offset for 1805/6 stack discipline
(1)   20/    1667 :                     ;17-03-13 protecting work areas in divi2,divi4 routines from 1806 SCAL
(1)   21/    1667 :                     ;17-03-15 onems compensates for reduced subroutine overhead in 1806
(1)   22/    1667 :                     ;17-04-09 don't include call/return for 1806
(1)   23/    1667 :                     ;17-10-17 SCRT routines changed to clean stack model i.e. push is stxd stxd, pop is inc lda inc ldn
(1)   24/    1667 :                     ;17-10-19 using CPUSPEED instead of LCC1802CPUSPEED, also STACKLOC instead of LCCSTACKLOC
(1)   25/    1667 :                     ;17-10-23 extending work area protection from 10-13 above for 1802 as well as 1805
(1)   26/    1667 :                     ;17-11-25 conditional include for register saves
(1)   27/    1667 : =EH                 rwork	equ	memAddr	;work register
(1)   28/    1667 :                     lcc1802init:
(1)   29/    1667 : =>DEFINED             IFDEF SAVEREGS
(1)   30/    1667 :                         include "saveregs.inc"
(2)    1/    1667 :                     ;
(2)    2/    1667 :                     ; SAVE REGISTERS:  SAVES A COPY OF ALL CPU REGISTERS & I/O BITS
(2)    3/    1667 :                     ;	IN RAM. assumes P=R0.	SAVES
(2)    4/    1667 :                     ;	ALL REGISTERS CORRECTLY EXCEPT R0 and R14.
(2)    5/    1667 :                     ;
(2)    6/    1667 : =>DEFINED             IFNDEF  STACKLOC
(2)    7/    1667 :                     	ldad 	R14,0x7F1F	; save registers at bottom of top low memory page
(2)    8/    1667 : =>TRUE                ELSE
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(saveregs.inc) - page 108 - 1/18/2018 14:51:20


(2)    9/    1667 : F8 FF                 	ldi	STACKLOC>>8
(2)   10/    1669 : BE                    	phi	R14
(2)   11/    166A : F8 1F                 	ldi	0x1f
(2)   12/    166C : AE                    	plo	R14
(2)   13/    166D : [6]                   ENDIF
(2)   14/    166D : EE                  	SEX	R14
(2)   15/    166E :                     ;
(2)   16/    166E : 8F                  	GLO	R15		; SAVE REGISTERS R0-RF IN RAM
(2)   17/    166F : 73                  	STXD
(2)   18/    1670 : 9F                  	GHI	R15		; RF 1ST, R0 LAST,
(2)   19/    1671 : 73                  	STXD			; WITH HI BYTE IN LOWER ADDRESS
(2)   20/    1672 : 8E                  	GLO	R14
(2)   21/    1673 : 73                  	STXD
(2)   22/    1674 : 9E                  	GHI	R14
(2)   23/    1675 : 73                  	STXD			; THE REGISTERS BEING USED FOR PROGRAM
(2)   24/    1676 : 8D                  	GLO	R13		; COUNTER AND RAM POINTER ARE CHANGING
(2)   25/    1677 : 73                  	STXD			; DURING EXECUTION, SO THEIR STORED VALUES
(2)   26/    1678 : 9D                  	GHI	R13		; WILL BE FIXED LATER.
(2)   27/    1679 : 73                  	STXD
(2)   28/    167A : 8C                  	GLO	R12
(2)   29/    167B : 73                  	STXD
(2)   30/    167C : 9C                  	GHI	R12
(2)   31/    167D : 73                  	STXD
(2)   32/    167E : 8B                  	GLO	R11
(2)   33/    167F : 73                  	STXD
(2)   34/    1680 : 9B                  	GHI	R11
(2)   35/    1681 : 73                  	STXD
(2)   36/    1682 : 8A                  	GLO	R10
(2)   37/    1683 : 73                  	STXD
(2)   38/    1684 : 9A                  	GHI	R10
(2)   39/    1685 : 73                  	STXD
(2)   40/    1686 : 89                  	GLO	R9
(2)   41/    1687 : 73                  	STXD
(2)   42/    1688 : 99                  	GHI	R9
(2)   43/    1689 : 73                  	STXD
(2)   44/    168A : 88                  	GLO	R8
(2)   45/    168B : 73                  	STXD
(2)   46/    168C : 98                  	GHI	R8
(2)   47/    168D : 73                  	STXD
(2)   48/    168E : 87                  	GLO	R7
(2)   49/    168F : 73                  	STXD
(2)   50/    1690 : 97                  	GHI	R7
(2)   51/    1691 : 73                  	STXD
(2)   52/    1692 : 86                  	GLO	R6
(2)   53/    1693 : 73                  	STXD
(2)   54/    1694 : 96                  	GHI	R6
(2)   55/    1695 : 73                  	STXD
(2)   56/    1696 : 85                  	GLO	R5
(2)   57/    1697 : 73                  	STXD
(2)   58/    1698 : 95                  	GHI	R5
(2)   59/    1699 : 73                  	STXD
(2)   60/    169A : 84                  	GLO	R4
(2)   61/    169B : 73                  	STXD
(2)   62/    169C : 94                  	GHI	R4
(2)   63/    169D : 73                  	STXD
(2)   64/    169E : 83                  	GLO	R3
(2)   65/    169F : 73                  	STXD
(2)   66/    16A0 : 93                  	GHI	R3
(2)   67/    16A1 : 73                  	STXD
(2)   68/    16A2 : 82                  	GLO	R2
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(saveregs.inc) - page 109 - 1/18/2018 14:51:20


(2)   69/    16A3 : 73                  	STXD
(2)   70/    16A4 : 92                  	GHI	R2
(2)   71/    16A5 : 73                  	STXD
(2)   72/    16A6 : 81                  	GLO	R1
(2)   73/    16A7 : 73                  	STXD
(2)   74/    16A8 : 91                  	GHI	R1
(2)   75/    16A9 : 73                  	STXD
(2)   76/    16AA : 80                  	GLO	R0
(2)   77/    16AB : 73                  	STXD
(2)   78/    16AC : 90                  	GHI	R0
(2)   79/    16AD : 73                  	STXD
(2)   80/    16AE :                     
(1)   31/    16AE : [29]                  ENDIF
(1)   32/    16AE : =>TRUE                IF    MOMCPU<>$1805		;for 1806 use SCAL 
(1)   33/    16AE : (MACRO)             	ldiReg	RCALL,_call
(1)   33/    16AE : =>FALSE              if MOMCPU=$1805
(1)   33/    16AE :                             RLDI    RCALL,_CALL
(1)   33/    16AE : =>TRUE               else
(1)   33/    16AE : F8 AE                       ldi     (_CALL)&255
(1)   33/    16B0 : A4                          plo     RCALL
(1)   33/    16B1 : F8 16                       ldi     (_CALL)>>8; was/256
(1)   33/    16B3 : B4                          phi     RCALL
(1)   33/    16B4 : [33]                 endif
(1)   34/    16B4 : (MACRO)             	ldiReg	RRET,_return
(1)   34/    16B4 : =>FALSE              if MOMCPU=$1805
(1)   34/    16B4 :                             RLDI    RRET,_RETURN
(1)   34/    16B4 : =>TRUE               else
(1)   34/    16B4 : F8 B4                       ldi     (_RETURN)&255
(1)   34/    16B6 : A5                          plo     RRET
(1)   34/    16B7 : F8 16                       ldi     (_RETURN)>>8; was/256
(1)   34/    16B9 : B5                          phi     RRET
(1)   34/    16BA : [34]                 endif
(1)   35/    16BA : =>FALSE               ELSE
(1)   36/    16BA :                     	ldiReg	RCALL,$$_die; _call
(1)   37/    16BA :                     	ldiReg	RRET,$$_die; _return
(1)   38/    16BA : [32]                  ENDIF
(1)   39/    16BA : =>DEFINED             IFNDEF  STACKLOC		;wjr 16-09-20 allow stack relocation
(1)   40/    16BA :                     	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1 as default
(1)   41/    16BA : =>TRUE                ELSEIF				;wjr 16-09-20
(1)   42/    16BA : (MACRO)             	ldiReg	SP,STACKLOC	;wjr 16-09-20 start stack as specified
(1)   42/    16BA : =>FALSE              if MOMCPU=$1805
(1)   42/    16BA :                             RLDI    SP,STACKLOC
(1)   42/    16BA : =>TRUE               else
(1)   42/    16BA : F8 FF                       ldi     (STACKLOC)&255
(1)   42/    16BC : A2                          plo     SP
(1)   42/    16BD : F8 FF                       ldi     (STACKLOC)>>8; was/256
(1)   42/    16BF : B2                          phi     SP
(1)   42/    16C0 : [42]                 endif
(1)   43/    16C0 : [39]                  ENDIF				;wjr 16-09-20
(1)   44/    16C0 : E2                  	sex	SP
(1)   45/    16C1 : (MACRO)             	ldiReg	RPC,$$_00000
(1)   45/    16C1 : =>FALSE              if MOMCPU=$1805
(1)   45/    16C1 :                             RLDI    RPC,$$_00000
(1)   45/    16C1 : =>TRUE               else
(1)   45/    16C1 : F8 C1                       ldi     ($$_00000)&255
(1)   45/    16C3 : A3                          plo     RPC
(1)   45/    16C4 : F8 16                       ldi     ($$_00000)>>8; was/256
(1)   45/    16C6 : B3                          phi     RPC
(1)   45/    16C7 : [45]                 endif
(1)   46/    16C7 : D3                  	sep	RPC
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 110 - 1/18/2018 14:51:20


(1)   47/    16C8 :                     $$_00000:
(1)   48/    16C8 : (MACRO)             	Ccall _main	;call the main routine
(1)   48/    16C8 : =>FALSE              if MOMCPU=$1805
(1)   48/    16C8 :                             SCAL    6
(1)   48/    16C8 :                             dw      _MAIN
(1)   48/    16C8 : =>TRUE               else
(1)   48/    16C8 : D4                          sep     RCALL
(1)   48/    16C9 : 02 23                       dw      _MAIN
(1)   48/    16CB : [48]                 endif
(1)   49/    16CB : C0 16 CB            $$_die:	lbr	$$_die		;loop here when main returns
(1)   50/    16CE : DE AD               	db	0xde,0xad
(1)   51/    16D0 :                     
(1)   52/    16D0 :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   53/    16D0 :                     _setqOn:
(1)   54/    16D0 : 7B                  	seq
(1)   55/    16D1 : (MACRO)             	Cretn
(1)   55/    16D1 : =>FALSE              if MOMCPU=$1805
(1)   55/    16D1 :                             sret    6
(1)   55/    16D1 : =>TRUE               else
(1)   55/    16D1 : D5                          sep     RRET
(1)   55/    16D2 : [55]                 endif
(1)   56/    16D2 :                     _setqOff:
(1)   57/    16D2 : 7A                  	req
(1)   58/    16D3 : (MACRO)             	Cretn
(1)   58/    16D3 : =>FALSE              if MOMCPU=$1805
(1)   58/    16D3 :                             sret    6
(1)   58/    16D3 : =>TRUE               else
(1)   58/    16D3 : D5                          sep     RRET
(1)   58/    16D4 : [58]                 endif
(1)   59/    16D4 : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math
(1)   60/    16D4 :                     _modU2:	;16 bit unsigned remainder
(1)   61/    16D4 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   62/    16D4 : (MACRO)                 Ccall _divU2
(1)   62/    16D4 : =>FALSE              if MOMCPU=$1805
(1)   62/    16D4 :                             SCAL    6
(1)   62/    16D4 :                             dw      _DIVU2
(1)   62/    16D4 : =>TRUE               else
(1)   62/    16D4 : D4                          sep     RCALL
(1)   62/    16D5 : 16 D5                       dw      _DIVU2
(1)   62/    16D7 : [62]                 endif
(1)   63/    16D7 : 8C                      glo regArg1
(1)   64/    16D8 : AF                      plo retVal
(1)   65/    16D9 : 9C                      ghi regArg1
(1)   66/    16DA : BF                      phi retVal
(1)   67/    16DB : (MACRO)                 Cretn
(1)   67/    16DB : =>FALSE              if MOMCPU=$1805
(1)   67/    16DB :                             sret    6
(1)   67/    16DB : =>TRUE               else
(1)   67/    16DB : D5                          sep     RRET
(1)   67/    16DC : [67]                 endif
(1)   68/    16DC :                         
(1)   69/    16DC :                     _modI2:	;16 bit signed remainder
(1)   70/    16DC :                     	; just calls the 16 bit division then puts remainder into return value
(1)   71/    16DC : (MACRO)                 Ccall _divI2
(1)   71/    16DC : =>FALSE              if MOMCPU=$1805
(1)   71/    16DC :                             SCAL    6
(1)   71/    16DC :                             dw      _DIVI2
(1)   71/    16DC : =>TRUE               else
(1)   71/    16DC : D4                          sep     RCALL
(1)   71/    16DD : 16 DD                       dw      _DIVI2
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 111 - 1/18/2018 14:51:20


(1)   71/    16DF : [71]                 endif
(1)   72/    16DF : 8C                      glo regArg1
(1)   73/    16E0 : AF                      plo retVal
(1)   74/    16E1 : 9C                      ghi regArg1
(1)   75/    16E2 : BF                      phi retVal
(1)   76/    16E3 : (MACRO)                 Cretn
(1)   76/    16E3 : =>FALSE              if MOMCPU=$1805
(1)   76/    16E3 :                             sret    6
(1)   76/    16E3 : =>TRUE               else
(1)   76/    16E3 : D5                          sep     RRET
(1)   76/    16E4 : [76]                 endif
(1)   77/    16E4 : [59]                 ENDIF
(1)   78/    16E4 :                     _out4:	
(1)   79/    16E4 : 8C                  	glo	regArg1
(1)   80/    16E5 : 22                  	dec	sp
(1)   81/    16E6 : 52                  	str	sp
(1)   82/    16E7 : 64                  	out	4
(1)   83/    16E8 : (MACRO)             	Cretn
(1)   83/    16E8 : =>FALSE              if MOMCPU=$1805
(1)   83/    16E8 :                             sret    6
(1)   83/    16E8 : =>TRUE               else
(1)   83/    16E8 : D5                          sep     RRET
(1)   83/    16E9 : [83]                 endif
(1)   84/    16E9 :                     
(1)   85/    16E9 :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   86/    16E9 : =>TRUE                if MOMCPU<>$1805		;for 1806 use SCAL
(1)   87/    16E9 :                     	align 16
(1)   88/    16F0 :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)   89/    16F0 : D3                  	sep     R3 ;go to subroutine
(1)   90/    16F1 : E2                  _call	sex	SP ;make sure X=SP
(1)   91/    16F2 : 86                  	glo	retAddr ;save previous return pointer on stack
(1)   92/    16F3 : 73                  	stxd
(1)   93/    16F4 : 96                  	ghi	retAddr
(1)   94/    16F5 : 73                  	stxd	
(1)   95/    16F6 : 83                  	glo	RPC ;copy old PC to retAddr
(1)   96/    16F7 : A6                  	plo	retAddr
(1)   97/    16F8 : 93                  	ghi	RPC
(1)   98/    16F9 : B6                  	phi	retAddr
(1)   99/    16FA : 46                  	lda	retAddr ;pick up subroutine address into RPC
(1)  100/    16FB : B3                  	phi	RPC
(1)  101/    16FC : 46                  	lda	retAddr
(1)  102/    16FD : A3                  	plo	RPC
(1)  103/    16FE : 30 F0               	br	_call-1
(1)  104/    1700 :                     
(1)  105/    1700 :                     ;Standard subroutine return 
(1)  106/    1700 :                     	align 16
(1)  107/    1700 : D3                  	sep	RPC	;return to the original program
(1)  108/    1701 : 86                  _return	glo	retAddr	;transfer the current return address to RPC
(1)  109/    1702 : A3                  	plo	RPC
(1)  110/    1703 : 96                  	ghi	retAddr
(1)  111/    1704 : B3                  	phi	RPC
(1)  112/    1705 : 12                  	inc 	SP
(1)  113/    1706 : 42                  	lda	SP	;pick up old return address
(1)  114/    1707 : B6                  	phi	retAddr
(1)  115/    1708 : 02                  	ldn	SP
(1)  116/    1709 : A6                  	plo	retAddr
(1)  117/    170A : 30 00               	br	_return-1
(1)  118/    170C : [86]                 ENDIF
(1)  119/    170C :                     	align 8
(1)  120/    1710 :                     _oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 112 - 1/18/2018 14:51:20


(1)  121/    1710 :                     ;subroutine overhead soaks up 27 instruction time.
(1)  122/    1710 :                     ;each loop is 2 instruction times
(1)  123/    1710 :                     ;so the number of loops needed is 
(1)  124/    1710 :                     ;CPU speed/16000 less the 27 all divide by two
(1)  125/    1710 : =>DEFINED           	IFNDEF	CPUSPEED
(1)  126/    1710 :                     CPUSPEED EQU 1600000	;1.6MHZ default
(1)  127/    1710 : [125]               	ENDIF
(1)  128/    1710 : =>FALSE              if MOMCPU=$1805		;for 1806 SCAL
(1)  129/    1710 :                     SUBOVHD  EQU 14		;1806 SCAL/SRET subroutine overhead
(1)  130/    1710 : =>TRUE               else
(1)  131/    1710 : =1BH                SUBOVHD  EQU 27		;default SCRT subroutine overhead
(1)  132/    1710 : [128]                endif 
(1)  133/    1710 : =>FALSE               IF CPUSPEED<=8000000
(1)  134/    1710 :                     	ldi	(CPUSPEED/1000/16-SUBOVHD)/2
(1)  135/    1710 :                     $$mslp:	smi	1
(1)  136/    1710 :                     	bnz	$$mslp
(1)  137/    1710 : =>TRUE                ELSE
(1)  138/    1710 : F8 B4               	ldi	(CPUSPEED/1000/16-SUBOVHD)/4
(1)  139/    1712 : FF 01               $$mslf:	smi	1
(1)  140/    1714 : E2                  	sex	2
(1)  141/    1715 : E2                  	sex	2
(1)  142/    1716 : 3A 12               	bnz	$$mslf
(1)  143/    1718 : [133]                 ENDIF
(1)  144/    1718 : (MACRO)             	Cretn
(1)  144/    1718 : =>FALSE              if MOMCPU=$1805
(1)  144/    1718 :                             sret    6
(1)  144/    1718 : =>TRUE               else
(1)  144/    1718 : D5                          sep     RRET
(1)  144/    1719 : [144]                endif
(1)  145/    1719 :                     
(1)  146/    1719 :                     
(1)  147/    1719 : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math	
(1)  148/    1719 :                     	align 256
(1)  149/    1800 :                     ;16 bit right shifting multiply which is faster for smaller operands
(1)  150/    1800 :                     ; credit to http://map.grauw.nl/articles/mult_div_shifts.php#lrmultr
(1)  151/    1800 :                     _mulU2:		;retval(product)=regarg1(multiplicand)*regarg2(multiplier)
(1)  152/    1800 : (MACRO)             	ld2z retval
(1)  152/    1800 : F8 00                       ldi     0
(1)  152/    1802 : AF                          plo     RETVAL
(1)  152/    1803 : BF                          phi     RETVAL
(1)  153/    1804 :                     $$mulrlp:
(1)  154/    1804 : (MACRO)             	shru2 regarg2
(1)  154/    1804 : 9D                          ghi     REGARG2
(1)  154/    1805 : F6                          shr
(1)  154/    1806 : BD                          phi     REGARG2
(1)  154/    1807 : 8D                          glo     REGARG2
(1)  154/    1808 : 76                          shrc
(1)  154/    1809 : AD                          plo     REGARG2
(1)  155/    180A : 3B 0A               	bnf $$mulrnoadd
(1)  156/    180C :                     ;	bottom bit of multiplier is one so add multiplicand to product
(1)  157/    180C : (MACRO)             	alu2 retval,retval,regarg1,add,adc
(1)  157/    180C : 8C                          glo     REGARG1
(1)  157/    180D : 52                          str     sp
(1)  157/    180E : 8F                          glo     RETVAL
(1)  157/    180F : F4                          ADD             ;calculate the low order byte
(1)  157/    1810 : AF                          plo     RETVAL
(1)  157/    1811 : 9C                          ghi     REGARG1
(1)  157/    1812 : 52                          str     sp
(1)  157/    1813 : 9F                          ghi     RETVAL
(1)  157/    1814 : 74                          ADC             ;calculate the high byte
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 113 - 1/18/2018 14:51:20


(1)  157/    1815 : BF                          phi     RETVAL
(1)  158/    1816 :                     $$mulrnoadd:
(1)  159/    1816 : 9D                  	ghi regarg2	;check for all bits of multiplier shifted out
(1)  160/    1817 : 3A 17               	bnz $$mulrshft	;nope, continue
(1)  161/    1819 : 8D                  	glo regarg2	;check bottom byte
(1)  162/    181A : 32 1A               	bz $$mulrdone
(1)  163/    181C :                     $$mulrshft:
(1)  164/    181C : (MACRO)             	shl2 regarg1	;shift multiplicand left 1
(1)  164/    181C : 8C                          glo     REGARG1
(1)  164/    181D : FE                          shl
(1)  164/    181E : AC                          plo     REGARG1
(1)  164/    181F : 9C                          ghi     REGARG1
(1)  164/    1820 : 7E                          shlc
(1)  164/    1821 : BC                          phi     REGARG1
(1)  165/    1822 : 30 04               	br $$mulrlp
(1)  166/    1824 :                     $$mulrdone:		;here the product is in retval
(1)  167/    1824 : (MACRO)             	cretn
(1)  167/    1824 : =>FALSE              if MOMCPU=$1805
(1)  167/    1824 :                             sret    6
(1)  167/    1824 : =>TRUE               else
(1)  167/    1824 : D5                          sep     RRET
(1)  167/    1825 : [167]                endif
(1)  168/    1825 :                     
(1)  169/    1825 :                     ;this is a divisor shifting algorithm which is faster for smaller operands
(1)  170/    1825 :                     ;credit to http://research.microsoft.com/pubs/70645/tr-2008-141.pdf
(1)  171/    1825 :                     ;changed oct 12 to save R10 & 1/2 R11 on stack
(1)  172/    1825 :                     _divu2: ;retval=regarg1(x or dividend)/regarg2(y or divisor)
(1)  173/    1825 :                     	;uses R14(rwork) to hold original divisor y0, 
(1)  174/    1825 :                     	;regarg1 to hold develop remainder, 
(1)  175/    1825 :                     	;R10 to hold working dividend R11.0 as a temp
(1)  176/    1825 :                     testsub: macro reg1,reg2	;test subtraction of reg2 from reg1
(1)  177/    1825 :                     				;result in D, rwork.hi, DF
(1)  178/    1825 :                     	glo reg2
(1)  179/    1825 :                     	str sp
(1)  180/    1825 :                     	glo reg1
(1)  181/    1825 :                     	sm
(1)  182/    1825 :                     	plo R11
(1)  183/    1825 :                     	ghi reg2
(1)  184/    1825 :                     	str sp
(1)  185/    1825 :                     	ghi reg1
(1)  186/    1825 :                     	smb
(1)  187/    1825 :                     	endm
(1)  188/    1825 :                     	
(1)  189/    1825 :                     ;	pushf R10	;save R10 & leave stack down 1
(1)  190/    1825 : (MACRO)             	pushr R10	;default push leaves stack clean
(1)  190/    1825 : =>FALSE              if MOMCPU=$1805
(1)  190/    1825 :                             RSXD    R10
(1)  190/    1825 : =>TRUE               else
(1)  190/    1825 : 8A                          glo     R10
(1)  190/    1826 : 73                          stxd
(1)  190/    1827 : 9A                          ghi     R10
(1)  190/    1828 : 73                          stxd
(1)  190/    1829 : [190]                endif
(1)  191/    1829 : 8B                  	glo R11		;and bottom
(1)  192/    182A : 73                  	stxd		;of R11 - leaves stack clear of work area
(1)  193/    182B : (MACRO)             	cpy2 R10,regarg1
(1)  193/    182B : 8C                          glo     REGARG1
(1)  193/    182C : AA                          plo     R10
(1)  193/    182D : 9C                          ghi     REGARG1
(1)  193/    182E : BA                          phi     R10
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 114 - 1/18/2018 14:51:20


(1)  194/    182F : (MACRO)             	ld2z retval	;quotient
(1)  194/    182F : F8 00                       ldi     0
(1)  194/    1831 : AF                          plo     RETVAL
(1)  194/    1832 : BF                          phi     RETVAL
(1)  195/    1833 : (MACRO)             	cpy2 rwork,regarg2
(1)  195/    1833 : 8D                          glo     REGARG2
(1)  195/    1834 : AE                          plo     RWORK
(1)  195/    1835 : 9D                          ghi     REGARG2
(1)  195/    1836 : BE                          phi     RWORK
(1)  196/    1837 :                     	
(1)  197/    1837 : (MACRO)             	testsub R10,regarg2
(1)  197/    1837 :                                                     ;result in D, rwork.hi, DF
(1)  197/    1837 : 8D                          glo REGARG2
(1)  197/    1838 : 52                          str sp
(1)  197/    1839 : 8A                          glo R10
(1)  197/    183A : F7                          sm
(1)  197/    183B : AB                          plo R11
(1)  197/    183C : 9D                          ghi REGARG2
(1)  197/    183D : 52                          str sp
(1)  197/    183E : 9A                          ghi R10
(1)  197/    183F : 77                          smb
(1)  198/    1840 : 3B 40               	bnf $$computequot	;DF=0 means it didn't fit
(1)  199/    1842 : BA                  	phi R10	;R10=R10-regarg2
(1)  200/    1843 : 8B                  	glo R11
(1)  201/    1844 : AA                  	plo R10
(1)  202/    1845 :                     	
(1)  203/    1845 :                     $$again:	;this is the divisor doubling phase
(1)  204/    1845 : (MACRO)              	testsub R10,regarg2
(1)  204/    1845 :                                                     ;result in D, rwork.hi, DF
(1)  204/    1845 : 8D                          glo REGARG2
(1)  204/    1846 : 52                          str sp
(1)  204/    1847 : 8A                          glo R10
(1)  204/    1848 : F7                          sm
(1)  204/    1849 : AB                          plo R11
(1)  204/    184A : 9D                          ghi REGARG2
(1)  204/    184B : 52                          str sp
(1)  204/    184C : 9A                          ghi R10
(1)  204/    184D : 77                          smb
(1)  205/    184E : 3B 4E                	bnf $$computequot	;df=0 means it didn't fit
(1)  206/    1850 : BA                  	phi R10	;R10=R10-regarg2
(1)  207/    1851 : 8B                  	glo R11
(1)  208/    1852 : AA                  	plo R10 	
(1)  209/    1853 : (MACRO)              	shl2 regarg2	;y=y+y
(1)  209/    1853 : 8D                          glo     REGARG2
(1)  209/    1854 : FE                          shl
(1)  209/    1855 : AD                          plo     REGARG2
(1)  209/    1856 : 9D                          ghi     REGARG2
(1)  209/    1857 : 7E                          shlc
(1)  209/    1858 : BD                          phi     REGARG2
(1)  210/    1859 : 30 45                	br $$again
(1)  211/    185B :                      	
(1)  212/    185B :                      $$computequot:	;here we're computing the quotient
(1)  213/    185B : (MACRO)              	testsub regarg1,regarg2
(1)  213/    185B :                                                     ;result in D, rwork.hi, DF
(1)  213/    185B : 8D                          glo REGARG2
(1)  213/    185C : 52                          str sp
(1)  213/    185D : 8C                          glo REGARG1
(1)  213/    185E : F7                          sm
(1)  213/    185F : AB                          plo R11
(1)  213/    1860 : 9D                          ghi REGARG2
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 115 - 1/18/2018 14:51:20


(1)  213/    1861 : 52                          str sp
(1)  213/    1862 : 9C                          ghi REGARG1
(1)  213/    1863 : 77                          smb
(1)  214/    1864 : 3B 64                	bnf $$testexit
(1)  215/    1866 : BC                   	phi regarg1		;complete the subtraction
(1)  216/    1867 : 8B                   	glo R11
(1)  217/    1868 : AC                   	plo regarg1
(1)  218/    1869 : 1F                   	inc retval
(1)  219/    186A :                      $$testexit:
(1)  220/    186A : 9E                   	ghi rwork
(1)  221/    186B : F7                   	sm	;top of regarg2 is still on stack
(1)  222/    186C : 3A 6C                	bnz $$ney0y
(1)  223/    186E : 8D                   	glo regarg2
(1)  224/    186F : 52                   	str sp
(1)  225/    1870 : 8E                   	glo rwork
(1)  226/    1871 : F7                   	sm	;test low order bytes
(1)  227/    1872 : 32 72                	bz	$$out	;if = we're done
(1)  228/    1874 :                      $$ney0y:
(1)  229/    1874 : (MACRO)              	shl2 retval	;double quotient
(1)  229/    1874 : 8F                          glo     RETVAL
(1)  229/    1875 : FE                          shl
(1)  229/    1876 : AF                          plo     RETVAL
(1)  229/    1877 : 9F                          ghi     RETVAL
(1)  229/    1878 : 7E                          shlc
(1)  229/    1879 : BF                          phi     RETVAL
(1)  230/    187A : (MACRO)              	shrU2 regarg2	;halve divisor
(1)  230/    187A : 9D                          ghi     REGARG2
(1)  230/    187B : F6                          shr
(1)  230/    187C : BD                          phi     REGARG2
(1)  230/    187D : 8D                          glo     REGARG2
(1)  230/    187E : 76                          shrc
(1)  230/    187F : AD                          plo     REGARG2
(1)  231/    1880 : 30 5B                	br $$computequot	;continue
(1)  232/    1882 :                      $$out:
(1)  233/    1882 :                      ;here the quotient is in retval, remainder in regarg1
(1)  234/    1882 : 12                    	inc sp	;release work area
(1)  235/    1883 : 02                  	ldn sp	;recover
(1)  236/    1884 : AB                  	plo R11	;bottom byte of R11
(1)  237/    1885 : (MACRO)             	popr R10 ;and all of R10
(1)  237/    1885 : 12                          inc     sp
(1)  237/    1886 : 42                          lda     sp
(1)  237/    1887 : BA                          phi     R10
(1)  237/    1888 : 02                          ldn     sp
(1)  237/    1889 : AA                          plo     R10
(1)  238/    188A : (MACRO)             	cretn	;and we're done
(1)  238/    188A : =>FALSE              if MOMCPU=$1805
(1)  238/    188A :                             sret    6
(1)  238/    188A : =>TRUE               else
(1)  238/    188A : D5                          sep     RRET
(1)  238/    188B : [238]                endif
(1)  239/    188B :                     
(1)  240/    188B :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  241/    188B :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  242/    188B :                     _divI2:
(1)  243/    188B : 22                      dec	sp	;leave a work area available
(1)  244/    188C : 9C                      ghi regArg1
(1)  245/    188D : 52                      str sp	;save the sign of the 1st arg
(1)  246/    188E : FE                      shl
(1)  247/    188F : 3B 8F                   bnf $$pos1	;if the 1st arg is -v
(1)  248/    1891 : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 116 - 1/18/2018 14:51:20


(1)  248/    1891 : 8C                          glo     REGARG1                     ;(flip all the bits and add 1)
(1)  248/    1892 : FB FF                       xri     0xff
(1)  248/    1894 : AC                          plo     REGARG1
(1)  248/    1895 : 9C                          ghi     REGARG1
(1)  248/    1896 : FB FF                       xri     0xff
(1)  248/    1898 : BC                          phi     REGARG1
(1)  248/    1899 : 1C                          inc     REGARG1
(1)  249/    189A :                     $$pos1: ;1st is now +v, check 2nd
(1)  250/    189A : 9D                      ghi regArg2
(1)  251/    189B : F3                      xor	
(1)  252/    189C : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  253/    189D : 9D                      ghi regArg2
(1)  254/    189E : FE                      shl
(1)  255/    189F : 3B 9F                   bnf $$pos2	;if the 2nd arg is -v
(1)  256/    18A1 : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  256/    18A1 : 8D                          glo     REGARG2                     ;(flip all the bits and add 1)
(1)  256/    18A2 : FB FF                       xri     0xff
(1)  256/    18A4 : AD                          plo     REGARG2
(1)  256/    18A5 : 9D                          ghi     REGARG2
(1)  256/    18A6 : FB FF                       xri     0xff
(1)  256/    18A8 : BD                          phi     REGARG2
(1)  256/    18A9 : 1D                          inc     REGARG2
(1)  257/    18AA :                     $$pos2: ; both args now +v
(1)  258/    18AA : 22                      dec sp	;protect workarea on the 1802
(1)  259/    18AB : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  259/    18AB : =>FALSE              if MOMCPU=$1805
(1)  259/    18AB :                             SCAL    6
(1)  259/    18AB :                             dw      _DIVU2
(1)  259/    18AB : =>TRUE               else
(1)  259/    18AB : D4                          sep     RCALL
(1)  259/    18AC : 18 25                       dw      _DIVU2
(1)  259/    18AE : [259]                endif
(1)  260/    18AE : 12                      inc sp	;recover work area
(1)  261/    18AF :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  262/    18AF : 42                      lda	sp ;get back the sign bits and restore SP
(1)  263/    18B0 : FE                      shl
(1)  264/    18B1 : 3B B1                   bnf $$done ;if the signs were different
(1)  265/    18B3 : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  265/    18B3 : 8F                          glo     RETVAL                     ;(flip all the bits and add 1)
(1)  265/    18B4 : FB FF                       xri     0xff
(1)  265/    18B6 : AF                          plo     RETVAL
(1)  265/    18B7 : 9F                          ghi     RETVAL
(1)  265/    18B8 : FB FF                       xri     0xff
(1)  265/    18BA : BF                          phi     RETVAL
(1)  265/    18BB : 1F                          inc     RETVAL
(1)  266/    18BC :                     $$done:
(1)  267/    18BC : (MACRO)                 Cretn ;and we're done - I hope!
(1)  267/    18BC : =>FALSE              if MOMCPU=$1805
(1)  267/    18BC :                             sret    6
(1)  267/    18BC : =>TRUE               else
(1)  267/    18BC : D5                          sep     RRET
(1)  267/    18BD : [267]                endif
(1)  268/    18BD : [147]                ENDIF
(1)  269/    18BD : =>UNDEFINED          IFNDEF  LCCNOLONG		;wjr 17-04-09 disable 32 bit math
(1)  270/    18BD :                     	align 256    ;32 bit operations follow
(1)  271/    1900 :                     _divu4:
(1)  272/    1900 :                     ;This is an unsigned 32 bit restoring division
(1)  273/    1900 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  274/    1900 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  275/    1900 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 117 - 1/18/2018 14:51:20


(1)  276/    1900 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  277/    1900 :                     
(1)  278/    1900 : F8 20               	ldi 32		;set loop count
(1)  279/    1902 : AE                  	plo memaddr	;in temp register
(1)  280/    1903 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  280/    1903 : F8 00                       ldi     (0)&255
(1)  280/    1905 : AD                          plo     RP1P2
(1)  280/    1906 : F8 00                       ldi     ((0)>>8)&255; 
(1)  280/    1908 : BD                          phi     RP1P2
(1)  280/    1909 : F8 00                       ldi     ((0)>>16)&255; 
(1)  280/    190B : AC                          plo     RP1P2-1
(1)  280/    190C : F8 00                       ldi     ((0)>>24)&255; 
(1)  280/    190E : BC                          phi     RP1P2-1
(1)  281/    190F :                     $$loop:
(1)  282/    190F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  282/    190F : 89                          glo     RL8     ;start with low byte of second register
(1)  282/    1910 : FE                          shl             ;shift left once
(1)  282/    1911 : A9                          plo     RL8     ; save it
(1)  282/    1912 : 99                          ghi     RL8     ;high byte of second RL8
(1)  282/    1913 : 7E                          shlc            ;shift one bit carrying
(1)  282/    1914 : B9                          phi     RL8     ;save it
(1)  282/    1915 : 88                          glo     RL8-1   ;now the bottom byte of top RL8
(1)  282/    1916 : 7E                          shlc
(1)  282/    1917 : A8                          plo     RL8-1
(1)  282/    1918 : 98                          ghi     RL8-1   ;finally the top byte of the high order RL8
(1)  282/    1919 : 7E                          shlc            ;gets the last shift
(1)  282/    191A : B8                          phi     RL8-1   ;and we're done
(1)  283/    191B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  283/    191B : 8D                          glo     RP1P2     ;start with low byte of second register
(1)  283/    191C : 7E                          shlc            ;shift left once continuing carry
(1)  283/    191D : AD                          plo     RP1P2     ; save it
(1)  283/    191E : 9D                          ghi     RP1P2     ;high byte of second RP1P2
(1)  283/    191F : 7E                          shlc            ;shift one bit carrying
(1)  283/    1920 : BD                          phi     RP1P2     ;save it
(1)  283/    1921 : 8C                          glo     RP1P2-1   ;now the bottom byte of top RP1P2
(1)  283/    1922 : 7E                          shlc
(1)  283/    1923 : AC                          plo     RP1P2-1
(1)  283/    1924 : 9C                          ghi     RP1P2-1   ;finally the top byte of the high order RP1P2
(1)  283/    1925 : 7E                          shlc            ;gets the last shift
(1)  283/    1926 : BC                          phi     RP1P2-1   ;and we're done
(1)  284/    1927 :                     
(1)  285/    1927 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  285/    1927 : 22                          dec     sp ;make a work ares
(1)  285/    1928 : 8B                          glo     RL10    ;long register pairs are addressed by their second member
(1)  285/    1929 : 52                          str     sp      ;so arithmetic operations start there
(1)  285/    192A : 8D                          glo     RP1P2
(1)  285/    192B : F7                          SM             ;calculate the low order byte
(1)  285/    192C : AD                          plo     RP1P2
(1)  285/    192D : 9B                          ghi     RL10
(1)  285/    192E : 52                          str     sp
(1)  285/    192F : 9D                          ghi     RP1P2
(1)  285/    1930 : 77                          SMB             ;calculate the second byte
(1)  285/    1931 : BD                          phi     RP1P2
(1)  285/    1932 : 8A                          glo     RL10-1
(1)  285/    1933 : 52                          str     sp
(1)  285/    1934 : 8C                          glo     RP1P2-1
(1)  285/    1935 : 77                          SMB             ;calculate the third byte
(1)  285/    1936 : AC                          plo     RP1P2-1
(1)  285/    1937 : 9A                          ghi     RL10-1
(1)  285/    1938 : 52                          str     sp
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 118 - 1/18/2018 14:51:20


(1)  285/    1939 : 9C                          ghi     RP1P2-1
(1)  285/    193A : 77                          SMB             ;calculate the high byte
(1)  285/    193B : BC                          phi     RP1P2-1
(1)  285/    193C : 12                          inc     sp      ;release the work area
(1)  286/    193D :                     
(1)  287/    193D : FA 80               	ani 0x80	;check the top bit
(1)  288/    193F : 32 3F               	bz $$norestore	;if it's 0
(1)  289/    1941 : 89                  		glo RL8
(1)  290/    1942 : FA FE               		ani 0xfe	;turn off the bottom bit
(1)  291/    1944 : A9                  		plo RL8
(1)  292/    1945 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  292/    1945 : 22                          dec     sp ;make a work ares
(1)  292/    1946 : 8B                          glo     RL10    ;long register pairs are addressed by their second member
(1)  292/    1947 : 52                          str     sp      ;so arithmetic operations start there
(1)  292/    1948 : 8D                          glo     RP1P2
(1)  292/    1949 : F4                          ADD             ;calculate the low order byte
(1)  292/    194A : AD                          plo     RP1P2
(1)  292/    194B : 9B                          ghi     RL10
(1)  292/    194C : 52                          str     sp
(1)  292/    194D : 9D                          ghi     RP1P2
(1)  292/    194E : 74                          ADC             ;calculate the second byte
(1)  292/    194F : BD                          phi     RP1P2
(1)  292/    1950 : 8A                          glo     RL10-1
(1)  292/    1951 : 52                          str     sp
(1)  292/    1952 : 8C                          glo     RP1P2-1
(1)  292/    1953 : 74                          ADC             ;calculate the third byte
(1)  292/    1954 : AC                          plo     RP1P2-1
(1)  292/    1955 : 9A                          ghi     RL10-1
(1)  292/    1956 : 52                          str     sp
(1)  292/    1957 : 9C                          ghi     RP1P2-1
(1)  292/    1958 : 74                          ADC             ;calculate the high byte
(1)  292/    1959 : BC                          phi     RP1P2-1
(1)  292/    195A : 12                          inc     sp      ;release the work area
(1)  293/    195B : 30 5B               	br $$endlp 	;else
(1)  294/    195D :                     $$norestore:
(1)  295/    195D : 89                  		glo RL8
(1)  296/    195E : F9 01               		ori 1	;turn on the bottom bit
(1)  297/    1960 : A9                  		plo RL8
(1)  298/    1961 :                     	;end if
(1)  299/    1961 :                     $$endlp:
(1)  300/    1961 : 2E                  	dec memaddr	;check the cycle count
(1)  301/    1962 : 8E                  	glo memaddr
(1)  302/    1963 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  303/    1965 :                     	
(1)  304/    1965 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  304/    1965 : =>FALSE              if MOMCPU=$1805
(1)  304/    1965 :                             sret    6
(1)  304/    1965 : =>TRUE               else
(1)  304/    1965 : D5                          sep     RRET
(1)  304/    1966 : [304]                endif
(1)  305/    1966 :                     		
(1)  306/    1966 :                     
(1)  307/    1966 :                     _mulu4:
(1)  308/    1966 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  309/    1966 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  310/    1966 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  311/    1966 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  312/    1966 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  313/    1966 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  314/    1966 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 119 - 1/18/2018 14:51:20


(1)  315/    1966 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  316/    1966 :                     	;for 10 we subtract and shift
(1)  317/    1966 :                     	;for 00 and 11 we just shift
(1)  318/    1966 :                     
(1)  319/    1966 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  319/    1966 : F8 00                       ldi     (0)&255
(1)  319/    1968 : AD                          plo     RP1P2
(1)  319/    1969 : F8 00                       ldi     ((0)>>8)&255; 
(1)  319/    196B : BD                          phi     RP1P2
(1)  319/    196C : F8 00                       ldi     ((0)>>16)&255; 
(1)  319/    196E : AC                          plo     RP1P2-1
(1)  319/    196F : F8 00                       ldi     ((0)>>24)&255; 
(1)  319/    1971 : BC                          phi     RP1P2-1
(1)  320/    1972 : F8 20                   ldi 32
(1)  321/    1974 : AE                      plo memaddr		;cycle count
(1)  322/    1975 : FC 00                   adi 0		;clear df
(1)  323/    1977 :                     $$mloop:
(1)  324/    1977 : 89                      glo RL8
(1)  325/    1978 : FA 01                   ani 1		;isolate bottom bit of result
(1)  326/    197A : 3B 7A                   bnf	$$check_sub	;
(1)  327/    197C : 3A 7C                   bnz	$$shift		;that would be the 11 case
(1)  328/    197E :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  329/    197E : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  329/    197E : 22                          dec     sp ;make a work ares
(1)  329/    197F : 8B                          glo     RL10    ;long register pairs are addressed by their second member
(1)  329/    1980 : 52                          str     sp      ;so arithmetic operations start there
(1)  329/    1981 : 8D                          glo     RP1P2
(1)  329/    1982 : F4                          ADD             ;calculate the low order byte
(1)  329/    1983 : AD                          plo     RP1P2
(1)  329/    1984 : 9B                          ghi     RL10
(1)  329/    1985 : 52                          str     sp
(1)  329/    1986 : 9D                          ghi     RP1P2
(1)  329/    1987 : 74                          ADC             ;calculate the second byte
(1)  329/    1988 : BD                          phi     RP1P2
(1)  329/    1989 : 8A                          glo     RL10-1
(1)  329/    198A : 52                          str     sp
(1)  329/    198B : 8C                          glo     RP1P2-1
(1)  329/    198C : 74                          ADC             ;calculate the third byte
(1)  329/    198D : AC                          plo     RP1P2-1
(1)  329/    198E : 9A                          ghi     RL10-1
(1)  329/    198F : 52                          str     sp
(1)  329/    1990 : 9C                          ghi     RP1P2-1
(1)  329/    1991 : 74                          ADC             ;calculate the high byte
(1)  329/    1992 : BC                          phi     RP1P2-1
(1)  329/    1993 : 12                          inc     sp      ;release the work area
(1)  330/    1994 : 30 94                   br $$shift
(1)  331/    1996 :                     $$check_sub:
(1)  332/    1996 : 32 96                   bz $$shift	;that would be the 00 case
(1)  333/    1998 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  334/    1998 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  334/    1998 : 22                          dec     sp ;make a work ares
(1)  334/    1999 : 8B                          glo     RL10    ;long register pairs are addressed by their second member
(1)  334/    199A : 52                          str     sp      ;so arithmetic operations start there
(1)  334/    199B : 8D                          glo     RP1P2
(1)  334/    199C : F7                          SM             ;calculate the low order byte
(1)  334/    199D : AD                          plo     RP1P2
(1)  334/    199E : 9B                          ghi     RL10
(1)  334/    199F : 52                          str     sp
(1)  334/    19A0 : 9D                          ghi     RP1P2
(1)  334/    19A1 : 77                          SMB             ;calculate the second byte
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 120 - 1/18/2018 14:51:20


(1)  334/    19A2 : BD                          phi     RP1P2
(1)  334/    19A3 : 8A                          glo     RL10-1
(1)  334/    19A4 : 52                          str     sp
(1)  334/    19A5 : 8C                          glo     RP1P2-1
(1)  334/    19A6 : 77                          SMB             ;calculate the third byte
(1)  334/    19A7 : AC                          plo     RP1P2-1
(1)  334/    19A8 : 9A                          ghi     RL10-1
(1)  334/    19A9 : 52                          str     sp
(1)  334/    19AA : 9C                          ghi     RP1P2-1
(1)  334/    19AB : 77                          SMB             ;calculate the high byte
(1)  334/    19AC : BC                          phi     RP1P2-1
(1)  334/    19AD : 12                          inc     sp      ;release the work area
(1)  335/    19AE :                     $$shift:
(1)  336/    19AE : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  336/    19AE : 9C                          ghi     RP1P2-1   ;long RP1P2 pairs start at RP1P2-1
(1)  336/    19AF : FE                          shl             ;set DF to the sign
(1)  336/    19B0 : 9C                          ghi     RP1P2-1   ;get the top byte back
(1)  336/    19B1 : 76                          shrc            ;shift one bit extending the sign
(1)  336/    19B2 : BC                          phi     RP1P2-1
(1)  336/    19B3 : 8C                          glo     RP1P2-1
(1)  336/    19B4 : 76                          shrc
(1)  336/    19B5 : AC                          plo     RP1P2-1
(1)  336/    19B6 : 9D                          ghi     RP1P2     ;get the top byte of the low order RP1P2
(1)  336/    19B7 : 76                          shrc            ;shift one bit extending the sign
(1)  336/    19B8 : BD                          phi     RP1P2
(1)  336/    19B9 : 8D                          glo     RP1P2     ;finish with the low byte of the 2nd RP1P2 of the pair
(1)  336/    19BA : 76                          shrc
(1)  336/    19BB : AD                          plo     RP1P2
(1)  337/    19BC : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  337/    19BC : 98                          ghi     RL8-1   ;long RL8 pairs start at RL8-1
(1)  337/    19BD : 76                          shrc            ;shift one bit extending the sign
(1)  337/    19BE : B8                          phi     RL8-1
(1)  337/    19BF : 88                          glo     RL8-1
(1)  337/    19C0 : 76                          shrc
(1)  337/    19C1 : A8                          plo     RL8-1
(1)  337/    19C2 : 99                          ghi     RL8     ;get the top byte of the low order RL8
(1)  337/    19C3 : 76                          shrc            ;shift one bit extending the sign
(1)  337/    19C4 : B9                          phi     RL8
(1)  337/    19C5 : 89                          glo     RL8     ;finish with the low byte of the 2nd RL8 of the pair
(1)  337/    19C6 : 76                          shrc
(1)  337/    19C7 : A9                          plo     RL8
(1)  338/    19C8 :                     
(1)  339/    19C8 : 2E                      dec memaddr		;cycle count
(1)  340/    19C9 : 8E                      glo memaddr
(1)  341/    19CA : 3A 77                   bnz $$mloop		;repeat cycle once for each bit position
(1)  342/    19CC :                         
(1)  343/    19CC : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  343/    19CC : =>FALSE              if MOMCPU=$1805
(1)  343/    19CC :                             sret    6
(1)  343/    19CC : =>TRUE               else
(1)  343/    19CC : D5                          sep     RRET
(1)  343/    19CD : [343]                endif
(1)  344/    19CD :                     
(1)  345/    19CD :                     	align 256
(1)  346/    1A00 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  347/    1A00 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  348/    1A00 :                     _divI4:
(1)  349/    1A00 : 22                      dec	sp	;leave a work area available
(1)  350/    1A01 : 98                      ghi RL8-1	;get the top of the dividend
(1)  351/    1A02 : 52                      str sp	;save the sign of the 1st arg
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 121 - 1/18/2018 14:51:20


(1)  352/    1A03 : FE                      shl
(1)  353/    1A04 : 3B 04                   bnf $$pos1	;if the 1st arg is -v
(1)  354/    1A06 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  354/    1A06 :  (MACRO-2)                  alu4I   RL8,RL8,0xffffffff,xri,xri      ;flip all the bits
(1)  354/    1A06 : 89                          glo     RL8    ;long regs are equated to the second reg which has the low order word 
(1)  354/    1A07 : FB FF                       XRI     (0XFFFFFFFF)&255
(1)  354/    1A09 : A9                          plo     RL8
(1)  354/    1A0A : 99                          ghi     RL8
(1)  354/    1A0B : FB FF                       XRI     ((0XFFFFFFFF)>>8)&255; 
(1)  354/    1A0D : B9                          phi     RL8
(1)  354/    1A0E : 88                          glo     RL8-1
(1)  354/    1A0F : FB FF                       XRI     ((0XFFFFFFFF)>>16)&255; 
(1)  354/    1A11 : A8                          plo     RL8-1
(1)  354/    1A12 : 98                          ghi     RL8-1
(1)  354/    1A13 : FB FF                       XRI     ((0XFFFFFFFF)>>24)&255; 
(1)  354/    1A15 : B8                          phi     RL8-1
(1)  354/    1A16 :  (MACRO-2)                  alu4i   RL8,RL8,1,adi,adci              ;and add 1
(1)  354/    1A16 : 89                          glo     RL8    ;long regs are equated to the second reg which has the low order word 
(1)  354/    1A17 : FC 01                       ADI     (1)&255
(1)  354/    1A19 : A9                          plo     RL8
(1)  354/    1A1A : 99                          ghi     RL8
(1)  354/    1A1B : 7C 00                       ADCI     ((1)>>8)&255; 
(1)  354/    1A1D : B9                          phi     RL8
(1)  354/    1A1E : 88                          glo     RL8-1
(1)  354/    1A1F : 7C 00                       ADCI     ((1)>>16)&255; 
(1)  354/    1A21 : A8                          plo     RL8-1
(1)  354/    1A22 : 98                          ghi     RL8-1
(1)  354/    1A23 : 7C 00                       ADCI     ((1)>>24)&255; 
(1)  354/    1A25 : B8                          phi     RL8-1
(1)  355/    1A26 :                     $$pos1: ;1st is now +v, check 2nd
(1)  356/    1A26 : 9A                      ghi RL10-1
(1)  357/    1A27 : F3                      xor	
(1)  358/    1A28 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  359/    1A29 : 9A                      ghi RL10-1
(1)  360/    1A2A : FE                      shl
(1)  361/    1A2B : 3B 2B                   bnf $$pos2	;if the 2nd arg is -v
(1)  362/    1A2D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  362/    1A2D :  (MACRO-2)                  alu4I   RL10,RL10,0xffffffff,xri,xri      ;flip all the bits
(1)  362/    1A2D : 8B                          glo     RL10    ;long regs are equated to the second reg which has the low order word 
(1)  362/    1A2E : FB FF                       XRI     (0XFFFFFFFF)&255
(1)  362/    1A30 : AB                          plo     RL10
(1)  362/    1A31 : 9B                          ghi     RL10
(1)  362/    1A32 : FB FF                       XRI     ((0XFFFFFFFF)>>8)&255; 
(1)  362/    1A34 : BB                          phi     RL10
(1)  362/    1A35 : 8A                          glo     RL10-1
(1)  362/    1A36 : FB FF                       XRI     ((0XFFFFFFFF)>>16)&255; 
(1)  362/    1A38 : AA                          plo     RL10-1
(1)  362/    1A39 : 9A                          ghi     RL10-1
(1)  362/    1A3A : FB FF                       XRI     ((0XFFFFFFFF)>>24)&255; 
(1)  362/    1A3C : BA                          phi     RL10-1
(1)  362/    1A3D :  (MACRO-2)                  alu4i   RL10,RL10,1,adi,adci              ;and add 1
(1)  362/    1A3D : 8B                          glo     RL10    ;long regs are equated to the second reg which has the low order word 
(1)  362/    1A3E : FC 01                       ADI     (1)&255
(1)  362/    1A40 : AB                          plo     RL10
(1)  362/    1A41 : 9B                          ghi     RL10
(1)  362/    1A42 : 7C 00                       ADCI     ((1)>>8)&255; 
(1)  362/    1A44 : BB                          phi     RL10
(1)  362/    1A45 : 8A                          glo     RL10-1
(1)  362/    1A46 : 7C 00                       ADCI     ((1)>>16)&255; 
(1)  362/    1A48 : AA                          plo     RL10-1
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 122 - 1/18/2018 14:51:20


(1)  362/    1A49 : 9A                          ghi     RL10-1
(1)  362/    1A4A : 7C 00                       ADCI     ((1)>>24)&255; 
(1)  362/    1A4C : BA                          phi     RL10-1
(1)  363/    1A4D :                     $$pos2: ; both args now +v
(1)  364/    1A4D : 22                      dec sp	;protect workarea on the 1802
(1)  365/    1A4E : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  365/    1A4E : =>FALSE              if MOMCPU=$1805
(1)  365/    1A4E :                             SCAL    6
(1)  365/    1A4E :                             dw      _DIVU4
(1)  365/    1A4E : =>TRUE               else
(1)  365/    1A4E : D4                          sep     RCALL
(1)  365/    1A4F : 19 00                       dw      _DIVU4
(1)  365/    1A51 : [365]                endif
(1)  366/    1A51 : 12                      inc sp	;recover work area
(1)  367/    1A52 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  368/    1A52 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  369/    1A53 : FE                      shl
(1)  370/    1A54 : 3B 54                   bnf $$done ;if the signs were different
(1)  371/    1A56 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  371/    1A56 :  (MACRO-2)                  alu4I   RL8,RL8,0xffffffff,xri,xri      ;flip all the bits
(1)  371/    1A56 : 89                          glo     RL8    ;long regs are equated to the second reg which has the low order word 
(1)  371/    1A57 : FB FF                       XRI     (0XFFFFFFFF)&255
(1)  371/    1A59 : A9                          plo     RL8
(1)  371/    1A5A : 99                          ghi     RL8
(1)  371/    1A5B : FB FF                       XRI     ((0XFFFFFFFF)>>8)&255; 
(1)  371/    1A5D : B9                          phi     RL8
(1)  371/    1A5E : 88                          glo     RL8-1
(1)  371/    1A5F : FB FF                       XRI     ((0XFFFFFFFF)>>16)&255; 
(1)  371/    1A61 : A8                          plo     RL8-1
(1)  371/    1A62 : 98                          ghi     RL8-1
(1)  371/    1A63 : FB FF                       XRI     ((0XFFFFFFFF)>>24)&255; 
(1)  371/    1A65 : B8                          phi     RL8-1
(1)  371/    1A66 :  (MACRO-2)                  alu4i   RL8,RL8,1,adi,adci              ;and add 1
(1)  371/    1A66 : 89                          glo     RL8    ;long regs are equated to the second reg which has the low order word 
(1)  371/    1A67 : FC 01                       ADI     (1)&255
(1)  371/    1A69 : A9                          plo     RL8
(1)  371/    1A6A : 99                          ghi     RL8
(1)  371/    1A6B : 7C 00                       ADCI     ((1)>>8)&255; 
(1)  371/    1A6D : B9                          phi     RL8
(1)  371/    1A6E : 88                          glo     RL8-1
(1)  371/    1A6F : 7C 00                       ADCI     ((1)>>16)&255; 
(1)  371/    1A71 : A8                          plo     RL8-1
(1)  371/    1A72 : 98                          ghi     RL8-1
(1)  371/    1A73 : 7C 00                       ADCI     ((1)>>24)&255; 
(1)  371/    1A75 : B8                          phi     RL8-1
(1)  372/    1A76 :                     $$done:
(1)  373/    1A76 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  373/    1A76 : =>FALSE              if MOMCPU=$1805
(1)  373/    1A76 :                             sret    6
(1)  373/    1A76 : =>TRUE               else
(1)  373/    1A76 : D5                          sep     RRET
(1)  373/    1A77 : [373]                endif
(1)  374/    1A77 : [269]                ENDIF
(1)  375/    1A77 : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math
(1)  376/    1A77 :                     _dubdabx:	
(1)  377/    1A77 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  378/    1A77 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  379/    1A77 :                     ;long interger is passed in rp1p2
(1)  380/    1A77 :                     ;buffer pointer is passed at sp+2+4**+1 for 1806
(1)  381/    1A77 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 123 - 1/18/2018 14:51:20


(1)  382/    1A77 :                     ;r8-11 are used as temps
(1)  383/    1A77 :                     ;r8 is the working pointer
(1)  384/    1A77 :                     ;r15.0 is bit count(32) and the return value register
(1)  385/    1A77 :                     ;r9.0 is digit count
(1)  386/    1A77 :                     ;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
(1)  387/    1A77 : (MACRO)             	ld2 r8,'O',sp,(2+4+1); pick up the buffer pointer
(1)  387/    1A77 : =>TRUE                      if      ('O'='O')
(1)  387/    1A77 :  (MACRO-2)                          ldAX    memAddr,SP,(2+4+1)
(1)  387/    1A77 : 82                          glo     SP
(1)  387/    1A78 : FC 07                       adi     ((2+4+1))#256
(1)  387/    1A7A : AE                          plo     MEMADDR
(1)  387/    1A7B : 92                          ghi     SP
(1)  387/    1A7C : 7C 00                       adci    ((2+4+1))>>8; was/256
(1)  387/    1A7E : BE                          phi     MEMADDR
(1)  387/    1A7F : =>FALSE                     else
(1)  387/    1A7F :                                     ldAD    memAddr,SP
(1)  387/    1A7F : [387]                       endif
(1)  387/    1A7F : 4E                          lda     memAddr
(1)  387/    1A80 : B8                          phi     R8
(1)  387/    1A81 : 0E                          ldn     memAddr
(1)  387/    1A82 : A8                          plo     R8
(1)  388/    1A83 : (MACRO)             	ld2 r10,'O',sp,(2+4+2+1); pick up the number of digits wanted
(1)  388/    1A83 : =>TRUE                      if      ('O'='O')
(1)  388/    1A83 :  (MACRO-2)                          ldAX    memAddr,SP,(2+4+2+1)
(1)  388/    1A83 : 82                          glo     SP
(1)  388/    1A84 : FC 09                       adi     ((2+4+2+1))#256
(1)  388/    1A86 : AE                          plo     MEMADDR
(1)  388/    1A87 : 92                          ghi     SP
(1)  388/    1A88 : 7C 00                       adci    ((2+4+2+1))>>8; was/256
(1)  388/    1A8A : BE                          phi     MEMADDR
(1)  388/    1A8B : =>FALSE                     else
(1)  388/    1A8B :                                     ldAD    memAddr,SP
(1)  388/    1A8B : [388]                       endif
(1)  388/    1A8B : 4E                          lda     memAddr
(1)  388/    1A8C : BA                          phi     R10
(1)  388/    1A8D : 0E                          ldn     memAddr
(1)  388/    1A8E : AA                          plo     R10
(1)  389/    1A8F : (MACRO)             	cpy2 r15,r8 ;save address for now
(1)  389/    1A8F : 88                          glo     R8
(1)  389/    1A90 : AF                          plo     R15
(1)  389/    1A91 : 98                          ghi     R8
(1)  389/    1A92 : BF                          phi     R15
(1)  390/    1A93 : F8 0B               	ldi 11	;digit count+1 for trailing 0
(1)  391/    1A95 : A9                  	plo r9
(1)  392/    1A96 :                     $$clrlp:	;clear the passed buffer
(1)  393/    1A96 : F8 00               	ldi 0	
(1)  394/    1A98 : 58                  	str r8	;clear a byte
(1)  395/    1A99 : 18                  	inc r8
(1)  396/    1A9A : 29                  	dec r9
(1)  397/    1A9B : 89                  	glo r9	;check the count
(1)  398/    1A9C : 3A 96               	bnz $$clrlp ;back for more
(1)  399/    1A9E : (MACRO)             	cpy2 r8,r15 ;get the address back
(1)  399/    1A9E : 8F                          glo     R15
(1)  399/    1A9F : A8                          plo     R8
(1)  399/    1AA0 : 9F                          ghi     R15
(1)  399/    1AA1 : B8                          phi     R8
(1)  400/    1AA2 :                     
(1)  401/    1AA2 : F8 20               	ldi 32	;bit count
(1)  402/    1AA4 : AF                  	plo r15
(1)  403/    1AA5 :                     ;now i'm going to spin off any leading 0's in the binary number
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 124 - 1/18/2018 14:51:20


(1)  404/    1AA5 :                     $$cktop:
(1)  405/    1AA5 : 9C                  	ghi rp1p2-1	;get the top bit of the number
(1)  406/    1AA6 : FE                  	shl		;check for a 1
(1)  407/    1AA7 : 33 A7               	bdf $$bitloop	;move on if we have one
(1)  408/    1AA9 : (MACRO)             	shl4 rp1p2	;shift the input number
(1)  408/    1AA9 : 8D                          glo     RP1P2     ;start with low byte of second register
(1)  408/    1AAA : FE                          shl             ;shift left once
(1)  408/    1AAB : AD                          plo     RP1P2     ; save it
(1)  408/    1AAC : 9D                          ghi     RP1P2     ;high byte of second RP1P2
(1)  408/    1AAD : 7E                          shlc            ;shift one bit carrying
(1)  408/    1AAE : BD                          phi     RP1P2     ;save it
(1)  408/    1AAF : 8C                          glo     RP1P2-1   ;now the bottom byte of top RP1P2
(1)  408/    1AB0 : 7E                          shlc
(1)  408/    1AB1 : AC                          plo     RP1P2-1
(1)  408/    1AB2 : 9C                          ghi     RP1P2-1   ;finally the top byte of the high order RP1P2
(1)  408/    1AB3 : 7E                          shlc            ;gets the last shift
(1)  408/    1AB4 : BC                          phi     RP1P2-1   ;and we're done
(1)  409/    1AB5 : 2F                  	dec r15		;reduce the number of times to shift
(1)  410/    1AB6 : 8F                  	glo r15
(1)  411/    1AB7 : 3A A5               	bnz $$cktop	;
(1)  412/    1AB9 : 1F                  	inc r15		;our whole number was 0 but force at least one pass
(1)  413/    1ABA :                     $$bitloop:
(1)  414/    1ABA : F8 0A               	ldi 10	;digit count
(1)  415/    1ABC : A9                  	plo r9
(1)  416/    1ABD :                     $$dcklp:
(1)  417/    1ABD : 08                  	ldn r8 	;pick up a digit
(1)  418/    1ABE : FF 05               	smi 5	;see if it's greater than 4
(1)  419/    1AC0 : 3B C0               	bnf $$dnoadd ;if not, bypass add
(1)  420/    1AC2 : FC 08               	adi 0x08	;add the 5 black and 3 more
(1)  421/    1AC4 : 58                  	str r8	;put it back
(1)  422/    1AC5 :                     $$dnoadd:
(1)  423/    1AC5 : 18                  	inc r8
(1)  424/    1AC6 : 29                  	dec r9	;decrement digit count
(1)  425/    1AC7 : 89                  	glo r9
(1)  426/    1AC8 : 3A BD               	bnz $$dcklp ;and back for next digit
(1)  427/    1ACA :                     	
(1)  428/    1ACA : (MACRO)             	shl4 rp1p2 ;shift the input number
(1)  428/    1ACA : 8D                          glo     RP1P2     ;start with low byte of second register
(1)  428/    1ACB : FE                          shl             ;shift left once
(1)  428/    1ACC : AD                          plo     RP1P2     ; save it
(1)  428/    1ACD : 9D                          ghi     RP1P2     ;high byte of second RP1P2
(1)  428/    1ACE : 7E                          shlc            ;shift one bit carrying
(1)  428/    1ACF : BD                          phi     RP1P2     ;save it
(1)  428/    1AD0 : 8C                          glo     RP1P2-1   ;now the bottom byte of top RP1P2
(1)  428/    1AD1 : 7E                          shlc
(1)  428/    1AD2 : AC                          plo     RP1P2-1
(1)  428/    1AD3 : 9C                          ghi     RP1P2-1   ;finally the top byte of the high order RP1P2
(1)  428/    1AD4 : 7E                          shlc            ;gets the last shift
(1)  428/    1AD5 : BC                          phi     RP1P2-1   ;and we're done
(1)  429/    1AD6 :                     	
(1)  430/    1AD6 : F8 0A               	ldi 10	;load the digit count again
(1)  431/    1AD8 : A9                  	plo r9
(1)  432/    1AD9 :                     ;r8 is now just past the units location and ready to walk back
(1)  433/    1AD9 :                     $$dshlp:
(1)  434/    1AD9 : 28                  	dec r8	;walk back from 0's position
(1)  435/    1ADA : 08                  	ldn r8	;get the digit back
(1)  436/    1ADB : 7E                  	shlc	;continue the shift
(1)  437/    1ADC : BF                  	phi r15 ;save it for the carry test
(1)  438/    1ADD : FA 0F               	ani 0x0f ;clear the 10 bit
(1)  439/    1ADF : 58                  	str r8	;put the digit back
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 125 - 1/18/2018 14:51:20


(1)  440/    1AE0 : 9F                  	ghi r15	;now test for carry
(1)  441/    1AE1 : FF 10               	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  442/    1AE3 : 29                  	dec r9	;decrement the digit count
(1)  443/    1AE4 : 89                  	glo r9
(1)  444/    1AE5 : 3A D9               	bnz $$dshlp ;back for more if needed
(1)  445/    1AE7 :                     	
(1)  446/    1AE7 : 2F                  	dec r15
(1)  447/    1AE8 : 8F                  	glo r15
(1)  448/    1AE9 : 3A BA               	bnz $$bitloop
(1)  449/    1AEB :                     	
(1)  450/    1AEB : (MACRO)             	cpy2 r15,r8	;save the starting location of the digits
(1)  450/    1AEB : 88                          glo     R8
(1)  450/    1AEC : AF                          plo     R15
(1)  450/    1AED : 98                          ghi     R8
(1)  450/    1AEE : BF                          phi     R15
(1)  451/    1AEF : F8 0A               	ldi 10		;digit count again
(1)  452/    1AF1 : A9                  	plo r9
(1)  453/    1AF2 :                     $$upnxt:
(1)  454/    1AF2 : 08                  	ldn r8		;get digit
(1)  455/    1AF3 : F9 30               	ori 0x30	;make ascii
(1)  456/    1AF5 : 58                  	str r8		;put it back
(1)  457/    1AF6 : 18                  	inc r8		;next digit
(1)  458/    1AF7 : 29                  	dec r9		;counter
(1)  459/    1AF8 : 89                  	glo r9
(1)  460/    1AF9 : 3A F2               	bnz $$upnxt	;upgrade all 10 spots
(1)  461/    1AFB : (MACRO)             	ldaX memaddr,sp,(2+4+2+1+1)	;point to lsb of desired digit count
(1)  461/    1AFB : 82                          glo     SP
(1)  461/    1AFC : FC 0A                       adi     ((2+4+2+1+1))#256
(1)  461/    1AFE : AE                          plo     MEMADDR
(1)  461/    1AFF : 92                          ghi     SP
(1)  461/    1B00 : 7C 00                       adci    ((2+4+2+1+1))>>8; was/256
(1)  461/    1B02 : BE                          phi     MEMADDR
(1)  462/    1B03 : EE                  	sex memaddr	;set up
(1)  463/    1B04 : F8 0A               	ldi 10		;max number of 0's to skip
(1)  464/    1B06 : F7                  	sm		;desired number of digits to skip
(1)  465/    1B07 : E2                  	sex sp		;reset index register
(1)  466/    1B08 : A9                  	plo r9		;number of leading 0's to skip
(1)  467/    1B09 :                     $$cknext:
(1)  468/    1B09 : 0F                  	ldn r15		;check digit
(1)  469/    1B0A : FF 30               	smi 0x30	;for '0'
(1)  470/    1B0C : 3A 0C               	bnz $$done
(1)  471/    1B0E : 1F                  	inc r15		;next digit
(1)  472/    1B0F : 29                  	dec r9		;reduce count
(1)  473/    1B10 : 89                  	glo r9
(1)  474/    1B11 : 3A 09               	bnz $$cknext
(1)  475/    1B13 :                     $$done:
(1)  476/    1B13 : (MACRO)             	cretn
(1)  476/    1B13 : =>FALSE              if MOMCPU=$1805
(1)  476/    1B13 :                             sret    6
(1)  476/    1B13 : =>TRUE               else
(1)  476/    1B13 : D5                          sep     RRET
(1)  476/    1B14 : [476]                endif
(1)  477/    1B14 : [375]                ENDIF	
(1)  478/    1B14 : =>UNDEFINED          IFNDEF  LCCNOLONG		;wjr 17-04-09 disable 32 bit math	
(1)  479/    1B14 :                     _modU4:	;32 bit unsigned remainder
(1)  480/    1B14 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  481/    1B14 : (MACRO)                 Ccall _divU4
(1)  481/    1B14 : =>FALSE              if MOMCPU=$1805
(1)  481/    1B14 :                             SCAL    6
(1)  481/    1B14 :                             dw      _DIVU4
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(lcc1802epiloNW.inc) - page 126 - 1/18/2018 14:51:20


(1)  481/    1B14 : =>TRUE               else
(1)  481/    1B14 : D4                          sep     RCALL
(1)  481/    1B15 : 19 00                       dw      _DIVU4
(1)  481/    1B17 : [481]                endif
(1)  482/    1B17 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  482/    1B17 :  (MACRO-2)                  cpy2    RL8,RP1P2 ;long reg pairs are addressed as the low order pair
(1)  482/    1B17 : 8D                          glo     RP1P2
(1)  482/    1B18 : A9                          plo     RL8
(1)  482/    1B19 : 9D                          ghi     RP1P2
(1)  482/    1B1A : B9                          phi     RL8
(1)  482/    1B1B :  (MACRO-2)                  cpy2    RL8-1,RP1P2-1
(1)  482/    1B1B : 8C                          glo     RP1P2-1
(1)  482/    1B1C : A8                          plo     RL8-1
(1)  482/    1B1D : 9C                          ghi     RP1P2-1
(1)  482/    1B1E : B8                          phi     RL8-1
(1)  483/    1B1F : (MACRO)                 Cretn
(1)  483/    1B1F : =>FALSE              if MOMCPU=$1805
(1)  483/    1B1F :                             sret    6
(1)  483/    1B1F : =>TRUE               else
(1)  483/    1B1F : D5                          sep     RRET
(1)  483/    1B20 : [483]                endif
(1)  484/    1B20 :                         
(1)  485/    1B20 :                     _modI4:	;32 bit signed remainder
(1)  486/    1B20 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  487/    1B20 : (MACRO)                 Ccall _divI4
(1)  487/    1B20 : =>FALSE              if MOMCPU=$1805
(1)  487/    1B20 :                             SCAL    6
(1)  487/    1B20 :                             dw      _DIVI4
(1)  487/    1B20 : =>TRUE               else
(1)  487/    1B20 : D4                          sep     RCALL
(1)  487/    1B21 : 1A 00                       dw      _DIVI4
(1)  487/    1B23 : [487]                endif
(1)  488/    1B23 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  488/    1B23 :  (MACRO-2)                  cpy2    RL8,RP1P2 ;long reg pairs are addressed as the low order pair
(1)  488/    1B23 : 8D                          glo     RP1P2
(1)  488/    1B24 : A9                          plo     RL8
(1)  488/    1B25 : 9D                          ghi     RP1P2
(1)  488/    1B26 : B9                          phi     RL8
(1)  488/    1B27 :  (MACRO-2)                  cpy2    RL8-1,RP1P2-1
(1)  488/    1B27 : 8C                          glo     RP1P2-1
(1)  488/    1B28 : A8                          plo     RL8-1
(1)  488/    1B29 : 9C                          ghi     RP1P2-1
(1)  488/    1B2A : B8                          phi     RL8-1
(1)  489/    1B2B : (MACRO)                 Cretn
(1)  489/    1B2B : =>FALSE              if MOMCPU=$1805
(1)  489/    1B2B :                             sret    6
(1)  489/    1B2B : =>TRUE               else
(1)  489/    1B2B : D5                          sep     RRET
(1)  489/    1B2C : [489]                endif
(1)  490/    1B2C : [478]                ENDIF	
(1)  491/    1B2C :                     
    1718/    1B2C :                     	include LCC1802fp.inc
(1)    1/    1B2C :                     ;17-03-06 changing sep rret to cretn, sep rcall to ccall
(1)    2/    1B2C :                     ;from http://www.elf-emulation.com/software/fp.asm - thanks to mike Reilley
(1)    3/    1B2C :                     ;maybe originally from RCA
(1)    4/    1B2C :                     ;these routines use ALL the registers from 6-15!
(1)    5/    1B2C :                     ;8-15 were more or less available to start with
(1)    6/    1B2C :                     ;it saves 6 when it uses it
(1)    7/    1B2C :                     ;I save 7 on entry and restore on exit
(1)    8/    1B2C :                     ;to keep my sanity I renamed some register equates where I was changing them e.g. F7 used to be RB
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 127 - 1/18/2018 14:51:20


(1)    9/    1B2C : =BH                 FB	equ	11	;was R9
(1)   10/    1B2C : =9H                 F9	equ	9	;was R7
(1)   11/    1B2C : =7H                 F7	equ	7	;was RB
(1)   12/    1B2C :                     ;April 1 added code to fp_add to restore resgisters when returning a 0 - around add_nz:
(1)   13/    1B2C :                     ; *** Convert signed long to float
(1)   14/    1B2C :                     ; *** RL8-1:RL8 is the number to convert(8:9)
(1)   15/    1B2C :                     ; *** result in same register
(1)   16/    1B2C :                     ; *** uses memaddr.1 for sign, .0 for shift count/exponent
(1)   17/    1B2C :                     	align 256
(1)   18/    1C00 : F8 00               cvif4:	ldi	0
(1)   19/    1C02 : BE                  	phi	memaddr	;sign
(1)   20/    1C03 : F8 96               	ldi	150	;150 is  the 127 exponent bias plus the 23 required to shift a long 1 to bit 23
(1)   21/    1C05 : AE                  	plo	memaddr	;
(1)   22/    1C06 : 98                  	ghi	RL8-1	;get sign and bits 7-1 of exponent
(1)   23/    1C07 : 32 07               	bz	$$nxt	;keep testing for 0
(1)   24/    1C09 : FE                  	shl		;sign bit to df
(1)   25/    1C0A : 3B 0A               	bnf	$$sgnpos ;number is >0
(1)   26/    1C0C : 76                  	shrc		;shift it back so we know byte is non-zerro
(1)   27/    1C0D : BE                  	phi	memaddr	;save it
(1)   28/    1C0E : (MACRO)             	negi4	RL8,RL8	;flip the number
(1)   28/    1C0E :  (MACRO-2)                  alu4I   RL8,RL8,0xffffffff,xri,xri      ;flip all the bits
(1)   28/    1C0E : 89                          glo     RL8    ;long regs are equated to the second reg which has the low order word 
(1)   28/    1C0F : FB FF                       XRI     (0XFFFFFFFF)&255
(1)   28/    1C11 : A9                          plo     RL8
(1)   28/    1C12 : 99                          ghi     RL8
(1)   28/    1C13 : FB FF                       XRI     ((0XFFFFFFFF)>>8)&255; 
(1)   28/    1C15 : B9                          phi     RL8
(1)   28/    1C16 : 88                          glo     RL8-1
(1)   28/    1C17 : FB FF                       XRI     ((0XFFFFFFFF)>>16)&255; 
(1)   28/    1C19 : A8                          plo     RL8-1
(1)   28/    1C1A : 98                          ghi     RL8-1
(1)   28/    1C1B : FB FF                       XRI     ((0XFFFFFFFF)>>24)&255; 
(1)   28/    1C1D : B8                          phi     RL8-1
(1)   28/    1C1E :  (MACRO-2)                  alu4i   RL8,RL8,1,adi,adci              ;and add 1
(1)   28/    1C1E : 89                          glo     RL8    ;long regs are equated to the second reg which has the low order word 
(1)   28/    1C1F : FC 01                       ADI     (1)&255
(1)   28/    1C21 : A9                          plo     RL8
(1)   28/    1C22 : 99                          ghi     RL8
(1)   28/    1C23 : 7C 00                       ADCI     ((1)>>8)&255; 
(1)   28/    1C25 : B9                          phi     RL8
(1)   28/    1C26 : 88                          glo     RL8-1
(1)   28/    1C27 : 7C 00                       ADCI     ((1)>>16)&255; 
(1)   28/    1C29 : A8                          plo     RL8-1
(1)   28/    1C2A : 98                          ghi     RL8-1
(1)   28/    1C2B : 7C 00                       ADCI     ((1)>>24)&255; 
(1)   28/    1C2D : B8                          phi     RL8-1
(1)   29/    1C2E : 30 2E               	br	$$sgnpos ;go handle positive long
(1)   30/    1C30 : 88                  $$nxt:	glo	RL8-1	;next byte
(1)   31/    1C31 : 3A 31               	bnz	$$sgnpos ;sign is positive, number is not 0
(1)   32/    1C33 : 99                  	ghi	RL8	;next byte
(1)   33/    1C34 : 3A 34               	bnz	$$sgnpos ;sign is positive, number is not 0
(1)   34/    1C36 : 89                  	glo	RL8	;last byte
(1)   35/    1C37 : 32 37               	bz	$$done	;the whole thing is zero so we're done
(1)   36/    1C39 : 98                  $$sgnpos: ghi	RL8-1	;top byte - begin shifting right to clear it
(1)   37/    1C3A : 32 3A               	bz	$$shl	;if it's zero we're done right shifting
(1)   38/    1C3C : 1E                  	inc	memaddr	;increase exponent 1 for each right shift
(1)   39/    1C3D : (MACRO)             	shru4	RL8
(1)   39/    1C3D : 98                          ghi     RL8-1   ;long RL8 pairs start at RL8-1
(1)   39/    1C3E : F6                          shr             ;shift one bit 
(1)   39/    1C3F : B8                          phi     RL8-1
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 128 - 1/18/2018 14:51:20


(1)   39/    1C40 : 88                          glo     RL8-1
(1)   39/    1C41 : 76                          shrc            ;continue the shift
(1)   39/    1C42 : A8                          plo     RL8-1
(1)   39/    1C43 : 99                          ghi     RL8     ;get the top byte of the low order RL8
(1)   39/    1C44 : 76                          shrc            ;continue the shift
(1)   39/    1C45 : B9                          phi     RL8
(1)   39/    1C46 : 89                          glo     RL8     ;finish with the low byte of the 2nd RL8 of the pair
(1)   39/    1C47 : 76                          shrc
(1)   39/    1C48 : A9                          plo     RL8
(1)   40/    1C49 : 30 39               	br	$$sgnpos
(1)   41/    1C4B : 88                  $$shl:	glo	RL8-1	;check bit 23
(1)   42/    1C4C : FA 80               	ani	0x80	;isolate it
(1)   43/    1C4E : 3A 4E               	bnz	$$shdn	;if it's on we're done here
(1)   44/    1C50 : 2E                  	dec	memaddr	;decrease exponent 1 for each left shift
(1)   45/    1C51 : (MACRO)             	shl4	RL8	;shift mantissa left one
(1)   45/    1C51 : 89                          glo     RL8     ;start with low byte of second register
(1)   45/    1C52 : FE                          shl             ;shift left once
(1)   45/    1C53 : A9                          plo     RL8     ; save it
(1)   45/    1C54 : 99                          ghi     RL8     ;high byte of second RL8
(1)   45/    1C55 : 7E                          shlc            ;shift one bit carrying
(1)   45/    1C56 : B9                          phi     RL8     ;save it
(1)   45/    1C57 : 88                          glo     RL8-1   ;now the bottom byte of top RL8
(1)   45/    1C58 : 7E                          shlc
(1)   45/    1C59 : A8                          plo     RL8-1
(1)   45/    1C5A : 98                          ghi     RL8-1   ;finally the top byte of the high order RL8
(1)   45/    1C5B : 7E                          shlc            ;gets the last shift
(1)   45/    1C5C : B8                          phi     RL8-1   ;and we're done
(1)   46/    1C5D : 30 4B               	br	$$shl
(1)   47/    1C5F : 8E                  $$shdn:	glo	memaddr	;get the exponent
(1)   48/    1C60 : F6                  	shr		;shift right so it can go into bits 31-24
(1)   49/    1C61 : B8                  	phi	RL8-1	;put top bits of exponent into place
(1)   50/    1C62 : 33 62               	bdf	$$setsgn ;if the bit 0 is on we're done
(1)   51/    1C64 : 88                  	glo	RL8-1	;get the byte
(1)   52/    1C65 : FA 7F               	ani	0x7f	;clear bit 23
(1)   53/    1C67 : A8                  	plo	RL8-1	;put it back
(1)   54/    1C68 : 9E                  $$setsgn: ghi	memaddr	;get the original sign byte
(1)   55/    1C69 : 32 69               	bz	$$done	;sign bit is already zero so we're done
(1)   56/    1C6B : 98                  	ghi	RL8-1	;get the sign byte
(1)   57/    1C6C : F9 80               	ori	0x80	;set the sign bit
(1)   58/    1C6E : B8                  	phi	RL8-1	;place it
(1)   59/    1C6F : (MACRO)             $$done:	Cretn		;and we're done
(1)   59/    1C6F : =>FALSE              if MOMCPU=$1805
(1)   59/    1C6F :                             sret    6
(1)   59/    1C6F : =>TRUE               else
(1)   59/    1C6F : D5                          sep     RRET
(1)   59/    1C70 : [59]                 endif
(1)   60/    1C70 :                     	
(1)   61/    1C70 :                     
(1)   62/    1C70 :                     
(1)   63/    1C70 :                     ; *** Convert float to signed long
(1)   64/    1C70 :                     ; *** RL8-1:RL8 is the number to convert(8:9)
(1)   65/    1C70 :                     ; *** result in same register
(1)   66/    1C70 :                     	align 256
(1)   67/    1D00 :                     cvfi4:
(1)   68/    1D00 : 98                  	ghi	RL8-1	;get sign and bits 7-1 of exponent
(1)   69/    1D01 : BE                  	phi	memaddr ;save for later
(1)   70/    1D02 : 88                  	glo	RL8-1	;get bit 0 of exponent
(1)   71/    1D03 : FE                  	shl		;shift to df
(1)   72/    1D04 : 9E                  	ghi	memaddr	;get exponent 7-1
(1)   73/    1D05 : 7E                  	shlc		;combine with 0
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 129 - 1/18/2018 14:51:20


(1)   74/    1D06 :                     ;the following sequence is equivalent to sdi 150; I did it this way to coddle my emulator which doesn't do this properly.
(1)   75/    1D06 : 22                  	dec	sp
(1)   76/    1D07 : 52                  	str	sp
(1)   77/    1D08 : F8 96               	ldi	150
(1)   78/    1D0A : F7                  	sm		;calculate shift count needed
(1)   79/    1D0B :                     ;*******note - the df flag set here is tested later
(1)   80/    1D0B : AE                  	plo	memaddr
(1)   81/    1D0C : 12                  	inc	sp	;release work area
(1)   82/    1D0D :                     ;end of sdi 150 sequence - now convert the mantissa to unsigned long
(1)   83/    1D0D : F8 00               	ldi	0
(1)   84/    1D0F : B8                  	phi	RL8-1	;clear the top byte of the float
(1)   85/    1D10 : 88                  	glo	RL8-1	;get the next byte
(1)   86/    1D11 : F9 80               	ori	0x80	;add in the implied 1 bit
(1)   87/    1D13 : A8                  	plo	RL8-1	;put it back
(1)   88/    1D14 : 8E                  	glo	memaddr	;make sure there's at least 1 shift
(1)   89/    1D15 : 32 15               	bz	$$sign
(1)   90/    1D17 :                     ;**********note df is set from subtraction before setting mantissa
(1)   91/    1D17 : 3B 17               	bnf	$$lsh ; if the shift count is negative
(1)   92/    1D19 :                     
(1)   93/    1D19 : (MACRO)             $$shr:	shru4	RL8
(1)   93/    1D19 : 98                          ghi     RL8-1   ;long RL8 pairs start at RL8-1
(1)   93/    1D1A : F6                          shr             ;shift one bit 
(1)   93/    1D1B : B8                          phi     RL8-1
(1)   93/    1D1C : 88                          glo     RL8-1
(1)   93/    1D1D : 76                          shrc            ;continue the shift
(1)   93/    1D1E : A8                          plo     RL8-1
(1)   93/    1D1F : 99                          ghi     RL8     ;get the top byte of the low order RL8
(1)   93/    1D20 : 76                          shrc            ;continue the shift
(1)   93/    1D21 : B9                          phi     RL8
(1)   93/    1D22 : 89                          glo     RL8     ;finish with the low byte of the 2nd RL8 of the pair
(1)   93/    1D23 : 76                          shrc
(1)   93/    1D24 : A9                          plo     RL8
(1)   94/    1D25 : 2E                  	dec	memaddr	;check shift count
(1)   95/    1D26 : 8E                  	glo	memaddr
(1)   96/    1D27 : 3A 19               	bnz	$$shr	;complete the shift
(1)   97/    1D29 : 30 29               	br	$$sign
(1)   98/    1D2B :                     
(1)   99/    1D2B :                     ;handle negative shift as best I can - gigo
(1)  100/    1D2B : (MACRO)             $$lsh: 	shl4	RL8	;shift once
(1)  100/    1D2B : 89                          glo     RL8     ;start with low byte of second register
(1)  100/    1D2C : FE                          shl             ;shift left once
(1)  100/    1D2D : A9                          plo     RL8     ; save it
(1)  100/    1D2E : 99                          ghi     RL8     ;high byte of second RL8
(1)  100/    1D2F : 7E                          shlc            ;shift one bit carrying
(1)  100/    1D30 : B9                          phi     RL8     ;save it
(1)  100/    1D31 : 88                          glo     RL8-1   ;now the bottom byte of top RL8
(1)  100/    1D32 : 7E                          shlc
(1)  100/    1D33 : A8                          plo     RL8-1
(1)  100/    1D34 : 98                          ghi     RL8-1   ;finally the top byte of the high order RL8
(1)  100/    1D35 : 7E                          shlc            ;gets the last shift
(1)  100/    1D36 : B8                          phi     RL8-1   ;and we're done
(1)  101/    1D37 : 1E                  	inc	memaddr
(1)  102/    1D38 : 8E                  	glo	memaddr
(1)  103/    1D39 : 3A 2B               	bnz	$$lsh	
(1)  104/    1D3B :                     	
(1)  105/    1D3B : 9E                  $$sign:	ghi	memaddr	;now the sign
(1)  106/    1D3C : FE                  	shl		;shift sign bit into df
(1)  107/    1D3D : 3B 3D               	bnf	$$done
(1)  108/    1D3F : (MACRO)             	negi4	RL8,RL8	;negate the number if needed
(1)  108/    1D3F :  (MACRO-2)                  alu4I   RL8,RL8,0xffffffff,xri,xri      ;flip all the bits
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 130 - 1/18/2018 14:51:20


(1)  108/    1D3F : 89                          glo     RL8    ;long regs are equated to the second reg which has the low order word 
(1)  108/    1D40 : FB FF                       XRI     (0XFFFFFFFF)&255
(1)  108/    1D42 : A9                          plo     RL8
(1)  108/    1D43 : 99                          ghi     RL8
(1)  108/    1D44 : FB FF                       XRI     ((0XFFFFFFFF)>>8)&255; 
(1)  108/    1D46 : B9                          phi     RL8
(1)  108/    1D47 : 88                          glo     RL8-1
(1)  108/    1D48 : FB FF                       XRI     ((0XFFFFFFFF)>>16)&255; 
(1)  108/    1D4A : A8                          plo     RL8-1
(1)  108/    1D4B : 98                          ghi     RL8-1
(1)  108/    1D4C : FB FF                       XRI     ((0XFFFFFFFF)>>24)&255; 
(1)  108/    1D4E : B8                          phi     RL8-1
(1)  108/    1D4F :  (MACRO-2)                  alu4i   RL8,RL8,1,adi,adci              ;and add 1
(1)  108/    1D4F : 89                          glo     RL8    ;long regs are equated to the second reg which has the low order word 
(1)  108/    1D50 : FC 01                       ADI     (1)&255
(1)  108/    1D52 : A9                          plo     RL8
(1)  108/    1D53 : 99                          ghi     RL8
(1)  108/    1D54 : 7C 00                       ADCI     ((1)>>8)&255; 
(1)  108/    1D56 : B9                          phi     RL8
(1)  108/    1D57 : 88                          glo     RL8-1
(1)  108/    1D58 : 7C 00                       ADCI     ((1)>>16)&255; 
(1)  108/    1D5A : A8                          plo     RL8-1
(1)  108/    1D5B : 98                          ghi     RL8-1
(1)  108/    1D5C : 7C 00                       ADCI     ((1)>>24)&255; 
(1)  108/    1D5E : B8                          phi     RL8-1
(1)  109/    1D5F : 30 5F               	br	$$done	; and return
(1)  110/    1D61 :                     
(1)  111/    1D61 : (MACRO)             $$done:	Cretn		;and we're done
(1)  111/    1D61 : =>FALSE              if MOMCPU=$1805
(1)  111/    1D61 :                             sret    6
(1)  111/    1D61 : =>TRUE               else
(1)  111/    1D61 : D5                          sep     RRET
(1)  111/    1D62 : [111]                endif
(1)  112/    1D62 :                     
(1)  113/    1D62 :                     ; *** Check if character is numeric
(1)  114/    1D62 :                     ; *** D - char to check
(1)  115/    1D62 :                     ; *** Returns DF=1 if numeric
(1)  116/    1D62 :                     ; ***         DF=0 if not
(1)  117/    1D62 : AE                  f_isnum:   plo     r14                 ; save a copy
(1)  118/    1D63 : FF 30                          smi     '0'                 ; check for below zero
(1)  119/    1D65 : 3B 65                          bnf     fails               ; jump if below
(1)  120/    1D67 : FF 0A                          smi     10                  ; see if above
(1)  121/    1D69 : 33 69                          bdf     fails               ; fails if so
(1)  122/    1D6B : FF 00               passes:    smi     0                   ; signal success
(1)  123/    1D6D : C8                             lskp
(1)  124/    1D6E : FC 00               fails:     adi     0                   ; signal failure
(1)  125/    1D70 : 8E                             glo     r14                 ; recover character
(1)  126/    1D71 : (MACRO)                        cretn	                ; and return; ******************************* 17-03-06
(1)  126/    1D71 : =>FALSE              if MOMCPU=$1805
(1)  126/    1D71 :                             sret    6
(1)  126/    1D71 : =>TRUE               else
(1)  126/    1D71 : D5                          sep     RRET
(1)  126/    1D72 : [126]                endif
(1)  127/    1D72 :                     ; *** Shift R8:F9 right 1 bit ***
(1)  128/    1D72 :                     ; *******************************
(1)  129/    1D72 : 98                  fp_shr_1:  ghi   r8                    ; shift high word right
(1)  130/    1D73 : F6                             shr
(1)  131/    1D74 : B8                             phi   r8
(1)  132/    1D75 : 88                             glo   r8
(1)  133/    1D76 : 76                             shrc
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 131 - 1/18/2018 14:51:20


(1)  134/    1D77 : A8                             plo   r8
(1)  135/    1D78 : 99                             ghi   F9                    ; shift low word right
(1)  136/    1D79 : 76                             shrc
(1)  137/    1D7A : B9                             phi   F9
(1)  138/    1D7B : 89                             glo   F9
(1)  139/    1D7C : 76                             shrc
(1)  140/    1D7D : A9                             plo   F9
(1)  141/    1D7E : (MACRO)                        Cretn
(1)  141/    1D7E : =>FALSE              if MOMCPU=$1805
(1)  141/    1D7E :                             sret    6
(1)  141/    1D7E : =>TRUE               else
(1)  141/    1D7E : D5                          sep     RRET
(1)  141/    1D7F : [141]                endif
(1)  142/    1D7F :                     
(1)  143/    1D7F :                     ; ******************************
(1)  144/    1D7F :                     ; *** Shift R8:F9 left 1 bit ***
(1)  145/    1D7F :                     ; ******************************
(1)  146/    1D7F : 89                  fp_shl_1:  glo   F9
(1)  147/    1D80 : FE                             shl
(1)  148/    1D81 : A9                             plo   F9
(1)  149/    1D82 : 99                             ghi   F9
(1)  150/    1D83 : 7E                             shlc
(1)  151/    1D84 : B9                             phi   F9
(1)  152/    1D85 : 88                             glo   r8
(1)  153/    1D86 : 7E                             shlc
(1)  154/    1D87 : A8                             plo   r8
(1)  155/    1D88 : 98                             ghi   r8
(1)  156/    1D89 : 7E                             shlc
(1)  157/    1D8A : B8                             phi   r8
(1)  158/    1D8B : (MACRO)                        cretn	;17-03-06
(1)  158/    1D8B : =>FALSE              if MOMCPU=$1805
(1)  158/    1D8B :                             sret    6
(1)  158/    1D8B : =>TRUE               else
(1)  158/    1D8B : D5                          sep     RRET
(1)  158/    1D8C : [158]                endif
(1)  159/    1D8C :                     
(1)  160/    1D8C :                     ; **********************
(1)  161/    1D8C :                     ; *** R8:F9 += RA:FB ***
(1)  162/    1D8C :                     ; **********************
(1)  163/    1D8C : 8B                  fp_add_12: glo   FB
(1)  164/    1D8D : 22                  	   dec r2	;wjr - make a work area
(1)  165/    1D8E : 52                             str   r2
(1)  166/    1D8F : 89                             glo   F9
(1)  167/    1D90 : F4                             add
(1)  168/    1D91 : A9                             plo   F9
(1)  169/    1D92 : 9B                             ghi   FB
(1)  170/    1D93 : 52                             str   r2
(1)  171/    1D94 : 99                             ghi   F9
(1)  172/    1D95 : 74                             adc
(1)  173/    1D96 : B9                             phi   F9
(1)  174/    1D97 : 8A                             glo   R10
(1)  175/    1D98 : 52                             str   r2
(1)  176/    1D99 : 88                             glo   r8
(1)  177/    1D9A : 74                             adc
(1)  178/    1D9B : A8                             plo   r8
(1)  179/    1D9C : 9A                             ghi   R10
(1)  180/    1D9D : 52                             str   r2
(1)  181/    1D9E : 98                             ghi   r8
(1)  182/    1D9F : 74                             adc
(1)  183/    1DA0 : B8                             phi   r8
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 132 - 1/18/2018 14:51:20


(1)  184/    1DA1 : 12                             inc	r2	;wjr - release work area
(1)  185/    1DA2 : (MACRO)                        Cretn
(1)  185/    1DA2 : =>FALSE              if MOMCPU=$1805
(1)  185/    1DA2 :                             sret    6
(1)  185/    1DA2 : =>TRUE               else
(1)  185/    1DA2 : D5                          sep     RRET
(1)  185/    1DA3 : [185]                endif
(1)  186/    1DA3 :                     
(1)  187/    1DA3 :                     ; *******************************
(1)  188/    1DA3 :                     ; *** Shift RF:RD right 1 bit ***
(1)  189/    1DA3 :                     ; *******************************
(1)  190/    1DA3 : 9F                  fp_shr_fd: ghi   R15                    ; shift high word right
(1)  191/    1DA4 : F6                             shr
(1)  192/    1DA5 : BF                             phi   R15
(1)  193/    1DA6 : 8F                             glo   R15
(1)  194/    1DA7 : 76                             shrc
(1)  195/    1DA8 : AF                             plo   R15
(1)  196/    1DA9 : 9D                             ghi   R13                    ; shift low word right
(1)  197/    1DAA : 76                             shrc
(1)  198/    1DAB : BD                             phi   R13
(1)  199/    1DAC : 8D                             glo   R13
(1)  200/    1DAD : 76                             shrc
(1)  201/    1DAE : AD                             plo   R13
(1)  202/    1DAF : (MACRO)                        Cretn
(1)  202/    1DAF : =>FALSE              if MOMCPU=$1805
(1)  202/    1DAF :                             sret    6
(1)  202/    1DAF : =>TRUE               else
(1)  202/    1DAF : D5                          sep     RRET
(1)  202/    1DB0 : [202]                endif
(1)  203/    1DB0 :                     
(1)  204/    1DB0 :                     ; *************************************
(1)  205/    1DB0 :                     ; *** Scale number to high bit is 1 ***
(1)  206/    1DB0 :                     ; *** R8:F9 - Number to scale       ***
(1)  207/    1DB0 :                     ; *** RF.1  - Exponent for number   ***
(1)  208/    1DB0 :                     ; *** F7.0  - Sign bit (bit 0) ***
(1)  209/    1DB0 :                     ; *** Returns: R8:F9 - final sp num ***
(1)  210/    1DB0 :                     ; *************************************
(1)  211/    1DB0 : 88                  fp_sc_up:  glo   r8                    ; need high bit to be a 1
(1)  212/    1DB1 : FA 80                          ani   080h                  ; check it
(1)  213/    1DB3 : CA 1D B3                       lbnz  fp_sc_cln             ; jump if good
(1)  214/    1DB6 : (MACRO)                        Ccall fp_shl_1              ; shift answer left
(1)  214/    1DB6 : =>FALSE              if MOMCPU=$1805
(1)  214/    1DB6 :                             SCAL    6
(1)  214/    1DB6 :                             dw      FP_SHL_1
(1)  214/    1DB6 : =>TRUE               else
(1)  214/    1DB6 : D4                          sep     RCALL
(1)  214/    1DB7 : 1D 7F                       dw      FP_SHL_1
(1)  214/    1DB9 : [214]                endif
(1)  215/    1DB9 : 9F                             ghi   R15                    ; get exp1
(1)  216/    1DBA : FF 01                          smi   1                     ; minus 1
(1)  217/    1DBC : BF                             phi   R15                    ; and put it back
(1)  218/    1DBD : C0 1D B0                       lbr   fp_sc_up              ; loop back intil msbit is 1
(1)  219/    1DC0 : 88                  fp_sc_cln: glo   r8                    ; get high byte
(1)  220/    1DC1 : FE                             shl                         ; shift out high 1 bit
(1)  221/    1DC2 : A8                             plo   r8                    ; set aside
(1)  222/    1DC3 : 9F                             ghi   R15                    ; get exponent byte
(1)  223/    1DC4 : B8                             phi   r8                    ; write other 7 bits to r8.1
(1)  224/    1DC5 : F6                             shr                         ; shift bit 0 into DF
(1)  225/    1DC6 : 88                             glo   r8                    ; get high byte of mantissa
(1)  226/    1DC7 : 76                             shrc                        ; shift bit 0 of expnent in
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 133 - 1/18/2018 14:51:20


(1)  227/    1DC8 : A8                             plo   r8                    ; and put it back
(1)  228/    1DC9 : 87                             glo   F7                   ; get signs
(1)  229/    1DCA : F6                             shr                         ; get sign 1
(1)  230/    1DCB : 98                             ghi   r8                    ; recover exponent
(1)  231/    1DCC : 76                             shrc                        ; shift in sign
(1)  232/    1DCD : B8                             phi   r8                    ; put it back
(1)  233/    1DCE : 12                             inc	r2	;wjr release work area
(1)  234/    1DCF : (MACRO)             	   popr R13	;wjr restore param regs
(1)  234/    1DCF : 12                          inc     sp
(1)  234/    1DD0 : 42                          lda     sp
(1)  234/    1DD1 : BD                          phi     R13
(1)  234/    1DD2 : 02                          ldn     sp
(1)  234/    1DD3 : AD                          plo     R13
(1)  235/    1DD4 : (MACRO)             	   popr R12	;wjr
(1)  235/    1DD4 : 12                          inc     sp
(1)  235/    1DD5 : 42                          lda     sp
(1)  235/    1DD6 : BC                          phi     R12
(1)  235/    1DD7 : 02                          ldn     sp
(1)  235/    1DD8 : AC                          plo     R12
(1)  236/    1DD9 : (MACRO)                        popr	F7	;wjr restore c variable register
(1)  236/    1DD9 : 12                          inc     sp
(1)  236/    1DDA : 42                          lda     sp
(1)  236/    1DDB : B7                          phi     F7
(1)  236/    1DDC : 02                          ldn     sp
(1)  236/    1DDD : A7                          plo     F7
(1)  237/    1DDE : (MACRO)                        Cretn                       ; return to caller
(1)  237/    1DDE : =>FALSE              if MOMCPU=$1805
(1)  237/    1DDE :                             sret    6
(1)  237/    1DDE : =>TRUE               else
(1)  237/    1DDE : D5                          sep     RRET
(1)  237/    1DDF : [237]                endif
(1)  238/    1DDF :                     
(1)  239/    1DDF :                     ; ************************************
(1)  240/    1DDF :                     ; *** Get exponenst from arguments ***
(1)  241/    1DDF :                     ; *** R8:F9 - Arg 1                ***
(1)  242/    1DDF :                     ; *** RA:FB - Arg 2                ***
(1)  243/    1DDF :                     ; *** Returns: RF.1 - exp1         ***
(1)  244/    1DDF :                     ; ***          RF.0 - exp2         ***
(1)  245/    1DDF :                     ; ************************************
(1)  246/    1DDF : 88                  fp_getexp: glo   r8                    ; get exponent of arg1 (bit 0)
(1)  247/    1DE0 : FE                             shl                         ; shift it into DF
(1)  248/    1DE1 : 98                             ghi   r8                    ; get top 7 bits
(1)  249/    1DE2 : 7E                             shlc                        ; shift in first bit
(1)  250/    1DE3 : BF                             phi   R15                    ; put exp1 into RF.1
(1)  251/    1DE4 :                                ;str   r2    wjr - this is never used; place into memory as well
(1)  252/    1DE4 : 8A                             glo   R10                    ; get exponent of arg2 (bit 0)
(1)  253/    1DE5 : FE                             shl                         ; shift it into DF
(1)  254/    1DE6 : 9A                             ghi   R10                    ; get top 7 bits
(1)  255/    1DE7 : 7E                             shlc                        ; shift in first bit
(1)  256/    1DE8 : AF                             plo   R15                    ; put into RF
(1)  257/    1DE9 : (MACRO)                        cretn	                  ; return to caller 17-03-06
(1)  257/    1DE9 : =>FALSE              if MOMCPU=$1805
(1)  257/    1DE9 :                             sret    6
(1)  257/    1DE9 : =>TRUE               else
(1)  257/    1DE9 : D5                          sep     RRET
(1)  257/    1DEA : [257]                endif
(1)  258/    1DEA :                     
(1)  259/    1DEA :                     ; ************************************
(1)  260/    1DEA :                     ; *** Get signs from arguments     ***
(1)  261/    1DEA :                     ; *** R8:F9 - Arg 1                ***
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 134 - 1/18/2018 14:51:20


(1)  262/    1DEA :                     ; *** RA:FB - Arg 2                ***
(1)  263/    1DEA :                     ; *** Returns: F7.0 - signs        ***
(1)  264/    1DEA :                     ; ************************************
(1)  265/    1DEA : 98                  fp_getsgn: ghi   r8                    ; get sign of arg1
(1)  266/    1DEB : FE                             shl                         ; shift into DF
(1)  267/    1DEC : 9A                             ghi   R10                    ; get sign of arg2
(1)  268/    1DED : 7E                             shlc                        ; shift into DF, sign of arg1 to bit 0
(1)  269/    1DEE : 7E                             shlc                        ; now shift in sign of arg2
(1)  270/    1DEF : A7                             plo   F7                    ; save them
(1)  271/    1DF0 : (MACRO)                        Cretn                       ; return to caller
(1)  271/    1DF0 : =>FALSE              if MOMCPU=$1805
(1)  271/    1DF0 :                             sret    6
(1)  271/    1DF0 : =>TRUE               else
(1)  271/    1DF0 : D5                          sep     RRET
(1)  271/    1DF1 : [271]                endif
(1)  272/    1DF1 :                     
(1)  273/    1DF1 :                     ; ***************************************
(1)  274/    1DF1 :                     ; *** Add 2 SP floating point numbers ***
(1)  275/    1DF1 :                     ; *** R8:F9 - Arg 1                   ***
(1)  276/    1DF1 :                     ; *** RA:FB - Arg 2                   ***
(1)  277/    1DF1 :                     ; *** Returns: R8:F9 - Answer         ***
(1)  278/    1DF1 :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  279/    1DF1 :                     ; ***        RF.1 - exponent of arg2  ***
(1)  280/    1DF1 :                     ; ***        F7.0 - signs        ***
(1)  281/    1DF1 :                     ; ***************************************
(1)  282/    1DF1 : 98                  fp_add:   ghi   r8                    ; check arg1 for zero
(1)  283/    1DF2 : CA 1D F2                       lbnz  add_a1nz
(1)  284/    1DF5 : 88                             glo   r8
(1)  285/    1DF6 : CA 1D F6                       lbnz  add_a1nz
(1)  286/    1DF9 : 99                             ghi   F9
(1)  287/    1DFA : CA 1D FA                       lbnz  add_a1nz
(1)  288/    1DFD : 89                             glo   F9
(1)  289/    1DFE : CA 1D FE                       lbnz  add_a1nz
(1)  290/    1E01 : 9A                             ghi   R10                    ; transfer arg2 to answer
(1)  291/    1E02 : B8                             phi   r8
(1)  292/    1E03 : 8A                             glo   R10
(1)  293/    1E04 : A8                             plo   r8
(1)  294/    1E05 : 9B                             ghi   FB
(1)  295/    1E06 : B9                             phi   F9
(1)  296/    1E07 : 8B                             glo   FB
(1)  297/    1E08 : A9                             plo   F9
(1)  298/    1E09 : (MACRO)                        Cretn                        ; return to caller
(1)  298/    1E09 : =>FALSE              if MOMCPU=$1805
(1)  298/    1E09 :                             sret    6
(1)  298/    1E09 : =>TRUE               else
(1)  298/    1E09 : D5                          sep     RRET
(1)  298/    1E0A : [298]                endif
(1)  299/    1E0A :                     
(1)  300/    1E0A : 9A                  add_a1nz:  ghi   R10                    ; check arg2 for zero
(1)  301/    1E0B : CA 1E 0B                       lbnz  add_a2nz
(1)  302/    1E0E : 8A                             glo   R10
(1)  303/    1E0F : CA 1E 0F                       lbnz  add_a2nz
(1)  304/    1E12 : 9B                             ghi   FB
(1)  305/    1E13 : CA 1E 13                       lbnz  add_a2nz
(1)  306/    1E16 : 8B                             glo   FB
(1)  307/    1E17 : CA 1E 17                       lbnz  add_a2nz
(1)  308/    1E1A : (MACRO)                        Cretn                       ; return arg1 as answer
(1)  308/    1E1A : =>FALSE              if MOMCPU=$1805
(1)  308/    1E1A :                             sret    6
(1)  308/    1E1A : =>TRUE               else
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 135 - 1/18/2018 14:51:20


(1)  308/    1E1A : D5                          sep     RRET
(1)  308/    1E1B : [308]                endif
(1)  309/    1E1B :                                
(1)  310/    1E1B : (MACRO)             add_a2nz:  pushr F7	;wjr save c variable register
(1)  310/    1E1B : =>FALSE              if MOMCPU=$1805
(1)  310/    1E1B :                             RSXD    F7
(1)  310/    1E1B : =>TRUE               else
(1)  310/    1E1B : 87                          glo     F7
(1)  310/    1E1C : 73                          stxd
(1)  310/    1E1D : 97                          ghi     F7
(1)  310/    1E1E : 73                          stxd
(1)  310/    1E1F : [310]                endif
(1)  311/    1E1F : (MACRO)             	   pushr R12	;wjr save param regs
(1)  311/    1E1F : =>FALSE              if MOMCPU=$1805
(1)  311/    1E1F :                             RSXD    R12
(1)  311/    1E1F : =>TRUE               else
(1)  311/    1E1F : 8C                          glo     R12
(1)  311/    1E20 : 73                          stxd
(1)  311/    1E21 : 9C                          ghi     R12
(1)  311/    1E22 : 73                          stxd
(1)  311/    1E23 : [311]                endif
(1)  312/    1E23 : (MACRO)             	   pushr R13	;wjr
(1)  312/    1E23 : =>FALSE              if MOMCPU=$1805
(1)  312/    1E23 :                             RSXD    R13
(1)  312/    1E23 : =>TRUE               else
(1)  312/    1E23 : 8D                          glo     R13
(1)  312/    1E24 : 73                          stxd
(1)  312/    1E25 : 9D                          ghi     R13
(1)  312/    1E26 : 73                          stxd
(1)  312/    1E27 : [312]                endif
(1)  313/    1E27 : 22                  	   dec	r2	;wjr - make a work area
(1)  314/    1E28 : (MACRO)             	   Ccall fp_getexp             ; get exponents
(1)  314/    1E28 : =>FALSE              if MOMCPU=$1805
(1)  314/    1E28 :                             SCAL    6
(1)  314/    1E28 :                             dw      FP_GETEXP
(1)  314/    1E28 : =>TRUE               else
(1)  314/    1E28 : D4                          sep     RCALL
(1)  314/    1E29 : 1D DF                       dw      FP_GETEXP
(1)  314/    1E2B : [314]                endif
(1)  315/    1E2B : 9F                             ghi   R15
(1)  316/    1E2C : 52                             str   r2
(1)  317/    1E2D : 8F                             glo   R15
(1)  318/    1E2E : F7                             sm                          ; perfrom exp2 - exp1
(1)  319/    1E2F : CB 1E 2F                       lbnf  add_ns                ; jump if no swap needed
(1)  320/    1E32 :                     
(1)  321/    1E32 : 98                             ghi   r8                    ; swap arg1 with arg2
(1)  322/    1E33 : AE                             plo   R14
(1)  323/    1E34 : 9A                             ghi   R10
(1)  324/    1E35 : B8                             phi   r8
(1)  325/    1E36 : 8E                             glo   R14
(1)  326/    1E37 : BA                             phi   R10
(1)  327/    1E38 : 88                             glo   r8
(1)  328/    1E39 : AE                             plo   R14
(1)  329/    1E3A : 8A                             glo   R10
(1)  330/    1E3B : A8                             plo   r8
(1)  331/    1E3C : 8E                             glo   R14
(1)  332/    1E3D : AA                             plo   R10
(1)  333/    1E3E : 99                             ghi   F9                    ; swap arg1 with arg2
(1)  334/    1E3F : AE                             plo   R14
(1)  335/    1E40 : 9B                             ghi   FB
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 136 - 1/18/2018 14:51:20


(1)  336/    1E41 : B9                             phi   F9
(1)  337/    1E42 : 8E                             glo   R14
(1)  338/    1E43 : BB                             phi   FB
(1)  339/    1E44 : 89                             glo   F9
(1)  340/    1E45 : AE                             plo   R14
(1)  341/    1E46 : 8B                             glo   FB
(1)  342/    1E47 : A9                             plo   F9
(1)  343/    1E48 : 8E                             glo   R14
(1)  344/    1E49 : AB                             plo   FB
(1)  345/    1E4A : 9F                             ghi   R15                    ; swap exponents
(1)  346/    1E4B : AE                             plo   R14
(1)  347/    1E4C : 8F                             glo   R15
(1)  348/    1E4D : BF                             phi   R15
(1)  349/    1E4E : 8E                             glo   R14
(1)  350/    1E4F : AF                             plo   R15
(1)  351/    1E50 : (MACRO)             add_ns:    ccall fp_getsgn              ; get signs of arguments
(1)  351/    1E50 : =>FALSE              if MOMCPU=$1805
(1)  351/    1E50 :                             SCAL    6
(1)  351/    1E50 :                             dw      FP_GETSGN
(1)  351/    1E50 : =>TRUE               else
(1)  351/    1E50 : D4                          sep     RCALL
(1)  351/    1E51 : 1D EA                       dw      FP_GETSGN
(1)  351/    1E53 : [351]                endif
(1)  352/    1E53 : F8 00                          ldi   0                     ; setup mantissas
(1)  353/    1E55 : B8                             phi   r8
(1)  354/    1E56 : BA                             phi   R10
(1)  355/    1E57 : F8 80                          ldi   128                   ; need to set high bit in mantissa
(1)  356/    1E59 : 52                             str   r2
(1)  357/    1E5A : 88                             glo   r8
(1)  358/    1E5B : F1                             or
(1)  359/    1E5C : A8                             plo   r8
(1)  360/    1E5D : 8A                             glo   R10
(1)  361/    1E5E : F1                             or
(1)  362/    1E5F : AA                             plo   R10
(1)  363/    1E60 : 9F                             ghi   R15                    ; get exp1
(1)  364/    1E61 : 52                             str   r2                    ; place into memory
(1)  365/    1E62 : 8F                  add_lp1:   glo   R15                    ; get exp2
(1)  366/    1E63 : F7                             sm                          ; see if match to exp1
(1)  367/    1E64 : C2 1E 64                       lbz   add_lp1dn             ; jump if match
(1)  368/    1E67 : 8F                             glo   R15                    ; need to increase it
(1)  369/    1E68 : FC 01                          adi   1
(1)  370/    1E6A : AF                             plo   R15
(1)  371/    1E6B : 8A                             glo   R10                    ; now shift arg2 over 1 bit
(1)  372/    1E6C : F6                             shr
(1)  373/    1E6D : AA                             plo   R10
(1)  374/    1E6E : 9B                             ghi   FB
(1)  375/    1E6F : 76                             shrc
(1)  376/    1E70 : BB                             phi   FB
(1)  377/    1E71 : 8B                             glo   FB
(1)  378/    1E72 : 76                             shrc
(1)  379/    1E73 : AB                             plo   FB
(1)  380/    1E74 : C0 1E 62                       lbr   add_lp1               ; keep shifting until exponents match
(1)  381/    1E77 : 87                  add_lp1dn: glo   F7                    ; see if signs match
(1)  382/    1E78 : 52                             str   r2
(1)  383/    1E79 : F6                             shr
(1)  384/    1E7A : F3                             xor
(1)  385/    1E7B : FA 01                          ani   1                     ; keep only bottom bit
(1)  386/    1E7D : CA 1E 7D                       lbnz  add_nm                ; jump if signs do not match
(1)  387/    1E80 : (MACRO)                        Ccall fp_add_12             ; perform arg1 += arg2
(1)  387/    1E80 : =>FALSE              if MOMCPU=$1805
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 137 - 1/18/2018 14:51:20


(1)  387/    1E80 :                             SCAL    6
(1)  387/    1E80 :                             dw      FP_ADD_12
(1)  387/    1E80 : =>TRUE               else
(1)  387/    1E80 : D4                          sep     RCALL
(1)  387/    1E81 : 1D 8C                       dw      FP_ADD_12
(1)  387/    1E83 : [387]                endif
(1)  388/    1E83 : C0 1E 83                       lbr   add_fnl               ; jump to clean up
(1)  389/    1E86 : 8B                  add_nm:    glo   FB                    ; perform arg1 - arg2
(1)  390/    1E87 : 52                             str   r2
(1)  391/    1E88 : 89                             glo   F9
(1)  392/    1E89 : F7                             sm
(1)  393/    1E8A : AC                             plo   R12                    ; place into RD:RC
(1)  394/    1E8B : 9B                             ghi   FB
(1)  395/    1E8C : 52                             str   r2
(1)  396/    1E8D : 99                             ghi   F9
(1)  397/    1E8E : 77                             smb
(1)  398/    1E8F : BC                             phi   R12
(1)  399/    1E90 : 8A                             glo   R10
(1)  400/    1E91 : 52                             str   r2
(1)  401/    1E92 : 88                             glo   r8
(1)  402/    1E93 : 77                             smb
(1)  403/    1E94 : AD                             plo   R13
(1)  404/    1E95 : 9A                             ghi   R10
(1)  405/    1E96 : 52                             str   r2
(1)  406/    1E97 : 98                             ghi   r8
(1)  407/    1E98 : 77                             smb
(1)  408/    1E99 : BD                             phi   R13
(1)  409/    1E9A : CB 1E 9A                       lbnf  add_no                ; jump if arg2 was larger than arg1
(1)  410/    1E9D : 9D                             ghi   R13                    ; transfer result to arg1
(1)  411/    1E9E : B8                             phi   r8
(1)  412/    1E9F : 8D                             glo   R13
(1)  413/    1EA0 : A8                             plo   r8
(1)  414/    1EA1 : 9C                             ghi   R12
(1)  415/    1EA2 : B9                             phi   F9
(1)  416/    1EA3 : 8C                             glo   R12
(1)  417/    1EA4 : A9                             plo   F9
(1)  418/    1EA5 : C0 1E A5                       lbr   add_fnl               ; finalize
(1)  419/    1EA8 : 89                  add_no:    glo   F9                    ; perform arg1 = arg2 - arg1
(1)  420/    1EA9 : 52                             str   r2
(1)  421/    1EAA : 8B                             glo   FB
(1)  422/    1EAB : F7                             sm
(1)  423/    1EAC : A9                             plo   F9
(1)  424/    1EAD : 99                             ghi   F9
(1)  425/    1EAE : 52                             str   r2
(1)  426/    1EAF : 9B                             ghi   FB
(1)  427/    1EB0 : 77                             smb
(1)  428/    1EB1 : B9                             phi   F9
(1)  429/    1EB2 : 88                             glo   r8
(1)  430/    1EB3 : 52                             str   r2
(1)  431/    1EB4 : 8A                             glo   R10
(1)  432/    1EB5 : 77                             smb
(1)  433/    1EB6 : A8                             plo   r8
(1)  434/    1EB7 : 98                             ghi   r8
(1)  435/    1EB8 : 52                             str   r2
(1)  436/    1EB9 : 9A                             ghi   R10
(1)  437/    1EBA : 77                             smb
(1)  438/    1EBB : B8                             phi   r8
(1)  439/    1EBC : 87                             glo   F7                    ; move sign 2 to sign1
(1)  440/    1EBD : FE                             shl
(1)  441/    1EBE : A7                             plo   F7
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 138 - 1/18/2018 14:51:20


(1)  442/    1EBF : 98                  add_fnl:   ghi   r8                    ; check for zero result
(1)  443/    1EC0 : CA 1E C0                       lbnz  add_nz                ; jump if not
(1)  444/    1EC3 : 88                             glo   r8
(1)  445/    1EC4 : CA 1E C4                       lbnz  add_nz
(1)  446/    1EC7 : 99                             ghi   F9
(1)  447/    1EC8 : CA 1E C8                       lbnz  add_nz
(1)  448/    1ECB : 89                             glo   F9
(1)  449/    1ECC : CA 1E CC                       lbnz  add_nz
(1)  450/    1ECF : 12                             inc	r2	;wjr release work area
(1)  451/    1ED0 : (MACRO)             	   popr R13	;wjr restore param regs
(1)  451/    1ED0 : 12                          inc     sp
(1)  451/    1ED1 : 42                          lda     sp
(1)  451/    1ED2 : BD                          phi     R13
(1)  451/    1ED3 : 02                          ldn     sp
(1)  451/    1ED4 : AD                          plo     R13
(1)  452/    1ED5 : (MACRO)             	   popr R12	;wjr
(1)  452/    1ED5 : 12                          inc     sp
(1)  452/    1ED6 : 42                          lda     sp
(1)  452/    1ED7 : BC                          phi     R12
(1)  452/    1ED8 : 02                          ldn     sp
(1)  452/    1ED9 : AC                          plo     R12
(1)  453/    1EDA : (MACRO)                        popr	F7	;wjr restore c variable register
(1)  453/    1EDA : 12                          inc     sp
(1)  453/    1EDB : 42                          lda     sp
(1)  453/    1EDC : B7                          phi     F7
(1)  453/    1EDD : 02                          ldn     sp
(1)  453/    1EDE : A7                          plo     F7
(1)  454/    1EDF : (MACRO)                        Cretn                       ; return the zero
(1)  454/    1EDF : =>FALSE              if MOMCPU=$1805
(1)  454/    1EDF :                             sret    6
(1)  454/    1EDF : =>TRUE               else
(1)  454/    1EDF : D5                          sep     RRET
(1)  454/    1EE0 : [454]                endif
(1)  455/    1EE0 : 98                  add_nz:    ghi   r8                    ; see if answer is beyond 24 bits
(1)  456/    1EE1 : C2 1E E1                       lbz   add_nx                ; jump if not
(1)  457/    1EE4 : (MACRO)                        Ccall fp_shr_1              ; shift answer to the right
(1)  457/    1EE4 : =>FALSE              if MOMCPU=$1805
(1)  457/    1EE4 :                             SCAL    6
(1)  457/    1EE4 :                             dw      FP_SHR_1
(1)  457/    1EE4 : =>TRUE               else
(1)  457/    1EE4 : D4                          sep     RCALL
(1)  457/    1EE5 : 1D 72                       dw      FP_SHR_1
(1)  457/    1EE7 : [457]                endif
(1)  458/    1EE7 : 9F                             ghi   R15                    ; get exp1
(1)  459/    1EE8 : FC 01                          adi   1                     ; increment it
(1)  460/    1EEA : BF                             phi   R15                    ; and put it back
(1)  461/    1EEB : C0 1E E0                       lbr   add_nz                ; keep going until not > 24 bits
(1)  462/    1EEE :                     
(1)  463/    1EEE : 87                  add_nx:    glo   F7                    ; move sign 1 to low bit
(1)  464/    1EEF : F6                             shr
(1)  465/    1EF0 : A7                             plo   F7
(1)  466/    1EF1 : C0 1D B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  467/    1EF4 :                     
(1)  468/    1EF4 :                     ; ***************************************
(1)  469/    1EF4 :                     ; *** sub 2 SP floating point numbers ***
(1)  470/    1EF4 :                     ; *** R8:F9 - Arg 1                   ***
(1)  471/    1EF4 :                     ; *** RA:FB - Arg 2                   ***
(1)  472/    1EF4 :                     ; *** Returns: R8:F9 - Answer         ***
(1)  473/    1EF4 :                     ; ***************************************
(1)  474/    1EF4 : 9A                  fp_sub:    ghi   R10                    ; change sign of arg2
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 139 - 1/18/2018 14:51:20


(1)  475/    1EF5 : FB 80                          xri   080h
(1)  476/    1EF7 : BA                             phi   R10                    ; and put it back
(1)  477/    1EF8 : C0 1D F1                       lbr   fp_add                ; now just add
(1)  478/    1EFB :                     
(1)  479/    1EFB :                     ; ***************************************
(1)  480/    1EFB :                     ; *** Div 2 SP floating point numbers ***
(1)  481/    1EFB :                     ; *** R8:F9 - Arg 1                   ***
(1)  482/    1EFB :                     ; *** RA:FB - Arg 2                   ***
(1)  483/    1EFB :                     ; *** Returns: R8:F9 - Answer         ***
(1)  484/    1EFB :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  485/    1EFB :                     ; ***        RF.1 - exponent of arg2  ***
(1)  486/    1EFB :                     ; ***        F7.0 - signs        ***
(1)  487/    1EFB :                     ; ***************************************
(1)  488/    1EFB : 98                  fp_div:    ghi   r8                    ; check arg1 for zero
(1)  489/    1EFC : CA 1E FC                       lbnz  div_a1nz
(1)  490/    1EFF : 88                             glo   r8
(1)  491/    1F00 : CA 1F 00                       lbnz  div_a1nz
(1)  492/    1F03 : 99                             ghi   F9
(1)  493/    1F04 : CA 1F 04                       lbnz  div_a1nz
(1)  494/    1F07 : 89                             glo   F9
(1)  495/    1F08 : CA 1F 08                       lbnz  div_a1nz
(1)  496/    1F0B : (MACRO)                        Cretn	                ; just return the zero
(1)  496/    1F0B : =>FALSE              if MOMCPU=$1805
(1)  496/    1F0B :                             sret    6
(1)  496/    1F0B : =>TRUE               else
(1)  496/    1F0B : D5                          sep     RRET
(1)  496/    1F0C : [496]                endif
(1)  497/    1F0C : 9A                  div_a1nz:  ghi   R10                    ; check arg2 for zero
(1)  498/    1F0D : CA 1F 0D                       lbnz  div_a2nz
(1)  499/    1F10 : 8A                             glo   R10
(1)  500/    1F11 : CA 1F 11                       lbnz  div_a2nz
(1)  501/    1F14 : 9B                             ghi   FB
(1)  502/    1F15 : CA 1F 15                       lbnz  div_a2nz
(1)  503/    1F18 : 8B                             glo   FB
(1)  504/    1F19 : CA 1F 19                       lbnz  div_a2nz
(1)  505/    1F1C : 98                             ghi   r8                    ; need sign of arg1
(1)  506/    1F1D : FA 80                          ani   080h                  ; want only sign
(1)  507/    1F1F : F9 7F                          ori   07fh                  ; exponent will be all ones
(1)  508/    1F21 : B8                             phi   r8                    ; put into answer
(1)  509/    1F22 : F8 80                          ldi   080h                  ; build rest of answer
(1)  510/    1F24 : A8                             plo   r8 
(1)  511/    1F25 : F8 00                          ldi   0
(1)  512/    1F27 : B9                             phi   F9
(1)  513/    1F28 : A9                             plo   F9
(1)  514/    1F29 : (MACRO)                        Cretn                  	; and return to caller
(1)  514/    1F29 : =>FALSE              if MOMCPU=$1805
(1)  514/    1F29 :                             sret    6
(1)  514/    1F29 : =>TRUE               else
(1)  514/    1F29 : D5                          sep     RRET
(1)  514/    1F2A : [514]                endif
(1)  515/    1F2A :                     
(1)  516/    1F2A : (MACRO)             div_a2nz:  pushr F7	;wjr save the C variable
(1)  516/    1F2A : =>FALSE              if MOMCPU=$1805
(1)  516/    1F2A :                             RSXD    F7
(1)  516/    1F2A : =>TRUE               else
(1)  516/    1F2A : 87                          glo     F7
(1)  516/    1F2B : 73                          stxd
(1)  516/    1F2C : 97                          ghi     F7
(1)  516/    1F2D : 73                          stxd
(1)  516/    1F2E : [516]                endif
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 140 - 1/18/2018 14:51:20


(1)  517/    1F2E : (MACRO)             	   pushr R12	;wjr save param regs
(1)  517/    1F2E : =>FALSE              if MOMCPU=$1805
(1)  517/    1F2E :                             RSXD    R12
(1)  517/    1F2E : =>TRUE               else
(1)  517/    1F2E : 8C                          glo     R12
(1)  517/    1F2F : 73                          stxd
(1)  517/    1F30 : 9C                          ghi     R12
(1)  517/    1F31 : 73                          stxd
(1)  517/    1F32 : [517]                endif
(1)  518/    1F32 : (MACRO)             	   pushr R13	;wjr
(1)  518/    1F32 : =>FALSE              if MOMCPU=$1805
(1)  518/    1F32 :                             RSXD    R13
(1)  518/    1F32 : =>TRUE               else
(1)  518/    1F32 : 8D                          glo     R13
(1)  518/    1F33 : 73                          stxd
(1)  518/    1F34 : 9D                          ghi     R13
(1)  518/    1F35 : 73                          stxd
(1)  518/    1F36 : [518]                endif
(1)  519/    1F36 : 22                  	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
(1)  520/    1F37 :                     
(1)  521/    1F37 : (MACRO)             	   Ccall fp_getexp              ; get exponents
(1)  521/    1F37 : =>FALSE              if MOMCPU=$1805
(1)  521/    1F37 :                             SCAL    6
(1)  521/    1F37 :                             dw      FP_GETEXP
(1)  521/    1F37 : =>TRUE               else
(1)  521/    1F37 : D4                          sep     RCALL
(1)  521/    1F38 : 1D DF                       dw      FP_GETEXP
(1)  521/    1F3A : [521]                endif
(1)  522/    1F3A : (MACRO)                        Ccall fp_getsgn		; get signs
(1)  522/    1F3A : =>FALSE              if MOMCPU=$1805
(1)  522/    1F3A :                             SCAL    6
(1)  522/    1F3A :                             dw      FP_GETSGN
(1)  522/    1F3A : =>TRUE               else
(1)  522/    1F3A : D4                          sep     RCALL
(1)  522/    1F3B : 1D EA                       dw      FP_GETSGN
(1)  522/    1F3D : [522]                endif
(1)  523/    1F3D : 8F                             glo   R15                    ; get exp2
(1)  524/    1F3E : FF 7F                          smi   127                   ; remove bias
(1)  525/    1F40 : 52                             str   r2                    ; place into memory
(1)  526/    1F41 : 9F                             ghi   R15                    ; get exp1
(1)  527/    1F42 : FF 7F                          smi   127                   ; remove bias
(1)  528/    1F44 : F7                             sm                          ; perform exp1 - exp2
(1)  529/    1F45 : FC 7F                          adi   127                   ; put bias back in
(1)  530/    1F47 : 73                             stxd                        ; save onto stack
(1)  531/    1F48 : 87                             glo   F7                    ; determine sign for answer
(1)  532/    1F49 : 52                             str   r2
(1)  533/    1F4A : F6                             shr
(1)  534/    1F4B : F3                             xor
(1)  535/    1F4C : 73                             stxd                        ; place onto stack
(1)  536/    1F4D : F8 00                          ldi   0                     ; setup man
(1)  537/    1F4F : BA                             phi   R10
(1)  538/    1F50 : 8A                             glo   R10
(1)  539/    1F51 : F9 80                          ori   080h
(1)  540/    1F53 : AA                             plo   R10
(1)  541/    1F54 : F8 00                          ldi   0                     ; setup div
(1)  542/    1F56 : B8                             phi   r8
(1)  543/    1F57 : 88                             glo   r8
(1)  544/    1F58 : F9 80                          ori   080h
(1)  545/    1F5A : A8                             plo   r8
(1)  546/    1F5B : F8 00                          ldi   0                     ; setup result
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 141 - 1/18/2018 14:51:20


(1)  547/    1F5D : BC                             phi   R12
(1)  548/    1F5E : AC                             plo   R12
(1)  549/    1F5F : B7                             phi   F7
(1)  550/    1F60 : A7                             plo   F7
(1)  551/    1F61 : AF                             plo   R15                    ; setup quotient
(1)  552/    1F62 : BF                             phi   R15
(1)  553/    1F63 : BD                             phi   R13
(1)  554/    1F64 : AD                             plo   R13
(1)  555/    1F65 : F8 80                          ldi   080h
(1)  556/    1F67 : AF                             plo   R15
(1)  557/    1F68 : 98                  div_lp:    ghi   r8                    ; check div for nonzero
(1)  558/    1F69 : CA 1F 69                       lbnz  div_go1
(1)  559/    1F6C : 88                             glo   r8
(1)  560/    1F6D : CA 1F 6D                       lbnz  div_go1
(1)  561/    1F70 : 99                             ghi   F9
(1)  562/    1F71 : CA 1F 71                       lbnz  div_go1
(1)  563/    1F74 : 89                             glo   F9
(1)  564/    1F75 : CA 1F 75                       lbnz  div_go1
(1)  565/    1F78 : C0 1F 78                       lbr   div_z
(1)  566/    1F7B : 9A                  div_go1:   ghi   R10
(1)  567/    1F7C : CA 1F 7C                       lbnz  div_go
(1)  568/    1F7F : 8A                             glo   R10
(1)  569/    1F80 : CA 1F 80                       lbnz  div_go
(1)  570/    1F83 : 9B                             ghi   FB
(1)  571/    1F84 : CA 1F 84                       lbnz  div_go
(1)  572/    1F87 : 8B                             glo   FB
(1)  573/    1F88 : CA 1F 88                       lbnz  div_go
(1)  574/    1F8B : C0 1F 8B                       lbr   div_z                 ; nothing more to do
(1)  575/    1F8E : 8B                  div_go:    glo   FB                    ; see if div > man
(1)  576/    1F8F : 52                             str   r2
(1)  577/    1F90 : 89                             glo   F9
(1)  578/    1F91 : F7                             sm
(1)  579/    1F92 : 9B                             ghi   FB
(1)  580/    1F93 : 52                             str   r2
(1)  581/    1F94 : 99                             ghi   F9
(1)  582/    1F95 : 77                             smb
(1)  583/    1F96 : 8A                             glo   R10
(1)  584/    1F97 : 52                             str   r2
(1)  585/    1F98 : 88                             glo   r8
(1)  586/    1F99 : 77                             smb
(1)  587/    1F9A : 9A                             ghi   R10
(1)  588/    1F9B : 52                             str   r2
(1)  589/    1F9C : 98                             ghi   r8
(1)  590/    1F9D : 77                             smb
(1)  591/    1F9E : CB 1F 9E                       lbnf  div_nope              ; jump if div was smaller
(1)  592/    1FA1 : 8B                             glo   FB                    ; div -= man
(1)  593/    1FA2 : 52                             str   r2
(1)  594/    1FA3 : 89                             glo   F9
(1)  595/    1FA4 : F7                             sm
(1)  596/    1FA5 : A9                             plo   F9
(1)  597/    1FA6 : 9B                             ghi   FB
(1)  598/    1FA7 : 52                             str   r2
(1)  599/    1FA8 : 99                             ghi   F9
(1)  600/    1FA9 : 77                             smb
(1)  601/    1FAA : B9                             phi   F9
(1)  602/    1FAB : 8A                             glo   R10
(1)  603/    1FAC : 52                             str   r2
(1)  604/    1FAD : 88                             glo   r8
(1)  605/    1FAE : 77                             smb
(1)  606/    1FAF : A8                             plo   r8
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 142 - 1/18/2018 14:51:20


(1)  607/    1FB0 : 9A                             ghi   R10
(1)  608/    1FB1 : 52                             str   r2
(1)  609/    1FB2 : 98                             ghi   r8
(1)  610/    1FB3 : 77                             smb
(1)  611/    1FB4 : B8                             phi   r8
(1)  612/    1FB5 : 9F                             ghi   R15                    ; merge quotient into result
(1)  613/    1FB6 : 52                             str   r2
(1)  614/    1FB7 : 9C                             ghi   R12
(1)  615/    1FB8 : F1                             or
(1)  616/    1FB9 : BC                             phi   R12
(1)  617/    1FBA : 8F                             glo   R15
(1)  618/    1FBB : 52                             str   r2
(1)  619/    1FBC : 8C                             glo   R12
(1)  620/    1FBD : F1                             or
(1)  621/    1FBE : AC                             plo   R12
(1)  622/    1FBF : 9D                             ghi   R13
(1)  623/    1FC0 : 52                             str   r2
(1)  624/    1FC1 : 97                             ghi   F7
(1)  625/    1FC2 : F1                             or
(1)  626/    1FC3 : B7                             phi   F7
(1)  627/    1FC4 : 8D                             glo   R13
(1)  628/    1FC5 : 52                             str   r2
(1)  629/    1FC6 : 87                             glo   F7
(1)  630/    1FC7 : F1                             or
(1)  631/    1FC8 : A7                             plo   F7
(1)  632/    1FC9 : (MACRO)             div_nope:  ccall fp_shr_fd              ; shift quotient right 17-03-06
(1)  632/    1FC9 : =>FALSE              if MOMCPU=$1805
(1)  632/    1FC9 :                             SCAL    6
(1)  632/    1FC9 :                             dw      FP_SHR_FD
(1)  632/    1FC9 : =>TRUE               else
(1)  632/    1FC9 : D4                          sep     RCALL
(1)  632/    1FCA : 1D A3                       dw      FP_SHR_FD
(1)  632/    1FCC : [632]                endif
(1)  633/    1FCC : 9A                             ghi   R10                    ; shift divisor right
(1)  634/    1FCD : F6                             shr
(1)  635/    1FCE : BA                             phi   R10
(1)  636/    1FCF : 8A                             glo   R10
(1)  637/    1FD0 : 76                             shrc
(1)  638/    1FD1 : AA                             plo   R10
(1)  639/    1FD2 : 9B                             ghi   FB
(1)  640/    1FD3 : 76                             shrc
(1)  641/    1FD4 : BB                             phi   FB
(1)  642/    1FD5 : 8B                             glo   FB
(1)  643/    1FD6 : 76                             shrc
(1)  644/    1FD7 : AB                             plo   FB
(1)  645/    1FD8 : C0 1F 68                       lbr   div_lp                ; loop back until done
(1)  646/    1FDB : 9C                  div_z:     ghi   R12                    ; move result to arg1
(1)  647/    1FDC : B8                             phi   r8
(1)  648/    1FDD : 8C                             glo   R12
(1)  649/    1FDE : A8                             plo   r8
(1)  650/    1FDF : 97                             ghi   F7
(1)  651/    1FE0 : B9                             phi   F9
(1)  652/    1FE1 : 87                             glo   F7
(1)  653/    1FE2 : A9                             plo   F9
(1)  654/    1FE3 : 60                             irx                         ; recover sign
(1)  655/    1FE4 : 72                             ldxa
(1)  656/    1FE5 : A7                             plo   F7
(1)  657/    1FE6 : F0                             ldx                         ; recover answer exponent
(1)  658/    1FE7 : BF                             phi   R15
(1)  659/    1FE8 : C0 1D B0                       lbr   fp_sc_up              ; scale number and build answer
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 143 - 1/18/2018 14:51:20


(1)  660/    1FEB :                     
(1)  661/    1FEB :                     ; ***************************************
(1)  662/    1FEB :                     ; *** Mul 2 SP floating point numbers ***
(1)  663/    1FEB :                     ; *** R8:F9 - Arg 1                   ***
(1)  664/    1FEB :                     ; *** RA:FB - Arg 2                   ***
(1)  665/    1FEB :                     ; *** Returns: R8:F9 - Answer         ***
(1)  666/    1FEB :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  667/    1FEB :                     ; ***        RF.1 - exponent of arg2  ***
(1)  668/    1FEB :                     ; ***        F7.0 - signs             ***
(1)  669/    1FEB :                     ; ***************************************
(1)  670/    1FEB : (MACRO)             fp_mul:    pushr F7	;wjr save the C variable
(1)  670/    1FEB : =>FALSE              if MOMCPU=$1805
(1)  670/    1FEB :                             RSXD    F7
(1)  670/    1FEB : =>TRUE               else
(1)  670/    1FEB : 87                          glo     F7
(1)  670/    1FEC : 73                          stxd
(1)  670/    1FED : 97                          ghi     F7
(1)  670/    1FEE : 73                          stxd
(1)  670/    1FEF : [670]                endif
(1)  671/    1FEF : (MACRO)             	   pushr R12	;wjr save param regs
(1)  671/    1FEF : =>FALSE              if MOMCPU=$1805
(1)  671/    1FEF :                             RSXD    R12
(1)  671/    1FEF : =>TRUE               else
(1)  671/    1FEF : 8C                          glo     R12
(1)  671/    1FF0 : 73                          stxd
(1)  671/    1FF1 : 9C                          ghi     R12
(1)  671/    1FF2 : 73                          stxd
(1)  671/    1FF3 : [671]                endif
(1)  672/    1FF3 : (MACRO)             	   pushr R13	;wjr
(1)  672/    1FF3 : =>FALSE              if MOMCPU=$1805
(1)  672/    1FF3 :                             RSXD    R13
(1)  672/    1FF3 : =>TRUE               else
(1)  672/    1FF3 : 8D                          glo     R13
(1)  672/    1FF4 : 73                          stxd
(1)  672/    1FF5 : 9D                          ghi     R13
(1)  672/    1FF6 : 73                          stxd
(1)  672/    1FF7 : [672]                endif
(1)  673/    1FF7 : 22                  	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
(1)  674/    1FF8 :                     
(1)  675/    1FF8 : (MACRO)                        Ccall    fp_getexp	       ; get exponents
(1)  675/    1FF8 : =>FALSE              if MOMCPU=$1805
(1)  675/    1FF8 :                             SCAL    6
(1)  675/    1FF8 :                             dw      FP_GETEXP
(1)  675/    1FF8 : =>TRUE               else
(1)  675/    1FF8 : D4                          sep     RCALL
(1)  675/    1FF9 : 1D DF                       dw      FP_GETEXP
(1)  675/    1FFB : [675]                endif
(1)  676/    1FFB : (MACRO)                        Ccall    fp_getsgn            ; get signs
(1)  676/    1FFB : =>FALSE              if MOMCPU=$1805
(1)  676/    1FFB :                             SCAL    6
(1)  676/    1FFB :                             dw      FP_GETSGN
(1)  676/    1FFB : =>TRUE               else
(1)  676/    1FFB : D4                          sep     RCALL
(1)  676/    1FFC : 1D EA                       dw      FP_GETSGN
(1)  676/    1FFE : [676]                endif
(1)  677/    1FFE : 8F                             glo   R15                    ; get exp2
(1)  678/    1FFF : FF 7F                          smi   127                   ; remove bias
(1)  679/    2001 : 52                             str   r2                    ; place into memory
(1)  680/    2002 : 9F                             ghi   R15                    ; get exp1
(1)  681/    2003 : FF 7F                          smi   127                   ; remove bias
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 144 - 1/18/2018 14:51:20


(1)  682/    2005 : F4                             add                         ; add in exponent 2
(1)  683/    2006 : FC 7F                          adi   127                   ; put bias back in
(1)  684/    2008 : 73                             stxd                        ; place onto stack
(1)  685/    2009 : 87                             glo   F7                    ; determine sign for answer
(1)  686/    200A : 52                             str   r2
(1)  687/    200B : F6                             shr
(1)  688/    200C : F3                             xor
(1)  689/    200D : 73                             stxd                        ; place onto stack
(1)  690/    200E : 9E                             ghi   R14                    ; get baud constant
(1)  691/    200F : 73                             stxd                        ; save on stack
(1)  692/    2010 : 96                             ghi   r6                    ; save return position on stack
(1)  693/    2011 : 73                             stxd
(1)  694/    2012 : 86                             glo   r6
(1)  695/    2013 : 73                             stxd
(1)  696/    2014 : F8 00                          ldi   0                     ; initial value of ct
(1)  697/    2016 : 73                             stxd
(1)  698/    2017 : BE                             phi   R14                    ; set mulH to 0
(1)  699/    2018 : AE                             plo   R14
(1)  700/    2019 : B6                             phi   r6
(1)  701/    201A : A6                             plo   r6
(1)  702/    201B : B8                             phi   r8                    ; mulL = arg1 & 0xffffff
(1)  703/    201C : 88                             glo   r8                    ; be sure high bit is set
(1)  704/    201D : F9 80                          ori   080h
(1)  705/    201F : A8                             plo   r8
(1)  706/    2020 : F8 00                          ldi   0
(1)  707/    2022 : BC                             phi   R12                    ; set result to 0
(1)  708/    2023 : AC                             plo   R12
(1)  709/    2024 : B7                             phi   F7
(1)  710/    2025 : A7                             plo   F7
(1)  711/    2026 : BF                             phi   R15
(1)  712/    2027 : AF                             plo   R15
(1)  713/    2028 : BD                             phi   R13
(1)  714/    2029 : AD                             plo   R13
(1)  715/    202A : BA                             phi   R10                    ; arg2 &= 0ffffff
(1)  716/    202B : 8A                             glo   R10                    ; be sure high bit is set
(1)  717/    202C : F9 80                          ori   080h
(1)  718/    202E : AA                             plo   R10
(1)  719/    202F : 8B                  mul_lp1:   glo   FB                    ; check for zero multiplier
(1)  720/    2030 : CA 20 30                       lbnz  mul_go1               ; jump if not zero
(1)  721/    2033 : 9B                             ghi   FB
(1)  722/    2034 : CA 20 34                       lbnz  mul_go1
(1)  723/    2037 : 8A                             glo   R10
(1)  724/    2038 : CA 20 38                       lbnz  mul_go1
(1)  725/    203B : 9A                             ghi   R10
(1)  726/    203C : C2 20 3C                       lbz   mul_dn                ; jump if muliplier is zero
(1)  727/    203F : 9A                  mul_go1:   ghi   R10                    ; shift multiplier right
(1)  728/    2040 : F6                             shr
(1)  729/    2041 : BA                             phi   R10
(1)  730/    2042 : 8A                             glo   R10
(1)  731/    2043 : 76                             shrc
(1)  732/    2044 : AA                             plo   R10
(1)  733/    2045 : 9B                             ghi   FB
(1)  734/    2046 : 76                             shrc
(1)  735/    2047 : BB                             phi   FB
(1)  736/    2048 : 8B                             glo   FB
(1)  737/    2049 : 76                             shrc
(1)  738/    204A : AB                             plo   FB
(1)  739/    204B : CB 20 4B                       lbnf  mul_no                ; jump if low bit was zero
(1)  740/    204E : 89                             glo   F9                    ; res += mul
(1)  741/    204F : 52                             str   r2
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 145 - 1/18/2018 14:51:20


(1)  742/    2050 : 87                             glo   F7
(1)  743/    2051 : F4                             add
(1)  744/    2052 : A7                             plo   F7
(1)  745/    2053 : 99                             ghi   F9
(1)  746/    2054 : 52                             str   r2
(1)  747/    2055 : 97                             ghi   F7
(1)  748/    2056 : 74                             adc
(1)  749/    2057 : B7                             phi   F7
(1)  750/    2058 : 88                             glo   r8
(1)  751/    2059 : 52                             str   r2
(1)  752/    205A : 8C                             glo   R12
(1)  753/    205B : 74                             adc
(1)  754/    205C : AC                             plo   R12
(1)  755/    205D : 98                             ghi   r8
(1)  756/    205E : 52                             str   r2
(1)  757/    205F : 9C                             ghi   R12
(1)  758/    2060 : 74                             adc
(1)  759/    2061 : BC                             phi   R12
(1)  760/    2062 : 86                             glo   r6                    ; now high 32 bits
(1)  761/    2063 : 52                             str   r2
(1)  762/    2064 : 8D                             glo   R13
(1)  763/    2065 : F4                             add
(1)  764/    2066 : AD                             plo   R13
(1)  765/    2067 : 96                             ghi   r6
(1)  766/    2068 : 52                             str   r2
(1)  767/    2069 : 96                             ghi   r6
(1)  768/    206A : 52                             str   r2
(1)  769/    206B : 9D                             ghi   R13
(1)  770/    206C : 74                             adc
(1)  771/    206D : BD                             phi   R13
(1)  772/    206E : 8E                             glo   R14
(1)  773/    206F : 52                             str   r2
(1)  774/    2070 : 8F                             glo   R15
(1)  775/    2071 : 74                             adc
(1)  776/    2072 : AF                             plo   R15
(1)  777/    2073 : 9E                             ghi   R14
(1)  778/    2074 : 52                             str   r2
(1)  779/    2075 : 9F                             ghi   R15
(1)  780/    2076 : 74                             adc
(1)  781/    2077 : BF                             phi   R15
(1)  782/    2078 : 9C                             ghi   R12                    ; see if need carry from low to high
(1)  783/    2079 : C2 20 79                       lbz   mul_no                ; jump if no carry is needed
(1)  784/    207C : 8D                             glo   R13                    ; move the carry on over
(1)  785/    207D : FC 01                          adi   1
(1)  786/    207F : AD                             plo   R13
(1)  787/    2080 : 9D                             ghi   R13
(1)  788/    2081 : 7C 00                          adci  0
(1)  789/    2083 : BD                             phi   R13
(1)  790/    2084 : 8F                             glo   R15
(1)  791/    2085 : 7C 00                          adci  0
(1)  792/    2087 : AF                             plo   R15
(1)  793/    2088 : 9F                             ghi   R15
(1)  794/    2089 : 7C 00                          adci  0
(1)  795/    208B : BF                             phi   R15
(1)  796/    208C : 60                  mul_no:    irx                         ; recover ct
(1)  797/    208D : F0                             ldx
(1)  798/    208E : FC 01                          adi   1                     ; increment by 1
(1)  799/    2090 : 73                             stxd                        ; and put it back
(1)  800/    2091 : 89                             glo   F9                    ; shift mulL left
(1)  801/    2092 : FE                             shl
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 146 - 1/18/2018 14:51:20


(1)  802/    2093 : A9                             plo   F9
(1)  803/    2094 : 99                             ghi   F9
(1)  804/    2095 : 7E                             shlc
(1)  805/    2096 : B9                             phi   F9
(1)  806/    2097 : 88                             glo   r8
(1)  807/    2098 : 7E                             shlc
(1)  808/    2099 : A8                             plo   r8
(1)  809/    209A : 98                             ghi   r8
(1)  810/    209B : 7E                             shlc
(1)  811/    209C : B8                             phi   r8
(1)  812/    209D : 86                             glo   r6                    ; shift mulH left
(1)  813/    209E : FE                             shl
(1)  814/    209F : A6                             plo   r6
(1)  815/    20A0 : 96                             ghi   r6
(1)  816/    20A1 : 7E                             shlc
(1)  817/    20A2 : B6                             phi   r6
(1)  818/    20A3 : 8E                             glo   R14
(1)  819/    20A4 : 7E                             shlc
(1)  820/    20A5 : AE                             plo   R14
(1)  821/    20A6 : 9E                             ghi   R14
(1)  822/    20A7 : 7E                             shlc
(1)  823/    20A8 : BE                             phi   R14
(1)  824/    20A9 : 98                             ghi   r8                    ; see if a carry is needed
(1)  825/    20AA : C2 20 2F                       lbz   mul_lp1               ; jump if not
(1)  826/    20AD : F8 00                          ldi   0                     ; zero the high byte
(1)  827/    20AF : B8                             phi   r8
(1)  828/    20B0 : 86                             glo   r6                    ; add in the carry
(1)  829/    20B1 : F9 01                          ori   1
(1)  830/    20B3 : A6                             plo   r6
(1)  831/    20B4 : C0 20 2F                       lbr   mul_lp1               ; loop back for more
(1)  832/    20B7 : 60                  mul_dn:    irx                         ; recover ct
(1)  833/    20B8 : 72                             ldxa
(1)  834/    20B9 : AE                             plo   R14                    ; set aside
(1)  835/    20BA : 72                             ldxa
(1)  836/    20BB : A6                             plo   r6
(1)  837/    20BC : 72                             ldxa
(1)  838/    20BD : B6                             phi   r6
(1)  839/    20BE : F0                             ldx
(1)  840/    20BF : BE                             phi   R14
(1)  841/    20C0 : 9C                             ghi   R12                    ; transfer resL to arg1
(1)  842/    20C1 : B8                             phi   r8
(1)  843/    20C2 : 8C                             glo   R12
(1)  844/    20C3 : A8                             plo   r8
(1)  845/    20C4 : 97                             ghi   F7
(1)  846/    20C5 : B9                             phi   F9
(1)  847/    20C6 : 87                             glo   F7
(1)  848/    20C7 : A9                             plo   F9
(1)  849/    20C8 : 8E                             glo   R14
(1)  850/    20C9 : AC                             plo   R12                    ; put ct into RC.0
(1)  851/    20CA : 8C                  mul_lp2:   glo   R12                    ; get ct
(1)  852/    20CB : FF 02                          smi   2                     ; see if <2
(1)  853/    20CD : CB 20 CD                       lbnf  mul_nxt1              ; jump if so
(1)  854/    20D0 : (MACRO)                        ccall    fp_shr_1           ; shift answer to the right 17-03-06
(1)  854/    20D0 : =>FALSE              if MOMCPU=$1805
(1)  854/    20D0 :                             SCAL    6
(1)  854/    20D0 :                             dw      FP_SHR_1
(1)  854/    20D0 : =>TRUE               else
(1)  854/    20D0 : D4                          sep     RCALL
(1)  854/    20D1 : 1D 72                       dw      FP_SHR_1
(1)  854/    20D3 : [854]                endif
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 147 - 1/18/2018 14:51:20


(1)  855/    20D3 : (MACRO)                        ccall    fp_shr_fd          ; shift resH right 17-03-06
(1)  855/    20D3 : =>FALSE              if MOMCPU=$1805
(1)  855/    20D3 :                             SCAL    6
(1)  855/    20D3 :                             dw      FP_SHR_FD
(1)  855/    20D3 : =>TRUE               else
(1)  855/    20D3 : D4                          sep     RCALL
(1)  855/    20D4 : 1D A3                       dw      FP_SHR_FD
(1)  855/    20D6 : [855]                endif
(1)  856/    20D6 : CB 20 D6                       lbnf  mul_lp2a              ; jump if no carry into low word
(1)  857/    20D9 : 88                             glo   r8                    ; set high bit
(1)  858/    20DA : F9 80                          ori   080h
(1)  859/    20DC : A8                             plo   r8
(1)  860/    20DD : 2C                  mul_lp2a:  dec   R12                    ; decrement count
(1)  861/    20DE : C0 20 CA                       lbr   mul_lp2               ; loop back to keep checking
(1)  862/    20E1 : 60                  mul_nxt1:  irx                         ; recover sign
(1)  863/    20E2 : 72                             ldxa
(1)  864/    20E3 : A7                             plo   F7
(1)  865/    20E4 : F0                             ldx                         ; recover answer exponent
(1)  866/    20E5 : AC                             plo   R12
(1)  867/    20E6 : 9F                  mul_lp3:   ghi   R15                    ; check resH for nonzero
(1)  868/    20E7 : CA 20 E7                       lbnz  mul_lp3a
(1)  869/    20EA : 8F                             glo   R15
(1)  870/    20EB : CA 20 EB                       lbnz  mul_lp3a
(1)  871/    20EE : 9D                             ghi   R13
(1)  872/    20EF : CA 20 EF                       lbnz  mul_lp3a
(1)  873/    20F2 : 8D                             glo   R13
(1)  874/    20F3 : CA 20 F3                       lbnz  mul_lp3a
(1)  875/    20F6 : C0 20 F6                       lbr   mul_lp4               ; jump if no bits set in resH
(1)  876/    20F9 : 1C                  mul_lp3a:  inc   R12                    ; increment exponent
(1)  877/    20FA : (MACRO)                        Ccall fp_shr_1                ; shift answer to the right
(1)  877/    20FA : =>FALSE              if MOMCPU=$1805
(1)  877/    20FA :                             SCAL    6
(1)  877/    20FA :                             dw      FP_SHR_1
(1)  877/    20FA : =>TRUE               else
(1)  877/    20FA : D4                          sep     RCALL
(1)  877/    20FB : 1D 72                       dw      FP_SHR_1
(1)  877/    20FD : [877]                endif
(1)  878/    20FD : (MACRO)                        Ccall fp_shr_fd               ; shift resH right
(1)  878/    20FD : =>FALSE              if MOMCPU=$1805
(1)  878/    20FD :                             SCAL    6
(1)  878/    20FD :                             dw      FP_SHR_FD
(1)  878/    20FD : =>TRUE               else
(1)  878/    20FD : D4                          sep     RCALL
(1)  878/    20FE : 1D A3                       dw      FP_SHR_FD
(1)  878/    2100 : [878]                endif
(1)  879/    2100 : CB 20 E6                       lbnf  mul_lp3               ; jump if no carry into low word
(1)  880/    2103 : 88                             glo   r8                    ; set high bit
(1)  881/    2104 : F9 80                          ori   080h
(1)  882/    2106 : A8                             plo   r8
(1)  883/    2107 : C0 20 E6                       lbr   mul_lp3
(1)  884/    210A : 8C                  mul_lp4:   glo   R12                    ; transfer exponent
(1)  885/    210B : BF                             phi   R15                    ; to high R15
(1)  886/    210C : C0 1D B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  887/    210F :                     
(1)  888/    210F :                     ; ***************************************
(1)  889/    210F :                     ; *** Convert ascii to floating point ***
(1)  890/    210F :                     ; *** RF - buffer to ascii text       ***
(1)  891/    210F :                     ; *** Returns: R8:F9 - number         ***
(1)  892/    210F :                     ; ***************************************
(1)  893/    210F : 4F                  fp_atof:   lda   R15                    ; get byte from buffer
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 148 - 1/18/2018 14:51:20


(1)  894/    2110 : FF 20                          smi   ' '                   ; check for space
(1)  895/    2112 : C2 21 0F                       lbz   fp_atof               ; move past any spaces
(1)  896/    2115 : 2F                             dec   R15                    ; point back to nonspace chara
(1)  897/    2116 : 0F                             ldn   R15                    ; check for possible sign
(1)  898/    2117 : FF 2D                          smi   '-'                   ; first check for minus
(1)  899/    2119 : CA 21 19                       lbnz   atof_nm              ; jump if not minus
(1)  900/    211C : F8 80                          ldi   080h                  ; high bit set for minus
(1)  901/    211E : 73                             stxd                        ; place onto stack
(1)  902/    211F : 1F                             inc   R15                    ; move past sign
(1)  903/    2120 : C0 21 20                       lbr   atof_go1              ; and continue
(1)  904/    2123 : F8 00               atof_nm:   ldi   0                     ; indicate positive number
(1)  905/    2125 : 73                             stxd                        ; place onto stack
(1)  906/    2126 : 0F                             ldn   R15                    ; now check for + sign
(1)  907/    2127 : FF 2B                          smi   '+'
(1)  908/    2129 : CA 21 29                       lbnz  atof_go1              ; jump if not plus
(1)  909/    212C : 1F                             inc   R15                    ; move past plus sign
(1)  910/    212D : F8 00               atof_go1:  ldi   0                     ; setup result
(1)  911/    212F : B8                             phi   r8
(1)  912/    2130 : A8                             plo   r8
(1)  913/    2131 : B9                             phi   F9
(1)  914/    2132 : A9                             plo   F9
(1)  915/    2133 : 0F                  atof_lp1:  ldn   R15                    ; get next byte from buffer
(1)  916/    2134 : (MACRO)                        Ccall f_isnum                ; is it numeric
(1)  916/    2134 : =>FALSE              if MOMCPU=$1805
(1)  916/    2134 :                             SCAL    6
(1)  916/    2134 :                             dw      F_ISNUM
(1)  916/    2134 : =>TRUE               else
(1)  916/    2134 : D4                          sep     RCALL
(1)  916/    2135 : 1D 62                       dw      F_ISNUM
(1)  916/    2137 : [916]                endif
(1)  917/    2137 : CB 21 37                       lbnf  atof_no1              ; jump if not
(1)  918/    213A : 98                             ghi   r8                    ; copy arg1 to arg2
(1)  919/    213B : BA                             phi   R10
(1)  920/    213C : 88                             glo   r8
(1)  921/    213D : AA                             plo   R10
(1)  922/    213E : 99                             ghi   F9
(1)  923/    213F : BB                             phi   FB
(1)  924/    2140 : 89                             glo   F9
(1)  925/    2141 : AB                             plo   FB
(1)  926/    2142 : (MACRO)                        Ccall fp_shl_1                ; multiply arg1 by 2
(1)  926/    2142 : =>FALSE              if MOMCPU=$1805
(1)  926/    2142 :                             SCAL    6
(1)  926/    2142 :                             dw      FP_SHL_1
(1)  926/    2142 : =>TRUE               else
(1)  926/    2142 : D4                          sep     RCALL
(1)  926/    2143 : 1D 7F                       dw      FP_SHL_1
(1)  926/    2145 : [926]                endif
(1)  927/    2145 : (MACRO)                        Ccall fp_shl_1                 ; multiply arg1 by 4
(1)  927/    2145 : =>FALSE              if MOMCPU=$1805
(1)  927/    2145 :                             SCAL    6
(1)  927/    2145 :                             dw      FP_SHL_1
(1)  927/    2145 : =>TRUE               else
(1)  927/    2145 : D4                          sep     RCALL
(1)  927/    2146 : 1D 7F                       dw      FP_SHL_1
(1)  927/    2148 : [927]                endif
(1)  928/    2148 : (MACRO)                        Ccall fp_add_12                ; multiply arg1 by 5
(1)  928/    2148 : =>FALSE              if MOMCPU=$1805
(1)  928/    2148 :                             SCAL    6
(1)  928/    2148 :                             dw      FP_ADD_12
(1)  928/    2148 : =>TRUE               else
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 149 - 1/18/2018 14:51:20


(1)  928/    2148 : D4                          sep     RCALL
(1)  928/    2149 : 1D 8C                       dw      FP_ADD_12
(1)  928/    214B : [928]                endif
(1)  929/    214B : (MACRO)                        Ccall fp_shl_1                ; multiply arg1 by 10
(1)  929/    214B : =>FALSE              if MOMCPU=$1805
(1)  929/    214B :                             SCAL    6
(1)  929/    214B :                             dw      FP_SHL_1
(1)  929/    214B : =>TRUE               else
(1)  929/    214B : D4                          sep     RCALL
(1)  929/    214C : 1D 7F                       dw      FP_SHL_1
(1)  929/    214E : [929]                endif
(1)  930/    214E : 4F                             lda   R15                    ; get number
(1)  931/    214F : FF 30                          smi   '0'                   ; convert to binary
(1)  932/    2151 : 52                             str   r2                    ; setup for add
(1)  933/    2152 : 89                             glo   F9                    ; add in next digit
(1)  934/    2153 : F4                             add
(1)  935/    2154 : A9                             plo   F9
(1)  936/    2155 : 99                             ghi   F9                    ; propagate carry
(1)  937/    2156 : 7C 00                          adci  0
(1)  938/    2158 : B9                             phi   F9
(1)  939/    2159 : 88                             glo   r8
(1)  940/    215A : 7C 00                          adci  0
(1)  941/    215C : A8                             plo   r8
(1)  942/    215D : 98                             ghi   r8
(1)  943/    215E : 7C 00                          adci  0
(1)  944/    2160 : B8                             phi   r8
(1)  945/    2161 : C0 21 33                       lbr   atof_lp1              ; loop until no more digits
(1)  946/    2164 : 0F                  atof_no1:  ldn   R15                    ; check for decimal point
(1)  947/    2165 : FF 2E                          smi   '.'
(1)  948/    2167 : CA 21 67                       lbnz  atof_ndp              ; jump if none
(1)  949/    216A : 1F                             inc   R15                    ; move past decimal
(1)  950/    216B : F8 21               atof_ndp:  ldi   scratch>>8          ; point to scratch area
(1)  951/    216D : BA                             phi   R10
(1)  952/    216E : F8 6E                          ldi   scratch&255
(1)  953/    2170 : AA                             plo   R10
(1)  954/    2171 : F8 10                          ldi   16                    ; 16 bytes to clear
(1)  955/    2173 : AC                             plo   R12
(1)  956/    2174 : F8 00               atof_lpx:  ldi   0
(1)  957/    2176 : 5A                             str   R10
(1)  958/    2177 : 1A                             inc   R10
(1)  959/    2178 : 2C                             dec   R12
(1)  960/    2179 : 8C                             glo   R12
(1)  961/    217A : CA 21 74                       lbnz  atof_lpx
(1)  962/    217D : F8 21                          ldi   (scratch+1)>>8      ; point to scratch area
(1)  963/    217F : BA                             phi   R10
(1)  964/    2180 : F8 81                          ldi   (scratch+1)&255
(1)  965/    2182 : AA                             plo   R10
(1)  966/    2183 : F8 01                          ldi   1                     ; setup count
(1)  967/    2185 : AC                             plo   R12
(1)  968/    2186 : F8 00                          ldi   0                     ; setup exp flag
(1)  969/    2188 : BC                             phi   R12
(1)  970/    2189 : 8C                  atof_lp2:  glo   R12                    ; see if done making bcd
(1)  971/    218A : FF 11                          smi   17
(1)  972/    218C : C2 21 8C                       lbz   atof_dn3              ; jump if so
(1)  973/    218F : 0F                             ldn   R15                    ; get character
(1)  974/    2190 : (MACRO)                        ccall    f_isnum                 ; is it numeric
(1)  974/    2190 : =>FALSE              if MOMCPU=$1805
(1)  974/    2190 :                             SCAL    6
(1)  974/    2190 :                             dw      F_ISNUM
(1)  974/    2190 : =>TRUE               else
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 150 - 1/18/2018 14:51:20


(1)  974/    2190 : D4                          sep     RCALL
(1)  974/    2191 : 1D 62                       dw      F_ISNUM
(1)  974/    2193 : [974]                endif
(1)  975/    2193 : CB 21 93                       lbnf  atof_dn3              ; jump if not
(1)  976/    2196 : 4F                             lda   R15                    ; get character
(1)  977/    2197 : FF 30                          smi   '0'                   ; converto to binary
(1)  978/    2199 : 5A                             str   R10                    ; write into bcd area
(1)  979/    219A : 1A                             inc   R10
(1)  980/    219B : 1C                             inc   R12                    ; increment count
(1)  981/    219C : CA 21 89                       lbnz  atof_lp2              ; loop back until done
(1)  982/    219F : F8 01                          ldi   1                     ; set non zero flag
(1)  983/    21A1 : BC                             phi   R12
(1)  984/    21A2 : C0 21 89                       lbr   atof_lp2
(1)  985/    21A5 : 9C                  atof_dn3:  ghi   R12                    ; check for non-zero digits
(1)  986/    21A6 : CA 21 A6                       lbnz  atof_nz
(1)  987/    21A9 : 98                             ghi   r8                    ; check for non-zero integer
(1)  988/    21AA : CA 21 AA                       lbnz  atof_nz
(1)  989/    21AD : 88                             glo   r8
(1)  990/    21AE : CA 21 AE                       lbnz  atof_nz
(1)  991/    21B1 : 99                             ghi   F9
(1)  992/    21B2 : CA 21 B2                       lbnz  atof_nz
(1)  993/    21B5 : 89                             glo   F9
(1)  994/    21B6 : CA 21 B6                       lbnz  atof_nz
(1)  995/    21B9 : 60                             irx                         ; recover sign
(1)  996/    21BA : F0                             ldx
(1)  997/    21BB : B8                             phi   r8                    ; put in high of zero
(1)  998/    21BC : C0 21 BC                       lbr	atof_end               ; and return
(1)  999/    21BF : F8 00               atof_nz:   ldi   0                     ; setup dp
(1) 1000/    21C1 : BC                             phi   R12
(1) 1001/    21C2 : 98                  atof_lp3:  ghi   r8                    ; check for high bit set
(1) 1002/    21C3 : FA 80                          ani   080h
(1) 1003/    21C5 : CA 21 C5                       lbnz  atof_dn4              ; jump if so
(1) 1004/    21C8 : (MACRO)                        Ccall fp_shl_1                ; shift answer left
(1) 1004/    21C8 : =>FALSE              if MOMCPU=$1805
(1) 1004/    21C8 :                             SCAL    6
(1) 1004/    21C8 :                             dw      FP_SHL_1
(1) 1004/    21C8 : =>TRUE               else
(1) 1004/    21C8 : D4                          sep     RCALL
(1) 1004/    21C9 : 1D 7F                       dw      FP_SHL_1
(1) 1004/    21CB : [1004]               endif
(1) 1005/    21CB : F8 21                          ldi   scratch>>8          ; point to bcd number
(1) 1006/    21CD : BA                             phi   R10
(1) 1007/    21CE : F8 CE                          ldi   255&scratch
(1) 1008/    21D0 : AA                             plo   R10
(1) 1009/    21D1 : F8 00                          ldi   0                     ; set high byte to zero
(1) 1010/    21D3 : 5A                             str   R10
(1) 1011/    21D4 : F8 21                          ldi   (scratch+15)>>8     ; point to last cell
(1) 1012/    21D6 : BA                             phi   R10
(1) 1013/    21D7 : F8 E6                          ldi   255&(scratch+15)
(1) 1014/    21D9 : AA                             plo   R10
(1) 1015/    21DA : F8 00                          ldi   0                     ; set carry forward
(1) 1016/    21DC : AE                             plo   R14
(1) 1017/    21DD : F8 10                          ldi   16                    ; setup count
(1) 1018/    21DF : AC                             plo   R12
(1) 1019/    21E0 : 8E                  atof_lp4:  glo   R14                    ; get carry
(1) 1020/    21E1 : 52                             str   r2                    ; in memory for add
(1) 1021/    21E2 : 0A                             ldn   R10                    ; get bcd digit
(1) 1022/    21E3 : F4                             add                         ; add in carry
(1) 1023/    21E4 : 52                             str   r2                    ; place into memory
(1) 1024/    21E5 : 0A                             ldn   R10                    ; recover bcd digit
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 151 - 1/18/2018 14:51:20


(1) 1025/    21E6 : F4                             add                         ; digit now doubled with carry
(1) 1026/    21E7 : 5A                             str   R10                    ; put it back
(1) 1027/    21E8 : FF 0A                          smi   10
(1) 1028/    21EA : CB 21 EA                       lbnf  atof_no4              ; jump if below 10
(1) 1029/    21ED : 5A                             str   R10                    ; store value - 10
(1) 1030/    21EE : F8 01                          ldi   1                     ; carry set to 1
(1) 1031/    21F0 : C8                             lskp                        ; skip next instruction
(1) 1032/    21F1 : F8 00               atof_no4:  ldi   0                     ; reset carry
(1) 1033/    21F3 : AE                             plo   R14
(1) 1034/    21F4 : 2A                             dec   R10                    ; move to previous digit
(1) 1035/    21F5 : 2C                             dec   R12                    ; decrement digit count
(1) 1036/    21F6 : 8C                             glo   R12                    ; see if done
(1) 1037/    21F7 : CA 21 E0                       lbnz  atof_lp4              ; jump if not
(1) 1038/    21FA : F8 21                          ldi   scratch>>8	       ; point to first digit
(1) 1039/    21FC : BA                             phi   R10
(1) 1040/    21FD : F8 FD                          ldi   255&scratch
(1) 1041/    21FF : AA                             plo   R10
(1) 1042/    2200 : 0A                             ldn   R10                    ; retrieve it
(1) 1043/    2201 : C2 22 01                       lbz   atof_nc4              ; jump if no carry
(1) 1044/    2204 : 89                             glo   F9                    ; add in the carry
(1) 1045/    2205 : F9 01                          ori   1
(1) 1046/    2207 : A9                             plo   F9
(1) 1047/    2208 : 9C                  atof_nc4:  ghi   R12                    ; increment dp
(1) 1048/    2209 : FC 01                          adi   1
(1) 1049/    220B : BC                             phi   R12
(1) 1050/    220C : C0 21 C2                       lbr   atof_lp3              ; loop until full
(1) 1051/    220F : 9C                  atof_dn4:  ghi   R12                    ; get dp
(1) 1052/    2210 : 52                             str   r2                    ; into memory
(1) 1053/    2211 : F8 1F                          ldi   31                    ; need to subtract from 31
(1) 1054/    2213 : F7                             sm
(1) 1055/    2214 : FC 7F                          adi   127                   ; add in bias
(1) 1056/    2216 : BD                             phi   R13                    ; set aside
(1) 1057/    2217 : 99                             ghi   F9                    ; shift result down 8 bits
(1) 1058/    2218 : A9                             plo   F9
(1) 1059/    2219 : 88                             glo   r8
(1) 1060/    221A : B9                             phi   F9
(1) 1061/    221B : 98                             ghi   r8
(1) 1062/    221C : FE                             shl                         ; shift out high bit
(1) 1063/    221D : A8                             plo   r8
(1) 1064/    221E : 9D                             ghi   R13                    ; get bit 0 of exponent
(1) 1065/    221F : F6                             shr
(1) 1066/    2220 : B8                             phi   r8                    ; bits 1-7 into high byte
(1) 1067/    2221 : 88                             glo   r8                    ; get mantissa
(1) 1068/    2222 : 76                             shrc                        ; shift in bit 0 of exponent
(1) 1069/    2223 : A8                             plo   r8                    ; and write it
(1) 1070/    2224 : 60                             irx                         ; point to sign
(1) 1071/    2225 : 98                             ghi   r8                    ; high byte
(1) 1072/    2226 : F1                             or                          ; set sign
(1) 1073/    2227 : B8                             phi   r8                    ; done with base conversion
(1) 1074/    2228 : 0F                             ldn   R15                    ; get next byte
(1) 1075/    2229 : FF 65                          smi   'e'                   ; check for exponents
(1) 1076/    222B : C2 22 2B                       lbz   atof_exp
(1) 1077/    222E : 0F                             ldn   R15
(1) 1078/    222F : FF 45                          smi   'E'
(1) 1079/    2231 : CA 22 31                       lbnz  atof_end
(1) 1080/    2234 : 1F                  atof_exp:  inc   R15                    ; move past E
(1) 1081/    2235 : 0F                             ldn   R15                    ; check for sign
(1) 1082/    2236 : FF 2D                          smi   '-'
(1) 1083/    2238 : C2 22 38                       lbz   atof_n
(1) 1084/    223B : 0F                             ldn   R15
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 152 - 1/18/2018 14:51:20


(1) 1085/    223C : FF 2B                          smi   '+'
(1) 1086/    223E : C2 22 3E                       lbz   atof_p
(1) 1087/    2241 : 2F                             dec   R15                    ; positive if no sign
(1) 1088/    2242 : F8 01               atof_p:    ldi   1                     ; indicate positive exponent
(1) 1089/    2244 : C8                             lskp
(1) 1090/    2245 : F8 00               atof_n:    ldi   0                     ; indicate negative exponent
(1) 1091/    2247 : BC                             phi   R12                    ; place into sign variable
(1) 1092/    2248 : 1F                             inc   R15                    ; move past sign
(1) 1093/    2249 : F8 00                          ldi   0                     ; setup intial count
(1) 1094/    224B : AC                             plo   R12
(1) 1095/    224C : 0F                  atof_lp5:  ldn   R15                    ; get next byte
(1) 1096/    224D : (MACRO)                        Ccall f_isnum                ; see if numeric
(1) 1096/    224D : =>FALSE              if MOMCPU=$1805
(1) 1096/    224D :                             SCAL    6
(1) 1096/    224D :                             dw      F_ISNUM
(1) 1096/    224D : =>TRUE               else
(1) 1096/    224D : D4                          sep     RCALL
(1) 1096/    224E : 1D 62                       dw      F_ISNUM
(1) 1096/    2250 : [1096]               endif
(1) 1097/    2250 : CB 22 50                       lbnf  atof_dn5              ; jump if not
(1) 1098/    2253 : 8C                             glo   R12                    ; make copy of exponent
(1) 1099/    2254 : 52                             str   r2
(1) 1100/    2255 : F6                             shr                         ; multiply by 2
(1) 1101/    2256 : F6                             shr                         ; by 4
(1) 1102/    2257 : F4                             add                         ; by 5
(1) 1103/    2258 : F6                             shr                         ; by 10
(1) 1104/    2259 : 52                             str   r2                    ; put here for add
(1) 1105/    225A : 4F                             lda   R15                    ; recover number
(1) 1106/    225B : FF 30                          smi   '0'                   ; convert to binary
(1) 1107/    225D : F4                             add                         ; add with total
(1) 1108/    225E : AC                             plo   R12                    ; copy back to R12
(1) 1109/    225F : C0 22 4C                       lbr   atof_lp5              ; loop back until done reading exponent
(1) 1110/    2262 : 8C                  atof_dn5:  glo   R12                    ; see if done
(1) 1111/    2263 : C2 22 63                       lbz   atof_end              ; jump if so
(1) 1112/    2266 : 2C                             dec   R12                    ; otherwise decrement count
(1) 1113/    2267 : 8C                             glo   R12                    ; save count
(1) 1114/    2268 : 73                             stxd
(1) 1115/    2269 : 9C                             ghi   R12                    ; save sign
(1) 1116/    226A : 73                             stxd
(1) 1117/    226B : 8F                             glo   R15
(1) 1118/    226C : 73                             stxd
(1) 1119/    226D : 9F                             ghi   R15
(1) 1120/    226E : 73                             stxd
(1) 1121/    226F : F8 41                          ldi   041h                  ; setup 10.0
(1) 1122/    2271 : BA                             phi   R10
(1) 1123/    2272 : F8 20                          ldi   020h
(1) 1124/    2274 : AA                             plo   R10
(1) 1125/    2275 : F8 00                          ldi   0
(1) 1126/    2277 : BB                             phi   FB
(1) 1127/    2278 : AB                             plo   FB
(1) 1128/    2279 : 9C                             ghi   R12
(1) 1129/    227A : C2 22 7A                       lbz   atof_div              ; jump if negative
(1) 1130/    227D : (MACRO)                        Ccall fp_mul                 ; multiply by 10
(1) 1130/    227D : =>FALSE              if MOMCPU=$1805
(1) 1130/    227D :                             SCAL    6
(1) 1130/    227D :                             dw      FP_MUL
(1) 1130/    227D : =>TRUE               else
(1) 1130/    227D : D4                          sep     RCALL
(1) 1130/    227E : 1F EB                       dw      FP_MUL
(1) 1130/    2280 : [1130]               endif
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(LCC1802fp.inc) - page 153 - 1/18/2018 14:51:20


(1) 1131/    2280 : C0 22 80                       lbr   atof_go5              ; clean up call
(1) 1132/    2283 : (MACRO)             atof_div:  Ccall fp_div                 ; divice by 10
(1) 1132/    2283 : =>FALSE              if MOMCPU=$1805
(1) 1132/    2283 :                             SCAL    6
(1) 1132/    2283 :                             dw      FP_DIV
(1) 1132/    2283 : =>TRUE               else
(1) 1132/    2283 : D4                          sep     RCALL
(1) 1132/    2284 : 1E FB                       dw      FP_DIV
(1) 1132/    2286 : [1132]               endif
(1) 1133/    2286 : 60                  atof_go5:  irx                         ; recover variables
(1) 1134/    2287 : 72                             ldxa
(1) 1135/    2288 : BF                             phi   R15
(1) 1136/    2289 : 72                             ldxa
(1) 1137/    228A : AF                             plo   R15
(1) 1138/    228B : 72                             ldxa
(1) 1139/    228C : BC                             phi   R12
(1) 1140/    228D : F0                             ldx
(1) 1141/    228E : AC                             plo   R12
(1) 1142/    228F : C0 22 62                       lbr   atof_dn5              ; loop until exponent is zero
(1) 1143/    2292 :                     atof_end:
(1) 1144/    2292 : 12                  	   inc	r2	;wjr release work area
(1) 1145/    2293 : (MACRO)             	   popr R13	;wjr restore param regs
(1) 1145/    2293 : 12                          inc     sp
(1) 1145/    2294 : 42                          lda     sp
(1) 1145/    2295 : BD                          phi     R13
(1) 1145/    2296 : 02                          ldn     sp
(1) 1145/    2297 : AD                          plo     R13
(1) 1146/    2298 : (MACRO)             	   popr R12	;wjr
(1) 1146/    2298 : 12                          inc     sp
(1) 1146/    2299 : 42                          lda     sp
(1) 1146/    229A : BC                          phi     R12
(1) 1146/    229B : 02                          ldn     sp
(1) 1146/    229C : AC                          plo     R12
(1) 1147/    229D : (MACRO)             	   popr	F7	;wjr restore c variable
(1) 1147/    229D : 12                          inc     sp
(1) 1147/    229E : 42                          lda     sp
(1) 1147/    229F : B7                          phi     F7
(1) 1147/    22A0 : 02                          ldn     sp
(1) 1147/    22A1 : A7                          plo     F7
(1) 1148/    22A2 : (MACRO)             	   Cretn
(1) 1148/    22A2 : =>FALSE              if MOMCPU=$1805
(1) 1148/    22A2 :                             sret    6
(1) 1148/    22A2 : =>TRUE               else
(1) 1148/    22A2 : D5                          sep     RRET
(1) 1148/    22A3 : [1148]               endif
(1) 1149/    22A3 : 00 00               scratch:   db	00,00
    1719/    22A5 :                     	include IO1802.inc
(1)    1/    22A5 :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/    22A5 :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/    22A5 :                     ;17-10-16 adding _putcpace(port,byte) to limit output speed to the AVR
(1)    4/    22A5 :                     ;         defaulting putc(x) to putcpace(7,x)
(1)    5/    22A5 :                     ;17-11-22 removing putc altogether
(1)    6/    22A5 :                     
(1)    7/    22A5 :                     _inp:		;raw port input
(1)    8/    22A5 :                     		;stores a small tailored program on the stack and executes it
(1)    9/    22A5 : 22                  	dec	sp	;work backwards
(1)   10/    22A6 : F8 D3               	ldi	0xD3	;return instruction
(1)   11/    22A8 : 73                  	stxd		
(1)   12/    22A9 : 8C                  	glo	regarg1	;get the port number
(1)   13/    22AA : FA 07               	ani	0x07	;clean it
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm(IO1802.inc) - page 154 - 1/18/2018 14:51:20


(1)   14/    22AC : 32 AC               	bz	+	; inp(0) isn't valid
(1)   15/    22AE : F9 68               	ori	0x68	;make it an input instruction
(1)   16/    22B0 : 73                  	stxd		;store it for execution
(1)   17/    22B1 : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   17/    22B1 : 82                          glo     SP
(1)   17/    22B2 : A8                          plo     RT1
(1)   17/    22B3 : 92                          ghi     SP
(1)   17/    22B4 : B8                          phi     RT1
(1)   18/    22B5 : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   19/    22B6 : D8                  	sep	rt1	;execute it
(1)   20/    22B7 :                     ;we will come back to here with the input byte in D
(1)   21/    22B7 : 12                  	inc	sp	;step over the work area
(1)   22/    22B8 : AF                  	plo	retVal	;save it to return
(1)   23/    22B9 : F8 00               	ldi	0
(1)   24/    22BB : BF                  	phi	retval	;clear top byte
(1)   25/    22BC : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   26/    22BD : 12                  	inc	sp	;and the D3
(1)   27/    22BE : (MACRO)             	Cretn		;and we're done
(1)   27/    22BE : =>FALSE              if MOMCPU=$1805
(1)   27/    22BE :                             sret    6
(1)   27/    22BE : =>TRUE               else
(1)   27/    22BE : D5                          sep     RRET
(1)   27/    22BF : [27]                 endif
(1)   28/    22BF :                     	
(1)   29/    22BF :                     _out:		;raw port output
(1)   30/    22BF :                     		;stores a small tailored program on the stack and executes it
(1)   31/    22BF :                     		;this could be bolder:
(1)   32/    22BF :                     		;store the program as 6x cc D5 where x is the port number and cc is the char
(1)   33/    22BF :                     		;then SEP sp
(1)   34/    22BF :                     		;the D5 would return to the calling program and finish fixing the stack.
(1)   35/    22BF :                     		;saves 6 instructions but it's a bit tricky.
(1)   36/    22BF : 22                  	dec	sp	;work backwards
(1)   37/    22C0 : F8 D3               	ldi	0xD3	;return instruction
(1)   38/    22C2 : 73                  	stxd		
(1)   39/    22C3 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the OUT instruction
(1)   39/    22C3 : 82                          glo     SP
(1)   39/    22C4 : A8                          plo     RT1
(1)   39/    22C5 : 92                          ghi     SP
(1)   39/    22C6 : B8                          phi     RT1
(1)   40/    22C7 : 8C                  	glo	regarg1	;get the port number
(1)   41/    22C8 : FA 07               	ani	0x07	;clean it
(1)   42/    22CA : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   43/    22CC : 73                  	stxd		;store it for execution
(1)   44/    22CD : 8D                  	glo	regarg2	;get the byte to be written
(1)   45/    22CE : 52                  	str	sp	;store it where sp points
(1)   46/    22CF : D8                  	sep	rt1	;execute it
(1)   47/    22D0 :                     ;we will come back to here with sp stepped up by one
(1)   48/    22D0 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   49/    22D1 : 12                  	inc	sp	;and the D3
(1)   50/    22D2 : (MACRO)             	Cretn		;and we're done
(1)   50/    22D2 : =>FALSE              if MOMCPU=$1805
(1)   50/    22D2 :                             sret    6
(1)   50/    22D2 : =>TRUE               else
(1)   50/    22D2 : D5                          sep     RRET
(1)   50/    22D3 : [50]                 endif
(1)   51/    22D3 :                     	
(1)   52/    22D3 :                     	
(1)   53/    22D3 :                     
    1720/    22D3 :                     
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 155 - 1/18/2018 14:51:20


  symbol table (* = unused):
  ------------------------

 ACK :                            6 - | *ADD_A1NZ :                    1E0A C |
*ADD_A2NZ :                    1E1B C | *ADD_FNL :                     1EBF C |
 ADD_LP1 :                     1E62 C | *ADD_LP1DN :                   1E77 C |
*ADD_NM :                      1E86 C | *ADD_NO :                      1EA8 C |
*ADD_NS :                      1E50 C | *ADD_NX :                      1EEE C |
 ADD_NZ :                      1EE0 C |  AGAIN283 :                    1845 C |
*ARCHITECTURE :  i386-unknown-win32 - | *ATOF_DIV :                    2283 C |
*ATOF_DN3 :                    21A5 C | *ATOF_DN4 :                    220F C |
 ATOF_DN5 :                    2262 C | *ATOF_END :                    2292 C |
*ATOF_EXP :                    2234 C | *ATOF_GO1 :                    212D C |
*ATOF_GO5 :                    2286 C |  ATOF_LP1 :                    2133 C |
 ATOF_LP2 :                    2189 C |  ATOF_LP3 :                    21C2 C |
 ATOF_LP4 :                    21E0 C |  ATOF_LP5 :                    224C C |
 ATOF_LPX :                    2174 C | *ATOF_N :                      2245 C |
*ATOF_NC4 :                    2208 C | *ATOF_NDP :                    216B C |
*ATOF_NM :                     2123 C | *ATOF_NO1 :                    2164 C |
*ATOF_NO4 :                    21F1 C | *ATOF_NZ :                     21BF C |
*ATOF_P :                      2242 C |  BAUDRATE :                    2580 - |
*BIGENDIAN :                      0 - |  BITLOOP288 :                  1ABA C |
 BLKSIZE :                       80 - | *BRANCHEXT :                      0 - |
*BVTABLE130 :                   8DF C |  CAN :                           18 - |
*CASESENSITIVE :                  0 - | *CHECK_SUB286 :                1996 C |
*CKEOT :                        667 C |  CKNEXT288 :                   1B09 C |
 CKTOP288 :                    1AA5 C |  CLRLP288 :                    1A96 C |
 CODELOC :                        0 - |  COMPUTEQUOT283 :              185B C |
*CONSTPI :        3.141592653589793 - |  CPUSPEED :                  B71B00 - |
*CVFI4 :                       1D00 C | *CVIF4 :                       1C00 C |
*DATE :                   1/18/2018 - |  DCKLP288 :                    1ABD C |
*DIV_A1NZ :                    1F0C C | *DIV_A2NZ :                    1F2A C |
*DIV_GO :                      1F8E C | *DIV_GO1 :                     1F7B C |
 DIV_LP :                      1F68 C | *DIV_NOPE :                    1FC9 C |
*DIV_Z :                       1FDB C | *DNOADD288 :                   1AC5 C |
*DONE284 :                     18BC C | *DONE287 :                     1A76 C |
*DONE288 :                     1B13 C | *DONE294 :                     1C6F C |
*DONE295 :                     1D61 C |  DSHLP288 :                    1AD9 C |
*ENDLP285 :                    1961 C |  EOT :                            4 - |
 F7 :                             7 - |  F9 :                             9 - |
*FAILS :                       1D6E C | *FALSE :                          0 - |
 FB :                             B - | *FILEDN :                       686 C |
 FILELP :                       666 C |  FP_ADD :                      1DF1 C |
 FP_ADD_12 :                   1D8C C |  FP_ATOF :                     210F C |
 FP_DIV :                      1EFB C |  FP_GETEXP :                   1DDF C |
 FP_GETSGN :                   1DEA C |  FP_MUL :                      1FEB C |
*FP_SC_CLN :                   1DC0 C |  FP_SC_UP :                    1DB0 C |
 FP_SHL_1 :                    1D7F C |  FP_SHR_1 :                    1D72 C |
 FP_SHR_FD :                   1DA3 C | *FP_SUB :                      1EF4 C |
*FULLPMMU :                       1 - |  F_ISNUM :                     1D62 C |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - | *INITNAK :                      650 C |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*INTERRUPT :                    68A C | *L1 :                            6A C |
*L10 :                         165B C | *L102 :                         938 C |
*L103 :                         93E C | *L104 :                         952 C |
*L106 :                         982 C |  L107 :                         976 C |
*L108 :                         978 C | *L11 :                           D7 C |
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 156 - 1/18/2018 14:51:20


*L110 :                         9AA C |  L111 :                         997 C |
*L112 :                         9A4 C | *L115 :                         C6E C |
*L116 :                         AB5 C | *L117 :                         AC0 C |
*L118 :                        1570 C | *L119 :                        156C C |
 L12 :                           93 C | *L120 :                         AC0 C |
*L122 :                         B00 C | *L124 :                         C62 C |
*L126 :                         DF7 C | *L127 :                         D39 C |
*L128 :                         D49 C |  L129 :                         D52 C |
*L13 :                           C4 C | *L130 :                         DD4 C |
 L132 :                         D59 C | *L133 :                         D59 C |
*L135 :                         D64 C | *L136 :                         DC3 C |
*L139 :                         D8D C | *L140 :                         ECD C |
*L141 :                         E87 C | *L143 :                         F1C C |
*L144 :                         F76 C | *L145 :                         FE3 C |
*L146 :                        1076 C | *L147 :                        1051 C |
*L148 :                        1076 C | *L149 :                        10F4 C |
*L15 :                           C5 C | *L150 :                        13E1 C |
 L151 :                        1143 C | *L152 :                        13DB C |
*L154 :                        1157 C | *L155 :                        13DB C |
*L157 :                        13CA C | *L158 :                        13DB C |
*L16 :                           B0 C | *L160 :                        1231 C |
*L161 :                        1243 C | *L162 :                        125B C |
*L163 :                        1284 C | *L164 :                        1299 C |
*L165 :                        129D C | *L166 :                        12D0 C |
*L167 :                        138E C | *L169 :                        1301 C |
*L171 :                        132B C | *L172 :                        1389 C |
*L173 :                        138E C | *L174 :                        13CA C |
*L176 :                        13AE C | *L178 :                        11C9 C |
*L179 :                        11E4 C | *L18 :                         1654 C |
*L180 :                        11B5 C | *L182 :                        1216 C |
*L183 :                        1424 C | *L184 :                        1563 C |
 L185 :                        1421 C | *L186 :                        1421 C |
*L188 :                        148F C |  L189 :                        1454 C |
*L19 :                         1650 C | *L190 :                        1472 C |
*L192 :                        148B C | *L193 :                        14E7 C |
 L194 :                        14C4 C | *L195 :                        14D2 C |
*L197 :                        1530 C |  L198 :                        1510 C |
*L199 :                        151B C |  L2 :                            23 C |
*L20 :                           EB C | *L201 :                        1561 C |
*L203 :                        1562 C | *L22 :                          1A1 C |
*L23 :                          12B C | *L25 :                          19B C |
*L29 :                          14A C | *L3 :                            53 C |
*L30 :                          14E C | *L31 :                          16D C |
*L32 :                          171 C | *L33 :                          21C C |
*L34 :                          1EB C | *L35 :                          218 C |
*L36 :                          20F C | *L37 :                          218 C |
*L38 :                         1632 C | *L39 :                          5E6 C |
*L41 :                         15FC C |  L42 :                          285 C |
*L43 :                          5E3 C | *L45 :                         15F9 C |
 L46 :                          2A6 C | *L47 :                          2EF C |
*L49 :                         15F6 C | *L5 :                            54 C |
*L50 :                          5C4 C | *L51 :                          5E3 C |
*L53 :                          420 C | *L54 :                         15E0 C |
*L55 :                         15D1 C | *L56 :                          48F C |
*L58 :                          4B3 C | *L6 :                            40 C |
*L60 :                         15BA C | *L61 :                         15A1 C |
*L62 :                          4BF C | *L63 :                         159B C |
*L64 :                          4E4 C | *L65 :                         1598 C |
*L66 :                          4FD C | *L67 :                         1595 C |
*L68 :                          55A C | *L69 :                         1592 C |
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 157 - 1/18/2018 14:51:20


*L70 :                          56D C | *L71 :                         158F C |
*L72 :                          582 C | *L73 :                         158C C |
*L74 :                          5A3 C | *L75 :                         1589 C |
*L76 :                         1574 C | *L77 :                          344 C |
*L78 :                          3B8 C | *L79 :                          376 C |
*L8 :                          1662 C | *L80 :                          391 C |
*L81 :                          3EA C | *L82 :                          405 C |
*L83 :                          865 C | *L87 :                          895 C |
 L88 :                          87F C | *L89 :                          882 C |
*L9 :                          165D C | *L91 :                          883 C |
*L92 :                          8F0 C | *L94 :                          961 C |
 L95 :                          908 C | *L96 :                          952 C |
*L98 :                          955 C | *L99 :                          945 C |
*LCC1802INIT :                 1667 C | *LISTON :                         1 - |
 LOOP285 :                     190F C |  LSH295 :                      1D2B C |
*MACEXP :                         7 - |  MEMADDR :                        E - |
 MLOOP286 :                    1977 C |  MOMCPU :                      1802 - |
*MOMCPUNAME :                  1802 - |  MSLF281 :                     1712 C |
*MULRDONE282 :                 1824 C |  MULRLP282 :                   1804 C |
*MULRNOADD282 :                1816 C | *MULRSHFT282 :                 181C C |
*MUL_DN :                      20B7 C | *MUL_GO1 :                     203F C |
 MUL_LP1 :                     202F C |  MUL_LP2 :                     20CA C |
*MUL_LP2A :                    20DD C |  MUL_LP3 :                     20E6 C |
*MUL_LP3A :                    20F9 C | *MUL_LP4 :                     210A C |
*MUL_NO :                      208C C | *MUL_NXT1 :                    20E1 C |
 NAK :                           15 - | *NESTMAX :                      100 - |
*NEY0Y283 :                    1874 C | *NORESTORE285 :                195D C |
*NXT294 :                      1C30 C | *OUT283 :                      1882 C |
*OUTIT130 :                     8DC C | *PACKING :                        0 - |
*PADDING :                        1 - | *PASSES :                      1D6B C |
*POS1284 :                     189A C | *POS1287 :                     1A26 C |
*POS2284 :                     18AA C | *POS2287 :                     1A4D C |
 R0 :                             0 - |  R1 :                             1 - |
 R10 :                            A - |  R11 :                            B - |
 R12 :                            C - |  R13 :                            D - |
 R14 :                            E - |  R15 :                            F - |
 R2 :                             2 - |  R3 :                             3 - |
 R4 :                             4 - |  R5 :                             5 - |
 R6 :                             6 - |  R7 :                             7 - |
 R8 :                             8 - |  R9 :                             9 - |
 RCALL :                          4 - |  READLP :                       678 C |
 REGARG1 :                        C - |  REGARG2 :                        D - |
*RELAXED :                        1 - |  RETADDR :                        6 - |
 RETVAL :                         F - | *RL0 :                            1 - |
 RL10 :                           B - |  RL12 :                           D - |
 RL6 :                            7 - |  RL8 :                            9 - |
 RP1P2 :                          D - |  RPC :                            3 - |
 RRCV :                           8 - |  RRET :                           5 - |
 RSND :                           9 - |  RT1 :                            8 - |
*RT2 :                            9 - |  RWORK :                          E - |
*SAVEREGS :                       1 - | *SCRATCH :                     22A3 C |
 SERINN :                       7D4 - |  SERINT :                       7C0 C |
 SEROUT :                       700 C |  SEROUT.TXCLOOP :               707 C |
*SEROUT.TXCRET :                746 C | *SETBITOFF130 :                 8D7 C |
*SETSGN294 :                   1C68 C |  SGNPOS294 :                   1C39 C |
*SHDN294 :                     1C5F C | *SHIFT286 :                    19AE C |
 SHL294 :                      1C4B C |  SHR295 :                      1D19 C |
*SIGN295 :                     1D3B C |  SOH :                            1 - |
 SP :                             2 - |  STACKLOC :                    FFFF - |
 SUBOVHD :                       1B - | *TESTEXIT283 :                 186A C |
 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 158 - 1/18/2018 14:51:20


*TIME :                    14:51:19 - |  TOCT :                          FF - |
*TOCT.OKGO :                    7D6 C |  TOCT.RXCLOOP :                 7DC C |
*TOCT.RXCRET :                  819 C |  TOCT.RXCW :                    7C4 C |
 TOCT.SERINN :                  7D4 C | *TRUE :                           1 - |
 UPNXT288 :                    1AF2 C | *VERSION :                     142F - |
*_00000272 :                   16C8 C | *_BOOTLOAD :                    1AB C |
 _CALL :                       16F1 C | *_DELAY :                       866 C |
 _DIE272 :                     16CB C | *_DIGITALREAD :                 8E8 C |
*_DIGITALWRITE :                8C0 C |  _DISPATCH :                     E5 C |
*_DIVI2 :                      188B C |  _DIVI4 :                      1A00 C |
 _DIVU2 :                      1825 C |  _DIVU4 :                      1900 C |
*_DUBDABX :                    1A77 C |  _DUMP :                          4 C |
*_EXIT :                       13FB C |  _FTOA :                        9F4 C |
*_GETCSER :                     850 C |  _GETHEXIT :                     EC C |
*_INCLUDESER2 :                 606 C | *_INP :                        22A5 C |
 _ITOA :                        C90 C |  _LTOA :                        E0F C |
 _MAIN :                        223 C | *_MEMCMP :                     1429 C |
*_MEMCPY :                     14A1 C | *_MEMSET :                     14F5 C |
*_MODI2 :                      16DC C | *_MODI4 :                      1B20 C |
*_MODU2 :                      16D4 C | *_MODU4 :                      1B14 C |
 _MULT_NUMS :                   9D4 C | *_MULU2 :                      1800 C |
*_MULU4 :                      1966 C | *_NSTDLIBINCLUDER :            153A C |
*_OLDUINOINCLUDER :             8A3 C | *_ONEMS :                      1710 C |
*_OUT :                        22BF C | *_OUT4 :                       16E4 C |
 _PIN4 :                          3 C |  _PRINTF :                     10F9 C |
 _PRINTFLT :                    F7F C |  _PRINTINT :                    EE3 C |
 _PRINTLINT :                   F25 C |  _PRINTSTR :                    988 C |
 _PUTCSER :                     85C C |  _PUTX :                       107B C |
 _PUTXN :                       FEC C |  _REGDUMP :                      7C C |
 _RETURN :                     1701 C |  _ROUND_NUMS :                  9B4 C |
*_SAVEREGS :                   1562 C | *_SETQOFF :                    16D2 C |
*_SETQON :                     16D0 C | *_STRCMP :                     154A C |
*_STRCPY :                     1540 C |  _STRLEN :                      96B C |
*_STRNCMP :                     8F1 C | *_XR :                          640 C |
*__FORW1 :                      8EF C | *__FORW10 :                    22D0 C |
*__FORW9 :                     22BC C | *__STRCMPGT :                  155F C |
 __STRCMPLP :                  154F C | *__STRCMPNE :                  155A C |
 __STRCPY :                    1544 C |

    429 symbols
    285 unused symbols

 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 159 - 1/18/2018 14:51:20


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU2RRS                               | ALU4                                 
ALU4I                                 | BITDELAY                             
BLKCPY                                | CCALL                                
CPY1                                  | CPY2                                 
CPY4                                  | CRETN                                
DECM                                  | DEMOTE                               
INC4                                  | INCM                                 
JCF4                                  | JCI2                                 
JCI2I                                 | JCI4                                 
JCU2                                  | JCU2I                                
JCU4                                  | JEQI1                                
JEQI2                                 | JEQI4                                
JEQU1I                                | JEQU2I                               
JNEU1I                                | JNEU2                                
JNEU2I                                | JNEU2NI                              
JNEU4                                 | JNI2I                                
JNU2I                                 | JNZU1                                
JNZU2                                 | JUMPV                                
JZU1                                  | JZU2                                 
LD1                                   | LD2                                  
LD2Z                                  | LD4                                  
LDA2                                  | LDAD                                 
LDAX                                  | LDAXS                                
LDI4                                  | LDIREG                               
LDN1                                  | LDN2                                 
LDN2S                                 | MVC1                                 
MVC2                                  | MVCN1                                
MVCN2                                 | NEGI2                                
NEGI4                                 | NOP1806                              
POPF                                  | POPL                                 
POPM                                  | POPR                                 
PUSHR                                 | RELEASE                              
RELEASEL                              | RELEASES                             
RESERVE                               | RESERVEL                             
RESERVES                              | SEXT                                 
SEXT4                                 | SHL2                                 
SHL2I                                 | SHL2R                                
SHL4                                  | SHL4I                                
SHL4R                                 | SHLC4                                
SHLR2R                                | SHRC4                                
SHRI2                                 | SHRI2I                               
SHRI2R                                | SHRI4                                
SHRI4I                                | SHRI4R                               
SHRU2                                 | SHRU2I                               
SHRU2R                                | SHRU4                                
SHRU4I                                | SHRU4R                               
ST1                                   | ST2                                  
ST2I                                  | ST4                                  
STR1                                  | STR1I                                
STR2                                  | STR2I                                
TESTSUB                               | XUSHF                                
XUSHL                                 | XUSHM                                
ZEXT                                  | ZEXT4                                

    108 macros

 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 160 - 1/18/2018 14:51:20


 AS V1.42 Beta [Bld 123] - source file SerialMon.oasm - page 161 - 1/18/2018 14:51:20


  codepages:
  ----------

STANDARD (0 changed characters)


0.32 seconds assembly time

   4871 lines source file
  12177 lines incl. macro expansions
      1 pass
        additional necessary passes not started due to
        errors, listing possibly incorrect
      2 errors
      2 warnings
