; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Thu Jan 18 14:51:18 2018

SP:	equ	2 ;stack pointer
memAddr: equ	14
retAddr: equ	6
retVal:	equ	15
regArg1: equ	12
regArg2: equ	13
	listing off
	include lcc1802proloNW.inc
	listing on
_PIN4:
	db 0
;$$function start$$ _dump
_dump:		;framesize=12
	pushr R1
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	cpy2 R7,R12; function(2055) 1
	cpy2 R6,R13; function(2054) 1
;void dump(unsigned char* data, unsigned int len){
;	for(i=0;i<len;i++){
	ld2z R1
	lbr L5
L2:
;		if (0==(i%16)) printf("\n%x ",data);
	alu2I R11,R1,15,ani,ani ;removed copy;BANDU2(reg,con)  
	jnzU2 R11,L6; NE 0 
	ldaD R12,L8; reg:acon
	cpy2 R13,R7 ;LOADP2(reg)
	Ccall _printf
L6:
;		printf("%cx ",*data++);
	ldaD R12,L9; reg:acon
	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
	incm R7,1
	ldn1 R13,R11	;opt14*
	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _printf
;	}
L3:
;	for(i=0;i<len;i++){
	incm R1,1
L5:
	jcU2 R1,R6,lbnf,L2; LT=lbnf i.e. subtract B from A and jump if borrow 
;	printf("\n");
	ldaD R12,L10; reg:acon
	Ccall _printf
;}
L1:
	release 4; release room for outgoing arguments
	popf R7	;opt11.3
	popm R6	;opt11.4
	popl R1	;opt11.4
	Cretn

;$$function end$$ _dump
;$$function start$$ _regdump
_regdump:		;framesize=10
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	cpy2 R7,R12; function(2055) 1
;void regdump(unsigned int* data){
;	for(i=0;i<16;i++){
	ld2z R6
	lbr L15
L12:
;		if (0==(i%4)) printf("\nR%cx ",i);
	alu2I R11,R6,3,ani,ani ;removed copy;BANDU2(reg,con)  
	jnzU2 R11,L16; NE 0 
	ldaD R12,L18; reg:acon
	cpy2 R13,R6 ;LOADU2*(reg)
	Ccall _printf
L16:
;		printf("%x ",*data++);
	ldaD R12,L19; reg:acon
	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
	incm R7,2
	ldn2 R13,R11	;opt9x
	Ccall _printf
;	}
L13:
;	for(i=0;i<16;i++){
	incm R6,1
L15:
	jcU2I R6,16,lbnf,L12 ;LT=lbnf i.e. subtract immedB from A and jump if borrow
;	printf("\n");
	ldaD R12,L10; reg:acon
	Ccall _printf
;}
L11:
	release 4; release room for outgoing arguments
	popf R7	;opt11.3
	popl R6	;opt11.3
	Cretn

;$$function end$$ _regdump
;$$function start$$ _dispatch
_dispatch:		;framesize=2
;void dispatch(unsigned char * addr){
;	asm(" cpy2 r0,r12\n"	//copy target address to R0
 cpy2 r0,r12
 sex 0
 sep 0
;}
L20:
	Cretn

;$$function end$$ _dispatch
;$$function start$$ _gethexit
_gethexit:		;framesize=6
	pushr R6
	pushr R7
;int gethexit(unsigned char cin){ //returns the corresponding hex value for 0-f, -1 otherwise
;	if ((cin>='0') && (cin<='9')){
	cpy1 R11,R12
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	jcI2I R11,48,lbnf,L23  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
	jnI2I R11,57,lbnf,L23; GT reverse  the subtraction
;		return cin-'0';
	cpy1 R11,R12
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	alu2I R15,R11,48,smi,smbi
	lbr L22
L23:
;	}else if ((cin>='a') & (cin<='f')){
	cpy1 R11,R12
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	jcI2I R11,97,lbnf,L29  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
	ldaD R7,1; reg:acon
	lbr L30
L29:
	ld2z R7
L30:
	cpy1 R11,R12
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	jnI2I R11,102,lbnf,L31; GT reverse  the subtraction
	ldaD R6,1; reg:acon
	lbr L32
L31:
	ld2z R6
L32:
	alu2 R11,R7,R6,and,and
	jzU2 R11,L25; EQ 0
;		return cin-'a'+10;
	cpy1 R11,R12
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	alu2I R11,R11,97,smi,smbi
	ldA2 R15,'O',R11,(10); reg:addr
	lbr L22
L25:
;	}else{
;		return -1;
	ldaD R15,-1; reg:acon
L22:
	popf R7	;opt11.3
	popl R6	;opt11.3
	Cretn

;$$function end$$ _gethexit
;$$function start$$ _bootload
_bootload:		;framesize=8
	reserve 6
;int bootload(){
;	int ret=XR(CODEADDR);
	ldaD R12,0x8000; reg:acon
	Ccall _XR; CALLI2(ar)
	st2 R15,'O',sp,(4+1); ASGNI2(addr,reg)
;	if (ret==EOT){
	ld2 R11,'O',sp,(4+1) ;reg:INDIRI2(addr)
	jneU2I R11,4,L34; NE
;		dispatch(CODEADDR);
	ldaD R12,0x8000; reg:acon
	Ccall _dispatch
;	} else if(ret=='T'){//timeout flag
	lbr L35
L34:
	ld2 R11,'O',sp,(4+1) ;reg:INDIRI2(addr)
	jneU2I R11,84,L36; NE
;		dispatch(CODEADDR);
	ldaD R12,0x8000; reg:acon
	Ccall _dispatch
;	} else{
	lbr L37
L36:
;		printf("Interrupt - starting monitor\n");
	ldaD R12,L38; reg:acon
	Ccall _printf
;	}
L37:
L35:
;	return 0;
	ld2z R15
L33:
	release 6
	Cretn

;$$function end$$ _bootload
;$$function start$$ _main
_main: ;copt is peeping your size 24 frame with oct 23 rules
	reserve 8; save room for local variables
	pushr R0
	pushr R1
	pushr R6
	pushr R7
	reserve 6; save room for outgoing arguments
;void main(){
;	unsigned char cin='?';
	ldaD R7,63; reg:acon
;	unsigned char seqop=0x7b, reqop=0x7a, brop=0x30;
	ldA2 R11,'O',sp,(19+1); reg:addr
	str1I 123,R11; ASGNU1(indaddr,acon)	DH
	ldA2 R11,'O',sp,(18+1); reg:addr
	str1I 122,R11; ASGNU1(indaddr,acon)	DH
	ldA2 R11,'O',sp,(17+1); reg:addr
	str1I 48,R11; ASGNU1(indaddr,acon)	DH
;	unsigned char * addr=0;
	ldaD R0,0; reg:acon
;	unsigned int caddr=0;
	ld2z R1
;	asm(" seq\n"); //make sure Q is high to start
;	printf("\nSerial Monitor Here - CODEADDR is %x. Baudrate 9600\n",CODEADDR);
 seq
	ldaD R12,L41; reg:acon
	ldaD R13,0x8000; reg:acon
	Ccall _printf
	lbr L43
L42:
;	while(1){
;		printf("> ");
	ldaD R12,L45; reg:acon
	Ccall _printf
;		cin=getc();
	Ccall _getcser; CALLI2(ar)
	cpy2 R11,R15 ;LOADU2*(reg)
	cpy1 R7,R11;LOADU1(reg)
;		hexval=gethexit(cin);
	cpy1 R12,R7
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _gethexit; CALLI2(ar)
	cpy2 R6,R15 ;LOADI2(reg)
	lbr L47
L46:
;		while(hexval>=0){//accumulate address entries - non hex digit characters will return -1
;			printf("%c",cin);
	ldaD R12,L49; reg:acon
	cpy1 R13,R7
	zExt R13 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _printf
;			caddr*=16;caddr+=hexval;
	shl2I R1,4
	cpy2 R11,R6 ;LOADU2*(reg)
	alu2 R1,R1,R11,add,adc; ADDU2(r,r)
;			cin=getc();
	Ccall _getcser; CALLI2(ar)
	cpy2 R11,R15 ;LOADU2*(reg)
	cpy1 R7,R11;LOADU1(reg)
;			hexval=gethexit(cin);
	cpy1 R12,R7
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _gethexit; CALLI2(ar)
	cpy2 R6,R15 ;LOADI2(reg)
;		}
L47:
;		while(hexval>=0){//accumulate address entries - non hex digit characters will return -1
	jcI2I R6,0,lbdf,L46; GE is flipped test from LT
;		switch (cin){
	cpy1 R11,R7
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	st2 R11,'O',sp,(15+1); ASGNI2(addr,reg)
	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
	ldaD R10,63; reg:acon
	jeqI2 R11,R10,L64; EQI2(reg,reg)
	jcI2 R10,R11,lbnf,L78 ;GT is reversed operands from LT
L77:
	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
	ldaD R10,33; reg:acon
	jeqI2 R11,R10,L66; EQI2(reg,reg)
	jcI2 R10,R11,lbnf,L80 ;GT is reversed operands from LT
L79:
	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
	jeqU2I R11,13,L62;EQI2(reg,con)
	lbr L50
L80:
	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
	jeqU2I R11,43,L72;EQI2(reg,con)
	jeqU2I R11,45,L74;EQI2(reg,con)
	lbr L50
L78:
	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
	ldaD R10,114; reg:acon
	jeqI2 R11,R10,L70; EQI2(reg,reg)
	jcI2 R10,R11,lbnf,L82 ;GT is reversed operands from LT
L81:
	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
	jeqU2I R11,103,L68;EQI2(reg,con)
	lbr L50
L82:
	ld2 R11,'O',sp,(15+1) ;reg:INDIRI2(addr)
	jeqU2I R11,120,L53;EQI2(reg,con)
	lbr L50
L53:
;				printf("\nCalling XR in 2 sec\n",ret);
	ldaD R12,L54; reg:acon
	ld2 R13,'O',sp,(20+1) ;reg:INDIRI2(addr)
	Ccall _printf
;				delay(2000);
	ldaD R12,2000; reg:acon
	Ccall _delay
;				ret=XR(addr);
	cpy2 R12,R0 ;LOADP2(reg)
	Ccall _XR; CALLI2(ar)
	st2 R15,'O',sp,(20+1); ASGNI2(addr,reg)
;				printf("XR returns %x\n",ret);
	ldaD R12,L55; reg:acon
	ld2 R13,'O',sp,(20+1) ;reg:INDIRI2(addr)
	Ccall _printf
;				if (ret==EOT){
	ld2 R11,'O',sp,(20+1) ;reg:INDIRI2(addr)
	jneU2I R11,4,L56; NE
;					dump(addr,256);
	cpy2 R12,R0 ;LOADP2(reg)
	ldaD R13,256; reg:acon
	Ccall _dump
;				} else if(ret=='T'){//timeout flag
	lbr L51
L56:
	ld2 R11,'O',sp,(20+1) ;reg:INDIRI2(addr)
	jneU2I R11,84,L58; NE
;					printf("Timeout - no transfer\n");
	ldaD R12,L60; reg:acon
	Ccall _printf
;				} else{
	lbr L51
L58:
;					printf("Interrupt - no transfer\n");
	ldaD R12,L61; reg:acon
	Ccall _printf
;				}
;				break;
	lbr L51
L62:
;				printf("->%x\n",caddr);
	ldaD R12,L63; reg:acon
	cpy2 R13,R1 ;LOADU2*(reg)
	Ccall _printf
;				addr=(unsigned char *)caddr;caddr=0;
	cpy2 R0,R1 ;LOADP2(reg)
	ld2z R1
;				dump(addr,16);
	cpy2 R12,R0 ;LOADP2(reg)
	ldaD R13,16; reg:acon
	Ccall _dump
;				break;
	lbr L51
L64:
;				printf("?\n");
	ldaD R12,L65; reg:acon
	Ccall _printf
;				dump(addr,16);
	cpy2 R12,R0 ;LOADP2(reg)
	ldaD R13,16; reg:acon
	Ccall _dump
;				break;
	lbr L51
L66:
;				printf("!\n");
	ldaD R12,L67; reg:acon
	Ccall _printf
;				*addr=seqop;*(addr+1)=reqop;*(addr+2)=brop;*(addr+3)=(unsigned char)((unsigned int)addr&255); //poke in a loop
	ld1 R11,'O',sp,(19+1)
	str1 R11,R0; ASGNU1(indaddr,reg)		DH
	cpy2 R11,R0
	incm R11,1
	ld1 R10,'O',sp,(18+1)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
	cpy2 R11,R0
	incm R11,2
	ld1 R10,'O',sp,(17+1)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
	cpy2 R11,R0
	incm R11,3
	cpy2 R10,R0 ;LOADU2*(reg)
	alu2I R10,R10,255,ani,ani ;removed copy;BANDU2(reg,con)  
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;				dump(addr,16);
	cpy2 R12,R0 ;LOADP2(reg)
	ldaD R13,16; reg:acon
	Ccall _dump
;				break;
	lbr L51
L68:
;				printf("g\n");
	ldaD R12,L69; reg:acon
	Ccall _printf
;				dispatch(addr);
	cpy2 R12,R0 ;LOADP2(reg)
	Ccall _dispatch
;				break;
	lbr L51
L70:
;				printf("r\n");
	ldaD R12,L71; reg:acon
	Ccall _printf
;				regdump(REGADDR);
	ldaD R12,0xff00; reg:acon
	Ccall _regdump
;				break;
	lbr L51
L72:
;				printf("+\n");
	ldaD R12,L73; reg:acon
	Ccall _printf
;				addr+=16;
	ldA2 R0,'O',R0,(16); reg:addr
;				dump(addr,16);
	cpy2 R12,R0 ;LOADP2(reg)
	ldaD R13,16; reg:acon
	Ccall _dump
;				break;
	lbr L51
L74:
;				printf("-\n");
	ldaD R12,L75; reg:acon
	Ccall _printf
;				addr-=16;
	ldA2 R0,'O',R0,(-16); reg:addr
;				dump(addr,16);
	cpy2 R12,R0 ;LOADP2(reg)
	ldaD R13,16; reg:acon
	Ccall _dump
;				break;
	lbr L51
L50:
;				printf("%c/%cx unrecognized\n",cin,cin);
	ldaD R12,L76; reg:acon
	cpy1 R11,R7
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	cpy2 R13,R11 ;LOADI2(reg)
	st2 R11,'O',sp,(4+1); arg+f**
	Ccall _printf
;				break;
L51:
;	}
L43:
;	while(1){
	lbr L42
;}
L39:
	release 6; release room for outgoing arguments
	popf R7	;opt11.3
	popm R6	;opt11.4
	popm R1	;opt11.4
	popl R0	;opt11.4
	release 8; release room for local variables 
	Cretn

;$$function end$$ _main
;$$function start$$ _includeser2
_includeser2:		;framesize=2
;void includeser2(){
;	asm("BAUDRATE EQU 	9600\n");
;	asm(" include xrwjrT3.inc\n");
;	asm(" include serwjrT3.inc\n");
BAUDRATE EQU 	9600
 include xrwjrT3.inc
 include serwjrT3.inc
;}
L83:
	Cretn

;$$function end$$ _includeser2
;$$function start$$ _delay
_delay:		;framesize=10
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	cpy2 R7,R12; function(2054) 1
;void delay(unsigned int howlong){
;	for (i=1;i!=howlong;i++){
	ldaD R6,1; reg:acon
	lbr L91
L88:
;		oneMs();
	Ccall _oneMs; CALLI2(ar)
;	}
L89:
;	for (i=1;i!=howlong;i++){
	incm R6,1
L91:
	jneU2 R6,R7,L88; NE
;}
L87:
	release 4; release room for outgoing arguments
	popf R7	;opt11.3
	popl R6	;opt11.3
	Cretn

;$$function end$$ _delay
;$$function start$$ _olduinoincluder
_olduinoincluder:		;framesize=2
;void olduinoincluder(){
;	asm("\tinclude olduino.inc\n");
	include olduino.inc
;}
L92:
	Cretn

;$$function end$$ _olduinoincluder
;$$function start$$ _strncmp
_strncmp:		;framesize=6
	pushr R6
	pushr R7
	ld2 R7,'O',sp,(10+1) ;reg:INDIRU2(addr)
;{
;    for ( ; n > 0; s1++, s2++, --n)
	lbr L98
L95:
;	if (*s1 != *s2)
	ldn1 R11,R12	;opt14*
	ldn1 R10,R13	;opt14*
	jeqI1 R11,R10,L99	;opt21
;	    return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1);
	ldn1 R11,R12	;opt14*
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldn1 R10,R13	;opt14*
	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
	jcI2 R11,R10,lbdf,L102; GE is flipped test from LT
	ldaD R6,-1; reg:acon
	lbr L103
L102:
	ldaD R6,1; reg:acon
L103:
	cpy2 R15,R6 ;LOADI2(reg)
	lbr L94
L99:
;	else if (*s1 == '\0')
	ldn1 R11,R12;reg:  INDIRU1(indaddr)
	jnzU1 R11,L104; NEI2(CVUI2(reg),con0)
;	    return 0;
	ld2z R15
	lbr L94
L104:
L96:
;    for ( ; n > 0; s1++, s2++, --n)
	incm R12,1
	incm R13,1
	decm R7,1	;SUBU2(reg,consm)
L98:
	jnzU2 R7,L95; NE 0 
;    return 0;
	ld2z R15
L94:
	popf R7	;opt11.3
	popl R6	;opt11.3
	Cretn

;$$function end$$ _strncmp
;$$function start$$ _strlen
_strlen:		;framesize=4
	pushr R7
;{
;	unsigned int slen = 0 ;
	ld2z R7
	lbr L108
L107:
;	while (*str != 0) {
;      slen++ ;
	incm R7,1
;      str++ ;
	incm R12,1
;   }
L108:
;	while (*str != 0) {
	ldn1 R11,R12;reg:  INDIRU1(indaddr)
	jnzU1 R11,L107; NEI2(CVUI2(reg),con0)
;   return slen;
	cpy2 R15,R7 ;LOADU2*(reg)
L106:
	popr R7
	Cretn

;$$function end$$ _strlen
;$$function start$$ _printstr
_printstr:		;framesize=8
	pushr R7
	reserve 4; save room for outgoing arguments
	cpy2 R7,R12; function(2055) 1
;void printstr(char *ptr){
	lbr L112
L111:
;    while(*ptr){
;		putc(*ptr++); //jan 29
	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
	incm R7,1
	ldn1 R12,R11	;opt14*
	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _putcser
;		asm(" nop1806\n nop1806\n nop1806\n"); //17-03-09
 nop1806
 nop1806
 nop1806
;	}
L112:
;    while(*ptr){
	ldn1 R11,R7;reg:  INDIRU1(indaddr)
	jnzU1 R11,L111; NEI2(CVUI2(reg),con0)
;}
L110:
	release 4; release room for outgoing arguments
	popr R7
	Cretn

;$$function end$$ _printstr
	align 4
_round_nums:
	dd 0x3f000000
	dd 0x3d4ccccd
	dd 0x3ba3d70a
	dd 0x3a03126f
	dd 0x3851b717
	dd 0x36a7c5ac
	dd 0x350637bd
	dd 0x3356bf95
	align 4
_mult_nums:
	dd 0x3f800000
	dd 0x41200000
	dd 0x42c80000
	dd 0x447a0000
	dd 0x461c4000
	dd 0x47c35000
	dd 0x49742400
	dd 0x4b189680
;$$function start$$ _ftoa
_ftoa:		;framesize=80
	reserve 62; save room for local variables
	pushr R0
	pushr R1
	pushr R6
	pushr R7
	reserve 8; save room for outgoing arguments
	cpy4 RL6,RL12; halfbaked&floaty
	ld2 R1,'O',sp,(86+1) ;reg:INDIRU2(addr)
;{
;   char *output = outbfr ;
	ld2 R0,'O',sp,(84+1) ;reg:INDIRP2(addr)
;   if (flt < 0.0) {
	ld4 RL10,'D',(L118),0;INDIRF4(addr)
	jcF4 RL6,RL10,lbdf,L116;GEF4(reg,reg) - reverse test
;      *output++ = '-' ;
	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
	incm R0,1
	str1I 45,R11; ASGNU1(indaddr,acon)	DH
;      flt *= -1.0 ;
	ld4 RL8,'D',(L119),0;INDIRF4(addr)
	cpy4 RL10,RL6; LOADU4(reg)
	Ccall fp_mul ;MULF4(reg,reg)
	cpy4 RL6,RL8; LOADU4(reg)
;   } else {
	lbr L117
L116:
;      if (use_leading_plus) {
	lbr L120
;         *output++ = '+' ;
	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
	incm R0,1
	str1I 43,R11; ASGNU1(indaddr,acon)	DH
;      }
L120:
;   }
L117:
;   if (dec_digits < 8) {
	jcI2I R1,8,lbdf,L122; GE is flipped test from LT
;      flt += round_nums[dec_digits] ;
	cpy4 RL8,RL6; LOADU4(reg)
	shlR2R	R11,R1	;opt6.1
	shl2I 	R11,1	;opt6.1
	ld4 RL10,'O',R11,(_round_nums);INDIRF4(addr)
	Ccall fp_add ;ADDF4(reg,reg)
	cpy4 RL6,RL8; LOADU4(reg)
;   }
L122:
;	mult=mult_nums[dec_digits];
	shlR2R	R11,R1	;opt6.1
	shl2I 	R11,1	;opt6.1
	ld4 RL10,'O',R11,(_mult_nums);INDIRF4(addr)
	st4 RL10,'O',sp,(68+1); ASGNF4(addr,reg)
;   wholeNum = flt;
	cpy4 RL8,RL6; LOADU4(reg)
	ccall cvfi4; CVFI4(reg) convert float to long
	st4 RL8,'O',sp,(72+1)
;   decimalNum = ((flt - wholeNum) * mult);
	cpy4 RL8,RL6; LOADU4(reg)
	st4 RL8,'O',sp,(16+1); ASGNF4(addr,reg)
	ld4 RL8,'O',sp,(72+1);reg:  INDIRI4(addr)
	Ccall cvif4; emit2
	cpy4 RL10,RL8; LOADU4(reg)
	ld4 RL8,'O',sp,(16+1);INDIRF4(addr)
	Ccall fp_sub ;SUBF4(reg,reg)
	ld4 RL10,'O',sp,(68+1);INDIRF4(addr)
	Ccall fp_mul ;MULF4(reg,reg)
	ccall cvfi4; CVFI4(reg) convert float to long
	st4 RL8,'O',sp,(64+1)
;   strcpy(output,dubdabx(wholeNum,output,1));
	ld4 Rp1p2,'O',sp,(72+1);reg:  INDIRI4(addr)
	st2 R0,'O',sp,(4+1); arg+f**
	ldaD R11,1; reg:acon
	st2 R11,'O',sp,(6+1); arg+f**
	Ccall _dubdabx
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R0 ;LOADP2(reg)
	cpy2 R13,R11 ;LOADP2(reg)
	Ccall _strcpy
;   output+=strlen(output);
	cpy2 R12,R0 ;LOADP2(reg)
	Ccall _strlen;CALLU2(ar)*
	alu2 R0,R15,R0,add,adc	;ADDP2(reg,reg)
;   if (dec_digits > 0) {
	jzU2 R1,L124; EQ 0
;		*output++ = '.' ;
	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
	incm R0,1
	str1I 46,R11; ASGNU1(indaddr,acon)	DH
;		strcpy(output,dubdabx(decimalNum,output,dec_digits));
	ld4 Rp1p2,'O',sp,(64+1);reg:  INDIRI4(addr)
	st2 R0,'O',sp,(4+1); arg+f**
	cpy2 R11,R1 ;LOADI2(reg)
	st2 R11,'O',sp,(6+1); arg+f**
	Ccall _dubdabx
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R0 ;LOADP2(reg)
	cpy2 R13,R11 ;LOADP2(reg)
	Ccall _strcpy
;	}
L124:
;   return outbfr;
	ld2 R15,'O',sp,(84+1) ;reg:INDIRP2(addr)
L115:
	release 8; release room for outgoing arguments
	popf R7	;opt11.3
	popm R6	;opt11.4
	popm R1	;opt11.4
	popl R0	;opt11.4
	release 62; release room for local variables 
	Cretn

;$$function end$$ _ftoa
;$$function start$$ _itoa
_itoa:		;framesize=16
	reserve 2; save room for local variables
	pushr R0
	pushr R1
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	st2 R12,'O',sp,(16+1)			
	inc memaddr				;opt16.1
	str2 R13,memaddr			
;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
;	unsigned int flag=0;
	ld2z R0
;	char * bptr; bptr=buffer;
	ld2 R11,'O',sp,(18+1) ;reg:INDIRP2(addr)
	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
;	if (s<0){
	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
	jcI2I R11,0,lbdf,L127; GE is flipped test from LT
;		*bptr='-';bptr++;
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	str1I 45,R11; ASGNU1(indaddr,acon)	DH
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
;		n=-s;
	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
	cpy2 R6,R11 ;LOADU2*(reg)
;	} else{
	lbr L128
L127:
;		n=s;
	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
	cpy2 R6,R11 ;LOADU2*(reg)
;	}
L128:
;	k=10000;
	ldaD R7,10000; reg:acon
	lbr L130
L129:
;	while(k>0){
;		for(r=0;k<=n;r++,n-=k); // was r=n/k
	ld2z R1
	lbr L135
L132:
L133:
	incm R1,1
	alu2 R6,R6,R7,sm,smb
L135:
	jcU2 R6,R7,lbdf,L132 ;LE is flipped test & operands
;		if (flag || r>0||k==1){
	jnzU2 R0,L139; NE 0 
	jnzU2 R1,L139; NE 0 
	jneU2I R7,1,L136; NE
L139:
;			*bptr=('0'+r);bptr++;
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	ldA2 R10,'O',R1,(48); reg:addr
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
;			flag='y';
	ldaD R0,121; reg:acon
;		}
L136:
;		k=k/10;
	cpy2 R12,R7 ;LOADU2*(reg)
	ldaD R13,10; reg:acon
	Ccall _divu2
	cpy2 R7,R15 ;LOADU2*(reg)
;	}
L130:
;	while(k>0){
	jnzU2 R7,L129; NE 0 
;	*bptr='\0';
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	str1I 0,R11; ASGNU1(indaddr,acon)	DH
;	return buffer;
	ld2 R15,'O',sp,(18+1) ;reg:INDIRP2(addr)
L126:
	release 4; release room for outgoing arguments
	popf R7	;opt11.3
	popm R6	;opt11.4
	popm R1	;opt11.4
	popl R0	;opt11.4
	release 2; release room for local variables 
	Cretn

;$$function end$$ _itoa
;$$function start$$ _ltoa
_ltoa:		;framesize=16
	pushr R1
	pushr R6
	pushr R7
	reserve 8; save room for outgoing arguments
	cpy4 RL6,RL12; halfbaked
;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
;	char* bptr=buffer;
	ld2 R1,'O',sp,(20+1) ;reg:INDIRP2(addr)
;	if (s<0){
	ldI4 RL10,0 ;loading a long integer constant
	jcI4 RL6,RL10,lbdf,L141; GE is flipped test from LT
;		*bptr++='-';
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,1
	str1I 45,R11; ASGNU1(indaddr,acon)	DH
;		s=-s;
	negI4 RL6,RL6 ;was alu4I RL6,RL6,0,sdi,sdbi
;	}
L141:
;	strcpy(bptr,dubdabx(s,bptr,1)); //uses assembler double-dabble routine
	cpy4 Rp1p2,RL6; LOADI4*
	st2 R1,'O',sp,(4+1); arg+f**
	ldaD R11,1; reg:acon
	st2 R11,'O',sp,(6+1); arg+f**
	Ccall _dubdabx
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R1 ;LOADP2(reg)
	cpy2 R13,R11 ;LOADP2(reg)
	Ccall _strcpy
;	return buffer;
	ld2 R15,'O',sp,(20+1) ;reg:INDIRP2(addr)
L140:
	release 8; release room for outgoing arguments
	popf R7	;opt11.3
	popm R6	;opt11.4
	popl R1	;opt11.4
	Cretn

;$$function end$$ _ltoa
;$$function start$$ _printint
_printint:		;framesize=14
	reserve 12
	st2 R12,'O',sp,(14+1); flag1 
;void printint(int s){ //print an integer
;	itoa(s,buffer);
	ld2 R12,'O',sp,(14+1) ;reg:INDIRI2(addr)
	ldA2 R13,'O',sp,(4+1); reg:addr
	Ccall _itoa
;	printstr(buffer);
	ldA2 R12,'O',sp,(4+1); reg:addr
	Ccall _printstr
;}
L143:
	release 12
	Cretn

;$$function end$$ _printint
;$$function start$$ _printlint
_printlint:		;framesize=20
	reserve 18
	st2 R12,'O',sp,(20+1)			
	inc memaddr				;opt16.1
	str2 R13,memaddr			
;void printlint(long s){ //print a long integer
;	printstr(ltoa(s,buffer));
	ld4 Rp1p2,'O',sp,(20+1);reg:  INDIRI4(addr)
	ldA2 R11,'O',sp,(6+1); reg:addr
	st2 R11,'O',sp,(4+1); arg+f**
	Ccall _ltoa
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R11 ;LOADP2(reg)
	Ccall _printstr
;}
L144:
	release 18
	Cretn

;$$function end$$ _printlint
;$$function start$$ _printflt
_printflt:		;framesize=30
	reserve 28
	st2 R12,'O',sp,(30+1)			
	inc memaddr				;opt16.1
	str2 R13,memaddr			
;void printflt(float s){ //print a float
;	printstr(ftoa(s,buffer,3));
	ld4 Rp1p2,'O',sp,(30+1);INDIRF4(addr)
	ldA2 R11,'O',sp,(8+1); reg:addr
	st2 R11,'O',sp,(4+1); arg+f**
	ldaD R11,3; reg:acon
	st2 R11,'O',sp,(6+1); arg+f**
	Ccall _ftoa
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R11 ;LOADP2(reg)
	Ccall _printstr
;}
L145:
	release 28
	Cretn

;$$function end$$ _printflt
;$$function start$$ _putxn
_putxn:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6+1); flag1 
	ldA2 R11,'O',sp,(6+1); reg:addr
	ld2 R10,'O',sp,(6+1) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;void putxn(unsigned char x){ //print a nibble as ascii hex
;	if (x<10){
	ld1 R11,'O',sp,(6+1)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jcI2I R11,10,lbdf,L147; GE is flipped test from LT
;		putc(x+'0');
	ld1 R11,'O',sp,(6+1)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldA2 R11,'O',R11,(48); reg:addr
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putcser
;	} else {
	lbr L148
L147:
;		putc(x+'A'-10);
	ld1 R11,'O',sp,(6+1)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldA2 R11,'O',R11,(65); reg:addr
	alu2I R11,R11,10,smi,smbi
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putcser
;	}
L148:
;}
L146:
	release 4
	Cretn

;$$function end$$ _putxn
;$$function start$$ _putx
_putx:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6+1); flag1 
	ldA2 R11,'O',sp,(6+1); reg:addr
	ld2 R10,'O',sp,(6+1) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;void putx(unsigned char x){ //print a unsigned char as ascii hex
;	putxn(x>>4);
	ld1 R11,'O',sp,(6+1)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	shrI2I R11,4
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putxn
;	putxn(x & 0x0F);
	ld1 R11,'O',sp,(6+1)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	alu2I R11,R11,15,ani,ani
	;removed ?	cpy2 R11,R11
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putxn
;}
L149:
	release 4
	Cretn

;$$function end$$ _putx
;$$function start$$ _printf
_printf:		;framesize=18
	reserve 4; save room for local variables
	pushr R0
	pushr R1
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	st2 R12,'O',sp,(18+1)			
	inc memaddr				;opt16
	str2 R13,memaddr			
;void printf(char *pptr,...){ //limited implementation of printf
;	register char* ptr=pptr; //try to save on loads/spills
	ld2 R7,'O',sp,(18+1) ;reg:INDIRP2(addr)
;	int argslot=0;	//used to align longs
	ld2z R0
;	int * this=(int *)&pptr;
	ldA2 R1,'O',sp,(18+1); reg:addr
;	this++; argslot++; //advance argument pointer and slot #
	incm R1,2
	incm R0,1
	lbr L152
L151:
;    while(*ptr) {
;		c=*ptr; ptr++;
	ldn1 R6,R7;reg:  INDIRU1(indaddr)
	incm R7,1
;		if (c!='%'){
	jeqU1I R6,37,L154;EQI2(CVUI2(reg),con8bit)**
;			putc(c);
	cpy1 R12,R6
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putcser
;			asm(" nop1806\n nop1806\n nop1806\n"); //17-03-13
 nop1806
 nop1806
 nop1806
;		} else{
	lbr L155
L154:
;			c=*ptr;ptr++;
	ldn1 R6,R7;reg:  INDIRU1(indaddr)
	incm R7,1
;			switch (c){
	cpy1 R11,R6
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	st2 R11,'O',sp,(13+1); ASGNI2(addr,reg)
	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
	jcI2I R11,99,lbnf,L178  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
	jnI2I R11,108,lbnf,L179; GT reverse  the subtraction
	shl2I R11,1
	ld2 R11,'O',R11,(L180-198) ;reg:INDIRP2(addr)
	jumpv R11; JUMPV(reg)
L180:
	dw L162
	dw L160
	dw L157
	dw L173
	dw L157
	dw L157
	dw L160
	dw L157
	dw L157
	dw L166
L178:
	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
	jeqU2I R11,88,L165;EQI2(reg,con)
	lbr L157
L179:
	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
	ldaD R10,115; reg:acon
	jeqI2 R11,R10,L161; EQI2(reg,reg)
	jcI2 R11,R10,lbnf,L157; LT=lbnf i.e. subtract B from A and jump if borrow 
L182:
	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
	jeqU2I R11,120,L165;EQI2(reg,con)
	lbr L157
L160:
;					printint(*this++);
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,2
	ldn2 R12,R11	;opt9x
	Ccall _printint
;					argslot+=1; //next argument slot
	incm R0,1
;					break;
	lbr L158
L161:
;					printstr((char*) *this++);
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,2
	ldn2s R11,R11	;opt9xs
	cpy2 R12,R11 ;LOADP2(reg)
	Ccall _printstr
;					argslot+=1; //next argument slot
	incm R0,1
;					break;
	lbr L158
L162:
;					if (*ptr=='x'){ //if there's an x
	ldn1 R11,R7;reg:  INDIRU1(indaddr)
	jneU1I R11,120,L163	; DH 4
;						ptr++; //skip over the x
	incm R7,1
;						putx(((unsigned int) *this++)&255); //print 1 byte as hex
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,2
	ldn2s R11,R11	;opt9xs
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;					} else{
	lbr L164
L163:
;						putc((unsigned int) *this++);		//print as char
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,2
	ldn2s R11,R11	;opt9xs
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putcser
;					}
L164:
;					argslot+=1; //next argument slot
	incm R0,1
;					break;
	lbr L158
L165:
;					putx(((unsigned int) *this)>>8);
	ldn2 R11,R1	;opt9x
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;					putx(((unsigned int) *this++)&255);
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,2
	ldn2s R11,R11	;opt9xs
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;					argslot+=1; //next argument slot
	incm R0,1
;					break;
	lbr L158
L166:
;					if (*ptr){ //as long as there's something there
	ldn1 R11,R7	;opt14*
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jzU2 R11,L167; EQ 0
;						xord=*ptr++;
	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
	incm R7,1
	ldA2 R10,'O',sp,(15+1); reg:addr
	ldn1 R11,R11;reg:  INDIRU1(indaddr)
	str1 R11,R10; ASGNU1(indaddr,reg)		DH
;						if (argslot&1) {
	alu2I R11,R0,1,ani,ani
	;removed ?	cpy2 R11,R0
	jzU2 R11,L169; EQ 0
;							this++;
	incm R1,2
;							argslot++;
	incm R0,1
;						}
L169:
;						if(xord=='d'){
	ld1 R11,'O',sp,(15+1)
	jneU1I R11,100,L171	; DH 4
;							printlint(*(long *)this);//treats "this" as a pointer to long
	ld4 Rp1p2,'O',R1,0;reg:  INDIRI4(addr)
	Ccall _printlint
;							this+=2;				// and advances it 4 bytes
	incm R1,4
;						} else{
	lbr L172
L171:
;							putx(((unsigned int) *this)>>8);
	ldn2 R11,R1	;opt9x
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;							putx(((unsigned int) *this++)&255);
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,2
	ldn2s R11,R11	;opt9xs
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;							putx(((unsigned int) *this)>>8);
	ldn2 R11,R1	;opt9x
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;							putx(((unsigned int) *this++)&255);
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,2
	ldn2s R11,R11	;opt9xs
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;						}
L172:
;						argslot+=2;
	incm R0,2
;						break;
	lbr L158
L167:
L173:
;					if (*ptr){ //as long as there's something there
	ldn1 R11,R7	;opt14*
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jzU2 R11,L174; EQ 0
;						if (argslot&1) { //adjust alignment
	alu2I R11,R0,1,ani,ani
	;removed ?	cpy2 R11,R0
	jzU2 R11,L176; EQ 0
;							this++;
	incm R1,2
;							argslot++;
	incm R0,1
;						}
L176:
;						printflt(*(float *)this);//treats "this" as a pointer to float
	ld4 Rp1p2,'O',R1,0;INDIRF4(addr)
	Ccall _printflt
;						this+=2;				// and advances it 4 bytes
	incm R1,4
;						argslot+=2;
	incm R0,2
;						break;
	lbr L158
L174:
L157:
;					putc('%');putc(c);
	ldaD R12,37; reg:acon
	Ccall _putcser
	cpy1 R12,R6
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putcser
;			} //switch
L158:
;		} //%
L155:
;	} //while
L152:
;    while(*ptr) {
	ldn1 R11,R7;reg:  INDIRU1(indaddr)
	jnzU1 R11,L151; NEI2(CVUI2(reg),con0)
;} //prtf
L150:
	release 4; release room for outgoing arguments
	popf R7	;opt11.3
	popm R6	;opt11.4
	popm R1	;opt11.4
	popl R0	;opt11.4
	release 4; release room for local variables 
	Cretn

;$$function end$$ _printf
;$$function start$$ _exit
_exit:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6+1); flag1 
;void exit(int code){
;	printf("exit %d\n",code);
	ldaD R12,L184; reg:acon
	ld2 R13,'O',sp,(6+1) ;reg:INDIRI2(addr)
	Ccall _printf
L185:
;	while(1);
L186:
	lbr L185
;}
L183:
	release 4
	Cretn

;$$function end$$ _exit
;$$function start$$ _memcmp
_memcmp:		;framesize=10
	pushr R0
	pushr R1
	pushr R6
	pushr R7
	ld2 R7,'O',sp,(14+1) ;reg:INDIRU2(addr)
;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
;    int v = 0;
	ld2z R6
;    p1 = (unsigned char *)Ptr1;
	cpy2 R1,R12 ;LOADP2(reg)
;    p2 = (unsigned char *)Ptr2;
	cpy2 R0,R13 ;LOADP2(reg)
	lbr L190
L189:
;    while(Count-- > 0 && v == 0) {
;        v = *(p1++) - *(p2++);
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,1
	cpy2 R10,R0 ;LOADP2(reg) ;opt1.1
	incm R0,1
	ldn1 R11,R11	;opt14*
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldn1 R10,R10	;opt14*
	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
	alu2 R6,R11,R10,sm,smb
;    }
L190:
;    while(Count-- > 0 && v == 0) {
	cpy2 R11,R7 ;LOADU2*(reg)
	cpy2 R7,R11	;SUBU2(reg,consm)
	decm R7,1	;SUBU2(reg,consm)
	jzU2 R11,L192; EQ 0
	jzU2 R6,L189; EQ 0
L192:
;    return v;
	cpy2 R15,R6 ;LOADI2(reg)
L188:
	popf R7	;opt11.3
	popm R6	;opt11.4
	popm R1	;opt11.4
	popl R0	;opt11.4
	Cretn

;$$function end$$ _memcmp
;$$function start$$ _memcpy
_memcpy:		;framesize=8
	pushr R1
	pushr R6
	pushr R7
	ld2 R7,'O',sp,(12+1) ;reg:INDIRU2(addr)
;void* memcpy(void* dest, const void* src, unsigned int count) {
;        char* dst8 = (char*)dest;
	cpy2 R6,R12 ;LOADP2(reg)
;        char* src8 = (char*)src;
	cpy2 R1,R13 ;LOADP2(reg)
	lbr L195
L194:
;        while (count--) {
;            *dst8++ = *src8++;
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,1
	cpy2 R10,R1 ;LOADP2(reg) ;opt1.1
	incm R1,1
	ldn1 R10,R10;reg:  INDIRU1(indaddr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;        }
L195:
;        while (count--) {
	cpy2 R11,R7 ;LOADU2*(reg)
	cpy2 R7,R11	;SUBU2(reg,consm)
	decm R7,1	;SUBU2(reg,consm)
	jnzU2 R11,L194; NE 0 
;        return dest;
	cpy2 R15,R12 ;LOADP2(reg)
L193:
	popf R7	;opt11.3
	popm R6	;opt11.4
	popl R1	;opt11.4
	Cretn

;$$function end$$ _memcpy
;$$function start$$ _memset
_memset:		;framesize=6
	pushr R6
	pushr R7
	ld2 R7,'O',sp,(10+1) ;reg:INDIRU2(addr)
;{
;    unsigned char* p=s;
	cpy2 R6,R12 ;LOADP2(reg)
	lbr L199
L198:
;        *p++ = (unsigned char)c;
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,1
	cpy2 R10,R13 ;LOADU2*(reg)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
L199:
;    while(n--)
	cpy2 R11,R7 ;LOADU2*(reg)
	cpy2 R7,R11	;SUBU2(reg,consm)
	decm R7,1	;SUBU2(reg,consm)
	jnzU2 R11,L198; NE 0 
;    return s;
	cpy2 R15,R12 ;LOADP2(reg)
L197:
	popf R7	;opt11.3
	popl R6	;opt11.3
	Cretn

;$$function end$$ _memset
;$$function start$$ _nstdlibincluder
_nstdlibincluder:		;framesize=2
;void nstdlibincluder(){
;	asm("\tinclude nstdlib.inc\n"); //strcpy, strcmp
	include nstdlib.inc
;}
L201:
	Cretn

;$$function end$$ _nstdlibincluder
;$$function start$$ _saveregs
_saveregs:		;framesize=2
;void saveregs(){asm("SAVEREGS: EQU 1\n");}
SAVEREGS: EQU 1
L203:
	Cretn

;$$function end$$ _saveregs
L184:
	db 101
	db 120
	db 105
	db 116
	db 32
	db 37
	db 100
	db 10
	db 0
	align 4
L119:
	dd 0xbf800000
	align 4
L118:
	dd 0x0
L76:
	db 37
	db 99
	db 47
	db 37
	db 99
	db 120
	db 32
	db 117
	db 110
	db 114
	db 101
	db 99
	db 111
	db 103
	db 110
	db 105
	db 122
	db 101
	db 100
	db 10
	db 0
L75:
	db 45
	db 10
	db 0
L73:
	db 43
	db 10
	db 0
L71:
	db 114
	db 10
	db 0
L69:
	db 103
	db 10
	db 0
L67:
	db 33
	db 10
	db 0
L65:
	db 63
	db 10
	db 0
L63:
	db 45
	db 62
	db 37
	db 120
	db 10
	db 0
L61:
	db 73
	db 110
	db 116
	db 101
	db 114
	db 114
	db 117
	db 112
	db 116
	db 32
	db 45
	db 32
	db 110
	db 111
	db 32
	db 116
	db 114
	db 97
	db 110
	db 115
	db 102
	db 101
	db 114
	db 10
	db 0
L60:
	db 84
	db 105
	db 109
	db 101
	db 111
	db 117
	db 116
	db 32
	db 45
	db 32
	db 110
	db 111
	db 32
	db 116
	db 114
	db 97
	db 110
	db 115
	db 102
	db 101
	db 114
	db 10
	db 0
L55:
	db 88
	db 82
	db 32
	db 114
	db 101
	db 116
	db 117
	db 114
	db 110
	db 115
	db 32
	db 37
	db 120
	db 10
	db 0
L54:
	db 10
	db 67
	db 97
	db 108
	db 108
	db 105
	db 110
	db 103
	db 32
	db 88
	db 82
	db 32
	db 105
	db 110
	db 32
	db 50
	db 32
	db 115
	db 101
	db 99
	db 10
	db 0
L49:
	db 37
	db 99
	db 0
L45:
	db 62
	db 32
	db 0
L41:
	db 10
	db 83
	db 101
	db 114
	db 105
	db 97
	db 108
	db 32
	db 77
	db 111
	db 110
	db 105
	db 116
	db 111
	db 114
	db 32
	db 72
	db 101
	db 114
	db 101
	db 32
	db 45
	db 32
	db 67
	db 79
	db 68
	db 69
	db 65
	db 68
	db 68
	db 82
	db 32
	db 105
	db 115
	db 32
	db 37
	db 120
	db 46
	db 32
	db 66
	db 97
	db 117
	db 100
	db 114
	db 97
	db 116
	db 101
	db 32
	db 57
	db 54
	db 48
	db 48
	db 10
	db 0
L38:
	db 73
	db 110
	db 116
	db 101
	db 114
	db 114
	db 117
	db 112
	db 116
	db 32
	db 45
	db 32
	db 115
	db 116
	db 97
	db 114
	db 116
	db 105
	db 110
	db 103
	db 32
	db 109
	db 111
	db 110
	db 105
	db 116
	db 111
	db 114
	db 10
	db 0
L19:
	db 37
	db 120
	db 32
	db 0
L18:
	db 10
	db 82
	db 37
	db 99
	db 120
	db 32
	db 0
L10:
	db 10
	db 0
L9:
	db 37
	db 99
	db 120
	db 32
	db 0
L8:
	db 10
	db 37
	db 120
	db 32
	db 0
	include lcc1802epiloNW.inc
	include LCC1802fp.inc
	include IO1802.inc
