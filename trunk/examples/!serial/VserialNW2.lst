 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 1 - 11/23/2017 8:43:24


       1/       0 :                     ; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Thu Nov 23 08:43:24 2017
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1) 1060/       0 :                     	listing	on
(1) 1061/       0 : C0 0D BD            	lbr	lcc1802Init
(1) 1062/       3 :                     	
(1) 1063/       3 :                     
      11/       3 :                     	listing on
      12/       3 :                     _PIN4:
      13/       3 : 00                  	db 0
      14/       4 :                     ;$$function start$$ _main
      15/       4 :                     _main: ;copt is peeping your size 8 frame with oct 23 rules
      16/       4 : (MACRO)             	reserve 6
      17/       A :                     ;void main(){
      18/       A :                     ;	unsigned char cin='?';
      19/       A : (MACRO)             	ldA2 R11,'O',sp,(5+1); reg:addr
      20/      12 : (MACRO)             	str1I 63,R11; ASGNU1(indaddr,acon)	DH
      21/      15 :                     ;	asm(" seq\n"); //make sure Q is high to start
      22/      15 :                     ;		printf("UUUUUUUU");
      23/      15 : 7B                   seq
      24/      16 : (MACRO)             	ldaD R12,L3; reg:acon
      25/      1C : (MACRO)             	Ccall _printf
      26/      1F :                     L4:
      27/      1F :                     ;	while(1);
      28/      1F :                     L5:
      29/      1F : C0 00 1F            	lbr L4
      30/      22 :                     ;}
      31/      22 :                     L1:
      32/      22 : (MACRO)             	release 6
      33/      28 : (MACRO)             	Cretn
      34/      29 :                     
      35/      29 :                     ;$$function end$$ _main
      36/      29 :                     ;$$function start$$ _includeser
      37/      29 :                     _includeser:		;framesize=2
      38/      29 :                     ;void includeser(){
      39/      29 :                     ;	asm("BAUDRATE EQU 2400\n");
      40/      29 :                     ;	asm(" include VELFserial3.inc\n");
      41/      29 : =960H               BAUDRATE EQU 2400
      42/      29 :                      include VELFserial3.inc
(1)    1/      29 :                     ;**********************************************************************
(1)    2/      29 :                     ;bit-bang Serial routines adapted from Josh Bensadon's VELFbios-v3.1.asm
(1)    3/      29 :                     ;Transmit Byte via Q connected to RS232 driver
(1)    4/      29 :                     ;call via SCRT
(1)    5/      29 :                     ;Byte to send in r12.0
(1)    6/      29 :                     ;Destroys r14
(1)    7/      29 :                     ;17-11-22 regoobered to 
(1)    8/      29 :                     ;----------------------------------------------------------------------
(1)    9/      29 :                     bitdelay: MACRO baudrate,cpuspeed,baseline,xreg
(1)   10/      29 :                     	rept ((cpuspeed/(baudrate*8)-baseline))/3
(1)   11/      29 :                     	NOP
(1)   12/      29 :                     	endm
(1)   13/      29 :                     	rept (((cpuspeed/(baudrate*8)-baseline)#3))>=1
(1)   14/      29 :                     	sex xreg
(1)   15/      29 :                     	endm
(1)   16/      29 :                     	ENDM
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(VELFserial3.inc) - page 2 - 11/23/2017 8:43:24


(1)   17/      29 : =>DEFINED            IFNDEF BAUDRATE
(1)   18/      29 :                     BAUDRATE EQU 	9600
(1)   19/      29 : [17]                 ENDIF
(1)   20/      29 : =>DEFINED            IFNDEF CPUSPEED
(1)   21/      29 :                     CPUSPEED EQU 	2000000
(1)   22/      29 : [20]                 ENDIF
(1)   23/      29 :                     	align 32
(1)   24/      40 :                     _putcser:		;entry from C program with character in reg 12
(1)   25/      40 : F8 09               	ldi 9		;9 bits to transmit (1 start + 8 data)
(1)   26/      42 : AE                  	plo r14
(1)   27/      43 : 8C                  	glo r12
(1)   28/      44 : FE                  	shl		;set start bit
(1)   29/      45 : 76                  	rshr		;DF=0
(1)   30/      46 :                     
(1)   31/      46 :                     .txcloop:
(1)   32/      46 : 33 4B               	bdf $+5		;10.5   jump to seq to send a 1 bit
(1)   33/      48 : 7A                  	req		;11.5   send a 0 bit
(1)   34/      49 : 30 4E               	br $+5		;1      jump +5 to next shift
(1)   35/      4B : 7B                  	seq		;11.5   send a 1 bit
(1)   36/      4C : 30 4E               	br $+2		;1      jump +2 to next shift (NOP for timing)
(1)   37/      4E : 76                  	rshr		;2      shift next bit to DF flag
(1)   38/      4F : BE                  	phi r14		;3      save D in r14.1
(1)   39/      50 : 2E                  	DEC r14		;4      dec bit count
(1)   40/      51 : 8E                  	glo r14		;5      get bit count
(1)   41/      52 : 32 62               	bz .txcret	;6      if 0 then all 9 bits (start and data) sent
(1)   42/      54 : 9E                  	ghi r14		;7      restore D
(1)   43/      55 : (MACRO)             	bitdelay BAUDRATE,CPUSPEED,20,2
(1)   44/      60 : 30 46               	br .txcloop	;9.5    loop back to send next bit
(1)   45/      62 : 9E                  .txcret: ghi r14		;7
(1)   46/      63 : (MACRO)             	bitdelay BAUDRATE,CPUSPEED,16,2
(1)   47/      6F : 7B                  	seq		;11.5 stop bit
(1)   48/      70 : (MACRO)             	cretn		;return and re-call will cover stop bit time
(1)   49/      71 :                     ;**********************************************************************
(1)   50/      71 :                     ;rx_char
(1)   51/      71 :                     ;Receive Byte via EF3 connected to RS232 receiver
(1)   52/      71 :                     ;Receives 8 bits
(1)   53/      71 :                     ;call via SCRT
(1)   54/      71 :                     ;Returns with Byte received in D and rf.0
(1)   55/      71 :                     ;Destroys r14.0
(1)   56/      71 :                     ;----------------------------------------------------------------------
(1)   57/      71 :                     	align 64
(1)   58/      80 :                     _getcser:
(1)   59/      80 : F8 08                	ldi 8		;start bit +7 bits from loop, last bit on returning
(1)   60/      82 : AE                  	plo r14
(1)   61/      83 : F8 00               	ldi 0
(1)   62/      85 :                     .rxcw:			;wait for start bit
(1)   63/      85 :                     	;bn4 $+4		;loop while high
(1)   64/      85 :                     	;br  RomLoad
(1)   65/      85 : 3E 85               	bn3 .rxcw	;each instr takes 9us, we need 104us = 11.5
(1)   66/      87 :                     			;delay 1/2 bit time to center samples
(1)   67/      87 : C4                  	NOP		;     Don't test for correct start bit
(1)   68/      88 : C4                  	NOP		;     it will work. if there's too much
(1)   69/      89 : C4                  	NOP		;     noise on the line, shorten the cable!
(1)   70/      8A :                     .rxcloop:
(1)   71/      8A : (MACRO)             	bitdelay BAUDRATE,CPUSPEED,20,2
(1)   72/      95 : 36 9B               	b3 $+6		;11.5 sample rx input bit
(1)   73/      97 : F9 80               	ori 80h		;1
(1)   74/      99 : 30 9D               	br $+4		;2
(1)   75/      9B : BE                  	phi r14		;1
(1)   76/      9C : BE                  	phi r14		;2
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(VELFserial3.inc) - page 3 - 11/23/2017 8:43:24


(1)   77/      9D : F6                  	shr		;3
(1)   78/      9E : BE                  	phi r14		;4
(1)   79/      9F : 2E                  	DEC r14		;5
(1)   80/      A0 : 8E                  	glo r14		;6
(1)   81/      A1 : 32 A6               	bz .rxcret	;7
(1)   82/      A3 : 9E                  	ghi r14		;8
(1)   83/      A4 : 30 8A               	br  .rxcloop	;9
(1)   84/      A6 : 9E                  .rxcret: ghi r14	;8
(1)   85/      A7 : 9E                  	ghi r14		;9
(1)   86/      A8 : (MACRO)             	bitdelay BAUDRATE,CPUSPEED,20,2
(1)   87/      B3 : 36 B7               	b3 $+4		;11.5 sample last rx input bit
(1)   88/      B5 : F9 80               	ori 80h		;1
(1)   89/      B7 : AF                  	plo r15
(1)   90/      B8 : (MACRO)             	cretn
(1)   91/      B9 :                     
      43/      B9 :                     ;}
      44/      B9 :                     L7:
      45/      B9 : (MACRO)             	Cretn
      46/      BA :                     
      47/      BA :                     ;$$function end$$ _includeser
      48/      BA :                     ;$$function start$$ _delay
      49/      BA :                     _delay:		;framesize=10
      50/      BA : (MACRO)             	pushr R6
      51/      BE : (MACRO)             	pushr R7
      52/      C2 : (MACRO)             	reserve 4; save room for outgoing arguments
      53/      C6 : (MACRO)             	cpy2 R7,R12; function(2054) 1
      54/      CA :                     ;void delay(unsigned int howlong){
      55/      CA :                     ;	for (i=1;i!=howlong;i++){
      56/      CA : (MACRO)             	ldaD R6,1; reg:acon
      57/      D0 : C0 00 D7            	lbr L14
      58/      D3 :                     L11:
      59/      D3 :                     ;		oneMs();
      60/      D3 : (MACRO)             	Ccall _oneMs; CALLI2(ar)
      61/      D6 :                     ;	}
      62/      D6 :                     L12:
      63/      D6 :                     ;	for (i=1;i!=howlong;i++){
      64/      D6 : (MACRO)             	incm R6,1
      65/      D7 :                     L14:
      66/      D7 : (MACRO)             	jneU2 R6,R7,L11; NE
      67/      E9 :                     ;}
      68/      E9 :                     L10:
      69/      E9 : (MACRO)             	release 4; release room for outgoing arguments
      70/      ED : (MACRO)             	popf R7	;opt11.3
      71/      F2 : (MACRO)             	popl R6	;opt11.3
      72/      F6 : (MACRO)             	Cretn
      73/      F7 :                     
      74/      F7 :                     ;$$function end$$ _delay
      75/      F7 :                     ;$$function start$$ _olduinoincluder
      76/      F7 :                     _olduinoincluder:		;framesize=2
      77/      F7 :                     ;void olduinoincluder(){
      78/      F7 :                     ;	asm("\tinclude olduino.inc\n");
      79/      F7 :                     	include olduino.inc
(1)    1/      F7 :                     ;Feb 8 2013, first version of assembler routines for olduino support	
(1)    2/      F7 :                     ;may 31 - incredibly, there's an error in digitalWrite.  lda2 changed to ldAD
(1)    3/      F7 :                     ;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
(1)    4/      F7 :                     	align 64	;needed to make sure all on same page
(1)    5/     100 :                     _digitalWrite:
(1)    6/     100 : 8C                  	glo regArg1	;get the bit number
(1)    7/     101 : FC 1F               	adi $$bvtable&255	;add the table offset
(1)    8/     103 : AE                  	plo memaddr
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(olduino.inc) - page 4 - 11/23/2017 8:43:24


(1)    9/     104 : 93                  	ghi RPC		;get the top byte of the current page
(1)   10/     105 : BE                  	phi memaddr	
(1)   11/     106 : 0E                  	ldn memaddr	;pick up the bit pattern
(1)   12/     107 : A8                  	plo rt1		;save it in a temp
(1)   13/     108 : (MACRO)             	ldAD memaddr,_PIN4 ;address the current port value
(1)   14/     10E : EE                  	sex memaddr	;prepare to change it
(1)   15/     10F : 8D                  	glo regArg2	;get on/off switch
(1)   16/     110 : 32 17               	bz $$setbitoff
(1)   17/     112 :                     ; here we have the bit pattern in rt1 and we're ready to apply it with OR
(1)   18/     112 : 88                  	glo rt1		;get the bit value back
(1)   19/     113 : F1                  	or		;apply it
(1)   20/     114 : 5E                  	str memaddr	;and save it
(1)   21/     115 : 30 1C               	br $$outit	;go fnish up
(1)   22/     117 :                     $$setbitoff:
(1)   23/     117 : 88                  	glo rt1		;get the bit pattern
(1)   24/     118 : FB FF               	xri 0xff	;reverse it
(1)   25/     11A : F2                  	and		;combine it with the existing pin value
(1)   26/     11B : 5E                  	str memaddr	;and save it
(1)   27/     11C :                     ;here we gave set/reset the correct bit in PIN4 and we just have to send it out
(1)   28/     11C :                     $$outit:
(1)   29/     11C : 64                  	out 4		;X was already set to memaddr
(1)   30/     11D : E2                  	sex sp		;reset X
(1)   31/     11E : (MACRO)             	cretn
(1)   32/     11F : 01 02 04 08 10 20   $$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
                    40 80 
(1)   33/     127 :                     ;int digitalRead(unsigned char pin){//for now this will always read ef3
(1)   34/     127 :                     	align 8	;protect jump boundary
(1)   35/     128 :                     _digitalRead:
(1)   36/     128 : F8 00               	ldi 0		;default is false
(1)   37/     12A : AF                  	plo R15
(1)   38/     12B : BF                  	phi R15
(1)   39/     12C : 36 2F               	b3 +		;i have to reverse the sense of the external line
(1)   40/     12E : 1F                  	inc R15		;if external line is high, supply a 1
(1)   41/     12F : (MACRO)             +	cretn
(1)   42/     130 :                     
      80/     130 :                     ;}
      81/     130 :                     L15:
      82/     130 : (MACRO)             	Cretn
      83/     131 :                     
      84/     131 :                     ;$$function end$$ _olduinoincluder
      85/     131 :                     ;$$function start$$ _strncmp
      86/     131 :                     _strncmp:		;framesize=6
      87/     131 : (MACRO)             	pushr R6
      88/     135 : (MACRO)             	pushr R7
      89/     139 : (MACRO)             	ld2 R7,'O',sp,(10+1) ;reg:INDIRU2(addr)
      90/     145 :                     ;{
      91/     145 :                     ;    for ( ; n > 0; s1++, s2++, --n)
      92/     145 : C0 01 95            	lbr L21
      93/     148 :                     L18:
      94/     148 :                     ;	if (*s1 != *s2)
      95/     148 : (MACRO)             	ldn1 R11,R12	;opt14*
      96/     14A : (MACRO)             	ldn1 R10,R13	;opt14*
      97/     14C : (MACRO)             	jeqI1 R11,R10,L22	;opt21
      98/     153 :                     ;	    return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1);
      99/     153 : (MACRO)             	ldn1 R11,R12	;opt14*
     100/     155 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     101/     158 : (MACRO)             	ldn1 R10,R13	;opt14*
     102/     15A : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     103/     15D : (MACRO)             	jcI2 R11,R10,lbdf,L25; GE is flipped test from LT
     104/     16F : (MACRO)             	ldaD R6,-1; reg:acon
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 5 - 11/23/2017 8:43:24


     105/     175 : C0 01 7E            	lbr L26
     106/     178 :                     L25:
     107/     178 : (MACRO)             	ldaD R6,1; reg:acon
     108/     17E :                     L26:
     109/     17E : (MACRO)             	cpy2 R15,R6 ;LOADI2(reg)
     110/     182 : C0 01 A1            	lbr L17
     111/     185 :                     L22:
     112/     185 :                     ;	else if (*s1 == '\0')
     113/     185 : (MACRO)             	ldn1 R11,R12;reg:  INDIRU1(indaddr)
     114/     187 : (MACRO)             	jnzU1 R11,L27; NEI2(CVUI2(reg),con0)
     115/     18B :                     ;	    return 0;
     116/     18B : (MACRO)             	ld2z R15
     117/     18F : C0 01 A1            	lbr L17
     118/     192 :                     L27:
     119/     192 :                     L19:
     120/     192 :                     ;    for ( ; n > 0; s1++, s2++, --n)
     121/     192 : (MACRO)             	incm R12,1
     122/     193 : (MACRO)             	incm R13,1
     123/     194 : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
     124/     195 :                     L21:
     125/     195 : (MACRO)             	jnzU2 R7,L18; NE 0 
     126/     19D :                     ;    return 0;
     127/     19D : (MACRO)             	ld2z R15
     128/     1A1 :                     L17:
     129/     1A1 : (MACRO)             	popf R7	;opt11.3
     130/     1A6 : (MACRO)             	popl R6	;opt11.3
     131/     1AA : (MACRO)             	Cretn
     132/     1AB :                     
     133/     1AB :                     ;$$function end$$ _strncmp
     134/     1AB :                     ;$$function start$$ _strlen
     135/     1AB :                     _strlen:		;framesize=4
     136/     1AB : (MACRO)             	pushr R7
     137/     1AF :                     ;{
     138/     1AF :                     ;	unsigned int slen = 0 ;
     139/     1AF : (MACRO)             	ld2z R7
     140/     1B3 : C0 01 B8            	lbr L31
     141/     1B6 :                     L30:
     142/     1B6 :                     ;	while (*str != 0) {
     143/     1B6 :                     ;      slen++ ;
     144/     1B6 : (MACRO)             	incm R7,1
     145/     1B7 :                     ;      str++ ;
     146/     1B7 : (MACRO)             	incm R12,1
     147/     1B8 :                     ;   }
     148/     1B8 :                     L31:
     149/     1B8 :                     ;	while (*str != 0) {
     150/     1B8 : (MACRO)             	ldn1 R11,R12;reg:  INDIRU1(indaddr)
     151/     1BA : (MACRO)             	jnzU1 R11,L30; NEI2(CVUI2(reg),con0)
     152/     1BE :                     ;   return slen;
     153/     1BE : (MACRO)             	cpy2 R15,R7 ;LOADU2*(reg)
     154/     1C2 :                     L29:
     155/     1C2 : (MACRO)             	popr R7
     156/     1C7 : (MACRO)             	Cretn
     157/     1C8 :                     
     158/     1C8 :                     ;$$function end$$ _strlen
     159/     1C8 :                     ;$$function start$$ _printstr
     160/     1C8 :                     _printstr:		;framesize=8
     161/     1C8 : (MACRO)             	pushr R7
     162/     1CC : (MACRO)             	reserve 4; save room for outgoing arguments
     163/     1D0 : (MACRO)             	cpy2 R7,R12; function(2055) 1
     164/     1D4 :                     ;void printstr(char *ptr){
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 6 - 11/23/2017 8:43:24


     165/     1D4 : C0 01 E4            	lbr L35
     166/     1D7 :                     L34:
     167/     1D7 :                     ;    while(*ptr){
     168/     1D7 :                     ;		putc(*ptr++); //jan 29
     169/     1D7 : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
     170/     1DB : (MACRO)             	incm R7,1
     171/     1DC : (MACRO)             	ldn1 R12,R11	;opt14*
     172/     1DE : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     173/     1E1 : (MACRO)             	Ccall _putcser
     174/     1E4 :                     ;		asm(" nop1806\n nop1806\n nop1806\n"); //17-03-09
     175/     1E4 : (MACRO)              nop1806
     176/     1E4 : (MACRO)              nop1806
     177/     1E4 : (MACRO)              nop1806
     178/     1E4 :                     ;	}
     179/     1E4 :                     L35:
     180/     1E4 :                     ;    while(*ptr){
     181/     1E4 : (MACRO)             	ldn1 R11,R7;reg:  INDIRU1(indaddr)
     182/     1E6 : (MACRO)             	jnzU1 R11,L34; NEI2(CVUI2(reg),con0)
     183/     1EA :                     ;}
     184/     1EA :                     L33:
     185/     1EA : (MACRO)             	release 4; release room for outgoing arguments
     186/     1EE : (MACRO)             	popr R7
     187/     1F3 : (MACRO)             	Cretn
     188/     1F4 :                     
     189/     1F4 :                     ;$$function end$$ _printstr
     190/     1F4 :                     	align 4
     191/     1F4 :                     _round_nums:
     192/     1F4 : 3F 00 00 00         	dd 0x3f000000
     193/     1F8 : 3D 4C CC CD         	dd 0x3d4ccccd
     194/     1FC : 3B A3 D7 0A         	dd 0x3ba3d70a
     195/     200 : 3A 03 12 6F         	dd 0x3a03126f
     196/     204 : 38 51 B7 17         	dd 0x3851b717
     197/     208 : 36 A7 C5 AC         	dd 0x36a7c5ac
     198/     20C : 35 06 37 BD         	dd 0x350637bd
     199/     210 : 33 56 BF 95         	dd 0x3356bf95
     200/     214 :                     	align 4
     201/     214 :                     _mult_nums:
     202/     214 : 3F 80 00 00         	dd 0x3f800000
     203/     218 : 41 20 00 00         	dd 0x41200000
     204/     21C : 42 C8 00 00         	dd 0x42c80000
     205/     220 : 44 7A 00 00         	dd 0x447a0000
     206/     224 : 46 1C 40 00         	dd 0x461c4000
     207/     228 : 47 C3 50 00         	dd 0x47c35000
     208/     22C : 49 74 24 00         	dd 0x49742400
     209/     230 : 4B 18 96 80         	dd 0x4b189680
     210/     234 :                     ;$$function start$$ _ftoa
     211/     234 :                     _ftoa:		;framesize=80
     212/     234 : (MACRO)             	reserve 62; save room for local variables
     213/     23E : (MACRO)             	pushr R0
     214/     242 : (MACRO)             	pushr R1
     215/     246 : (MACRO)             	pushr R6
     216/     24A : (MACRO)             	pushr R7
     217/     24E : (MACRO)             	reserve 8; save room for outgoing arguments
     218/     256 : (MACRO)             	cpy4 RL6,RL12; halfbaked&floaty
     219/     25E : (MACRO)             	ld2 R1,'O',sp,(86+1) ;reg:INDIRU2(addr)
     220/     26A :                     ;{
     221/     26A :                     ;   char *output = outbfr ;
     222/     26A : (MACRO)             	ld2 R0,'O',sp,(84+1) ;reg:INDIRP2(addr)
     223/     276 :                     ;   if (flt < 0.0) {
     224/     276 : (MACRO)             	ld4 RL10,'D',(L41),0;INDIRF4(addr)
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 7 - 11/23/2017 8:43:24


     225/     284 : (MACRO)             	jcF4 RL6,RL10,lbdf,L39;GEF4(reg,reg) - reverse test
     226/     2C9 :                     ;      *output++ = '-' ;
     227/     2C9 : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
     228/     2CD : (MACRO)             	incm R0,1
     229/     2CE : (MACRO)             	str1I 45,R11; ASGNU1(indaddr,acon)	DH
     230/     2D1 :                     ;      flt *= -1.0 ;
     231/     2D1 : (MACRO)             	ld4 RL8,'D',(L42),0;INDIRF4(addr)
     232/     2DF : (MACRO)             	cpy4 RL10,RL6; LOADU4(reg)
     233/     2E7 : (MACRO)             	Ccall fp_mul ;MULF4(reg,reg)
     234/     2EA : (MACRO)             	cpy4 RL6,RL8; LOADU4(reg)
     235/     2F2 :                     ;   } else {
     236/     2F2 : C0 03 00            	lbr L40
     237/     2F5 :                     L39:
     238/     2F5 :                     ;      if (use_leading_plus) {
     239/     2F5 : C0 03 00            	lbr L43
     240/     2F8 :                     ;         *output++ = '+' ;
     241/     2F8 : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
     242/     2FC : (MACRO)             	incm R0,1
     243/     2FD : (MACRO)             	str1I 43,R11; ASGNU1(indaddr,acon)	DH
     244/     300 :                     ;      }
     245/     300 :                     L43:
     246/     300 :                     ;   }
     247/     300 :                     L40:
     248/     300 :                     ;   if (dec_digits < 8) {
     249/     300 : (MACRO)             	jcI2I R1,8,lbdf,L45; GE is flipped test from LT
     250/     311 :                     ;      flt += round_nums[dec_digits] ;
     251/     311 : (MACRO)             	cpy4 RL8,RL6; LOADU4(reg)
     252/     319 : (MACRO)             	shlR2R	R11,R1	;opt6.1
     253/     31F : (MACRO)             	shl2I 	R11,1	;opt6.1
     254/     325 : (MACRO)             	ld4 RL10,'O',R11,(_round_nums);INDIRF4(addr)
     255/     335 : (MACRO)             	Ccall fp_add ;ADDF4(reg,reg)
     256/     338 : (MACRO)             	cpy4 RL6,RL8; LOADU4(reg)
     257/     340 :                     ;   }
     258/     340 :                     L45:
     259/     340 :                     ;	mult=mult_nums[dec_digits];
     260/     340 : (MACRO)             	shlR2R	R11,R1	;opt6.1
     261/     346 : (MACRO)             	shl2I 	R11,1	;opt6.1
     262/     34C : (MACRO)             	ld4 RL10,'O',R11,(_mult_nums);INDIRF4(addr)
     263/     35C : (MACRO)             	st4 RL10,'O',sp,(68+1); ASGNF4(addr,reg)
     264/     36F :                     ;   wholeNum = flt;
     265/     36F : (MACRO)             	cpy4 RL8,RL6; LOADU4(reg)
     266/     377 : (MACRO)             	ccall cvfi4; CVFI4(reg) convert float to long
     267/     37A : (MACRO)             	st4 RL8,'O',sp,(72+1)
     268/     38D :                     ;   decimalNum = ((flt - wholeNum) * mult);
     269/     38D : (MACRO)             	cpy4 RL8,RL6; LOADU4(reg)
     270/     395 : (MACRO)             	st4 RL8,'O',sp,(16+1); ASGNF4(addr,reg)
     271/     3A8 : (MACRO)             	ld4 RL8,'O',sp,(72+1);reg:  INDIRI4(addr)
     272/     3B8 : (MACRO)             	Ccall cvif4; emit2
     273/     3BB : (MACRO)             	cpy4 RL10,RL8; LOADU4(reg)
     274/     3C3 : (MACRO)             	ld4 RL8,'O',sp,(16+1);INDIRF4(addr)
     275/     3D3 : (MACRO)             	Ccall fp_sub ;SUBF4(reg,reg)
     276/     3D6 : (MACRO)             	ld4 RL10,'O',sp,(68+1);INDIRF4(addr)
     277/     3E6 : (MACRO)             	Ccall fp_mul ;MULF4(reg,reg)
     278/     3E9 : (MACRO)             	ccall cvfi4; CVFI4(reg) convert float to long
     279/     3EC : (MACRO)             	st4 RL8,'O',sp,(64+1)
     280/     3FF :                     ;   strcpy(output,dubdabx(wholeNum,output,1));
     281/     3FF : (MACRO)             	ld4 Rp1p2,'O',sp,(72+1);reg:  INDIRI4(addr)
     282/     40F : (MACRO)             	st2 R0,'O',sp,(4+1); arg+f**
     283/     41C : (MACRO)             	ldaD R11,1; reg:acon
     284/     422 : (MACRO)             	st2 R11,'O',sp,(6+1); arg+f**
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 8 - 11/23/2017 8:43:24


     285/     42F : (MACRO)             	Ccall _dubdabx
     286/     432 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     287/     436 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     288/     43A : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     289/     43E : (MACRO)             	Ccall _strcpy
     290/     441 :                     ;   output+=strlen(output);
     291/     441 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     292/     445 : (MACRO)             	Ccall _strlen;CALLU2(ar)*
     293/     448 : (MACRO)             	alu2 R0,R15,R0,add,adc	;ADDP2(reg,reg)
     294/     452 :                     ;   if (dec_digits > 0) {
     295/     452 : (MACRO)             	jzU2 R1,L47; EQ 0
     296/     45A :                     ;		*output++ = '.' ;
     297/     45A : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
     298/     45E : (MACRO)             	incm R0,1
     299/     45F : (MACRO)             	str1I 46,R11; ASGNU1(indaddr,acon)	DH
     300/     462 :                     ;		strcpy(output,dubdabx(decimalNum,output,dec_digits));
     301/     462 : (MACRO)             	ld4 Rp1p2,'O',sp,(64+1);reg:  INDIRI4(addr)
     302/     472 : (MACRO)             	st2 R0,'O',sp,(4+1); arg+f**
     303/     47F : (MACRO)             	cpy2 R11,R1 ;LOADI2(reg)
     304/     483 : (MACRO)             	st2 R11,'O',sp,(6+1); arg+f**
     305/     490 : (MACRO)             	Ccall _dubdabx
     306/     493 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     307/     497 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     308/     49B : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     309/     49F : (MACRO)             	Ccall _strcpy
     310/     4A2 :                     ;	}
     311/     4A2 :                     L47:
     312/     4A2 :                     ;   return outbfr;
     313/     4A2 : (MACRO)             	ld2 R15,'O',sp,(84+1) ;reg:INDIRP2(addr)
     314/     4AE :                     L38:
     315/     4AE : (MACRO)             	release 8; release room for outgoing arguments
     316/     4B6 : (MACRO)             	popf R7	;opt11.3
     317/     4BB : (MACRO)             	popm R6	;opt11.4
     318/     4BF : (MACRO)             	popm R1	;opt11.4
     319/     4C3 : (MACRO)             	popl R0	;opt11.4
     320/     4C7 : (MACRO)             	release 62; release room for local variables 
     321/     4CF : (MACRO)             	Cretn
     322/     4D0 :                     
     323/     4D0 :                     ;$$function end$$ _ftoa
     324/     4D0 :                     ;$$function start$$ _itoa
     325/     4D0 :                     _itoa:		;framesize=16
     326/     4D0 : (MACRO)             	reserve 2; save room for local variables
     327/     4D2 : (MACRO)             	pushr R0
     328/     4D6 : (MACRO)             	pushr R1
     329/     4DA : (MACRO)             	pushr R6
     330/     4DE : (MACRO)             	pushr R7
     331/     4E2 : (MACRO)             	reserve 4; save room for outgoing arguments
     332/     4E6 : (MACRO)             	st2 R12,'O',sp,(16+1)			
     333/     4F3 : 1E                  	inc memaddr				;opt16.1
     334/     4F4 : (MACRO)             	str2 R13,memaddr			
     335/     4FA :                     ;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
     336/     4FA :                     ;	unsigned int flag=0;
     337/     4FA : (MACRO)             	ld2z R0
     338/     4FE :                     ;	char * bptr; bptr=buffer;
     339/     4FE : (MACRO)             	ld2 R11,'O',sp,(18+1) ;reg:INDIRP2(addr)
     340/     50A : (MACRO)             	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
     341/     517 :                     ;	if (s<0){
     342/     517 : (MACRO)             	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
     343/     523 : (MACRO)             	jcI2I R11,0,lbdf,L50; GE is flipped test from LT
     344/     534 :                     ;		*bptr='-';bptr++;
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 9 - 11/23/2017 8:43:24


     345/     534 : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
     346/     540 : (MACRO)             	str1I 45,R11; ASGNU1(indaddr,acon)	DH
     347/     543 : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
     348/     54F : (MACRO)             	incm R11,1
     349/     550 : (MACRO)             	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
     350/     55D :                     ;		n=-s;
     351/     55D : (MACRO)             	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
     352/     569 : (MACRO)             	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
     353/     572 : (MACRO)             	cpy2 R6,R11 ;LOADU2*(reg)
     354/     576 :                     ;	} else{
     355/     576 : C0 05 89            	lbr L51
     356/     579 :                     L50:
     357/     579 :                     ;		n=s;
     358/     579 : (MACRO)             	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
     359/     585 : (MACRO)             	cpy2 R6,R11 ;LOADU2*(reg)
     360/     589 :                     ;	}
     361/     589 :                     L51:
     362/     589 :                     ;	k=10000;
     363/     589 : (MACRO)             	ldaD R7,10000; reg:acon
     364/     58F : C0 06 14            	lbr L53
     365/     592 :                     L52:
     366/     592 :                     ;	while(k>0){
     367/     592 :                     ;		for(r=0;k<=n;r++,n-=k); // was r=n/k
     368/     592 : (MACRO)             	ld2z R1
     369/     596 : C0 05 A4            	lbr L58
     370/     599 :                     L55:
     371/     599 :                     L56:
     372/     599 : (MACRO)             	incm R1,1
     373/     59A : (MACRO)             	alu2 R6,R6,R7,sm,smb
     374/     5A4 :                     L58:
     375/     5A4 : (MACRO)             	jcU2 R6,R7,lbdf,L55 ;LE is flipped test & operands
     376/     5B1 :                     ;		if (flag || r>0||k==1){
     377/     5B1 : (MACRO)             	jnzU2 R0,L62; NE 0 
     378/     5B9 : (MACRO)             	jnzU2 R1,L62; NE 0 
     379/     5C1 : (MACRO)             	jneU2I R7,1,L59; NE
     380/     5CD :                     L62:
     381/     5CD :                     ;			*bptr=('0'+r);bptr++;
     382/     5CD : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
     383/     5D9 : (MACRO)             	ldA2 R10,'O',R1,(48); reg:addr
     384/     5E1 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     385/     5E3 : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
     386/     5EF : (MACRO)             	incm R11,1
     387/     5F0 : (MACRO)             	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
     388/     5FD :                     ;			flag='y';
     389/     5FD : (MACRO)             	ldaD R0,121; reg:acon
     390/     603 :                     ;		}
     391/     603 :                     L59:
     392/     603 :                     ;		k=k/10;
     393/     603 : (MACRO)             	cpy2 R12,R7 ;LOADU2*(reg)
     394/     607 : (MACRO)             	ldaD R13,10; reg:acon
     395/     60D : (MACRO)             	Ccall _divu2
     396/     610 : (MACRO)             	cpy2 R7,R15 ;LOADU2*(reg)
     397/     614 :                     ;	}
     398/     614 :                     L53:
     399/     614 :                     ;	while(k>0){
     400/     614 : (MACRO)             	jnzU2 R7,L52; NE 0 
     401/     61C :                     ;	*bptr='\0';
     402/     61C : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
     403/     628 : (MACRO)             	str1I 0,R11; ASGNU1(indaddr,acon)	DH
     404/     62B :                     ;	return buffer;
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 10 - 11/23/2017 8:43:24


     405/     62B : (MACRO)             	ld2 R15,'O',sp,(18+1) ;reg:INDIRP2(addr)
     406/     637 :                     L49:
     407/     637 : (MACRO)             	release 4; release room for outgoing arguments
     408/     63B : (MACRO)             	popf R7	;opt11.3
     409/     640 : (MACRO)             	popm R6	;opt11.4
     410/     644 : (MACRO)             	popm R1	;opt11.4
     411/     648 : (MACRO)             	popl R0	;opt11.4
     412/     64C : (MACRO)             	release 2; release room for local variables 
     413/     64E : (MACRO)             	Cretn
     414/     64F :                     
     415/     64F :                     ;$$function end$$ _itoa
     416/     64F :                     ;$$function start$$ _ltoa
     417/     64F :                     _ltoa:		;framesize=16
     418/     64F : (MACRO)             	pushr R1
     419/     653 : (MACRO)             	pushr R6
     420/     657 : (MACRO)             	pushr R7
     421/     65B : (MACRO)             	reserve 8; save room for outgoing arguments
     422/     663 : (MACRO)             	cpy4 RL6,RL12; halfbaked
     423/     66B :                     ;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
     424/     66B :                     ;	char* bptr=buffer;
     425/     66B : (MACRO)             	ld2 R1,'O',sp,(20+1) ;reg:INDIRP2(addr)
     426/     677 :                     ;	if (s<0){
     427/     677 : (MACRO)             	ldI4 RL10,0 ;loading a long integer constant
     428/     683 : (MACRO)             	jcI4 RL6,RL10,lbdf,L64; GE is flipped test from LT
     429/     69F :                     ;		*bptr++='-';
     430/     69F : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     431/     6A3 : (MACRO)             	incm R1,1
     432/     6A4 : (MACRO)             	str1I 45,R11; ASGNU1(indaddr,acon)	DH
     433/     6A7 :                     ;		s=-s;
     434/     6A7 : (MACRO)             	negI4 RL6,RL6 ;was alu4I RL6,RL6,0,sdi,sdbi
     435/     6C7 :                     ;	}
     436/     6C7 :                     L64:
     437/     6C7 :                     ;	strcpy(bptr,dubdabx(s,bptr,1)); //uses assembler double-dabble routine
     438/     6C7 : (MACRO)             	cpy4 Rp1p2,RL6; LOADI4*
     439/     6CF : (MACRO)             	st2 R1,'O',sp,(4+1); arg+f**
     440/     6DC : (MACRO)             	ldaD R11,1; reg:acon
     441/     6E2 : (MACRO)             	st2 R11,'O',sp,(6+1); arg+f**
     442/     6EF : (MACRO)             	Ccall _dubdabx
     443/     6F2 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     444/     6F6 : (MACRO)             	cpy2 R12,R1 ;LOADP2(reg)
     445/     6FA : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     446/     6FE : (MACRO)             	Ccall _strcpy
     447/     701 :                     ;	return buffer;
     448/     701 : (MACRO)             	ld2 R15,'O',sp,(20+1) ;reg:INDIRP2(addr)
     449/     70D :                     L63:
     450/     70D : (MACRO)             	release 8; release room for outgoing arguments
     451/     715 : (MACRO)             	popf R7	;opt11.3
     452/     71A : (MACRO)             	popm R6	;opt11.4
     453/     71E : (MACRO)             	popl R1	;opt11.4
     454/     722 : (MACRO)             	Cretn
     455/     723 :                     
     456/     723 :                     ;$$function end$$ _ltoa
     457/     723 :                     ;$$function start$$ _printint
     458/     723 :                     _printint:		;framesize=14
     459/     723 : (MACRO)             	reserve 12
     460/     72D : (MACRO)             	st2 R12,'O',sp,(14+1); flag1 
     461/     73A :                     ;void printint(int s){ //print an integer
     462/     73A :                     ;	itoa(s,buffer);
     463/     73A : (MACRO)             	ld2 R12,'O',sp,(14+1) ;reg:INDIRI2(addr)
     464/     746 : (MACRO)             	ldA2 R13,'O',sp,(4+1); reg:addr
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 11 - 11/23/2017 8:43:24


     465/     74E : (MACRO)             	Ccall _itoa
     466/     751 :                     ;	printstr(buffer);
     467/     751 : (MACRO)             	ldA2 R12,'O',sp,(4+1); reg:addr
     468/     759 : (MACRO)             	Ccall _printstr
     469/     75C :                     ;}
     470/     75C :                     L66:
     471/     75C : (MACRO)             	release 12
     472/     764 : (MACRO)             	Cretn
     473/     765 :                     
     474/     765 :                     ;$$function end$$ _printint
     475/     765 :                     ;$$function start$$ _printlint
     476/     765 :                     _printlint:		;framesize=20
     477/     765 : (MACRO)             	reserve 18
     478/     76F : (MACRO)             	st2 R12,'O',sp,(20+1)			
     479/     77C : 1E                  	inc memaddr				;opt16.1
     480/     77D : (MACRO)             	str2 R13,memaddr			
     481/     783 :                     ;void printlint(long s){ //print a long integer
     482/     783 :                     ;	printstr(ltoa(s,buffer));
     483/     783 : (MACRO)             	ld4 Rp1p2,'O',sp,(20+1);reg:  INDIRI4(addr)
     484/     793 : (MACRO)             	ldA2 R11,'O',sp,(6+1); reg:addr
     485/     79B : (MACRO)             	st2 R11,'O',sp,(4+1); arg+f**
     486/     7A8 : (MACRO)             	Ccall _ltoa
     487/     7AB : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     488/     7AF : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     489/     7B3 : (MACRO)             	Ccall _printstr
     490/     7B6 :                     ;}
     491/     7B6 :                     L67:
     492/     7B6 : (MACRO)             	release 18
     493/     7BE : (MACRO)             	Cretn
     494/     7BF :                     
     495/     7BF :                     ;$$function end$$ _printlint
     496/     7BF :                     ;$$function start$$ _printflt
     497/     7BF :                     _printflt:		;framesize=30
     498/     7BF : (MACRO)             	reserve 28
     499/     7C9 : (MACRO)             	st2 R12,'O',sp,(30+1)			
     500/     7D6 : 1E                  	inc memaddr				;opt16.1
     501/     7D7 : (MACRO)             	str2 R13,memaddr			
     502/     7DD :                     ;void printflt(float s){ //print a float
     503/     7DD :                     ;	printstr(ftoa(s,buffer,3));
     504/     7DD : (MACRO)             	ld4 Rp1p2,'O',sp,(30+1);INDIRF4(addr)
     505/     7ED : (MACRO)             	ldA2 R11,'O',sp,(8+1); reg:addr
     506/     7F5 : (MACRO)             	st2 R11,'O',sp,(4+1); arg+f**
     507/     802 : (MACRO)             	ldaD R11,3; reg:acon
     508/     808 : (MACRO)             	st2 R11,'O',sp,(6+1); arg+f**
     509/     815 : (MACRO)             	Ccall _ftoa
     510/     818 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     511/     81C : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     512/     820 : (MACRO)             	Ccall _printstr
     513/     823 :                     ;}
     514/     823 :                     L68:
     515/     823 : (MACRO)             	release 28
     516/     82B : (MACRO)             	Cretn
     517/     82C :                     
     518/     82C :                     ;$$function end$$ _printflt
     519/     82C :                     ;$$function start$$ _putxn
     520/     82C :                     _putxn:		;framesize=6
     521/     82C : (MACRO)             	reserve 4
     522/     830 : (MACRO)             	st2 R12,'O',sp,(6+1); flag1 
     523/     83D : (MACRO)             	ldA2 R11,'O',sp,(6+1); reg:addr
     524/     845 : (MACRO)             	ld2 R10,'O',sp,(6+1) ;reg:INDIRI2(addr)
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 12 - 11/23/2017 8:43:24


     525/     851 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     526/     853 :                     ;void putxn(unsigned char x){ //print a nibble as ascii hex
     527/     853 :                     ;	if (x<10){
     528/     853 : (MACRO)             	ld1 R11,'O',sp,(6+1)
     529/     85D : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     530/     860 : (MACRO)             	jcI2I R11,10,lbdf,L70; GE is flipped test from LT
     531/     871 :                     ;		putc(x+'0');
     532/     871 : (MACRO)             	ld1 R11,'O',sp,(6+1)
     533/     87B : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     534/     87E : (MACRO)             	ldA2 R11,'O',R11,(48); reg:addr
     535/     886 : (MACRO)             	cpy1 R12,R11
     536/     888 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     537/     88B : (MACRO)             	Ccall _putcser
     538/     88E :                     ;	} else {
     539/     88E : C0 08 B6            	lbr L71
     540/     891 :                     L70:
     541/     891 :                     ;		putc(x+'A'-10);
     542/     891 : (MACRO)             	ld1 R11,'O',sp,(6+1)
     543/     89B : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     544/     89E : (MACRO)             	ldA2 R11,'O',R11,(65); reg:addr
     545/     8A6 : (MACRO)             	alu2I R11,R11,10,smi,smbi
     546/     8AE : (MACRO)             	cpy1 R12,R11
     547/     8B0 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     548/     8B3 : (MACRO)             	Ccall _putcser
     549/     8B6 :                     ;	}
     550/     8B6 :                     L71:
     551/     8B6 :                     ;}
     552/     8B6 :                     L69:
     553/     8B6 : (MACRO)             	release 4
     554/     8BA : (MACRO)             	Cretn
     555/     8BB :                     
     556/     8BB :                     ;$$function end$$ _putxn
     557/     8BB :                     ;$$function start$$ _putx
     558/     8BB :                     _putx:		;framesize=6
     559/     8BB : (MACRO)             	reserve 4
     560/     8BF : (MACRO)             	st2 R12,'O',sp,(6+1); flag1 
     561/     8CC : (MACRO)             	ldA2 R11,'O',sp,(6+1); reg:addr
     562/     8D4 : (MACRO)             	ld2 R10,'O',sp,(6+1) ;reg:INDIRI2(addr)
     563/     8E0 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     564/     8E2 :                     ;void putx(unsigned char x){ //print a unsigned char as ascii hex
     565/     8E2 :                     ;	putxn(x>>4);
     566/     8E2 : (MACRO)             	ld1 R11,'O',sp,(6+1)
     567/     8EC : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     568/     8EF : (MACRO)             	shrI2I R11,4
     569/     90F : (MACRO)             	cpy1 R12,R11
     570/     911 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     571/     914 : (MACRO)             	Ccall _putxn
     572/     917 :                     ;	putxn(x & 0x0F);
     573/     917 : (MACRO)             	ld1 R11,'O',sp,(6+1)
     574/     921 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     575/     924 : (MACRO)             	alu2I R11,R11,15,ani,ani
     576/     92C :                     	;removed ?	cpy2 R11,R11
     577/     92C : (MACRO)             	cpy1 R12,R11
     578/     92E : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     579/     931 : (MACRO)             	Ccall _putxn
     580/     934 :                     ;}
     581/     934 :                     L72:
     582/     934 : (MACRO)             	release 4
     583/     938 : (MACRO)             	Cretn
     584/     939 :                     
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 13 - 11/23/2017 8:43:24


     585/     939 :                     ;$$function end$$ _putx
     586/     939 :                     ;$$function start$$ _printf
     587/     939 :                     _printf:		;framesize=18
     588/     939 : (MACRO)             	reserve 4; save room for local variables
     589/     93D : (MACRO)             	pushr R0
     590/     941 : (MACRO)             	pushr R1
     591/     945 : (MACRO)             	pushr R6
     592/     949 : (MACRO)             	pushr R7
     593/     94D : (MACRO)             	reserve 4; save room for outgoing arguments
     594/     951 : (MACRO)             	st2 R12,'O',sp,(18+1)			
     595/     95E : 1E                  	inc memaddr				;opt16
     596/     95F : (MACRO)             	str2 R13,memaddr			
     597/     965 :                     ;void printf(char *pptr,...){ //limited implementation of printf
     598/     965 :                     ;	register char* ptr=pptr; //try to save on loads/spills
     599/     965 : (MACRO)             	ld2 R7,'O',sp,(18+1) ;reg:INDIRP2(addr)
     600/     971 :                     ;	int argslot=0;	//used to align longs
     601/     971 : (MACRO)             	ld2z R0
     602/     975 :                     ;	int * this=(int *)&pptr;
     603/     975 : (MACRO)             	ldA2 R1,'O',sp,(18+1); reg:addr
     604/     97D :                     ;	this++; argslot++; //advance argument pointer and slot #
     605/     97D : (MACRO)             	incm R1,2
     606/     97F : (MACRO)             	incm R0,1
     607/     980 : C0 0C 1B            	lbr L75
     608/     983 :                     L74:
     609/     983 :                     ;    while(*ptr) {
     610/     983 :                     ;		c=*ptr; ptr++;
     611/     983 : (MACRO)             	ldn1 R6,R7;reg:  INDIRU1(indaddr)
     612/     985 : (MACRO)             	incm R7,1
     613/     986 :                     ;		if (c!='%'){
     614/     986 : (MACRO)             	jeqU1I R6,37,L77;EQI2(CVUI2(reg),con8bit)**
     615/     98C :                     ;			putc(c);
     616/     98C : (MACRO)             	cpy1 R12,R6
     617/     98E : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     618/     991 : (MACRO)             	Ccall _putcser
     619/     994 :                     ;			asm(" nop1806\n nop1806\n nop1806\n"); //17-03-13
     620/     994 : (MACRO)              nop1806
     621/     994 : (MACRO)              nop1806
     622/     994 : (MACRO)              nop1806
     623/     994 :                     ;		} else{
     624/     994 : C0 0C 1B            	lbr L78
     625/     997 :                     L77:
     626/     997 :                     ;			c=*ptr;ptr++;
     627/     997 : (MACRO)             	ldn1 R6,R7;reg:  INDIRU1(indaddr)
     628/     999 : (MACRO)             	incm R7,1
     629/     99A :                     ;			switch (c){
     630/     99A : (MACRO)             	cpy1 R11,R6
     631/     99C : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     632/     99F : (MACRO)             	st2 R11,'O',sp,(13+1); ASGNI2(addr,reg)
     633/     9AC : (MACRO)             	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
     634/     9B8 : (MACRO)             	jcI2I R11,99,lbnf,L101  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     635/     9C9 : (MACRO)             	jnI2I R11,108,lbnf,L102; GT reverse  the subtraction
     636/     9DA : (MACRO)             	shl2I R11,1
     637/     9E0 : (MACRO)             	ld2 R11,'O',R11,(L103-198) ;reg:INDIRP2(addr)
     638/     9EC : (MACRO)             	jumpv R11; JUMPV(reg)
     639/     9F5 :                     L103:
     640/     9F5 : 0A 9B               	dw L85
     641/     9F7 : 0A 71               	dw L83
     642/     9F9 : 0C 0A               	dw L80
     643/     9FB : 0B CE               	dw L96
     644/     9FD : 0C 0A               	dw L80
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 14 - 11/23/2017 8:43:24


     645/     9FF : 0C 0A               	dw L80
     646/     A01 : 0A 71               	dw L83
     647/     A03 : 0C 0A               	dw L80
     648/     A05 : 0C 0A               	dw L80
     649/     A07 : 0B 10               	dw L89
     650/     A09 :                     L101:
     651/     A09 : (MACRO)             	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
     652/     A15 : (MACRO)             	jeqU2I R11,88,L88;EQI2(reg,con)
     653/     A21 : C0 0C 0A            	lbr L80
     654/     A24 :                     L102:
     655/     A24 : (MACRO)             	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
     656/     A30 : (MACRO)             	ldaD R10,115; reg:acon
     657/     A36 : (MACRO)             	jeqI2 R11,R10,L84; EQI2(reg,reg)
     658/     A44 : (MACRO)             	jcI2 R11,R10,lbnf,L80; LT=lbnf i.e. subtract B from A and jump if borrow 
     659/     A56 :                     L105:
     660/     A56 : (MACRO)             	ld2 R11,'O',sp,(13+1) ;reg:INDIRI2(addr)
     661/     A62 : (MACRO)             	jeqU2I R11,120,L88;EQI2(reg,con)
     662/     A6E : C0 0C 0A            	lbr L80
     663/     A71 :                     L83:
     664/     A71 :                     ;					printint(*this++);
     665/     A71 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     666/     A75 : (MACRO)             	incm R1,2
     667/     A77 : (MACRO)             	ldn2 R12,R11	;opt9x
     668/     A7C : (MACRO)             	Ccall _printint
     669/     A7F :                     ;					argslot+=1; //next argument slot
     670/     A7F : (MACRO)             	incm R0,1
     671/     A80 :                     ;					break;
     672/     A80 : C0 0C 1B            	lbr L81
     673/     A83 :                     L84:
     674/     A83 :                     ;					printstr((char*) *this++);
     675/     A83 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     676/     A87 : (MACRO)             	incm R1,2
     677/     A89 : (MACRO)             	ldn2s R11,R11	;opt9xs
     678/     A90 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     679/     A94 : (MACRO)             	Ccall _printstr
     680/     A97 :                     ;					argslot+=1; //next argument slot
     681/     A97 : (MACRO)             	incm R0,1
     682/     A98 :                     ;					break;
     683/     A98 : C0 0C 1B            	lbr L81
     684/     A9B :                     L85:
     685/     A9B :                     ;					if (*ptr=='x'){ //if there's an x
     686/     A9B : (MACRO)             	ldn1 R11,R7;reg:  INDIRU1(indaddr)
     687/     A9D : (MACRO)             	jneU1I R11,120,L86	; DH 4
     688/     AA3 :                     ;						ptr++; //skip over the x
     689/     AA3 : (MACRO)             	incm R7,1
     690/     AA4 :                     ;						putx(((unsigned int) *this++)&255); //print 1 byte as hex
     691/     AA4 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     692/     AA8 : (MACRO)             	incm R1,2
     693/     AAA : (MACRO)             	ldn2s R11,R11	;opt9xs
     694/     AB1 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     695/     AB9 : (MACRO)             	cpy1 R12,R11
     696/     ABB : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     697/     ABE : (MACRO)             	Ccall _putx
     698/     AC1 :                     ;					} else{
     699/     AC1 : C0 0A D9            	lbr L87
     700/     AC4 :                     L86:
     701/     AC4 :                     ;						putc((unsigned int) *this++);		//print as char
     702/     AC4 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     703/     AC8 : (MACRO)             	incm R1,2
     704/     ACA : (MACRO)             	ldn2s R11,R11	;opt9xs
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 15 - 11/23/2017 8:43:24


     705/     AD1 : (MACRO)             	cpy1 R12,R11
     706/     AD3 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     707/     AD6 : (MACRO)             	Ccall _putcser
     708/     AD9 :                     ;					}
     709/     AD9 :                     L87:
     710/     AD9 :                     ;					argslot+=1; //next argument slot
     711/     AD9 : (MACRO)             	incm R0,1
     712/     ADA :                     ;					break;
     713/     ADA : C0 0C 1B            	lbr L81
     714/     ADD :                     L88:
     715/     ADD :                     ;					putx(((unsigned int) *this)>>8);
     716/     ADD : (MACRO)             	ldn2 R11,R1	;opt9x
     717/     AE2 : 9B                  	ghi	R11	;opt2
     718/     AE3 : AB                  	plo	R11
     719/     AE4 : F8 00               	ldi	0
     720/     AE6 : BB                  	phi	R11	
     721/     AE7 : (MACRO)             	cpy1 R12,R11
     722/     AE9 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     723/     AEC : (MACRO)             	Ccall _putx
     724/     AEF :                     ;					putx(((unsigned int) *this++)&255);
     725/     AEF : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     726/     AF3 : (MACRO)             	incm R1,2
     727/     AF5 : (MACRO)             	ldn2s R11,R11	;opt9xs
     728/     AFC : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     729/     B04 : (MACRO)             	cpy1 R12,R11
     730/     B06 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     731/     B09 : (MACRO)             	Ccall _putx
     732/     B0C :                     ;					argslot+=1; //next argument slot
     733/     B0C : (MACRO)             	incm R0,1
     734/     B0D :                     ;					break;
     735/     B0D : C0 0C 1B            	lbr L81
     736/     B10 :                     L89:
     737/     B10 :                     ;					if (*ptr){ //as long as there's something there
     738/     B10 : (MACRO)             	ldn1 R11,R7	;opt14*
     739/     B12 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     740/     B15 : (MACRO)             	jzU2 R11,L90; EQ 0
     741/     B1D :                     ;						xord=*ptr++;
     742/     B1D : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
     743/     B21 : (MACRO)             	incm R7,1
     744/     B22 : (MACRO)             	ldA2 R10,'O',sp,(15+1); reg:addr
     745/     B2A : (MACRO)             	ldn1 R11,R11;reg:  INDIRU1(indaddr)
     746/     B2C : (MACRO)             	str1 R11,R10; ASGNU1(indaddr,reg)		DH
     747/     B2E :                     ;						if (argslot&1) {
     748/     B2E : (MACRO)             	alu2I R11,R0,1,ani,ani
     749/     B36 :                     	;removed ?	cpy2 R11,R0
     750/     B36 : (MACRO)             	jzU2 R11,L92; EQ 0
     751/     B3E :                     ;							this++;
     752/     B3E : (MACRO)             	incm R1,2
     753/     B40 :                     ;							argslot++;
     754/     B40 : (MACRO)             	incm R0,1
     755/     B41 :                     ;						}
     756/     B41 :                     L92:
     757/     B41 :                     ;						if(xord=='d'){
     758/     B41 : (MACRO)             	ld1 R11,'O',sp,(15+1)
     759/     B4B : (MACRO)             	jneU1I R11,100,L94	; DH 4
     760/     B51 :                     ;							printlint(*(long *)this);//treats "this" as a pointer to long
     761/     B51 : (MACRO)             	ld4 Rp1p2,'O',R1,0;reg:  INDIRI4(addr)
     762/     B61 : (MACRO)             	Ccall _printlint
     763/     B64 :                     ;							this+=2;				// and advances it 4 bytes
     764/     B64 : (MACRO)             	incm R1,4
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 16 - 11/23/2017 8:43:24


     765/     B68 :                     ;						} else{
     766/     B68 : C0 0B C9            	lbr L95
     767/     B6B :                     L94:
     768/     B6B :                     ;							putx(((unsigned int) *this)>>8);
     769/     B6B : (MACRO)             	ldn2 R11,R1	;opt9x
     770/     B70 : 9B                  	ghi	R11	;opt2
     771/     B71 : AB                  	plo	R11
     772/     B72 : F8 00               	ldi	0
     773/     B74 : BB                  	phi	R11	
     774/     B75 : (MACRO)             	cpy1 R12,R11
     775/     B77 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     776/     B7A : (MACRO)             	Ccall _putx
     777/     B7D :                     ;							putx(((unsigned int) *this++)&255);
     778/     B7D : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     779/     B81 : (MACRO)             	incm R1,2
     780/     B83 : (MACRO)             	ldn2s R11,R11	;opt9xs
     781/     B8A : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     782/     B92 : (MACRO)             	cpy1 R12,R11
     783/     B94 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     784/     B97 : (MACRO)             	Ccall _putx
     785/     B9A :                     ;							putx(((unsigned int) *this)>>8);
     786/     B9A : (MACRO)             	ldn2 R11,R1	;opt9x
     787/     B9F : 9B                  	ghi	R11	;opt2
     788/     BA0 : AB                  	plo	R11
     789/     BA1 : F8 00               	ldi	0
     790/     BA3 : BB                  	phi	R11	
     791/     BA4 : (MACRO)             	cpy1 R12,R11
     792/     BA6 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     793/     BA9 : (MACRO)             	Ccall _putx
     794/     BAC :                     ;							putx(((unsigned int) *this++)&255);
     795/     BAC : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     796/     BB0 : (MACRO)             	incm R1,2
     797/     BB2 : (MACRO)             	ldn2s R11,R11	;opt9xs
     798/     BB9 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     799/     BC1 : (MACRO)             	cpy1 R12,R11
     800/     BC3 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     801/     BC6 : (MACRO)             	Ccall _putx
     802/     BC9 :                     ;						}
     803/     BC9 :                     L95:
     804/     BC9 :                     ;						argslot+=2;
     805/     BC9 : (MACRO)             	incm R0,2
     806/     BCB :                     ;						break;
     807/     BCB : C0 0C 1B            	lbr L81
     808/     BCE :                     L90:
     809/     BCE :                     L96:
     810/     BCE :                     ;					if (*ptr){ //as long as there's something there
     811/     BCE : (MACRO)             	ldn1 R11,R7	;opt14*
     812/     BD0 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     813/     BD3 : (MACRO)             	jzU2 R11,L97; EQ 0
     814/     BDB :                     ;						if (argslot&1) { //adjust alignment
     815/     BDB : (MACRO)             	alu2I R11,R0,1,ani,ani
     816/     BE3 :                     	;removed ?	cpy2 R11,R0
     817/     BE3 : (MACRO)             	jzU2 R11,L99; EQ 0
     818/     BEB :                     ;							this++;
     819/     BEB : (MACRO)             	incm R1,2
     820/     BED :                     ;							argslot++;
     821/     BED : (MACRO)             	incm R0,1
     822/     BEE :                     ;						}
     823/     BEE :                     L99:
     824/     BEE :                     ;						printflt(*(float *)this);//treats "this" as a pointer to float
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 17 - 11/23/2017 8:43:24


     825/     BEE : (MACRO)             	ld4 Rp1p2,'O',R1,0;INDIRF4(addr)
     826/     BFE : (MACRO)             	Ccall _printflt
     827/     C01 :                     ;						this+=2;				// and advances it 4 bytes
     828/     C01 : (MACRO)             	incm R1,4
     829/     C05 :                     ;						argslot+=2;
     830/     C05 : (MACRO)             	incm R0,2
     831/     C07 :                     ;						break;
     832/     C07 : C0 0C 1B            	lbr L81
     833/     C0A :                     L97:
     834/     C0A :                     L80:
     835/     C0A :                     ;					putc('%');putc(c);
     836/     C0A : (MACRO)             	ldaD R12,37; reg:acon
     837/     C10 : (MACRO)             	Ccall _putcser
     838/     C13 : (MACRO)             	cpy1 R12,R6
     839/     C15 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     840/     C18 : (MACRO)             	Ccall _putcser
     841/     C1B :                     ;			} //switch
     842/     C1B :                     L81:
     843/     C1B :                     ;		} //%
     844/     C1B :                     L78:
     845/     C1B :                     ;	} //while
     846/     C1B :                     L75:
     847/     C1B :                     ;    while(*ptr) {
     848/     C1B : (MACRO)             	ldn1 R11,R7;reg:  INDIRU1(indaddr)
     849/     C1D : (MACRO)             	jnzU1 R11,L74; NEI2(CVUI2(reg),con0)
     850/     C21 :                     ;} //prtf
     851/     C21 :                     L73:
     852/     C21 : (MACRO)             	release 4; release room for outgoing arguments
     853/     C25 : (MACRO)             	popf R7	;opt11.3
     854/     C2A : (MACRO)             	popm R6	;opt11.4
     855/     C2E : (MACRO)             	popm R1	;opt11.4
     856/     C32 : (MACRO)             	popl R0	;opt11.4
     857/     C36 : (MACRO)             	release 4; release room for local variables 
     858/     C3A : (MACRO)             	Cretn
     859/     C3B :                     
     860/     C3B :                     ;$$function end$$ _printf
     861/     C3B :                     ;$$function start$$ _exit
     862/     C3B :                     _exit:		;framesize=6
     863/     C3B : (MACRO)             	reserve 4
     864/     C3F : (MACRO)             	st2 R12,'O',sp,(6+1); flag1 
     865/     C4C :                     ;void exit(int code){
     866/     C4C :                     ;	printf("exit %d\n",code);
     867/     C4C : (MACRO)             	ldaD R12,L107; reg:acon
     868/     C52 : (MACRO)             	ld2 R13,'O',sp,(6+1) ;reg:INDIRI2(addr)
     869/     C5E : (MACRO)             	Ccall _printf
     870/     C61 :                     L108:
     871/     C61 :                     ;	while(1);
     872/     C61 :                     L109:
     873/     C61 : C0 0C 61            	lbr L108
     874/     C64 :                     ;}
     875/     C64 :                     L106:
     876/     C64 : (MACRO)             	release 4
     877/     C68 : (MACRO)             	Cretn
     878/     C69 :                     
     879/     C69 :                     ;$$function end$$ _exit
     880/     C69 :                     ;$$function start$$ _memcmp
     881/     C69 :                     _memcmp:		;framesize=10
     882/     C69 : (MACRO)             	pushr R0
     883/     C6D : (MACRO)             	pushr R1
     884/     C71 : (MACRO)             	pushr R6
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 18 - 11/23/2017 8:43:24


     885/     C75 : (MACRO)             	pushr R7
     886/     C79 : (MACRO)             	ld2 R7,'O',sp,(14+1) ;reg:INDIRU2(addr)
     887/     C85 :                     ;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
     888/     C85 :                     ;    int v = 0;
     889/     C85 : (MACRO)             	ld2z R6
     890/     C89 :                     ;    p1 = (unsigned char *)Ptr1;
     891/     C89 : (MACRO)             	cpy2 R1,R12 ;LOADP2(reg)
     892/     C8D :                     ;    p2 = (unsigned char *)Ptr2;
     893/     C8D : (MACRO)             	cpy2 R0,R13 ;LOADP2(reg)
     894/     C91 : C0 0C B2            	lbr L113
     895/     C94 :                     L112:
     896/     C94 :                     ;    while(Count-- > 0 && v == 0) {
     897/     C94 :                     ;        v = *(p1++) - *(p2++);
     898/     C94 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     899/     C98 : (MACRO)             	incm R1,1
     900/     C99 : (MACRO)             	cpy2 R10,R0 ;LOADP2(reg) ;opt1.1
     901/     C9D : (MACRO)             	incm R0,1
     902/     C9E : (MACRO)             	ldn1 R11,R11	;opt14*
     903/     CA0 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     904/     CA3 : (MACRO)             	ldn1 R10,R10	;opt14*
     905/     CA5 : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     906/     CA8 : (MACRO)             	alu2 R6,R11,R10,sm,smb
     907/     CB2 :                     ;    }
     908/     CB2 :                     L113:
     909/     CB2 :                     ;    while(Count-- > 0 && v == 0) {
     910/     CB2 : (MACRO)             	cpy2 R11,R7 ;LOADU2*(reg)
     911/     CB6 : (MACRO)             	cpy2 R7,R11	;SUBU2(reg,consm)
     912/     CBA : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
     913/     CBB : (MACRO)             	jzU2 R11,L115; EQ 0
     914/     CC3 : (MACRO)             	jzU2 R6,L112; EQ 0
     915/     CCB :                     L115:
     916/     CCB :                     ;    return v;
     917/     CCB : (MACRO)             	cpy2 R15,R6 ;LOADI2(reg)
     918/     CCF :                     L111:
     919/     CCF : (MACRO)             	popf R7	;opt11.3
     920/     CD4 : (MACRO)             	popm R6	;opt11.4
     921/     CD8 : (MACRO)             	popm R1	;opt11.4
     922/     CDC : (MACRO)             	popl R0	;opt11.4
     923/     CE0 : (MACRO)             	Cretn
     924/     CE1 :                     
     925/     CE1 :                     ;$$function end$$ _memcmp
     926/     CE1 :                     ;$$function start$$ _memcpy
     927/     CE1 :                     _memcpy:		;framesize=8
     928/     CE1 : (MACRO)             	pushr R1
     929/     CE5 : (MACRO)             	pushr R6
     930/     CE9 : (MACRO)             	pushr R7
     931/     CED : (MACRO)             	ld2 R7,'O',sp,(12+1) ;reg:INDIRU2(addr)
     932/     CF9 :                     ;void* memcpy(void* dest, const void* src, unsigned int count) {
     933/     CF9 :                     ;        char* dst8 = (char*)dest;
     934/     CF9 : (MACRO)             	cpy2 R6,R12 ;LOADP2(reg)
     935/     CFD :                     ;        char* src8 = (char*)src;
     936/     CFD : (MACRO)             	cpy2 R1,R13 ;LOADP2(reg)
     937/     D01 : C0 0D 12            	lbr L118
     938/     D04 :                     L117:
     939/     D04 :                     ;        while (count--) {
     940/     D04 :                     ;            *dst8++ = *src8++;
     941/     D04 : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
     942/     D08 : (MACRO)             	incm R6,1
     943/     D09 : (MACRO)             	cpy2 R10,R1 ;LOADP2(reg) ;opt1.1
     944/     D0D : (MACRO)             	incm R1,1
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 19 - 11/23/2017 8:43:24


     945/     D0E : (MACRO)             	ldn1 R10,R10;reg:  INDIRU1(indaddr)
     946/     D10 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     947/     D12 :                     ;        }
     948/     D12 :                     L118:
     949/     D12 :                     ;        while (count--) {
     950/     D12 : (MACRO)             	cpy2 R11,R7 ;LOADU2*(reg)
     951/     D16 : (MACRO)             	cpy2 R7,R11	;SUBU2(reg,consm)
     952/     D1A : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
     953/     D1B : (MACRO)             	jnzU2 R11,L117; NE 0 
     954/     D23 :                     ;        return dest;
     955/     D23 : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
     956/     D27 :                     L116:
     957/     D27 : (MACRO)             	popf R7	;opt11.3
     958/     D2C : (MACRO)             	popm R6	;opt11.4
     959/     D30 : (MACRO)             	popl R1	;opt11.4
     960/     D34 : (MACRO)             	Cretn
     961/     D35 :                     
     962/     D35 :                     ;$$function end$$ _memcpy
     963/     D35 :                     ;$$function start$$ _memset
     964/     D35 :                     _memset:		;framesize=6
     965/     D35 : (MACRO)             	pushr R6
     966/     D39 : (MACRO)             	pushr R7
     967/     D3D : (MACRO)             	ld2 R7,'O',sp,(10+1) ;reg:INDIRU2(addr)
     968/     D49 :                     ;{
     969/     D49 :                     ;    unsigned char* p=s;
     970/     D49 : (MACRO)             	cpy2 R6,R12 ;LOADP2(reg)
     971/     D4D : C0 0D 5B            	lbr L122
     972/     D50 :                     L121:
     973/     D50 :                     ;        *p++ = (unsigned char)c;
     974/     D50 : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
     975/     D54 : (MACRO)             	incm R6,1
     976/     D55 : (MACRO)             	cpy2 R10,R13 ;LOADU2*(reg)
     977/     D59 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     978/     D5B :                     L122:
     979/     D5B :                     ;    while(n--)
     980/     D5B : (MACRO)             	cpy2 R11,R7 ;LOADU2*(reg)
     981/     D5F : (MACRO)             	cpy2 R7,R11	;SUBU2(reg,consm)
     982/     D63 : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
     983/     D64 : (MACRO)             	jnzU2 R11,L121; NE 0 
     984/     D6C :                     ;    return s;
     985/     D6C : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
     986/     D70 :                     L120:
     987/     D70 : (MACRO)             	popf R7	;opt11.3
     988/     D75 : (MACRO)             	popl R6	;opt11.3
     989/     D79 : (MACRO)             	Cretn
     990/     D7A :                     
     991/     D7A :                     ;$$function end$$ _memset
     992/     D7A :                     ;$$function start$$ _nstdlibincluder
     993/     D7A :                     _nstdlibincluder:		;framesize=2
     994/     D7A :                     ;void nstdlibincluder(){
     995/     D7A :                     ;	asm("\tinclude nstdlib.inc\n"); //strcpy, strcmp
     996/     D7A :                     	include nstdlib.inc
(1)    1/     D7A :                     ;nstdlib.inc includes assembly versions of nstdlib routines strcpy, strcmp
(1)    2/     D7A :                     ;Oct 1 first test seems ok
(1)    3/     D7A :                     ;char * strcpy(char * to, const char *from)
(1)    4/     D7A :                     	align 64
(1)    5/     D80 :                     _strcpy:
(1)    6/     D80 :                     ;char *save = to; (to is R12, from is R13)
(1)    7/     D80 : 8C                  	glo R12	
(1)    8/     D81 : AF                  	plo R15
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(nstdlib.inc) - page 20 - 11/23/2017 8:43:25


(1)    9/     D82 : 9C                  	ghi R12
(1)   10/     D83 : BF                  	phi R15
(1)   11/     D84 :                     ;for (; (*to = *from) != 0; ++from, ++to);
(1)   12/     D84 : 4D                  __strcpy: lda R13
(1)   13/     D85 : 5C                  	str R12
(1)   14/     D86 : 1C                  	inc R12
(1)   15/     D87 : 3A 84               	bnz __strcpy
(1)   16/     D89 :                     ;return(save);
(1)   17/     D89 : (MACRO)             	cretn
(1)   18/     D8A :                     ;}
(1)   19/     D8A :                     
(1)   20/     D8A :                     
(1)   21/     D8A :                     ;int strcmp(const char *s1, const char *s2){  s1 will be R12, s2 R13
(1)   22/     D8A :                     _strcmp:	;entry point from C program
(1)   23/     D8A :                     ;  int ret = 0;
(1)   24/     D8A : (MACRO)             	ld2z	R15	;ret is R15
(1)   25/     D8E :                     ;  while (!(ret = *(unsigned char *) s1 - *(unsigned char *) s2) && *s2) ++s1, ++s2;
(1)   26/     D8E : 22                  	dec	sp	;make a work area
(1)   27/     D8F :                     __strcmplp:
(1)   28/     D8F : 4D                  	lda	R13	;get string 2 character
(1)   29/     D90 : 52                  	str	sp	;prep for compare
(1)   30/     D91 : 4C                  	lda	R12	;get string 1 character
(1)   31/     D92 : F7                  	sm		;subtract string 2 char from string 1
(1)   32/     D93 : 3A 9A               	bnz	__strcmpne ;strings not equal quit
(1)   33/     D95 :                     	
(1)   34/     D95 : 02                  	ldn	sp	;check string 2 character
(1)   35/     D96 : 3A 8F               	bnz	__strcmplp ;back for more if not done
(1)   36/     D98 : 12                  	inc	sp	;release the work area
(1)   37/     D99 : (MACRO)             	cretn		;back to caler with 0 in R15
(1)   38/     D9A :                     	
(1)   39/     D9A :                     __strcmpne:	;here I know they're not equal
(1)   40/     D9A : 12                  	inc	sp		;release the work area
(1)   41/     D9B : 33 9F               	bdf	__strcmpgt	;string1>string2
(1)   42/     D9D : 2F                  	dec	R15		;string 1<string 2, return -1
(1)   43/     D9E : (MACRO)             	cretn
(1)   44/     D9F :                     __strcmpgt:
(1)   45/     D9F : 1F                  	inc	R15		;string1>string2, return 1
(1)   46/     DA0 : (MACRO)             	cretn
(1)   47/     DA1 :                     
     997/     DA1 :                     ;}
     998/     DA1 :                     L124:
     999/     DA1 : (MACRO)             	Cretn
    1000/     DA2 :                     
    1001/     DA2 :                     ;$$function end$$ _nstdlibincluder
    1002/     DA2 :                     L107:
    1003/     DA2 : 65                  	db 101
    1004/     DA3 : 78                  	db 120
    1005/     DA4 : 69                  	db 105
    1006/     DA5 : 74                  	db 116
    1007/     DA6 : 20                  	db 32
    1008/     DA7 : 25                  	db 37
    1009/     DA8 : 64                  	db 100
    1010/     DA9 : 0A                  	db 10
    1011/     DAA : 00                  	db 0
    1012/     DAB :                     	align 4
    1013/     DAC :                     L42:
    1014/     DAC : BF 80 00 00         	dd 0xbf800000
    1015/     DB0 :                     	align 4
    1016/     DB0 :                     L41:
    1017/     DB0 : 00 00 00 00         	dd 0x0
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 21 - 11/23/2017 8:43:25


    1018/     DB4 :                     L3:
    1019/     DB4 : 55                  	db 85
    1020/     DB5 : 55                  	db 85
    1021/     DB6 : 55                  	db 85
    1022/     DB7 : 55                  	db 85
    1023/     DB8 : 55                  	db 85
    1024/     DB9 : 55                  	db 85
    1025/     DBA : 55                  	db 85
    1026/     DBB : 55                  	db 85
    1027/     DBC : 00                  	db 0
    1028/     DBD :                     	include lcc1802epiloNW.inc
(1)    1/     DBD :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/     DBD :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/     DBD :                     ;this is the version published with the lcc1802121229 release
(1)    4/     DBD :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/     DBD :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/     DBD :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/     DBD :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/     DBD :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/     DBD :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/     DBD :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/     DBD :                     ;feb 27 changed stack to start at 7fff
(1)   12/     DBD :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/     DBD :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/     DBD :                     ;april 4 adding digit count argument to dubdabx
(1)   15/     DBD :                     ;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
(1)   16/     DBD :                     ;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
(1)   17/     DBD :                     ;16-09-20 allow stack relocation 
(1)   18/     DBD :                     ;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
(1)   19/     DBD :                     ;17-03-07 adjusting stack offset for 1805/6 stack discipline
(1)   20/     DBD :                     ;17-03-13 protecting work areas in divi2,divi4 routines from 1806 SCAL
(1)   21/     DBD :                     ;17-03-15 onems compensates for reduced subroutine overhead in 1806
(1)   22/     DBD :                     ;17-04-09 don't include call/return for 1806
(1)   23/     DBD :                     ;17-10-17 SCRT routines changed to clean stack model i.e. push is stxd stxd, pop is inc lda inc ldn
(1)   24/     DBD :                     ;17-10-19 using CPUSPEED instead of LCC1802CPUSPEED, also STACKLOC instead of LCCSTACKLOC
(1)   25/     DBD :                     ;17-10-23 extending work area protection from 10-13 above for 1802 as well as 1805
(1)   26/     DBD : =EH                 rwork	equ	memAddr	;work register
(1)   27/     DBD :                     lcc1802init:	
(1)   28/     DBD : =>TRUE                IF    MOMCPU<>$1805		;for 1806 use SCAL 
(1)   29/     DBD : (MACRO)             	ldiReg	RCALL,_call
(1)   30/     DC3 : (MACRO)             	ldiReg	RRET,_return
(1)   31/     DC9 : =>FALSE               ELSE
(1)   32/     DC9 :                     	ldiReg	RCALL,$$_die; _call
(1)   33/     DC9 :                     	ldiReg	RRET,$$_die; _return
(1)   34/     DC9 : [28]                  ENDIF
(1)   35/     DC9 : =>DEFINED             IFNDEF  STACKLOC		;wjr 16-09-20 allow stack relocation
(1)   36/     DC9 :                     	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1 as default
(1)   37/     DC9 : =>TRUE                ELSEIF				;wjr 16-09-20
(1)   38/     DC9 : (MACRO)             	ldiReg	SP,STACKLOC	;wjr 16-09-20 start stack as specified
(1)   39/     DCF : [35]                  ENDIF				;wjr 16-09-20
(1)   40/     DCF : E2                  	sex	SP
(1)   41/     DD0 : (MACRO)             	ldiReg	RPC,$$_00000
(1)   42/     DD6 : D3                  	sep	RPC
(1)   43/     DD7 :                     $$_00000:
(1)   44/     DD7 : (MACRO)             	Ccall _main	;call the main routine
(1)   45/     DDA : C0 0D DA            $$_die:	lbr	$$_die		;loop here when main returns
(1)   46/     DDD : DE AD               	db	0xde,0xad
(1)   47/     DDF :                     
(1)   48/     DDF :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   49/     DDF :                     _setqOn:
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(lcc1802epiloNW.inc) - page 22 - 11/23/2017 8:43:25


(1)   50/     DDF : 7B                  	seq
(1)   51/     DE0 : (MACRO)             	Cretn
(1)   52/     DE1 :                     _setqOff:
(1)   53/     DE1 : 7A                  	req
(1)   54/     DE2 : (MACRO)             	Cretn
(1)   55/     DE3 : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math
(1)   56/     DE3 :                     _modU2:	;16 bit unsigned remainder
(1)   57/     DE3 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   58/     DE3 : (MACRO)                 Ccall _divU2
(1)   59/     DE6 : 8C                      glo regArg1
(1)   60/     DE7 : AF                      plo retVal
(1)   61/     DE8 : 9C                      ghi regArg1
(1)   62/     DE9 : BF                      phi retVal
(1)   63/     DEA : (MACRO)                 Cretn
(1)   64/     DEB :                         
(1)   65/     DEB :                     _modI2:	;16 bit signed remainder
(1)   66/     DEB :                     	; just calls the 16 bit division then puts remainder into return value
(1)   67/     DEB : (MACRO)                 Ccall _divI2
(1)   68/     DEE : 8C                      glo regArg1
(1)   69/     DEF : AF                      plo retVal
(1)   70/     DF0 : 9C                      ghi regArg1
(1)   71/     DF1 : BF                      phi retVal
(1)   72/     DF2 : (MACRO)                 Cretn
(1)   73/     DF3 : [55]                 ENDIF
(1)   74/     DF3 :                     _out4:	
(1)   75/     DF3 : 8C                  	glo	regArg1
(1)   76/     DF4 : 22                  	dec	sp
(1)   77/     DF5 : 52                  	str	sp
(1)   78/     DF6 : 64                  	out	4
(1)   79/     DF7 : (MACRO)             	Cretn
(1)   80/     DF8 :                     
(1)   81/     DF8 :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   82/     DF8 : =>TRUE                if MOMCPU<>$1805		;for 1806 use SCAL
(1)   83/     DF8 :                     	align 16
(1)   84/     E00 :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)   85/     E00 : D3                  	sep     R3 ;go to subroutine
(1)   86/     E01 : E2                  _call	sex	SP ;make sure X=SP
(1)   87/     E02 : 86                  	glo	retAddr ;save previous return pointer on stack
(1)   88/     E03 : 73                  	stxd
(1)   89/     E04 : 96                  	ghi	retAddr
(1)   90/     E05 : 73                  	stxd	
(1)   91/     E06 : 83                  	glo	RPC ;copy old PC to retAddr
(1)   92/     E07 : A6                  	plo	retAddr
(1)   93/     E08 : 93                  	ghi	RPC
(1)   94/     E09 : B6                  	phi	retAddr
(1)   95/     E0A : 46                  	lda	retAddr ;pick up subroutine address into RPC
(1)   96/     E0B : B3                  	phi	RPC
(1)   97/     E0C : 46                  	lda	retAddr
(1)   98/     E0D : A3                  	plo	RPC
(1)   99/     E0E : 30 00               	br	_call-1
(1)  100/     E10 :                     
(1)  101/     E10 :                     ;Standard subroutine return 
(1)  102/     E10 :                     	align 16
(1)  103/     E10 : D3                  	sep	RPC	;return to the original program
(1)  104/     E11 : 86                  _return	glo	retAddr	;transfer the current return address to RPC
(1)  105/     E12 : A3                  	plo	RPC
(1)  106/     E13 : 96                  	ghi	retAddr
(1)  107/     E14 : B3                  	phi	RPC
(1)  108/     E15 : 12                  	inc 	SP
(1)  109/     E16 : 42                  	lda	SP	;pick up old return address
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(lcc1802epiloNW.inc) - page 23 - 11/23/2017 8:43:25


(1)  110/     E17 : B6                  	phi	retAddr
(1)  111/     E18 : 02                  	ldn	SP
(1)  112/     E19 : A6                  	plo	retAddr
(1)  113/     E1A : 30 10               	br	_return-1
(1)  114/     E1C : [82]                 ENDIF
(1)  115/     E1C :                     	align 8
(1)  116/     E20 :                     _oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
(1)  117/     E20 :                     ;subroutine overhead soaks up 27 instruction time.
(1)  118/     E20 :                     ;each loop is 2 instruction times
(1)  119/     E20 :                     ;so the number of loops needed is 
(1)  120/     E20 :                     ;CPU speed/16000 less the 27 all divide by two
(1)  121/     E20 : =>DEFINED           	IFNDEF	CPUSPEED
(1)  122/     E20 :                     CPUSPEED EQU 1600000	;1.6MHZ default
(1)  123/     E20 : [121]               	ENDIF
(1)  124/     E20 : =>FALSE              if MOMCPU=$1805		;for 1806 SCAL
(1)  125/     E20 :                     SUBOVHD  EQU 14		;1806 SCAL/SRET subroutine overhead
(1)  126/     E20 : =>TRUE               else
(1)  127/     E20 : =1BH                SUBOVHD  EQU 27		;default SCRT subroutine overhead
(1)  128/     E20 : [124]                endif 
(1)  129/     E20 : =>TRUE                IF CPUSPEED<=8000000
(1)  130/     E20 : F8 11               	ldi	(CPUSPEED/1000/16-SUBOVHD)/2
(1)  131/     E22 : FF 01               $$mslp:	smi	1
(1)  132/     E24 : 3A 22               	bnz	$$mslp
(1)  133/     E26 : =>FALSE               ELSE
(1)  134/     E26 :                     	ldi	(CPUSPEED/1000/16-SUBOVHD)/4
(1)  135/     E26 :                     $$mslf:	smi	1
(1)  136/     E26 :                     	sex	2
(1)  137/     E26 :                     	sex	2
(1)  138/     E26 :                     	bnz	$$mslf
(1)  139/     E26 : [129]                 ENDIF
(1)  140/     E26 : (MACRO)             	Cretn
(1)  141/     E27 :                     
(1)  142/     E27 :                     
(1)  143/     E27 : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math	
(1)  144/     E27 :                     	align 256
(1)  145/     F00 :                     ;16 bit right shifting multiply which is faster for smaller operands
(1)  146/     F00 :                     ; credit to http://map.grauw.nl/articles/mult_div_shifts.php#lrmultr
(1)  147/     F00 :                     _mulU2:		;retval(product)=regarg1(multiplicand)*regarg2(multiplier)
(1)  148/     F00 : (MACRO)             	ld2z retval
(1)  149/     F04 :                     $$mulrlp:
(1)  150/     F04 : (MACRO)             	shru2 regarg2
(1)  151/     F0A : 3B 16               	bnf $$mulrnoadd
(1)  152/     F0C :                     ;	bottom bit of multiplier is one so add multiplicand to product
(1)  153/     F0C : (MACRO)             	alu2 retval,retval,regarg1,add,adc
(1)  154/     F16 :                     $$mulrnoadd:
(1)  155/     F16 : 9D                  	ghi regarg2	;check for all bits of multiplier shifted out
(1)  156/     F17 : 3A 1C               	bnz $$mulrshft	;nope, continue
(1)  157/     F19 : 8D                  	glo regarg2	;check bottom byte
(1)  158/     F1A : 32 24               	bz $$mulrdone
(1)  159/     F1C :                     $$mulrshft:
(1)  160/     F1C : (MACRO)             	shl2 regarg1	;shift multiplicand left 1
(1)  161/     F22 : 30 04               	br $$mulrlp
(1)  162/     F24 :                     $$mulrdone:		;here the product is in retval
(1)  163/     F24 : (MACRO)             	cretn
(1)  164/     F25 :                     
(1)  165/     F25 :                     ;this is a divisor shifting algorithm which is faster for smaller operands
(1)  166/     F25 :                     ;credit to http://research.microsoft.com/pubs/70645/tr-2008-141.pdf
(1)  167/     F25 :                     ;changed oct 12 to save R10 & 1/2 R11 on stack
(1)  168/     F25 :                     _divu2: ;retval=regarg1(x or dividend)/regarg2(y or divisor)
(1)  169/     F25 :                     	;uses R14(rwork) to hold original divisor y0, 
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(lcc1802epiloNW.inc) - page 24 - 11/23/2017 8:43:25


(1)  170/     F25 :                     	;regarg1 to hold develop remainder, 
(1)  171/     F25 :                     	;R10 to hold working dividend R11.0 as a temp
(1)  172/     F25 :                     testsub: macro reg1,reg2	;test subtraction of reg2 from reg1
(1)  173/     F25 :                     				;result in D, rwork.hi, DF
(1)  174/     F25 :                     	glo reg2
(1)  175/     F25 :                     	str sp
(1)  176/     F25 :                     	glo reg1
(1)  177/     F25 :                     	sm
(1)  178/     F25 :                     	plo R11
(1)  179/     F25 :                     	ghi reg2
(1)  180/     F25 :                     	str sp
(1)  181/     F25 :                     	ghi reg1
(1)  182/     F25 :                     	smb
(1)  183/     F25 :                     	endm
(1)  184/     F25 :                     	
(1)  185/     F25 :                     ;	pushf R10	;save R10 & leave stack down 1
(1)  186/     F25 : (MACRO)             	pushr R10	;default push leaves stack clean
(1)  187/     F29 : 8B                  	glo R11		;and bottom
(1)  188/     F2A : 73                  	stxd		;of R11 - leaves stack clear of work area
(1)  189/     F2B : (MACRO)             	cpy2 R10,regarg1
(1)  190/     F2F : (MACRO)             	ld2z retval	;quotient
(1)  191/     F33 : (MACRO)             	cpy2 rwork,regarg2
(1)  192/     F37 :                     	
(1)  193/     F37 : (MACRO)             	testsub R10,regarg2
(1)  194/     F40 : 3B 5B               	bnf $$computequot	;DF=0 means it didn't fit
(1)  195/     F42 : BA                  	phi R10	;R10=R10-regarg2
(1)  196/     F43 : 8B                  	glo R11
(1)  197/     F44 : AA                  	plo R10
(1)  198/     F45 :                     	
(1)  199/     F45 :                     $$again:	;this is the divisor doubling phase
(1)  200/     F45 : (MACRO)              	testsub R10,regarg2
(1)  201/     F4E : 3B 5B                	bnf $$computequot	;df=0 means it didn't fit
(1)  202/     F50 : BA                  	phi R10	;R10=R10-regarg2
(1)  203/     F51 : 8B                  	glo R11
(1)  204/     F52 : AA                  	plo R10 	
(1)  205/     F53 : (MACRO)              	shl2 regarg2	;y=y+y
(1)  206/     F59 : 30 45                	br $$again
(1)  207/     F5B :                      	
(1)  208/     F5B :                      $$computequot:	;here we're computing the quotient
(1)  209/     F5B : (MACRO)              	testsub regarg1,regarg2
(1)  210/     F64 : 3B 6A                	bnf $$testexit
(1)  211/     F66 : BC                   	phi regarg1		;complete the subtraction
(1)  212/     F67 : 8B                   	glo R11
(1)  213/     F68 : AC                   	plo regarg1
(1)  214/     F69 : 1F                   	inc retval
(1)  215/     F6A :                      $$testexit:
(1)  216/     F6A : 9E                   	ghi rwork
(1)  217/     F6B : F7                   	sm	;top of regarg2 is still on stack
(1)  218/     F6C : 3A 74                	bnz $$ney0y
(1)  219/     F6E : 8D                   	glo regarg2
(1)  220/     F6F : 52                   	str sp
(1)  221/     F70 : 8E                   	glo rwork
(1)  222/     F71 : F7                   	sm	;test low order bytes
(1)  223/     F72 : 32 82                	bz	$$out	;if = we're done
(1)  224/     F74 :                      $$ney0y:
(1)  225/     F74 : (MACRO)              	shl2 retval	;double quotient
(1)  226/     F7A : (MACRO)              	shrU2 regarg2	;halve divisor
(1)  227/     F80 : 30 5B                	br $$computequot	;continue
(1)  228/     F82 :                      $$out:
(1)  229/     F82 :                      ;here the quotient is in retval, remainder in regarg1
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(lcc1802epiloNW.inc) - page 25 - 11/23/2017 8:43:25


(1)  230/     F82 : 12                    	inc sp	;release work area
(1)  231/     F83 : 02                  	ldn sp	;recover
(1)  232/     F84 : AB                  	plo R11	;bottom byte of R11
(1)  233/     F85 : (MACRO)             	popr R10 ;and all of R10
(1)  234/     F8A : (MACRO)             	cretn	;and we're done
(1)  235/     F8B :                     
(1)  236/     F8B :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  237/     F8B :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  238/     F8B :                     _divI2:
(1)  239/     F8B : 22                      dec	sp	;leave a work area available
(1)  240/     F8C : 9C                      ghi regArg1
(1)  241/     F8D : 52                      str sp	;save the sign of the 1st arg
(1)  242/     F8E : FE                      shl
(1)  243/     F8F : 3B 9A                   bnf $$pos1	;if the 1st arg is -v
(1)  244/     F91 : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
(1)  245/     F9A :                     $$pos1: ;1st is now +v, check 2nd
(1)  246/     F9A : 9D                      ghi regArg2
(1)  247/     F9B : F3                      xor	
(1)  248/     F9C : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  249/     F9D : 9D                      ghi regArg2
(1)  250/     F9E : FE                      shl
(1)  251/     F9F : 3B AA                   bnf $$pos2	;if the 2nd arg is -v
(1)  252/     FA1 : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  253/     FAA :                     $$pos2: ; both args now +v
(1)  254/     FAA : 22                      dec sp	;protect workarea on the 1802
(1)  255/     FAB : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  256/     FAE : 12                      inc sp	;recover work area
(1)  257/     FAF :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  258/     FAF : 42                      lda	sp ;get back the sign bits and restore SP
(1)  259/     FB0 : FE                      shl
(1)  260/     FB1 : 3B BC                   bnf $$done ;if the signs were different
(1)  261/     FB3 : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  262/     FBC :                     $$done:
(1)  263/     FBC : (MACRO)                 Cretn ;and we're done - I hope!
(1)  264/     FBD : [143]                ENDIF
(1)  265/     FBD : =>UNDEFINED          IFNDEF  LCCNOLONG		;wjr 17-04-09 disable 32 bit math
(1)  266/     FBD :                     	align 256    ;32 bit operations follow
(1)  267/    1000 :                     _divu4:
(1)  268/    1000 :                     ;This is an unsigned 32 bit restoring division
(1)  269/    1000 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  270/    1000 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  271/    1000 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  272/    1000 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  273/    1000 :                     
(1)  274/    1000 : F8 20               	ldi 32		;set loop count
(1)  275/    1002 : AE                  	plo memaddr	;in temp register
(1)  276/    1003 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  277/    100F :                     $$loop:
(1)  278/    100F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  279/    101B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  280/    1027 :                     
(1)  281/    1027 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  282/    103D :                     
(1)  283/    103D : FA 80               	ani 0x80	;check the top bit
(1)  284/    103F : 32 5D               	bz $$norestore	;if it's 0
(1)  285/    1041 : 89                  		glo RL8
(1)  286/    1042 : FA FE               		ani 0xfe	;turn off the bottom bit
(1)  287/    1044 : A9                  		plo RL8
(1)  288/    1045 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  289/    105B : 30 61               	br $$endlp 	;else
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(lcc1802epiloNW.inc) - page 26 - 11/23/2017 8:43:25


(1)  290/    105D :                     $$norestore:
(1)  291/    105D : 89                  		glo RL8
(1)  292/    105E : F9 01               		ori 1	;turn on the bottom bit
(1)  293/    1060 : A9                  		plo RL8
(1)  294/    1061 :                     	;end if
(1)  295/    1061 :                     $$endlp:
(1)  296/    1061 : 2E                  	dec memaddr	;check the cycle count
(1)  297/    1062 : 8E                  	glo memaddr
(1)  298/    1063 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  299/    1065 :                     	
(1)  300/    1065 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  301/    1066 :                     		
(1)  302/    1066 :                     
(1)  303/    1066 :                     _mulu4:
(1)  304/    1066 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  305/    1066 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  306/    1066 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  307/    1066 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  308/    1066 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  309/    1066 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  310/    1066 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  311/    1066 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  312/    1066 :                     	;for 10 we subtract and shift
(1)  313/    1066 :                     	;for 00 and 11 we just shift
(1)  314/    1066 :                     
(1)  315/    1066 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  316/    1072 : F8 20                   ldi 32
(1)  317/    1074 : AE                      plo memaddr		;cycle count
(1)  318/    1075 : FC 00                   adi 0		;clear df
(1)  319/    1077 :                     $$mloop:
(1)  320/    1077 : 89                      glo RL8
(1)  321/    1078 : FA 01                   ani 1		;isolate bottom bit of result
(1)  322/    107A : 3B 96                   bnf	$$check_sub	;
(1)  323/    107C : 3A AE                   bnz	$$shift		;that would be the 11 case
(1)  324/    107E :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  325/    107E : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  326/    1094 : 30 AE                   br $$shift
(1)  327/    1096 :                     $$check_sub:
(1)  328/    1096 : 32 AE                   bz $$shift	;that would be the 00 case
(1)  329/    1098 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  330/    1098 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  331/    10AE :                     $$shift:
(1)  332/    10AE : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  333/    10BC : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  334/    10C8 :                     
(1)  335/    10C8 : 2E                      dec memaddr		;cycle count
(1)  336/    10C9 : 8E                      glo memaddr
(1)  337/    10CA : 3A 77                   bnz $$mloop		;repeat cycle once for each bit position
(1)  338/    10CC :                         
(1)  339/    10CC : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  340/    10CD :                     
(1)  341/    10CD :                     	align 256
(1)  342/    1100 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  343/    1100 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  344/    1100 :                     _divI4:
(1)  345/    1100 : 22                      dec	sp	;leave a work area available
(1)  346/    1101 : 98                      ghi RL8-1	;get the top of the dividend
(1)  347/    1102 : 52                      str sp	;save the sign of the 1st arg
(1)  348/    1103 : FE                      shl
(1)  349/    1104 : 3B 26                   bnf $$pos1	;if the 1st arg is -v
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(lcc1802epiloNW.inc) - page 27 - 11/23/2017 8:43:25


(1)  350/    1106 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  351/    1126 :                     $$pos1: ;1st is now +v, check 2nd
(1)  352/    1126 : 9A                      ghi RL10-1
(1)  353/    1127 : F3                      xor	
(1)  354/    1128 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  355/    1129 : 9A                      ghi RL10-1
(1)  356/    112A : FE                      shl
(1)  357/    112B : 3B 4D                   bnf $$pos2	;if the 2nd arg is -v
(1)  358/    112D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  359/    114D :                     $$pos2: ; both args now +v
(1)  360/    114D : 22                      dec sp	;protect workarea on the 1802
(1)  361/    114E : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  362/    1151 : 12                      inc sp	;recover work area
(1)  363/    1152 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  364/    1152 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  365/    1153 : FE                      shl
(1)  366/    1154 : 3B 76                   bnf $$done ;if the signs were different
(1)  367/    1156 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  368/    1176 :                     $$done:
(1)  369/    1176 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  370/    1177 : [265]                ENDIF
(1)  371/    1177 : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math
(1)  372/    1177 :                     _dubdabx:	
(1)  373/    1177 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  374/    1177 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  375/    1177 :                     ;long interger is passed in rp1p2
(1)  376/    1177 :                     ;buffer pointer is passed at sp+2+4**+1 for 1806
(1)  377/    1177 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
(1)  378/    1177 :                     ;r8-11 are used as temps
(1)  379/    1177 :                     ;r8 is the working pointer
(1)  380/    1177 :                     ;r15.0 is bit count(32) and the return value register
(1)  381/    1177 :                     ;r9.0 is digit count
(1)  382/    1177 :                     ;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
(1)  383/    1177 : (MACRO)             	ld2 r8,'O',sp,(2+4+1); pick up the buffer pointer
(1)  384/    1183 : (MACRO)             	ld2 r10,'O',sp,(2+4+2+1); pick up the number of digits wanted
(1)  385/    118F : (MACRO)             	cpy2 r15,r8 ;save address for now
(1)  386/    1193 : F8 0B               	ldi 11	;digit count+1 for trailing 0
(1)  387/    1195 : A9                  	plo r9
(1)  388/    1196 :                     $$clrlp:	;clear the passed buffer
(1)  389/    1196 : F8 00               	ldi 0	
(1)  390/    1198 : 58                  	str r8	;clear a byte
(1)  391/    1199 : 18                  	inc r8
(1)  392/    119A : 29                  	dec r9
(1)  393/    119B : 89                  	glo r9	;check the count
(1)  394/    119C : 3A 96               	bnz $$clrlp ;back for more
(1)  395/    119E : (MACRO)             	cpy2 r8,r15 ;get the address back
(1)  396/    11A2 :                     
(1)  397/    11A2 : F8 20               	ldi 32	;bit count
(1)  398/    11A4 : AF                  	plo r15
(1)  399/    11A5 :                     ;now i'm going to spin off any leading 0's in the binary number
(1)  400/    11A5 :                     $$cktop:
(1)  401/    11A5 : 9C                  	ghi rp1p2-1	;get the top bit of the number
(1)  402/    11A6 : FE                  	shl		;check for a 1
(1)  403/    11A7 : 33 BA               	bdf $$bitloop	;move on if we have one
(1)  404/    11A9 : (MACRO)             	shl4 rp1p2	;shift the input number
(1)  405/    11B5 : 2F                  	dec r15		;reduce the number of times to shift
(1)  406/    11B6 : 8F                  	glo r15
(1)  407/    11B7 : 3A A5               	bnz $$cktop	;
(1)  408/    11B9 : 1F                  	inc r15		;our whole number was 0 but force at least one pass
(1)  409/    11BA :                     $$bitloop:
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(lcc1802epiloNW.inc) - page 28 - 11/23/2017 8:43:25


(1)  410/    11BA : F8 0A               	ldi 10	;digit count
(1)  411/    11BC : A9                  	plo r9
(1)  412/    11BD :                     $$dcklp:
(1)  413/    11BD : 08                  	ldn r8 	;pick up a digit
(1)  414/    11BE : FF 05               	smi 5	;see if it's greater than 4
(1)  415/    11C0 : 3B C5               	bnf $$dnoadd ;if not, bypass add
(1)  416/    11C2 : FC 08               	adi 0x08	;add the 5 black and 3 more
(1)  417/    11C4 : 58                  	str r8	;put it back
(1)  418/    11C5 :                     $$dnoadd:
(1)  419/    11C5 : 18                  	inc r8
(1)  420/    11C6 : 29                  	dec r9	;decrement digit count
(1)  421/    11C7 : 89                  	glo r9
(1)  422/    11C8 : 3A BD               	bnz $$dcklp ;and back for next digit
(1)  423/    11CA :                     	
(1)  424/    11CA : (MACRO)             	shl4 rp1p2 ;shift the input number
(1)  425/    11D6 :                     	
(1)  426/    11D6 : F8 0A               	ldi 10	;load the digit count again
(1)  427/    11D8 : A9                  	plo r9
(1)  428/    11D9 :                     ;r8 is now just past the units location and ready to walk back
(1)  429/    11D9 :                     $$dshlp:
(1)  430/    11D9 : 28                  	dec r8	;walk back from 0's position
(1)  431/    11DA : 08                  	ldn r8	;get the digit back
(1)  432/    11DB : 7E                  	shlc	;continue the shift
(1)  433/    11DC : BF                  	phi r15 ;save it for the carry test
(1)  434/    11DD : FA 0F               	ani 0x0f ;clear the 10 bit
(1)  435/    11DF : 58                  	str r8	;put the digit back
(1)  436/    11E0 : 9F                  	ghi r15	;now test for carry
(1)  437/    11E1 : FF 10               	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  438/    11E3 : 29                  	dec r9	;decrement the digit count
(1)  439/    11E4 : 89                  	glo r9
(1)  440/    11E5 : 3A D9               	bnz $$dshlp ;back for more if needed
(1)  441/    11E7 :                     	
(1)  442/    11E7 : 2F                  	dec r15
(1)  443/    11E8 : 8F                  	glo r15
(1)  444/    11E9 : 3A BA               	bnz $$bitloop
(1)  445/    11EB :                     	
(1)  446/    11EB : (MACRO)             	cpy2 r15,r8	;save the starting location of the digits
(1)  447/    11EF : F8 0A               	ldi 10		;digit count again
(1)  448/    11F1 : A9                  	plo r9
(1)  449/    11F2 :                     $$upnxt:
(1)  450/    11F2 : 08                  	ldn r8		;get digit
(1)  451/    11F3 : F9 30               	ori 0x30	;make ascii
(1)  452/    11F5 : 58                  	str r8		;put it back
(1)  453/    11F6 : 18                  	inc r8		;next digit
(1)  454/    11F7 : 29                  	dec r9		;counter
(1)  455/    11F8 : 89                  	glo r9
(1)  456/    11F9 : 3A F2               	bnz $$upnxt	;upgrade all 10 spots
(1)  457/    11FB : (MACRO)             	ldaX memaddr,sp,(2+4+2+1+1)	;point to lsb of desired digit count
(1)  458/    1203 : EE                  	sex memaddr	;set up
(1)  459/    1204 : F8 0A               	ldi 10		;max number of 0's to skip
(1)  460/    1206 : F7                  	sm		;desired number of digits to skip
(1)  461/    1207 : E2                  	sex sp		;reset index register
(1)  462/    1208 : A9                  	plo r9		;number of leading 0's to skip
(1)  463/    1209 :                     $$cknext:
(1)  464/    1209 : 0F                  	ldn r15		;check digit
(1)  465/    120A : FF 30               	smi 0x30	;for '0'
(1)  466/    120C : 3A 13               	bnz $$done
(1)  467/    120E : 1F                  	inc r15		;next digit
(1)  468/    120F : 29                  	dec r9		;reduce count
(1)  469/    1210 : 89                  	glo r9
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(lcc1802epiloNW.inc) - page 29 - 11/23/2017 8:43:25


(1)  470/    1211 : 3A 09               	bnz $$cknext
(1)  471/    1213 :                     $$done:
(1)  472/    1213 : (MACRO)             	cretn
(1)  473/    1214 : [371]                ENDIF	
(1)  474/    1214 : =>UNDEFINED          IFNDEF  LCCNOLONG		;wjr 17-04-09 disable 32 bit math	
(1)  475/    1214 :                     _modU4:	;32 bit unsigned remainder
(1)  476/    1214 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  477/    1214 : (MACRO)                 Ccall _divU4
(1)  478/    1217 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  479/    121F : (MACRO)                 Cretn
(1)  480/    1220 :                         
(1)  481/    1220 :                     _modI4:	;32 bit signed remainder
(1)  482/    1220 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  483/    1220 : (MACRO)                 Ccall _divI4
(1)  484/    1223 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  485/    122B : (MACRO)                 Cretn
(1)  486/    122C : [474]                ENDIF	
(1)  487/    122C :                     
    1029/    122C :                     	include LCC1802fp.inc
(1)    1/    122C :                     ;17-03-06 changing sep rret to cretn, sep rcall to ccall
(1)    2/    122C :                     ;from http://www.elf-emulation.com/software/fp.asm - thanks to mike Reilley
(1)    3/    122C :                     ;maybe originally from RCA
(1)    4/    122C :                     ;these routines use ALL the registers from 6-15!
(1)    5/    122C :                     ;8-15 were more or less available to start with
(1)    6/    122C :                     ;it saves 6 when it uses it
(1)    7/    122C :                     ;I save 7 on entry and restore on exit
(1)    8/    122C :                     ;to keep my sanity I renamed some register equates where I was changing them e.g. F7 used to be RB
(1)    9/    122C : =BH                 FB	equ	11	;was R9
(1)   10/    122C : =9H                 F9	equ	9	;was R7
(1)   11/    122C : =7H                 F7	equ	7	;was RB
(1)   12/    122C :                     ;April 1 added code to fp_add to restore resgisters when returning a 0 - around add_nz:
(1)   13/    122C :                     ; *** Convert signed long to float
(1)   14/    122C :                     ; *** RL8-1:RL8 is the number to convert(8:9)
(1)   15/    122C :                     ; *** result in same register
(1)   16/    122C :                     ; *** uses memaddr.1 for sign, .0 for shift count/exponent
(1)   17/    122C :                     	align 256
(1)   18/    1300 : F8 00               cvif4:	ldi	0
(1)   19/    1302 : BE                  	phi	memaddr	;sign
(1)   20/    1303 : F8 96               	ldi	150	;150 is  the 127 exponent bias plus the 23 required to shift a long 1 to bit 23
(1)   21/    1305 : AE                  	plo	memaddr	;
(1)   22/    1306 : 98                  	ghi	RL8-1	;get sign and bits 7-1 of exponent
(1)   23/    1307 : 32 30               	bz	$$nxt	;keep testing for 0
(1)   24/    1309 : FE                  	shl		;sign bit to df
(1)   25/    130A : 3B 39               	bnf	$$sgnpos ;number is >0
(1)   26/    130C : 76                  	shrc		;shift it back so we know byte is non-zerro
(1)   27/    130D : BE                  	phi	memaddr	;save it
(1)   28/    130E : (MACRO)             	negi4	RL8,RL8	;flip the number
(1)   29/    132E : 30 39               	br	$$sgnpos ;go handle positive long
(1)   30/    1330 : 88                  $$nxt:	glo	RL8-1	;next byte
(1)   31/    1331 : 3A 39               	bnz	$$sgnpos ;sign is positive, number is not 0
(1)   32/    1333 : 99                  	ghi	RL8	;next byte
(1)   33/    1334 : 3A 39               	bnz	$$sgnpos ;sign is positive, number is not 0
(1)   34/    1336 : 89                  	glo	RL8	;last byte
(1)   35/    1337 : 32 6F               	bz	$$done	;the whole thing is zero so we're done
(1)   36/    1339 : 98                  $$sgnpos: ghi	RL8-1	;top byte - begin shifting right to clear it
(1)   37/    133A : 32 4B               	bz	$$shl	;if it's zero we're done right shifting
(1)   38/    133C : 1E                  	inc	memaddr	;increase exponent 1 for each right shift
(1)   39/    133D : (MACRO)             	shru4	RL8
(1)   40/    1349 : 30 39               	br	$$sgnpos
(1)   41/    134B : 88                  $$shl:	glo	RL8-1	;check bit 23
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 30 - 11/23/2017 8:43:25


(1)   42/    134C : FA 80               	ani	0x80	;isolate it
(1)   43/    134E : 3A 5F               	bnz	$$shdn	;if it's on we're done here
(1)   44/    1350 : 2E                  	dec	memaddr	;decrease exponent 1 for each left shift
(1)   45/    1351 : (MACRO)             	shl4	RL8	;shift mantissa left one
(1)   46/    135D : 30 4B               	br	$$shl
(1)   47/    135F : 8E                  $$shdn:	glo	memaddr	;get the exponent
(1)   48/    1360 : F6                  	shr		;shift right so it can go into bits 31-24
(1)   49/    1361 : B8                  	phi	RL8-1	;put top bits of exponent into place
(1)   50/    1362 : 33 68               	bdf	$$setsgn ;if the bit 0 is on we're done
(1)   51/    1364 : 88                  	glo	RL8-1	;get the byte
(1)   52/    1365 : FA 7F               	ani	0x7f	;clear bit 23
(1)   53/    1367 : A8                  	plo	RL8-1	;put it back
(1)   54/    1368 : 9E                  $$setsgn: ghi	memaddr	;get the original sign byte
(1)   55/    1369 : 32 6F               	bz	$$done	;sign bit is already zero so we're done
(1)   56/    136B : 98                  	ghi	RL8-1	;get the sign byte
(1)   57/    136C : F9 80               	ori	0x80	;set the sign bit
(1)   58/    136E : B8                  	phi	RL8-1	;place it
(1)   59/    136F : (MACRO)             $$done:	Cretn		;and we're done
(1)   60/    1370 :                     	
(1)   61/    1370 :                     
(1)   62/    1370 :                     
(1)   63/    1370 :                     ; *** Convert float to signed long
(1)   64/    1370 :                     ; *** RL8-1:RL8 is the number to convert(8:9)
(1)   65/    1370 :                     ; *** result in same register
(1)   66/    1370 :                     	align 256
(1)   67/    1400 :                     cvfi4:
(1)   68/    1400 : 98                  	ghi	RL8-1	;get sign and bits 7-1 of exponent
(1)   69/    1401 : BE                  	phi	memaddr ;save for later
(1)   70/    1402 : 88                  	glo	RL8-1	;get bit 0 of exponent
(1)   71/    1403 : FE                  	shl		;shift to df
(1)   72/    1404 : 9E                  	ghi	memaddr	;get exponent 7-1
(1)   73/    1405 : 7E                  	shlc		;combine with 0
(1)   74/    1406 :                     ;the following sequence is equivalent to sdi 150; I did it this way to coddle my emulator which doesn't do this properly.
(1)   75/    1406 : 22                  	dec	sp
(1)   76/    1407 : 52                  	str	sp
(1)   77/    1408 : F8 96               	ldi	150
(1)   78/    140A : F7                  	sm		;calculate shift count needed
(1)   79/    140B :                     ;*******note - the df flag set here is tested later
(1)   80/    140B : AE                  	plo	memaddr
(1)   81/    140C : 12                  	inc	sp	;release work area
(1)   82/    140D :                     ;end of sdi 150 sequence - now convert the mantissa to unsigned long
(1)   83/    140D : F8 00               	ldi	0
(1)   84/    140F : B8                  	phi	RL8-1	;clear the top byte of the float
(1)   85/    1410 : 88                  	glo	RL8-1	;get the next byte
(1)   86/    1411 : F9 80               	ori	0x80	;add in the implied 1 bit
(1)   87/    1413 : A8                  	plo	RL8-1	;put it back
(1)   88/    1414 : 8E                  	glo	memaddr	;make sure there's at least 1 shift
(1)   89/    1415 : 32 3B               	bz	$$sign
(1)   90/    1417 :                     ;**********note df is set from subtraction before setting mantissa
(1)   91/    1417 : 3B 2B               	bnf	$$lsh ; if the shift count is negative
(1)   92/    1419 :                     
(1)   93/    1419 : (MACRO)             $$shr:	shru4	RL8
(1)   94/    1425 : 2E                  	dec	memaddr	;check shift count
(1)   95/    1426 : 8E                  	glo	memaddr
(1)   96/    1427 : 3A 19               	bnz	$$shr	;complete the shift
(1)   97/    1429 : 30 3B               	br	$$sign
(1)   98/    142B :                     
(1)   99/    142B :                     ;handle negative shift as best I can - gigo
(1)  100/    142B : (MACRO)             $$lsh: 	shl4	RL8	;shift once
(1)  101/    1437 : 1E                  	inc	memaddr
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 31 - 11/23/2017 8:43:25


(1)  102/    1438 : 8E                  	glo	memaddr
(1)  103/    1439 : 3A 2B               	bnz	$$lsh	
(1)  104/    143B :                     	
(1)  105/    143B : 9E                  $$sign:	ghi	memaddr	;now the sign
(1)  106/    143C : FE                  	shl		;shift sign bit into df
(1)  107/    143D : 3B 61               	bnf	$$done
(1)  108/    143F : (MACRO)             	negi4	RL8,RL8	;negate the number if needed
(1)  109/    145F : 30 61               	br	$$done	; and return
(1)  110/    1461 :                     
(1)  111/    1461 : (MACRO)             $$done:	Cretn		;and we're done
(1)  112/    1462 :                     
(1)  113/    1462 :                     ; *** Check if character is numeric
(1)  114/    1462 :                     ; *** D - char to check
(1)  115/    1462 :                     ; *** Returns DF=1 if numeric
(1)  116/    1462 :                     ; ***         DF=0 if not
(1)  117/    1462 : AE                  f_isnum:   plo     r14                 ; save a copy
(1)  118/    1463 : FF 30                          smi     '0'                 ; check for below zero
(1)  119/    1465 : 3B 6E                          bnf     fails               ; jump if below
(1)  120/    1467 : FF 0A                          smi     10                  ; see if above
(1)  121/    1469 : 33 6E                          bdf     fails               ; fails if so
(1)  122/    146B : FF 00               passes:    smi     0                   ; signal success
(1)  123/    146D : C8                             lskp
(1)  124/    146E : FC 00               fails:     adi     0                   ; signal failure
(1)  125/    1470 : 8E                             glo     r14                 ; recover character
(1)  126/    1471 : (MACRO)                        cretn	                ; and return; ******************************* 17-03-06
(1)  127/    1472 :                     ; *** Shift R8:F9 right 1 bit ***
(1)  128/    1472 :                     ; *******************************
(1)  129/    1472 : 98                  fp_shr_1:  ghi   r8                    ; shift high word right
(1)  130/    1473 : F6                             shr
(1)  131/    1474 : B8                             phi   r8
(1)  132/    1475 : 88                             glo   r8
(1)  133/    1476 : 76                             shrc
(1)  134/    1477 : A8                             plo   r8
(1)  135/    1478 : 99                             ghi   F9                    ; shift low word right
(1)  136/    1479 : 76                             shrc
(1)  137/    147A : B9                             phi   F9
(1)  138/    147B : 89                             glo   F9
(1)  139/    147C : 76                             shrc
(1)  140/    147D : A9                             plo   F9
(1)  141/    147E : (MACRO)                        Cretn
(1)  142/    147F :                     
(1)  143/    147F :                     ; ******************************
(1)  144/    147F :                     ; *** Shift R8:F9 left 1 bit ***
(1)  145/    147F :                     ; ******************************
(1)  146/    147F : 89                  fp_shl_1:  glo   F9
(1)  147/    1480 : FE                             shl
(1)  148/    1481 : A9                             plo   F9
(1)  149/    1482 : 99                             ghi   F9
(1)  150/    1483 : 7E                             shlc
(1)  151/    1484 : B9                             phi   F9
(1)  152/    1485 : 88                             glo   r8
(1)  153/    1486 : 7E                             shlc
(1)  154/    1487 : A8                             plo   r8
(1)  155/    1488 : 98                             ghi   r8
(1)  156/    1489 : 7E                             shlc
(1)  157/    148A : B8                             phi   r8
(1)  158/    148B : (MACRO)                        cretn	;17-03-06
(1)  159/    148C :                     
(1)  160/    148C :                     ; **********************
(1)  161/    148C :                     ; *** R8:F9 += RA:FB ***
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 32 - 11/23/2017 8:43:25


(1)  162/    148C :                     ; **********************
(1)  163/    148C : 8B                  fp_add_12: glo   FB
(1)  164/    148D : 22                  	   dec r2	;wjr - make a work area
(1)  165/    148E : 52                             str   r2
(1)  166/    148F : 89                             glo   F9
(1)  167/    1490 : F4                             add
(1)  168/    1491 : A9                             plo   F9
(1)  169/    1492 : 9B                             ghi   FB
(1)  170/    1493 : 52                             str   r2
(1)  171/    1494 : 99                             ghi   F9
(1)  172/    1495 : 74                             adc
(1)  173/    1496 : B9                             phi   F9
(1)  174/    1497 : 8A                             glo   R10
(1)  175/    1498 : 52                             str   r2
(1)  176/    1499 : 88                             glo   r8
(1)  177/    149A : 74                             adc
(1)  178/    149B : A8                             plo   r8
(1)  179/    149C : 9A                             ghi   R10
(1)  180/    149D : 52                             str   r2
(1)  181/    149E : 98                             ghi   r8
(1)  182/    149F : 74                             adc
(1)  183/    14A0 : B8                             phi   r8
(1)  184/    14A1 : 12                             inc	r2	;wjr - release work area
(1)  185/    14A2 : (MACRO)                        Cretn
(1)  186/    14A3 :                     
(1)  187/    14A3 :                     ; *******************************
(1)  188/    14A3 :                     ; *** Shift RF:RD right 1 bit ***
(1)  189/    14A3 :                     ; *******************************
(1)  190/    14A3 : 9F                  fp_shr_fd: ghi   R15                    ; shift high word right
(1)  191/    14A4 : F6                             shr
(1)  192/    14A5 : BF                             phi   R15
(1)  193/    14A6 : 8F                             glo   R15
(1)  194/    14A7 : 76                             shrc
(1)  195/    14A8 : AF                             plo   R15
(1)  196/    14A9 : 9D                             ghi   R13                    ; shift low word right
(1)  197/    14AA : 76                             shrc
(1)  198/    14AB : BD                             phi   R13
(1)  199/    14AC : 8D                             glo   R13
(1)  200/    14AD : 76                             shrc
(1)  201/    14AE : AD                             plo   R13
(1)  202/    14AF : (MACRO)                        Cretn
(1)  203/    14B0 :                     
(1)  204/    14B0 :                     ; *************************************
(1)  205/    14B0 :                     ; *** Scale number to high bit is 1 ***
(1)  206/    14B0 :                     ; *** R8:F9 - Number to scale       ***
(1)  207/    14B0 :                     ; *** RF.1  - Exponent for number   ***
(1)  208/    14B0 :                     ; *** F7.0  - Sign bit (bit 0) ***
(1)  209/    14B0 :                     ; *** Returns: R8:F9 - final sp num ***
(1)  210/    14B0 :                     ; *************************************
(1)  211/    14B0 : 88                  fp_sc_up:  glo   r8                    ; need high bit to be a 1
(1)  212/    14B1 : FA 80                          ani   080h                  ; check it
(1)  213/    14B3 : CA 14 C0                       lbnz  fp_sc_cln             ; jump if good
(1)  214/    14B6 : (MACRO)                        Ccall fp_shl_1              ; shift answer left
(1)  215/    14B9 : 9F                             ghi   R15                    ; get exp1
(1)  216/    14BA : FF 01                          smi   1                     ; minus 1
(1)  217/    14BC : BF                             phi   R15                    ; and put it back
(1)  218/    14BD : C0 14 B0                       lbr   fp_sc_up              ; loop back intil msbit is 1
(1)  219/    14C0 : 88                  fp_sc_cln: glo   r8                    ; get high byte
(1)  220/    14C1 : FE                             shl                         ; shift out high 1 bit
(1)  221/    14C2 : A8                             plo   r8                    ; set aside
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 33 - 11/23/2017 8:43:25


(1)  222/    14C3 : 9F                             ghi   R15                    ; get exponent byte
(1)  223/    14C4 : B8                             phi   r8                    ; write other 7 bits to r8.1
(1)  224/    14C5 : F6                             shr                         ; shift bit 0 into DF
(1)  225/    14C6 : 88                             glo   r8                    ; get high byte of mantissa
(1)  226/    14C7 : 76                             shrc                        ; shift bit 0 of expnent in
(1)  227/    14C8 : A8                             plo   r8                    ; and put it back
(1)  228/    14C9 : 87                             glo   F7                   ; get signs
(1)  229/    14CA : F6                             shr                         ; get sign 1
(1)  230/    14CB : 98                             ghi   r8                    ; recover exponent
(1)  231/    14CC : 76                             shrc                        ; shift in sign
(1)  232/    14CD : B8                             phi   r8                    ; put it back
(1)  233/    14CE : 12                             inc	r2	;wjr release work area
(1)  234/    14CF : (MACRO)             	   popr R13	;wjr restore param regs
(1)  235/    14D4 : (MACRO)             	   popr R12	;wjr
(1)  236/    14D9 : (MACRO)                        popr	F7	;wjr restore c variable register
(1)  237/    14DE : (MACRO)                        Cretn                       ; return to caller
(1)  238/    14DF :                     
(1)  239/    14DF :                     ; ************************************
(1)  240/    14DF :                     ; *** Get exponenst from arguments ***
(1)  241/    14DF :                     ; *** R8:F9 - Arg 1                ***
(1)  242/    14DF :                     ; *** RA:FB - Arg 2                ***
(1)  243/    14DF :                     ; *** Returns: RF.1 - exp1         ***
(1)  244/    14DF :                     ; ***          RF.0 - exp2         ***
(1)  245/    14DF :                     ; ************************************
(1)  246/    14DF : 88                  fp_getexp: glo   r8                    ; get exponent of arg1 (bit 0)
(1)  247/    14E0 : FE                             shl                         ; shift it into DF
(1)  248/    14E1 : 98                             ghi   r8                    ; get top 7 bits
(1)  249/    14E2 : 7E                             shlc                        ; shift in first bit
(1)  250/    14E3 : BF                             phi   R15                    ; put exp1 into RF.1
(1)  251/    14E4 :                                ;str   r2    wjr - this is never used; place into memory as well
(1)  252/    14E4 : 8A                             glo   R10                    ; get exponent of arg2 (bit 0)
(1)  253/    14E5 : FE                             shl                         ; shift it into DF
(1)  254/    14E6 : 9A                             ghi   R10                    ; get top 7 bits
(1)  255/    14E7 : 7E                             shlc                        ; shift in first bit
(1)  256/    14E8 : AF                             plo   R15                    ; put into RF
(1)  257/    14E9 : (MACRO)                        cretn	                  ; return to caller 17-03-06
(1)  258/    14EA :                     
(1)  259/    14EA :                     ; ************************************
(1)  260/    14EA :                     ; *** Get signs from arguments     ***
(1)  261/    14EA :                     ; *** R8:F9 - Arg 1                ***
(1)  262/    14EA :                     ; *** RA:FB - Arg 2                ***
(1)  263/    14EA :                     ; *** Returns: F7.0 - signs        ***
(1)  264/    14EA :                     ; ************************************
(1)  265/    14EA : 98                  fp_getsgn: ghi   r8                    ; get sign of arg1
(1)  266/    14EB : FE                             shl                         ; shift into DF
(1)  267/    14EC : 9A                             ghi   R10                    ; get sign of arg2
(1)  268/    14ED : 7E                             shlc                        ; shift into DF, sign of arg1 to bit 0
(1)  269/    14EE : 7E                             shlc                        ; now shift in sign of arg2
(1)  270/    14EF : A7                             plo   F7                    ; save them
(1)  271/    14F0 : (MACRO)                        Cretn                       ; return to caller
(1)  272/    14F1 :                     
(1)  273/    14F1 :                     ; ***************************************
(1)  274/    14F1 :                     ; *** Add 2 SP floating point numbers ***
(1)  275/    14F1 :                     ; *** R8:F9 - Arg 1                   ***
(1)  276/    14F1 :                     ; *** RA:FB - Arg 2                   ***
(1)  277/    14F1 :                     ; *** Returns: R8:F9 - Answer         ***
(1)  278/    14F1 :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  279/    14F1 :                     ; ***        RF.1 - exponent of arg2  ***
(1)  280/    14F1 :                     ; ***        F7.0 - signs        ***
(1)  281/    14F1 :                     ; ***************************************
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 34 - 11/23/2017 8:43:25


(1)  282/    14F1 : 98                  fp_add:   ghi   r8                    ; check arg1 for zero
(1)  283/    14F2 : CA 15 0A                       lbnz  add_a1nz
(1)  284/    14F5 : 88                             glo   r8
(1)  285/    14F6 : CA 15 0A                       lbnz  add_a1nz
(1)  286/    14F9 : 99                             ghi   F9
(1)  287/    14FA : CA 15 0A                       lbnz  add_a1nz
(1)  288/    14FD : 89                             glo   F9
(1)  289/    14FE : CA 15 0A                       lbnz  add_a1nz
(1)  290/    1501 : 9A                             ghi   R10                    ; transfer arg2 to answer
(1)  291/    1502 : B8                             phi   r8
(1)  292/    1503 : 8A                             glo   R10
(1)  293/    1504 : A8                             plo   r8
(1)  294/    1505 : 9B                             ghi   FB
(1)  295/    1506 : B9                             phi   F9
(1)  296/    1507 : 8B                             glo   FB
(1)  297/    1508 : A9                             plo   F9
(1)  298/    1509 : (MACRO)                        Cretn                        ; return to caller
(1)  299/    150A :                     
(1)  300/    150A : 9A                  add_a1nz:  ghi   R10                    ; check arg2 for zero
(1)  301/    150B : CA 15 1B                       lbnz  add_a2nz
(1)  302/    150E : 8A                             glo   R10
(1)  303/    150F : CA 15 1B                       lbnz  add_a2nz
(1)  304/    1512 : 9B                             ghi   FB
(1)  305/    1513 : CA 15 1B                       lbnz  add_a2nz
(1)  306/    1516 : 8B                             glo   FB
(1)  307/    1517 : CA 15 1B                       lbnz  add_a2nz
(1)  308/    151A : (MACRO)                        Cretn                       ; return arg1 as answer
(1)  309/    151B :                                
(1)  310/    151B : (MACRO)             add_a2nz:  pushr F7	;wjr save c variable register
(1)  311/    151F : (MACRO)             	   pushr R12	;wjr save param regs
(1)  312/    1523 : (MACRO)             	   pushr R13	;wjr
(1)  313/    1527 : 22                  	   dec	r2	;wjr - make a work area
(1)  314/    1528 : (MACRO)             	   Ccall fp_getexp             ; get exponents
(1)  315/    152B : 9F                             ghi   R15
(1)  316/    152C : 52                             str   r2
(1)  317/    152D : 8F                             glo   R15
(1)  318/    152E : F7                             sm                          ; perfrom exp2 - exp1
(1)  319/    152F : CB 15 50                       lbnf  add_ns                ; jump if no swap needed
(1)  320/    1532 :                     
(1)  321/    1532 : 98                             ghi   r8                    ; swap arg1 with arg2
(1)  322/    1533 : AE                             plo   R14
(1)  323/    1534 : 9A                             ghi   R10
(1)  324/    1535 : B8                             phi   r8
(1)  325/    1536 : 8E                             glo   R14
(1)  326/    1537 : BA                             phi   R10
(1)  327/    1538 : 88                             glo   r8
(1)  328/    1539 : AE                             plo   R14
(1)  329/    153A : 8A                             glo   R10
(1)  330/    153B : A8                             plo   r8
(1)  331/    153C : 8E                             glo   R14
(1)  332/    153D : AA                             plo   R10
(1)  333/    153E : 99                             ghi   F9                    ; swap arg1 with arg2
(1)  334/    153F : AE                             plo   R14
(1)  335/    1540 : 9B                             ghi   FB
(1)  336/    1541 : B9                             phi   F9
(1)  337/    1542 : 8E                             glo   R14
(1)  338/    1543 : BB                             phi   FB
(1)  339/    1544 : 89                             glo   F9
(1)  340/    1545 : AE                             plo   R14
(1)  341/    1546 : 8B                             glo   FB
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 35 - 11/23/2017 8:43:25


(1)  342/    1547 : A9                             plo   F9
(1)  343/    1548 : 8E                             glo   R14
(1)  344/    1549 : AB                             plo   FB
(1)  345/    154A : 9F                             ghi   R15                    ; swap exponents
(1)  346/    154B : AE                             plo   R14
(1)  347/    154C : 8F                             glo   R15
(1)  348/    154D : BF                             phi   R15
(1)  349/    154E : 8E                             glo   R14
(1)  350/    154F : AF                             plo   R15
(1)  351/    1550 : (MACRO)             add_ns:    ccall fp_getsgn              ; get signs of arguments
(1)  352/    1553 : F8 00                          ldi   0                     ; setup mantissas
(1)  353/    1555 : B8                             phi   r8
(1)  354/    1556 : BA                             phi   R10
(1)  355/    1557 : F8 80                          ldi   128                   ; need to set high bit in mantissa
(1)  356/    1559 : 52                             str   r2
(1)  357/    155A : 88                             glo   r8
(1)  358/    155B : F1                             or
(1)  359/    155C : A8                             plo   r8
(1)  360/    155D : 8A                             glo   R10
(1)  361/    155E : F1                             or
(1)  362/    155F : AA                             plo   R10
(1)  363/    1560 : 9F                             ghi   R15                    ; get exp1
(1)  364/    1561 : 52                             str   r2                    ; place into memory
(1)  365/    1562 : 8F                  add_lp1:   glo   R15                    ; get exp2
(1)  366/    1563 : F7                             sm                          ; see if match to exp1
(1)  367/    1564 : C2 15 77                       lbz   add_lp1dn             ; jump if match
(1)  368/    1567 : 8F                             glo   R15                    ; need to increase it
(1)  369/    1568 : FC 01                          adi   1
(1)  370/    156A : AF                             plo   R15
(1)  371/    156B : 8A                             glo   R10                    ; now shift arg2 over 1 bit
(1)  372/    156C : F6                             shr
(1)  373/    156D : AA                             plo   R10
(1)  374/    156E : 9B                             ghi   FB
(1)  375/    156F : 76                             shrc
(1)  376/    1570 : BB                             phi   FB
(1)  377/    1571 : 8B                             glo   FB
(1)  378/    1572 : 76                             shrc
(1)  379/    1573 : AB                             plo   FB
(1)  380/    1574 : C0 15 62                       lbr   add_lp1               ; keep shifting until exponents match
(1)  381/    1577 : 87                  add_lp1dn: glo   F7                    ; see if signs match
(1)  382/    1578 : 52                             str   r2
(1)  383/    1579 : F6                             shr
(1)  384/    157A : F3                             xor
(1)  385/    157B : FA 01                          ani   1                     ; keep only bottom bit
(1)  386/    157D : CA 15 86                       lbnz  add_nm                ; jump if signs do not match
(1)  387/    1580 : (MACRO)                        Ccall fp_add_12             ; perform arg1 += arg2
(1)  388/    1583 : C0 15 BF                       lbr   add_fnl               ; jump to clean up
(1)  389/    1586 : 8B                  add_nm:    glo   FB                    ; perform arg1 - arg2
(1)  390/    1587 : 52                             str   r2
(1)  391/    1588 : 89                             glo   F9
(1)  392/    1589 : F7                             sm
(1)  393/    158A : AC                             plo   R12                    ; place into RD:RC
(1)  394/    158B : 9B                             ghi   FB
(1)  395/    158C : 52                             str   r2
(1)  396/    158D : 99                             ghi   F9
(1)  397/    158E : 77                             smb
(1)  398/    158F : BC                             phi   R12
(1)  399/    1590 : 8A                             glo   R10
(1)  400/    1591 : 52                             str   r2
(1)  401/    1592 : 88                             glo   r8
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 36 - 11/23/2017 8:43:25


(1)  402/    1593 : 77                             smb
(1)  403/    1594 : AD                             plo   R13
(1)  404/    1595 : 9A                             ghi   R10
(1)  405/    1596 : 52                             str   r2
(1)  406/    1597 : 98                             ghi   r8
(1)  407/    1598 : 77                             smb
(1)  408/    1599 : BD                             phi   R13
(1)  409/    159A : CB 15 A8                       lbnf  add_no                ; jump if arg2 was larger than arg1
(1)  410/    159D : 9D                             ghi   R13                    ; transfer result to arg1
(1)  411/    159E : B8                             phi   r8
(1)  412/    159F : 8D                             glo   R13
(1)  413/    15A0 : A8                             plo   r8
(1)  414/    15A1 : 9C                             ghi   R12
(1)  415/    15A2 : B9                             phi   F9
(1)  416/    15A3 : 8C                             glo   R12
(1)  417/    15A4 : A9                             plo   F9
(1)  418/    15A5 : C0 15 BF                       lbr   add_fnl               ; finalize
(1)  419/    15A8 : 89                  add_no:    glo   F9                    ; perform arg1 = arg2 - arg1
(1)  420/    15A9 : 52                             str   r2
(1)  421/    15AA : 8B                             glo   FB
(1)  422/    15AB : F7                             sm
(1)  423/    15AC : A9                             plo   F9
(1)  424/    15AD : 99                             ghi   F9
(1)  425/    15AE : 52                             str   r2
(1)  426/    15AF : 9B                             ghi   FB
(1)  427/    15B0 : 77                             smb
(1)  428/    15B1 : B9                             phi   F9
(1)  429/    15B2 : 88                             glo   r8
(1)  430/    15B3 : 52                             str   r2
(1)  431/    15B4 : 8A                             glo   R10
(1)  432/    15B5 : 77                             smb
(1)  433/    15B6 : A8                             plo   r8
(1)  434/    15B7 : 98                             ghi   r8
(1)  435/    15B8 : 52                             str   r2
(1)  436/    15B9 : 9A                             ghi   R10
(1)  437/    15BA : 77                             smb
(1)  438/    15BB : B8                             phi   r8
(1)  439/    15BC : 87                             glo   F7                    ; move sign 2 to sign1
(1)  440/    15BD : FE                             shl
(1)  441/    15BE : A7                             plo   F7
(1)  442/    15BF : 98                  add_fnl:   ghi   r8                    ; check for zero result
(1)  443/    15C0 : CA 15 E0                       lbnz  add_nz                ; jump if not
(1)  444/    15C3 : 88                             glo   r8
(1)  445/    15C4 : CA 15 E0                       lbnz  add_nz
(1)  446/    15C7 : 99                             ghi   F9
(1)  447/    15C8 : CA 15 E0                       lbnz  add_nz
(1)  448/    15CB : 89                             glo   F9
(1)  449/    15CC : CA 15 E0                       lbnz  add_nz
(1)  450/    15CF : 12                             inc	r2	;wjr release work area
(1)  451/    15D0 : (MACRO)             	   popr R13	;wjr restore param regs
(1)  452/    15D5 : (MACRO)             	   popr R12	;wjr
(1)  453/    15DA : (MACRO)                        popr	F7	;wjr restore c variable register
(1)  454/    15DF : (MACRO)                        Cretn                       ; return the zero
(1)  455/    15E0 : 98                  add_nz:    ghi   r8                    ; see if answer is beyond 24 bits
(1)  456/    15E1 : C2 15 EE                       lbz   add_nx                ; jump if not
(1)  457/    15E4 : (MACRO)                        Ccall fp_shr_1              ; shift answer to the right
(1)  458/    15E7 : 9F                             ghi   R15                    ; get exp1
(1)  459/    15E8 : FC 01                          adi   1                     ; increment it
(1)  460/    15EA : BF                             phi   R15                    ; and put it back
(1)  461/    15EB : C0 15 E0                       lbr   add_nz                ; keep going until not > 24 bits
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 37 - 11/23/2017 8:43:25


(1)  462/    15EE :                     
(1)  463/    15EE : 87                  add_nx:    glo   F7                    ; move sign 1 to low bit
(1)  464/    15EF : F6                             shr
(1)  465/    15F0 : A7                             plo   F7
(1)  466/    15F1 : C0 14 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  467/    15F4 :                     
(1)  468/    15F4 :                     ; ***************************************
(1)  469/    15F4 :                     ; *** sub 2 SP floating point numbers ***
(1)  470/    15F4 :                     ; *** R8:F9 - Arg 1                   ***
(1)  471/    15F4 :                     ; *** RA:FB - Arg 2                   ***
(1)  472/    15F4 :                     ; *** Returns: R8:F9 - Answer         ***
(1)  473/    15F4 :                     ; ***************************************
(1)  474/    15F4 : 9A                  fp_sub:    ghi   R10                    ; change sign of arg2
(1)  475/    15F5 : FB 80                          xri   080h
(1)  476/    15F7 : BA                             phi   R10                    ; and put it back
(1)  477/    15F8 : C0 14 F1                       lbr   fp_add                ; now just add
(1)  478/    15FB :                     
(1)  479/    15FB :                     ; ***************************************
(1)  480/    15FB :                     ; *** Div 2 SP floating point numbers ***
(1)  481/    15FB :                     ; *** R8:F9 - Arg 1                   ***
(1)  482/    15FB :                     ; *** RA:FB - Arg 2                   ***
(1)  483/    15FB :                     ; *** Returns: R8:F9 - Answer         ***
(1)  484/    15FB :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  485/    15FB :                     ; ***        RF.1 - exponent of arg2  ***
(1)  486/    15FB :                     ; ***        F7.0 - signs        ***
(1)  487/    15FB :                     ; ***************************************
(1)  488/    15FB : 98                  fp_div:    ghi   r8                    ; check arg1 for zero
(1)  489/    15FC : CA 16 0C                       lbnz  div_a1nz
(1)  490/    15FF : 88                             glo   r8
(1)  491/    1600 : CA 16 0C                       lbnz  div_a1nz
(1)  492/    1603 : 99                             ghi   F9
(1)  493/    1604 : CA 16 0C                       lbnz  div_a1nz
(1)  494/    1607 : 89                             glo   F9
(1)  495/    1608 : CA 16 0C                       lbnz  div_a1nz
(1)  496/    160B : (MACRO)                        Cretn	                ; just return the zero
(1)  497/    160C : 9A                  div_a1nz:  ghi   R10                    ; check arg2 for zero
(1)  498/    160D : CA 16 2A                       lbnz  div_a2nz
(1)  499/    1610 : 8A                             glo   R10
(1)  500/    1611 : CA 16 2A                       lbnz  div_a2nz
(1)  501/    1614 : 9B                             ghi   FB
(1)  502/    1615 : CA 16 2A                       lbnz  div_a2nz
(1)  503/    1618 : 8B                             glo   FB
(1)  504/    1619 : CA 16 2A                       lbnz  div_a2nz
(1)  505/    161C : 98                             ghi   r8                    ; need sign of arg1
(1)  506/    161D : FA 80                          ani   080h                  ; want only sign
(1)  507/    161F : F9 7F                          ori   07fh                  ; exponent will be all ones
(1)  508/    1621 : B8                             phi   r8                    ; put into answer
(1)  509/    1622 : F8 80                          ldi   080h                  ; build rest of answer
(1)  510/    1624 : A8                             plo   r8 
(1)  511/    1625 : F8 00                          ldi   0
(1)  512/    1627 : B9                             phi   F9
(1)  513/    1628 : A9                             plo   F9
(1)  514/    1629 : (MACRO)                        Cretn                  	; and return to caller
(1)  515/    162A :                     
(1)  516/    162A : (MACRO)             div_a2nz:  pushr F7	;wjr save the C variable
(1)  517/    162E : (MACRO)             	   pushr R12	;wjr save param regs
(1)  518/    1632 : (MACRO)             	   pushr R13	;wjr
(1)  519/    1636 : 22                  	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
(1)  520/    1637 :                     
(1)  521/    1637 : (MACRO)             	   Ccall fp_getexp              ; get exponents
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 38 - 11/23/2017 8:43:25


(1)  522/    163A : (MACRO)                        Ccall fp_getsgn		; get signs
(1)  523/    163D : 8F                             glo   R15                    ; get exp2
(1)  524/    163E : FF 7F                          smi   127                   ; remove bias
(1)  525/    1640 : 52                             str   r2                    ; place into memory
(1)  526/    1641 : 9F                             ghi   R15                    ; get exp1
(1)  527/    1642 : FF 7F                          smi   127                   ; remove bias
(1)  528/    1644 : F7                             sm                          ; perform exp1 - exp2
(1)  529/    1645 : FC 7F                          adi   127                   ; put bias back in
(1)  530/    1647 : 73                             stxd                        ; save onto stack
(1)  531/    1648 : 87                             glo   F7                    ; determine sign for answer
(1)  532/    1649 : 52                             str   r2
(1)  533/    164A : F6                             shr
(1)  534/    164B : F3                             xor
(1)  535/    164C : 73                             stxd                        ; place onto stack
(1)  536/    164D : F8 00                          ldi   0                     ; setup man
(1)  537/    164F : BA                             phi   R10
(1)  538/    1650 : 8A                             glo   R10
(1)  539/    1651 : F9 80                          ori   080h
(1)  540/    1653 : AA                             plo   R10
(1)  541/    1654 : F8 00                          ldi   0                     ; setup div
(1)  542/    1656 : B8                             phi   r8
(1)  543/    1657 : 88                             glo   r8
(1)  544/    1658 : F9 80                          ori   080h
(1)  545/    165A : A8                             plo   r8
(1)  546/    165B : F8 00                          ldi   0                     ; setup result
(1)  547/    165D : BC                             phi   R12
(1)  548/    165E : AC                             plo   R12
(1)  549/    165F : B7                             phi   F7
(1)  550/    1660 : A7                             plo   F7
(1)  551/    1661 : AF                             plo   R15                    ; setup quotient
(1)  552/    1662 : BF                             phi   R15
(1)  553/    1663 : BD                             phi   R13
(1)  554/    1664 : AD                             plo   R13
(1)  555/    1665 : F8 80                          ldi   080h
(1)  556/    1667 : AF                             plo   R15
(1)  557/    1668 : 98                  div_lp:    ghi   r8                    ; check div for nonzero
(1)  558/    1669 : CA 16 7B                       lbnz  div_go1
(1)  559/    166C : 88                             glo   r8
(1)  560/    166D : CA 16 7B                       lbnz  div_go1
(1)  561/    1670 : 99                             ghi   F9
(1)  562/    1671 : CA 16 7B                       lbnz  div_go1
(1)  563/    1674 : 89                             glo   F9
(1)  564/    1675 : CA 16 7B                       lbnz  div_go1
(1)  565/    1678 : C0 16 DB                       lbr   div_z
(1)  566/    167B : 9A                  div_go1:   ghi   R10
(1)  567/    167C : CA 16 8E                       lbnz  div_go
(1)  568/    167F : 8A                             glo   R10
(1)  569/    1680 : CA 16 8E                       lbnz  div_go
(1)  570/    1683 : 9B                             ghi   FB
(1)  571/    1684 : CA 16 8E                       lbnz  div_go
(1)  572/    1687 : 8B                             glo   FB
(1)  573/    1688 : CA 16 8E                       lbnz  div_go
(1)  574/    168B : C0 16 DB                       lbr   div_z                 ; nothing more to do
(1)  575/    168E : 8B                  div_go:    glo   FB                    ; see if div > man
(1)  576/    168F : 52                             str   r2
(1)  577/    1690 : 89                             glo   F9
(1)  578/    1691 : F7                             sm
(1)  579/    1692 : 9B                             ghi   FB
(1)  580/    1693 : 52                             str   r2
(1)  581/    1694 : 99                             ghi   F9
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 39 - 11/23/2017 8:43:25


(1)  582/    1695 : 77                             smb
(1)  583/    1696 : 8A                             glo   R10
(1)  584/    1697 : 52                             str   r2
(1)  585/    1698 : 88                             glo   r8
(1)  586/    1699 : 77                             smb
(1)  587/    169A : 9A                             ghi   R10
(1)  588/    169B : 52                             str   r2
(1)  589/    169C : 98                             ghi   r8
(1)  590/    169D : 77                             smb
(1)  591/    169E : CB 16 C9                       lbnf  div_nope              ; jump if div was smaller
(1)  592/    16A1 : 8B                             glo   FB                    ; div -= man
(1)  593/    16A2 : 52                             str   r2
(1)  594/    16A3 : 89                             glo   F9
(1)  595/    16A4 : F7                             sm
(1)  596/    16A5 : A9                             plo   F9
(1)  597/    16A6 : 9B                             ghi   FB
(1)  598/    16A7 : 52                             str   r2
(1)  599/    16A8 : 99                             ghi   F9
(1)  600/    16A9 : 77                             smb
(1)  601/    16AA : B9                             phi   F9
(1)  602/    16AB : 8A                             glo   R10
(1)  603/    16AC : 52                             str   r2
(1)  604/    16AD : 88                             glo   r8
(1)  605/    16AE : 77                             smb
(1)  606/    16AF : A8                             plo   r8
(1)  607/    16B0 : 9A                             ghi   R10
(1)  608/    16B1 : 52                             str   r2
(1)  609/    16B2 : 98                             ghi   r8
(1)  610/    16B3 : 77                             smb
(1)  611/    16B4 : B8                             phi   r8
(1)  612/    16B5 : 9F                             ghi   R15                    ; merge quotient into result
(1)  613/    16B6 : 52                             str   r2
(1)  614/    16B7 : 9C                             ghi   R12
(1)  615/    16B8 : F1                             or
(1)  616/    16B9 : BC                             phi   R12
(1)  617/    16BA : 8F                             glo   R15
(1)  618/    16BB : 52                             str   r2
(1)  619/    16BC : 8C                             glo   R12
(1)  620/    16BD : F1                             or
(1)  621/    16BE : AC                             plo   R12
(1)  622/    16BF : 9D                             ghi   R13
(1)  623/    16C0 : 52                             str   r2
(1)  624/    16C1 : 97                             ghi   F7
(1)  625/    16C2 : F1                             or
(1)  626/    16C3 : B7                             phi   F7
(1)  627/    16C4 : 8D                             glo   R13
(1)  628/    16C5 : 52                             str   r2
(1)  629/    16C6 : 87                             glo   F7
(1)  630/    16C7 : F1                             or
(1)  631/    16C8 : A7                             plo   F7
(1)  632/    16C9 : (MACRO)             div_nope:  ccall fp_shr_fd              ; shift quotient right 17-03-06
(1)  633/    16CC : 9A                             ghi   R10                    ; shift divisor right
(1)  634/    16CD : F6                             shr
(1)  635/    16CE : BA                             phi   R10
(1)  636/    16CF : 8A                             glo   R10
(1)  637/    16D0 : 76                             shrc
(1)  638/    16D1 : AA                             plo   R10
(1)  639/    16D2 : 9B                             ghi   FB
(1)  640/    16D3 : 76                             shrc
(1)  641/    16D4 : BB                             phi   FB
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 40 - 11/23/2017 8:43:25


(1)  642/    16D5 : 8B                             glo   FB
(1)  643/    16D6 : 76                             shrc
(1)  644/    16D7 : AB                             plo   FB
(1)  645/    16D8 : C0 16 68                       lbr   div_lp                ; loop back until done
(1)  646/    16DB : 9C                  div_z:     ghi   R12                    ; move result to arg1
(1)  647/    16DC : B8                             phi   r8
(1)  648/    16DD : 8C                             glo   R12
(1)  649/    16DE : A8                             plo   r8
(1)  650/    16DF : 97                             ghi   F7
(1)  651/    16E0 : B9                             phi   F9
(1)  652/    16E1 : 87                             glo   F7
(1)  653/    16E2 : A9                             plo   F9
(1)  654/    16E3 : 60                             irx                         ; recover sign
(1)  655/    16E4 : 72                             ldxa
(1)  656/    16E5 : A7                             plo   F7
(1)  657/    16E6 : F0                             ldx                         ; recover answer exponent
(1)  658/    16E7 : BF                             phi   R15
(1)  659/    16E8 : C0 14 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  660/    16EB :                     
(1)  661/    16EB :                     ; ***************************************
(1)  662/    16EB :                     ; *** Mul 2 SP floating point numbers ***
(1)  663/    16EB :                     ; *** R8:F9 - Arg 1                   ***
(1)  664/    16EB :                     ; *** RA:FB - Arg 2                   ***
(1)  665/    16EB :                     ; *** Returns: R8:F9 - Answer         ***
(1)  666/    16EB :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  667/    16EB :                     ; ***        RF.1 - exponent of arg2  ***
(1)  668/    16EB :                     ; ***        F7.0 - signs             ***
(1)  669/    16EB :                     ; ***************************************
(1)  670/    16EB : (MACRO)             fp_mul:    pushr F7	;wjr save the C variable
(1)  671/    16EF : (MACRO)             	   pushr R12	;wjr save param regs
(1)  672/    16F3 : (MACRO)             	   pushr R13	;wjr
(1)  673/    16F7 : 22                  	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
(1)  674/    16F8 :                     
(1)  675/    16F8 : (MACRO)                        Ccall    fp_getexp	       ; get exponents
(1)  676/    16FB : (MACRO)                        Ccall    fp_getsgn            ; get signs
(1)  677/    16FE : 8F                             glo   R15                    ; get exp2
(1)  678/    16FF : FF 7F                          smi   127                   ; remove bias
(1)  679/    1701 : 52                             str   r2                    ; place into memory
(1)  680/    1702 : 9F                             ghi   R15                    ; get exp1
(1)  681/    1703 : FF 7F                          smi   127                   ; remove bias
(1)  682/    1705 : F4                             add                         ; add in exponent 2
(1)  683/    1706 : FC 7F                          adi   127                   ; put bias back in
(1)  684/    1708 : 73                             stxd                        ; place onto stack
(1)  685/    1709 : 87                             glo   F7                    ; determine sign for answer
(1)  686/    170A : 52                             str   r2
(1)  687/    170B : F6                             shr
(1)  688/    170C : F3                             xor
(1)  689/    170D : 73                             stxd                        ; place onto stack
(1)  690/    170E : 9E                             ghi   R14                    ; get baud constant
(1)  691/    170F : 73                             stxd                        ; save on stack
(1)  692/    1710 : 96                             ghi   r6                    ; save return position on stack
(1)  693/    1711 : 73                             stxd
(1)  694/    1712 : 86                             glo   r6
(1)  695/    1713 : 73                             stxd
(1)  696/    1714 : F8 00                          ldi   0                     ; initial value of ct
(1)  697/    1716 : 73                             stxd
(1)  698/    1717 : BE                             phi   R14                    ; set mulH to 0
(1)  699/    1718 : AE                             plo   R14
(1)  700/    1719 : B6                             phi   r6
(1)  701/    171A : A6                             plo   r6
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 41 - 11/23/2017 8:43:25


(1)  702/    171B : B8                             phi   r8                    ; mulL = arg1 & 0xffffff
(1)  703/    171C : 88                             glo   r8                    ; be sure high bit is set
(1)  704/    171D : F9 80                          ori   080h
(1)  705/    171F : A8                             plo   r8
(1)  706/    1720 : F8 00                          ldi   0
(1)  707/    1722 : BC                             phi   R12                    ; set result to 0
(1)  708/    1723 : AC                             plo   R12
(1)  709/    1724 : B7                             phi   F7
(1)  710/    1725 : A7                             plo   F7
(1)  711/    1726 : BF                             phi   R15
(1)  712/    1727 : AF                             plo   R15
(1)  713/    1728 : BD                             phi   R13
(1)  714/    1729 : AD                             plo   R13
(1)  715/    172A : BA                             phi   R10                    ; arg2 &= 0ffffff
(1)  716/    172B : 8A                             glo   R10                    ; be sure high bit is set
(1)  717/    172C : F9 80                          ori   080h
(1)  718/    172E : AA                             plo   R10
(1)  719/    172F : 8B                  mul_lp1:   glo   FB                    ; check for zero multiplier
(1)  720/    1730 : CA 17 3F                       lbnz  mul_go1               ; jump if not zero
(1)  721/    1733 : 9B                             ghi   FB
(1)  722/    1734 : CA 17 3F                       lbnz  mul_go1
(1)  723/    1737 : 8A                             glo   R10
(1)  724/    1738 : CA 17 3F                       lbnz  mul_go1
(1)  725/    173B : 9A                             ghi   R10
(1)  726/    173C : C2 17 B7                       lbz   mul_dn                ; jump if muliplier is zero
(1)  727/    173F : 9A                  mul_go1:   ghi   R10                    ; shift multiplier right
(1)  728/    1740 : F6                             shr
(1)  729/    1741 : BA                             phi   R10
(1)  730/    1742 : 8A                             glo   R10
(1)  731/    1743 : 76                             shrc
(1)  732/    1744 : AA                             plo   R10
(1)  733/    1745 : 9B                             ghi   FB
(1)  734/    1746 : 76                             shrc
(1)  735/    1747 : BB                             phi   FB
(1)  736/    1748 : 8B                             glo   FB
(1)  737/    1749 : 76                             shrc
(1)  738/    174A : AB                             plo   FB
(1)  739/    174B : CB 17 8C                       lbnf  mul_no                ; jump if low bit was zero
(1)  740/    174E : 89                             glo   F9                    ; res += mul
(1)  741/    174F : 52                             str   r2
(1)  742/    1750 : 87                             glo   F7
(1)  743/    1751 : F4                             add
(1)  744/    1752 : A7                             plo   F7
(1)  745/    1753 : 99                             ghi   F9
(1)  746/    1754 : 52                             str   r2
(1)  747/    1755 : 97                             ghi   F7
(1)  748/    1756 : 74                             adc
(1)  749/    1757 : B7                             phi   F7
(1)  750/    1758 : 88                             glo   r8
(1)  751/    1759 : 52                             str   r2
(1)  752/    175A : 8C                             glo   R12
(1)  753/    175B : 74                             adc
(1)  754/    175C : AC                             plo   R12
(1)  755/    175D : 98                             ghi   r8
(1)  756/    175E : 52                             str   r2
(1)  757/    175F : 9C                             ghi   R12
(1)  758/    1760 : 74                             adc
(1)  759/    1761 : BC                             phi   R12
(1)  760/    1762 : 86                             glo   r6                    ; now high 32 bits
(1)  761/    1763 : 52                             str   r2
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 42 - 11/23/2017 8:43:25


(1)  762/    1764 : 8D                             glo   R13
(1)  763/    1765 : F4                             add
(1)  764/    1766 : AD                             plo   R13
(1)  765/    1767 : 96                             ghi   r6
(1)  766/    1768 : 52                             str   r2
(1)  767/    1769 : 96                             ghi   r6
(1)  768/    176A : 52                             str   r2
(1)  769/    176B : 9D                             ghi   R13
(1)  770/    176C : 74                             adc
(1)  771/    176D : BD                             phi   R13
(1)  772/    176E : 8E                             glo   R14
(1)  773/    176F : 52                             str   r2
(1)  774/    1770 : 8F                             glo   R15
(1)  775/    1771 : 74                             adc
(1)  776/    1772 : AF                             plo   R15
(1)  777/    1773 : 9E                             ghi   R14
(1)  778/    1774 : 52                             str   r2
(1)  779/    1775 : 9F                             ghi   R15
(1)  780/    1776 : 74                             adc
(1)  781/    1777 : BF                             phi   R15
(1)  782/    1778 : 9C                             ghi   R12                    ; see if need carry from low to high
(1)  783/    1779 : C2 17 8C                       lbz   mul_no                ; jump if no carry is needed
(1)  784/    177C : 8D                             glo   R13                    ; move the carry on over
(1)  785/    177D : FC 01                          adi   1
(1)  786/    177F : AD                             plo   R13
(1)  787/    1780 : 9D                             ghi   R13
(1)  788/    1781 : 7C 00                          adci  0
(1)  789/    1783 : BD                             phi   R13
(1)  790/    1784 : 8F                             glo   R15
(1)  791/    1785 : 7C 00                          adci  0
(1)  792/    1787 : AF                             plo   R15
(1)  793/    1788 : 9F                             ghi   R15
(1)  794/    1789 : 7C 00                          adci  0
(1)  795/    178B : BF                             phi   R15
(1)  796/    178C : 60                  mul_no:    irx                         ; recover ct
(1)  797/    178D : F0                             ldx
(1)  798/    178E : FC 01                          adi   1                     ; increment by 1
(1)  799/    1790 : 73                             stxd                        ; and put it back
(1)  800/    1791 : 89                             glo   F9                    ; shift mulL left
(1)  801/    1792 : FE                             shl
(1)  802/    1793 : A9                             plo   F9
(1)  803/    1794 : 99                             ghi   F9
(1)  804/    1795 : 7E                             shlc
(1)  805/    1796 : B9                             phi   F9
(1)  806/    1797 : 88                             glo   r8
(1)  807/    1798 : 7E                             shlc
(1)  808/    1799 : A8                             plo   r8
(1)  809/    179A : 98                             ghi   r8
(1)  810/    179B : 7E                             shlc
(1)  811/    179C : B8                             phi   r8
(1)  812/    179D : 86                             glo   r6                    ; shift mulH left
(1)  813/    179E : FE                             shl
(1)  814/    179F : A6                             plo   r6
(1)  815/    17A0 : 96                             ghi   r6
(1)  816/    17A1 : 7E                             shlc
(1)  817/    17A2 : B6                             phi   r6
(1)  818/    17A3 : 8E                             glo   R14
(1)  819/    17A4 : 7E                             shlc
(1)  820/    17A5 : AE                             plo   R14
(1)  821/    17A6 : 9E                             ghi   R14
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 43 - 11/23/2017 8:43:25


(1)  822/    17A7 : 7E                             shlc
(1)  823/    17A8 : BE                             phi   R14
(1)  824/    17A9 : 98                             ghi   r8                    ; see if a carry is needed
(1)  825/    17AA : C2 17 2F                       lbz   mul_lp1               ; jump if not
(1)  826/    17AD : F8 00                          ldi   0                     ; zero the high byte
(1)  827/    17AF : B8                             phi   r8
(1)  828/    17B0 : 86                             glo   r6                    ; add in the carry
(1)  829/    17B1 : F9 01                          ori   1
(1)  830/    17B3 : A6                             plo   r6
(1)  831/    17B4 : C0 17 2F                       lbr   mul_lp1               ; loop back for more
(1)  832/    17B7 : 60                  mul_dn:    irx                         ; recover ct
(1)  833/    17B8 : 72                             ldxa
(1)  834/    17B9 : AE                             plo   R14                    ; set aside
(1)  835/    17BA : 72                             ldxa
(1)  836/    17BB : A6                             plo   r6
(1)  837/    17BC : 72                             ldxa
(1)  838/    17BD : B6                             phi   r6
(1)  839/    17BE : F0                             ldx
(1)  840/    17BF : BE                             phi   R14
(1)  841/    17C0 : 9C                             ghi   R12                    ; transfer resL to arg1
(1)  842/    17C1 : B8                             phi   r8
(1)  843/    17C2 : 8C                             glo   R12
(1)  844/    17C3 : A8                             plo   r8
(1)  845/    17C4 : 97                             ghi   F7
(1)  846/    17C5 : B9                             phi   F9
(1)  847/    17C6 : 87                             glo   F7
(1)  848/    17C7 : A9                             plo   F9
(1)  849/    17C8 : 8E                             glo   R14
(1)  850/    17C9 : AC                             plo   R12                    ; put ct into RC.0
(1)  851/    17CA : 8C                  mul_lp2:   glo   R12                    ; get ct
(1)  852/    17CB : FF 02                          smi   2                     ; see if <2
(1)  853/    17CD : CB 17 E1                       lbnf  mul_nxt1              ; jump if so
(1)  854/    17D0 : (MACRO)                        ccall    fp_shr_1           ; shift answer to the right 17-03-06
(1)  855/    17D3 : (MACRO)                        ccall    fp_shr_fd          ; shift resH right 17-03-06
(1)  856/    17D6 : CB 17 DD                       lbnf  mul_lp2a              ; jump if no carry into low word
(1)  857/    17D9 : 88                             glo   r8                    ; set high bit
(1)  858/    17DA : F9 80                          ori   080h
(1)  859/    17DC : A8                             plo   r8
(1)  860/    17DD : 2C                  mul_lp2a:  dec   R12                    ; decrement count
(1)  861/    17DE : C0 17 CA                       lbr   mul_lp2               ; loop back to keep checking
(1)  862/    17E1 : 60                  mul_nxt1:  irx                         ; recover sign
(1)  863/    17E2 : 72                             ldxa
(1)  864/    17E3 : A7                             plo   F7
(1)  865/    17E4 : F0                             ldx                         ; recover answer exponent
(1)  866/    17E5 : AC                             plo   R12
(1)  867/    17E6 : 9F                  mul_lp3:   ghi   R15                    ; check resH for nonzero
(1)  868/    17E7 : CA 17 F9                       lbnz  mul_lp3a
(1)  869/    17EA : 8F                             glo   R15
(1)  870/    17EB : CA 17 F9                       lbnz  mul_lp3a
(1)  871/    17EE : 9D                             ghi   R13
(1)  872/    17EF : CA 17 F9                       lbnz  mul_lp3a
(1)  873/    17F2 : 8D                             glo   R13
(1)  874/    17F3 : CA 17 F9                       lbnz  mul_lp3a
(1)  875/    17F6 : C0 18 0A                       lbr   mul_lp4               ; jump if no bits set in resH
(1)  876/    17F9 : 1C                  mul_lp3a:  inc   R12                    ; increment exponent
(1)  877/    17FA : (MACRO)                        Ccall fp_shr_1                ; shift answer to the right
(1)  878/    17FD : (MACRO)                        Ccall fp_shr_fd               ; shift resH right
(1)  879/    1800 : CB 17 E6                       lbnf  mul_lp3               ; jump if no carry into low word
(1)  880/    1803 : 88                             glo   r8                    ; set high bit
(1)  881/    1804 : F9 80                          ori   080h
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 44 - 11/23/2017 8:43:25


(1)  882/    1806 : A8                             plo   r8
(1)  883/    1807 : C0 17 E6                       lbr   mul_lp3
(1)  884/    180A : 8C                  mul_lp4:   glo   R12                    ; transfer exponent
(1)  885/    180B : BF                             phi   R15                    ; to high R15
(1)  886/    180C : C0 14 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  887/    180F :                     
(1)  888/    180F :                     ; ***************************************
(1)  889/    180F :                     ; *** Convert ascii to floating point ***
(1)  890/    180F :                     ; *** RF - buffer to ascii text       ***
(1)  891/    180F :                     ; *** Returns: R8:F9 - number         ***
(1)  892/    180F :                     ; ***************************************
(1)  893/    180F : 4F                  fp_atof:   lda   R15                    ; get byte from buffer
(1)  894/    1810 : FF 20                          smi   ' '                   ; check for space
(1)  895/    1812 : C2 18 0F                       lbz   fp_atof               ; move past any spaces
(1)  896/    1815 : 2F                             dec   R15                    ; point back to nonspace chara
(1)  897/    1816 : 0F                             ldn   R15                    ; check for possible sign
(1)  898/    1817 : FF 2D                          smi   '-'                   ; first check for minus
(1)  899/    1819 : CA 18 23                       lbnz   atof_nm              ; jump if not minus
(1)  900/    181C : F8 80                          ldi   080h                  ; high bit set for minus
(1)  901/    181E : 73                             stxd                        ; place onto stack
(1)  902/    181F : 1F                             inc   R15                    ; move past sign
(1)  903/    1820 : C0 18 2D                       lbr   atof_go1              ; and continue
(1)  904/    1823 : F8 00               atof_nm:   ldi   0                     ; indicate positive number
(1)  905/    1825 : 73                             stxd                        ; place onto stack
(1)  906/    1826 : 0F                             ldn   R15                    ; now check for + sign
(1)  907/    1827 : FF 2B                          smi   '+'
(1)  908/    1829 : CA 18 2D                       lbnz  atof_go1              ; jump if not plus
(1)  909/    182C : 1F                             inc   R15                    ; move past plus sign
(1)  910/    182D : F8 00               atof_go1:  ldi   0                     ; setup result
(1)  911/    182F : B8                             phi   r8
(1)  912/    1830 : A8                             plo   r8
(1)  913/    1831 : B9                             phi   F9
(1)  914/    1832 : A9                             plo   F9
(1)  915/    1833 : 0F                  atof_lp1:  ldn   R15                    ; get next byte from buffer
(1)  916/    1834 : (MACRO)                        Ccall f_isnum                ; is it numeric
(1)  917/    1837 : CB 18 64                       lbnf  atof_no1              ; jump if not
(1)  918/    183A : 98                             ghi   r8                    ; copy arg1 to arg2
(1)  919/    183B : BA                             phi   R10
(1)  920/    183C : 88                             glo   r8
(1)  921/    183D : AA                             plo   R10
(1)  922/    183E : 99                             ghi   F9
(1)  923/    183F : BB                             phi   FB
(1)  924/    1840 : 89                             glo   F9
(1)  925/    1841 : AB                             plo   FB
(1)  926/    1842 : (MACRO)                        Ccall fp_shl_1                ; multiply arg1 by 2
(1)  927/    1845 : (MACRO)                        Ccall fp_shl_1                 ; multiply arg1 by 4
(1)  928/    1848 : (MACRO)                        Ccall fp_add_12                ; multiply arg1 by 5
(1)  929/    184B : (MACRO)                        Ccall fp_shl_1                ; multiply arg1 by 10
(1)  930/    184E : 4F                             lda   R15                    ; get number
(1)  931/    184F : FF 30                          smi   '0'                   ; convert to binary
(1)  932/    1851 : 52                             str   r2                    ; setup for add
(1)  933/    1852 : 89                             glo   F9                    ; add in next digit
(1)  934/    1853 : F4                             add
(1)  935/    1854 : A9                             plo   F9
(1)  936/    1855 : 99                             ghi   F9                    ; propagate carry
(1)  937/    1856 : 7C 00                          adci  0
(1)  938/    1858 : B9                             phi   F9
(1)  939/    1859 : 88                             glo   r8
(1)  940/    185A : 7C 00                          adci  0
(1)  941/    185C : A8                             plo   r8
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 45 - 11/23/2017 8:43:25


(1)  942/    185D : 98                             ghi   r8
(1)  943/    185E : 7C 00                          adci  0
(1)  944/    1860 : B8                             phi   r8
(1)  945/    1861 : C0 18 33                       lbr   atof_lp1              ; loop until no more digits
(1)  946/    1864 : 0F                  atof_no1:  ldn   R15                    ; check for decimal point
(1)  947/    1865 : FF 2E                          smi   '.'
(1)  948/    1867 : CA 18 6B                       lbnz  atof_ndp              ; jump if none
(1)  949/    186A : 1F                             inc   R15                    ; move past decimal
(1)  950/    186B : F8 19               atof_ndp:  ldi   scratch>>8          ; point to scratch area
(1)  951/    186D : BA                             phi   R10
(1)  952/    186E : F8 A3                          ldi   scratch&255
(1)  953/    1870 : AA                             plo   R10
(1)  954/    1871 : F8 10                          ldi   16                    ; 16 bytes to clear
(1)  955/    1873 : AC                             plo   R12
(1)  956/    1874 : F8 00               atof_lpx:  ldi   0
(1)  957/    1876 : 5A                             str   R10
(1)  958/    1877 : 1A                             inc   R10
(1)  959/    1878 : 2C                             dec   R12
(1)  960/    1879 : 8C                             glo   R12
(1)  961/    187A : CA 18 74                       lbnz  atof_lpx
(1)  962/    187D : F8 19                          ldi   (scratch+1)>>8      ; point to scratch area
(1)  963/    187F : BA                             phi   R10
(1)  964/    1880 : F8 A4                          ldi   (scratch+1)&255
(1)  965/    1882 : AA                             plo   R10
(1)  966/    1883 : F8 01                          ldi   1                     ; setup count
(1)  967/    1885 : AC                             plo   R12
(1)  968/    1886 : F8 00                          ldi   0                     ; setup exp flag
(1)  969/    1888 : BC                             phi   R12
(1)  970/    1889 : 8C                  atof_lp2:  glo   R12                    ; see if done making bcd
(1)  971/    188A : FF 11                          smi   17
(1)  972/    188C : C2 18 A5                       lbz   atof_dn3              ; jump if so
(1)  973/    188F : 0F                             ldn   R15                    ; get character
(1)  974/    1890 : (MACRO)                        ccall    f_isnum                 ; is it numeric
(1)  975/    1893 : CB 18 A5                       lbnf  atof_dn3              ; jump if not
(1)  976/    1896 : 4F                             lda   R15                    ; get character
(1)  977/    1897 : FF 30                          smi   '0'                   ; converto to binary
(1)  978/    1899 : 5A                             str   R10                    ; write into bcd area
(1)  979/    189A : 1A                             inc   R10
(1)  980/    189B : 1C                             inc   R12                    ; increment count
(1)  981/    189C : CA 18 89                       lbnz  atof_lp2              ; loop back until done
(1)  982/    189F : F8 01                          ldi   1                     ; set non zero flag
(1)  983/    18A1 : BC                             phi   R12
(1)  984/    18A2 : C0 18 89                       lbr   atof_lp2
(1)  985/    18A5 : 9C                  atof_dn3:  ghi   R12                    ; check for non-zero digits
(1)  986/    18A6 : CA 18 BF                       lbnz  atof_nz
(1)  987/    18A9 : 98                             ghi   r8                    ; check for non-zero integer
(1)  988/    18AA : CA 18 BF                       lbnz  atof_nz
(1)  989/    18AD : 88                             glo   r8
(1)  990/    18AE : CA 18 BF                       lbnz  atof_nz
(1)  991/    18B1 : 99                             ghi   F9
(1)  992/    18B2 : CA 18 BF                       lbnz  atof_nz
(1)  993/    18B5 : 89                             glo   F9
(1)  994/    18B6 : CA 18 BF                       lbnz  atof_nz
(1)  995/    18B9 : 60                             irx                         ; recover sign
(1)  996/    18BA : F0                             ldx
(1)  997/    18BB : B8                             phi   r8                    ; put in high of zero
(1)  998/    18BC : C0 19 92                       lbr	atof_end               ; and return
(1)  999/    18BF : F8 00               atof_nz:   ldi   0                     ; setup dp
(1) 1000/    18C1 : BC                             phi   R12
(1) 1001/    18C2 : 98                  atof_lp3:  ghi   r8                    ; check for high bit set
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 46 - 11/23/2017 8:43:25


(1) 1002/    18C3 : FA 80                          ani   080h
(1) 1003/    18C5 : CA 19 0F                       lbnz  atof_dn4              ; jump if so
(1) 1004/    18C8 : (MACRO)                        Ccall fp_shl_1                ; shift answer left
(1) 1005/    18CB : F8 19                          ldi   scratch>>8          ; point to bcd number
(1) 1006/    18CD : BA                             phi   R10
(1) 1007/    18CE : F8 A3                          ldi   255&scratch
(1) 1008/    18D0 : AA                             plo   R10
(1) 1009/    18D1 : F8 00                          ldi   0                     ; set high byte to zero
(1) 1010/    18D3 : 5A                             str   R10
(1) 1011/    18D4 : F8 19                          ldi   (scratch+15)>>8     ; point to last cell
(1) 1012/    18D6 : BA                             phi   R10
(1) 1013/    18D7 : F8 B2                          ldi   255&(scratch+15)
(1) 1014/    18D9 : AA                             plo   R10
(1) 1015/    18DA : F8 00                          ldi   0                     ; set carry forward
(1) 1016/    18DC : AE                             plo   R14
(1) 1017/    18DD : F8 10                          ldi   16                    ; setup count
(1) 1018/    18DF : AC                             plo   R12
(1) 1019/    18E0 : 8E                  atof_lp4:  glo   R14                    ; get carry
(1) 1020/    18E1 : 52                             str   r2                    ; in memory for add
(1) 1021/    18E2 : 0A                             ldn   R10                    ; get bcd digit
(1) 1022/    18E3 : F4                             add                         ; add in carry
(1) 1023/    18E4 : 52                             str   r2                    ; place into memory
(1) 1024/    18E5 : 0A                             ldn   R10                    ; recover bcd digit
(1) 1025/    18E6 : F4                             add                         ; digit now doubled with carry
(1) 1026/    18E7 : 5A                             str   R10                    ; put it back
(1) 1027/    18E8 : FF 0A                          smi   10
(1) 1028/    18EA : CB 18 F1                       lbnf  atof_no4              ; jump if below 10
(1) 1029/    18ED : 5A                             str   R10                    ; store value - 10
(1) 1030/    18EE : F8 01                          ldi   1                     ; carry set to 1
(1) 1031/    18F0 : C8                             lskp                        ; skip next instruction
(1) 1032/    18F1 : F8 00               atof_no4:  ldi   0                     ; reset carry
(1) 1033/    18F3 : AE                             plo   R14
(1) 1034/    18F4 : 2A                             dec   R10                    ; move to previous digit
(1) 1035/    18F5 : 2C                             dec   R12                    ; decrement digit count
(1) 1036/    18F6 : 8C                             glo   R12                    ; see if done
(1) 1037/    18F7 : CA 18 E0                       lbnz  atof_lp4              ; jump if not
(1) 1038/    18FA : F8 19                          ldi   scratch>>8	       ; point to first digit
(1) 1039/    18FC : BA                             phi   R10
(1) 1040/    18FD : F8 A3                          ldi   255&scratch
(1) 1041/    18FF : AA                             plo   R10
(1) 1042/    1900 : 0A                             ldn   R10                    ; retrieve it
(1) 1043/    1901 : C2 19 08                       lbz   atof_nc4              ; jump if no carry
(1) 1044/    1904 : 89                             glo   F9                    ; add in the carry
(1) 1045/    1905 : F9 01                          ori   1
(1) 1046/    1907 : A9                             plo   F9
(1) 1047/    1908 : 9C                  atof_nc4:  ghi   R12                    ; increment dp
(1) 1048/    1909 : FC 01                          adi   1
(1) 1049/    190B : BC                             phi   R12
(1) 1050/    190C : C0 18 C2                       lbr   atof_lp3              ; loop until full
(1) 1051/    190F : 9C                  atof_dn4:  ghi   R12                    ; get dp
(1) 1052/    1910 : 52                             str   r2                    ; into memory
(1) 1053/    1911 : F8 1F                          ldi   31                    ; need to subtract from 31
(1) 1054/    1913 : F7                             sm
(1) 1055/    1914 : FC 7F                          adi   127                   ; add in bias
(1) 1056/    1916 : BD                             phi   R13                    ; set aside
(1) 1057/    1917 : 99                             ghi   F9                    ; shift result down 8 bits
(1) 1058/    1918 : A9                             plo   F9
(1) 1059/    1919 : 88                             glo   r8
(1) 1060/    191A : B9                             phi   F9
(1) 1061/    191B : 98                             ghi   r8
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 47 - 11/23/2017 8:43:25


(1) 1062/    191C : FE                             shl                         ; shift out high bit
(1) 1063/    191D : A8                             plo   r8
(1) 1064/    191E : 9D                             ghi   R13                    ; get bit 0 of exponent
(1) 1065/    191F : F6                             shr
(1) 1066/    1920 : B8                             phi   r8                    ; bits 1-7 into high byte
(1) 1067/    1921 : 88                             glo   r8                    ; get mantissa
(1) 1068/    1922 : 76                             shrc                        ; shift in bit 0 of exponent
(1) 1069/    1923 : A8                             plo   r8                    ; and write it
(1) 1070/    1924 : 60                             irx                         ; point to sign
(1) 1071/    1925 : 98                             ghi   r8                    ; high byte
(1) 1072/    1926 : F1                             or                          ; set sign
(1) 1073/    1927 : B8                             phi   r8                    ; done with base conversion
(1) 1074/    1928 : 0F                             ldn   R15                    ; get next byte
(1) 1075/    1929 : FF 65                          smi   'e'                   ; check for exponents
(1) 1076/    192B : C2 19 34                       lbz   atof_exp
(1) 1077/    192E : 0F                             ldn   R15
(1) 1078/    192F : FF 45                          smi   'E'
(1) 1079/    1931 : CA 19 92                       lbnz  atof_end
(1) 1080/    1934 : 1F                  atof_exp:  inc   R15                    ; move past E
(1) 1081/    1935 : 0F                             ldn   R15                    ; check for sign
(1) 1082/    1936 : FF 2D                          smi   '-'
(1) 1083/    1938 : C2 19 45                       lbz   atof_n
(1) 1084/    193B : 0F                             ldn   R15
(1) 1085/    193C : FF 2B                          smi   '+'
(1) 1086/    193E : C2 19 42                       lbz   atof_p
(1) 1087/    1941 : 2F                             dec   R15                    ; positive if no sign
(1) 1088/    1942 : F8 01               atof_p:    ldi   1                     ; indicate positive exponent
(1) 1089/    1944 : C8                             lskp
(1) 1090/    1945 : F8 00               atof_n:    ldi   0                     ; indicate negative exponent
(1) 1091/    1947 : BC                             phi   R12                    ; place into sign variable
(1) 1092/    1948 : 1F                             inc   R15                    ; move past sign
(1) 1093/    1949 : F8 00                          ldi   0                     ; setup intial count
(1) 1094/    194B : AC                             plo   R12
(1) 1095/    194C : 0F                  atof_lp5:  ldn   R15                    ; get next byte
(1) 1096/    194D : (MACRO)                        Ccall f_isnum                ; see if numeric
(1) 1097/    1950 : CB 19 62                       lbnf  atof_dn5              ; jump if not
(1) 1098/    1953 : 8C                             glo   R12                    ; make copy of exponent
(1) 1099/    1954 : 52                             str   r2
(1) 1100/    1955 : F6                             shr                         ; multiply by 2
(1) 1101/    1956 : F6                             shr                         ; by 4
(1) 1102/    1957 : F4                             add                         ; by 5
(1) 1103/    1958 : F6                             shr                         ; by 10
(1) 1104/    1959 : 52                             str   r2                    ; put here for add
(1) 1105/    195A : 4F                             lda   R15                    ; recover number
(1) 1106/    195B : FF 30                          smi   '0'                   ; convert to binary
(1) 1107/    195D : F4                             add                         ; add with total
(1) 1108/    195E : AC                             plo   R12                    ; copy back to R12
(1) 1109/    195F : C0 19 4C                       lbr   atof_lp5              ; loop back until done reading exponent
(1) 1110/    1962 : 8C                  atof_dn5:  glo   R12                    ; see if done
(1) 1111/    1963 : C2 19 92                       lbz   atof_end              ; jump if so
(1) 1112/    1966 : 2C                             dec   R12                    ; otherwise decrement count
(1) 1113/    1967 : 8C                             glo   R12                    ; save count
(1) 1114/    1968 : 73                             stxd
(1) 1115/    1969 : 9C                             ghi   R12                    ; save sign
(1) 1116/    196A : 73                             stxd
(1) 1117/    196B : 8F                             glo   R15
(1) 1118/    196C : 73                             stxd
(1) 1119/    196D : 9F                             ghi   R15
(1) 1120/    196E : 73                             stxd
(1) 1121/    196F : F8 41                          ldi   041h                  ; setup 10.0
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(LCC1802fp.inc) - page 48 - 11/23/2017 8:43:25


(1) 1122/    1971 : BA                             phi   R10
(1) 1123/    1972 : F8 20                          ldi   020h
(1) 1124/    1974 : AA                             plo   R10
(1) 1125/    1975 : F8 00                          ldi   0
(1) 1126/    1977 : BB                             phi   FB
(1) 1127/    1978 : AB                             plo   FB
(1) 1128/    1979 : 9C                             ghi   R12
(1) 1129/    197A : C2 19 83                       lbz   atof_div              ; jump if negative
(1) 1130/    197D : (MACRO)                        Ccall fp_mul                 ; multiply by 10
(1) 1131/    1980 : C0 19 86                       lbr   atof_go5              ; clean up call
(1) 1132/    1983 : (MACRO)             atof_div:  Ccall fp_div                 ; divice by 10
(1) 1133/    1986 : 60                  atof_go5:  irx                         ; recover variables
(1) 1134/    1987 : 72                             ldxa
(1) 1135/    1988 : BF                             phi   R15
(1) 1136/    1989 : 72                             ldxa
(1) 1137/    198A : AF                             plo   R15
(1) 1138/    198B : 72                             ldxa
(1) 1139/    198C : BC                             phi   R12
(1) 1140/    198D : F0                             ldx
(1) 1141/    198E : AC                             plo   R12
(1) 1142/    198F : C0 19 62                       lbr   atof_dn5              ; loop until exponent is zero
(1) 1143/    1992 :                     atof_end:
(1) 1144/    1992 : 12                  	   inc	r2	;wjr release work area
(1) 1145/    1993 : (MACRO)             	   popr R13	;wjr restore param regs
(1) 1146/    1998 : (MACRO)             	   popr R12	;wjr
(1) 1147/    199D : (MACRO)             	   popr	F7	;wjr restore c variable
(1) 1148/    19A2 : (MACRO)             	   Cretn
(1) 1149/    19A3 : 00 00               scratch:   db	00,00
    1030/    19A5 :                     	include IO1802.inc
(1)    1/    19A5 :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/    19A5 :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/    19A5 :                     ;17-10-16 adding _putcpace(port,byte) to limit output speed to the AVR
(1)    4/    19A5 :                     ;         defaulting putc(x) to putcpace(7,x)
(1)    5/    19A5 :                     ;17-11-22 removing putc altogether
(1)    6/    19A5 :                     
(1)    7/    19A5 :                     _inp:		;raw port input
(1)    8/    19A5 :                     		;stores a small tailored program on the stack and executes it
(1)    9/    19A5 : 22                  	dec	sp	;work backwards
(1)   10/    19A6 : F8 D3               	ldi	0xD3	;return instruction
(1)   11/    19A8 : 73                  	stxd		
(1)   12/    19A9 : 8C                  	glo	regarg1	;get the port number
(1)   13/    19AA : FA 07               	ani	0x07	;clean it
(1)   14/    19AC : 32 BC               	bz	+	; inp(0) isn't valid
(1)   15/    19AE : F9 68               	ori	0x68	;make it an input instruction
(1)   16/    19B0 : 73                  	stxd		;store it for execution
(1)   17/    19B1 : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   18/    19B5 : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   19/    19B6 : D8                  	sep	rt1	;execute it
(1)   20/    19B7 :                     ;we will come back to here with the input byte in D
(1)   21/    19B7 : 12                  	inc	sp	;step over the work area
(1)   22/    19B8 : AF                  	plo	retVal	;save it to return
(1)   23/    19B9 : F8 00               	ldi	0
(1)   24/    19BB : BF                  	phi	retval	;clear top byte
(1)   25/    19BC : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   26/    19BD : 12                  	inc	sp	;and the D3
(1)   27/    19BE : (MACRO)             	Cretn		;and we're done
(1)   28/    19BF :                     	
(1)   29/    19BF :                     _out:		;raw port output
(1)   30/    19BF :                     		;stores a small tailored program on the stack and executes it
(1)   31/    19BF :                     		;this could be bolder:
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm(IO1802.inc) - page 49 - 11/23/2017 8:43:25


(1)   32/    19BF :                     		;store the program as 6x cc D5 where x is the port number and cc is the char
(1)   33/    19BF :                     		;then SEP sp
(1)   34/    19BF :                     		;the D5 would return to the calling program and finish fixing the stack.
(1)   35/    19BF :                     		;saves 6 instructions but it's a bit tricky.
(1)   36/    19BF : 22                  	dec	sp	;work backwards
(1)   37/    19C0 : F8 D3               	ldi	0xD3	;return instruction
(1)   38/    19C2 : 73                  	stxd		
(1)   39/    19C3 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the OUT instruction
(1)   40/    19C7 : 8C                  	glo	regarg1	;get the port number
(1)   41/    19C8 : FA 07               	ani	0x07	;clean it
(1)   42/    19CA : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   43/    19CC : 73                  	stxd		;store it for execution
(1)   44/    19CD : 8D                  	glo	regarg2	;get the byte to be written
(1)   45/    19CE : 52                  	str	sp	;store it where sp points
(1)   46/    19CF : D8                  	sep	rt1	;execute it
(1)   47/    19D0 :                     ;we will come back to here with sp stepped up by one
(1)   48/    19D0 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   49/    19D1 : 12                  	inc	sp	;and the D3
(1)   50/    19D2 : (MACRO)             	Cretn		;and we're done
(1)   51/    19D3 :                     	
(1)   52/    19D3 :                     	
(1)   53/    19D3 :                     
    1031/    19D3 :                     
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 50 - 11/23/2017 8:43:25


  symbol table (* = unused):
  ------------------------

 ADD_A1NZ :                    150A C |  ADD_A2NZ :                    151B C |
 ADD_FNL :                     15BF C |  ADD_LP1 :                     1562 C |
 ADD_LP1DN :                   1577 C |  ADD_NM :                      1586 C |
 ADD_NO :                      15A8 C |  ADD_NS :                      1550 C |
 ADD_NX :                      15EE C |  ADD_NZ :                      15E0 C |
 AGAIN190 :                     F45 C | *ARCHITECTURE :  i386-unknown-win32 - |
 ATOF_DIV :                    1983 C |  ATOF_DN3 :                    18A5 C |
 ATOF_DN4 :                    190F C |  ATOF_DN5 :                    1962 C |
 ATOF_END :                    1992 C |  ATOF_EXP :                    1934 C |
 ATOF_GO1 :                    182D C |  ATOF_GO5 :                    1986 C |
 ATOF_LP1 :                    1833 C |  ATOF_LP2 :                    1889 C |
 ATOF_LP3 :                    18C2 C |  ATOF_LP4 :                    18E0 C |
 ATOF_LP5 :                    194C C |  ATOF_LPX :                    1874 C |
 ATOF_N :                      1945 C |  ATOF_NC4 :                    1908 C |
 ATOF_NDP :                    186B C |  ATOF_NM :                     1823 C |
 ATOF_NO1 :                    1864 C |  ATOF_NO4 :                    18F1 C |
 ATOF_NZ :                     18BF C |  ATOF_P :                      1942 C |
 BAUDRATE :                     960 - | *BIGENDIAN :                      0 - |
 BITLOOP195 :                  11BA C | *BRANCHEXT :                      0 - |
 BVTABLE60 :                    11F C | *CASESENSITIVE :                  0 - |
 CHECK_SUB193 :                1096 C |  CKNEXT195 :                   1209 C |
 CKTOP195 :                    11A5 C |  CLRLP195 :                    1196 C |
 CODELOC :                        0 - |  COMPUTEQUOT190 :               F5B C |
*CONSTPI :        3.141592653589793 - |  CPUSPEED :                   F4240 - |
 CVFI4 :                       1400 C |  CVIF4 :                       1300 C |
*DATE :                  11/23/2017 - |  DCKLP195 :                    11BD C |
 DIV_A1NZ :                    160C C |  DIV_A2NZ :                    162A C |
 DIV_GO :                      168E C |  DIV_GO1 :                     167B C |
 DIV_LP :                      1668 C |  DIV_NOPE :                    16C9 C |
 DIV_Z :                       16DB C |  DNOADD195 :                   11C5 C |
 DONE191 :                      FBC C |  DONE194 :                     1176 C |
 DONE195 :                     1213 C |  DONE201 :                     136F C |
 DONE202 :                     1461 C |  DSHLP195 :                    11D9 C |
 ENDLP192 :                    1061 C |  F7 :                             7 - |
 F9 :                             9 - |  FAILS :                       146E C |
*FALSE :                          0 - |  FB :                             B - |
 FP_ADD :                      14F1 C |  FP_ADD_12 :                   148C C |
 FP_ATOF :                     180F C |  FP_DIV :                      15FB C |
 FP_GETEXP :                   14DF C |  FP_GETSGN :                   14EA C |
 FP_MUL :                      16EB C |  FP_SC_CLN :                   14C0 C |
 FP_SC_UP :                    14B0 C |  FP_SHL_1 :                    147F C |
 FP_SHR_1 :                    1472 C |  FP_SHR_FD :                   14A3 C |
 FP_SUB :                      15F4 C | *FULLPMMU :                       1 - |
 F_ISNUM :                     1462 C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*L1 :                            22 C | *L10 :                           E9 C |
 L101 :                         A09 C |  L102 :                         A24 C |
 L103 :                         9F5 C | *L105 :                         A56 C |
*L106 :                         C64 C |  L107 :                         DA2 C |
 L108 :                         C61 C | *L109 :                         C61 C |
 L11 :                           D3 C | *L111 :                         CCF C |
 L112 :                         C94 C |  L113 :                         CB2 C |
 L115 :                         CCB C | *L116 :                         D27 C |
 L117 :                         D04 C |  L118 :                         D12 C |
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 51 - 11/23/2017 8:43:25


*L12 :                           D6 C | *L120 :                         D70 C |
 L121 :                         D50 C |  L122 :                         D5B C |
*L124 :                         DA1 C |  L14 :                           D7 C |
*L15 :                          130 C |  L17 :                          1A1 C |
 L18 :                          148 C | *L19 :                          192 C |
 L21 :                          195 C |  L22 :                          185 C |
 L25 :                          178 C |  L26 :                          17E C |
 L27 :                          192 C | *L29 :                          1C2 C |
 L3 :                           DB4 C |  L30 :                          1B6 C |
 L31 :                          1B8 C | *L33 :                          1EA C |
 L34 :                          1D7 C |  L35 :                          1E4 C |
*L38 :                          4AE C |  L39 :                          2F5 C |
 L4 :                            1F C |  L40 :                          300 C |
 L41 :                          DB0 C |  L42 :                          DAC C |
 L43 :                          300 C |  L45 :                          340 C |
 L47 :                          4A2 C | *L49 :                          637 C |
*L5 :                            1F C |  L50 :                          579 C |
 L51 :                          589 C |  L52 :                          592 C |
 L53 :                          614 C |  L55 :                          599 C |
*L56 :                          599 C |  L58 :                          5A4 C |
 L59 :                          603 C |  L62 :                          5CD C |
*L63 :                          70D C |  L64 :                          6C7 C |
*L66 :                          75C C | *L67 :                          7B6 C |
*L68 :                          823 C | *L69 :                          8B6 C |
*L7 :                            B9 C |  L70 :                          891 C |
 L71 :                          8B6 C | *L72 :                          934 C |
*L73 :                          C21 C |  L74 :                          983 C |
 L75 :                          C1B C |  L77 :                          997 C |
 L78 :                          C1B C |  L80 :                          C0A C |
 L81 :                          C1B C |  L83 :                          A71 C |
 L84 :                          A83 C |  L85 :                          A9B C |
 L86 :                          AC4 C |  L87 :                          AD9 C |
 L88 :                          ADD C |  L89 :                          B10 C |
 L90 :                          BCE C |  L92 :                          B41 C |
 L94 :                          B6B C |  L95 :                          BC9 C |
 L96 :                          BCE C |  L97 :                          C0A C |
 L99 :                          BEE C |  LCC1802INIT :                  DBD C |
*LISTON :                         1 - |  LOOP192 :                     100F C |
 LSH202 :                      142B C | *MACEXP :                         0 - |
 MEMADDR :                        E - |  MLOOP193 :                    1077 C |
 MOMCPU :                      1802 - | *MOMCPUNAME :                  1802 - |
 MSLP188 :                      E22 C |  MULRDONE189 :                  F24 C |
 MULRLP189 :                    F04 C |  MULRNOADD189 :                 F16 C |
 MULRSHFT189 :                  F1C C |  MUL_DN :                      17B7 C |
 MUL_GO1 :                     173F C |  MUL_LP1 :                     172F C |
 MUL_LP2 :                     17CA C |  MUL_LP2A :                    17DD C |
 MUL_LP3 :                     17E6 C |  MUL_LP3A :                    17F9 C |
 MUL_LP4 :                     180A C |  MUL_NO :                      178C C |
 MUL_NXT1 :                    17E1 C | *NESTMAX :                      100 - |
 NEY0Y190 :                     F74 C |  NORESTORE192 :                105D C |
 NXT201 :                      1330 C |  OUT190 :                       F82 C |
 OUTIT60 :                      11C C | *PACKING :                        0 - |
*PADDING :                        1 - | *PASSES :                      146B C |
 POS1191 :                      F9A C |  POS1194 :                     1126 C |
 POS2191 :                      FAA C |  POS2194 :                     114D C |
 R0 :                             0 - |  R1 :                             1 - |
 R10 :                            A - |  R11 :                            B - |
 R12 :                            C - |  R13 :                            D - |
 R14 :                            E - |  R15 :                            F - |
 R2 :                             2 - |  R3 :                             3 - |
 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 52 - 11/23/2017 8:43:25


*R4 :                             4 - | *R5 :                             5 - |
 R6 :                             6 - |  R7 :                             7 - |
 R8 :                             8 - |  R9 :                             9 - |
 RCALL :                          4 - |  REGARG1 :                        C - |
 REGARG2 :                        D - | *RELAXED :                        1 - |
 RETADDR :                        6 - |  RETVAL :                         F - |
*RL0 :                            1 - |  RL10 :                           B - |
 RL12 :                           D - |  RL6 :                            7 - |
 RL8 :                            9 - |  RP1P2 :                          D - |
 RPC :                            3 - |  RRET :                           5 - |
 RT1 :                            8 - | *RT2 :                            9 - |
 RWORK :                          E - |  SCRATCH :                     19A3 C |
 SETBITOFF60 :                  117 C |  SETSGN201 :                   1368 C |
 SGNPOS201 :                   1339 C |  SHDN201 :                     135F C |
 SHIFT193 :                    10AE C |  SHL201 :                      134B C |
 SHR202 :                      1419 C |  SIGN202 :                     143B C |
 SP :                             2 - |  STACKLOC :                    7FFF - |
 SUBOVHD :                       1B - |  TESTEXIT190 :                  F6A C |
*TIME :                     8:43:24 - | *TRUE :                           1 - |
 UPNXT195 :                    11F2 C | *VERSION :                     142F - |
 _00000179 :                    DD7 C |  _CALL :                        E01 C |
*_DELAY :                        BA C |  _DIE179 :                      DDA C |
*_DIGITALREAD :                 128 C | *_DIGITALWRITE :                100 C |
 _DIVI2 :                       F8B C |  _DIVI4 :                      1100 C |
 _DIVU2 :                       F25 C |  _DIVU4 :                      1000 C |
 _DUBDABX :                    1177 C | *_EXIT :                        C3B C |
 _FTOA :                        234 C | *_GETCSER :                      80 C |
 _GETCSER.RXCLOOP :              8A C |  _GETCSER.RXCRET :               A6 C |
 _GETCSER.RXCW :                 85 C | *_INCLUDESER :                   29 C |
*_INP :                        19A5 C |  _ITOA :                        4D0 C |
 _LTOA :                        64F C |  _MAIN :                          4 C |
*_MEMCMP :                      C69 C | *_MEMCPY :                      CE1 C |
*_MEMSET :                      D35 C | *_MODI2 :                       DEB C |
*_MODI4 :                      1220 C | *_MODU2 :                       DE3 C |
*_MODU4 :                      1214 C |  _MULT_NUMS :                   214 C |
*_MULU2 :                       F00 C | *_MULU4 :                      1066 C |
*_NSTDLIBINCLUDER :             D7A C | *_OLDUINOINCLUDER :              F7 C |
 _ONEMS :                       E20 C | *_OUT :                        19BF C |
*_OUT4 :                        DF3 C |  _PIN4 :                          3 C |
 _PRINTF :                      939 C |  _PRINTFLT :                    7BF C |
 _PRINTINT :                    723 C |  _PRINTLINT :                   765 C |
 _PRINTSTR :                    1C8 C |  _PUTCSER :                      40 C |
 _PUTCSER.TXCLOOP :              46 C |  _PUTCSER.TXCRET :               62 C |
 _PUTX :                        8BB C |  _PUTXN :                       82C C |
 _RETURN :                      E11 C |  _ROUND_NUMS :                  1F4 C |
*_SETQOFF :                     DE1 C | *_SETQON :                      DDF C |
*_STRCMP :                      D8A C |  _STRCPY :                      D80 C |
 _STRLEN :                      1AB C | *_STRNCMP :                     131 C |
 __FORW0 :                      12F C |  __FORW8 :                     19BC C |
*__FORW9 :                     19D0 C |  __STRCMPGT :                   D9F C |
 __STRCMPLP :                   D8F C |  __STRCMPNE :                   D9A C |
 __STRCPY :                     D84 C |

    337 symbols
     83 unused symbols

 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 53 - 11/23/2017 8:43:25


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU2RRS                               | ALU4                                 
ALU4I                                 | BITDELAY                             
BLKCPY                                | CCALL                                
CPY1                                  | CPY2                                 
CPY4                                  | CRETN                                
DECM                                  | DEMOTE                               
INC4                                  | INCM                                 
JCF4                                  | JCI2                                 
JCI2I                                 | JCI4                                 
JCU2                                  | JCU2I                                
JCU4                                  | JEQI1                                
JEQI2                                 | JEQI4                                
JEQU1I                                | JEQU2I                               
JNEU1I                                | JNEU2                                
JNEU2I                                | JNEU2NI                              
JNEU4                                 | JNI2I                                
JNU2I                                 | JNZU1                                
JNZU2                                 | JUMPV                                
JZU1                                  | JZU2                                 
LD1                                   | LD2                                  
LD2Z                                  | LD4                                  
LDA2                                  | LDAD                                 
LDAX                                  | LDAXS                                
LDI4                                  | LDIREG                               
LDN1                                  | LDN2                                 
LDN2S                                 | MVC1                                 
MVC2                                  | MVCN1                                
MVCN2                                 | NEGI2                                
NEGI4                                 | NOP1806                              
POPF                                  | POPL                                 
POPM                                  | POPR                                 
PUSHR                                 | RELEASE                              
RELEASEL                              | RELEASES                             
RESERVE                               | RESERVEL                             
RESERVES                              | SEXT                                 
SEXT4                                 | SHL2                                 
SHL2I                                 | SHL2R                                
SHL4                                  | SHL4I                                
SHL4R                                 | SHLC4                                
SHLR2R                                | SHRC4                                
SHRI2                                 | SHRI2I                               
SHRI2R                                | SHRI4                                
SHRI4I                                | SHRI4R                               
SHRU2                                 | SHRU2I                               
SHRU2R                                | SHRU4                                
SHRU4I                                | SHRU4R                               
ST1                                   | ST2                                  
ST2I                                  | ST4                                  
STR1                                  | STR1I                                
STR2                                  | STR2I                                
TESTSUB                               | XUSHF                                
XUSHL                                 | XUSHM                                
ZEXT                                  | ZEXT4                                

    108 macros

 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 54 - 11/23/2017 8:43:25


 AS V1.42 Beta [Bld 87] - source file VserialNW2.oasm - page 55 - 11/23/2017 8:43:25


  codepages:
  ----------

STANDARD (0 changed characters)


0.22 seconds assembly time

   3963 lines source file
   9231 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
