; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Thu Nov 23 08:43:24 2017
SP:	equ	2 ;stack pointer
memAddr: equ	14
retAddr: equ	6
retVal:	equ	15
regArg1: equ	12
regArg2: equ	13
	listing off
	RELAXED ON
;definitions and prolog functions needed for smc1802 programs (Hi Bill)
;dec 21 packaged version for the christmas compiler (Ho Ho Ho)
;Dec 24 fixed shift macros to use memaddr as a work register and not corrupt the shift count
;jan 6 fixed shift left macro as above
;jan 11 saving as lcc1802epiloNG.inc for the NG compiler
;jan 12 minor correction to rldmi
;jan 14 minor correction to ldi4
;jan 16 adding shri4I
;jan20 correct error in shl2r
;jan21 moved 4 byte macros to bottom and added shrc4
;Jan 28 archived before beginning work on Birthday Compiler
;Feb 7 adding nointerrupts/interrupts to control interruptability
;Feb 13 changing address mode macros
;Feb 14 removing nointerrupts, adding reserve/release for stack frame, ld2z macro
;Mar 3 changing reserve/release to use inc/dec for 8 or less bytes
;Mar 4 adding incm macro for multiple increments
;mar 5 adding jzi2 macro to speed up if processing
;mar 6 adding ldn1, str1 for register indirect addressing
;mar 17 adding decm macro
;mar 28 adding jumpv macro
;may 15 adding jnzu1, jzu1 macros
;june 21 adding demote macro
;Oct 2, 2013 DH version for dhrystone optimization 
;Oct 2, 2013 added str2 macro 2 byte store at addr pointed to by register
;oct 4,	added st2i 2 byte immediate sore, pushf,pushm,pushl sequences, 
;oct 24, added ldaXs for stack pointed addresses, added mvcn1, mvc1 for 1 byte storage to storage moves, jneu1i for single byte immediate compare
;Feb 17 2014 added "inc sp" to restore stack pointer in jeqI1, affected strncmp.
;Feb 18 2017 added org to LCCCODELOC to allow for non-zero origin
;Feb 19 2017 beginning to adapt for 1806
;17-03-06 remove inc/dec from ccall, cretn6, add inc to popr
;17-03-07 add popf,popm,popl for optimization
;17-03-14 removed savemi, rldmi,cretn6
;17-03-27 added jequ1i
;17-10-17 compatability with clean stack discipline
;         changed pushr, removed pushf pushr pushm, removed many dec/inc sp's for work areas
;17-10-19 changed LCCCODELOC to CODELOC
	org	CODELOC		;wjr 17-02-18 allow code relocation
R0:	equ	0
R1:	equ	1
R2:	equ	2
R3:	equ	3
R4:	equ	4
R5:	equ	5
R6:	equ	6
R7:	equ	7
R8:	equ	8
R9:	equ	9
R10:	equ	10
R11:	equ	11
R12:	equ	12
R13:	equ	13
R14:	equ	14
R15:	equ	15
RL0:	equ	1 ;long register pairs are identified by their odd numbered register
RL6:	equ	7 
RL8:	equ	9 ;temp 1
RL10:	equ	11;temp 2
RL12:	equ	13 ;return value register for longs
Rp1p2:	equ	13 ;argument register for longs
Rt1:	equ	8  ;1st temp register
Rt2:	equ	9  ;2nd temp register
RCALL:	equ 	4 ;standard call routine
RRET:	equ 	5 ;standard return register
RPC:	equ 	3 ; standard program counter
;	listing	off
	macexp off	;this seems to have to go before the definitions
;macro definitions
;more natural 1802 macros
	listing	on
	lbr	lcc1802Init
	listing on
_PIN4:
	db 0
;$$function start$$ _main
_main: ;copt is peeping your size 8 frame with oct 23 rules
        dec sp
        dec sp
        dec sp
        dec sp
        dec sp
        dec sp
;void main(){
;	unsigned char cin='?';
;Oct 13 (5+1) added to ldAD call
        glo     SP
        adi     ((5+1))#256
        plo     R11
        ghi     SP
        adci    ((5+1))>>8; was/256
        phi     R11
        ldi     63
        str     R11
;	asm(" seq\n"); //make sure Q is high to start
;		printf("UUUUUUUU");
 seq
        ldi     (L3)&255
        plo     R12
        ldi     (L3)>>8; was/256
        phi     R12
        sep     RCALL
        dw      _PRINTF
L4:
;	while(1);
L5:
	lbr L4
;}
L1:
        inc sp
        inc sp
        inc sp
        inc sp
        inc sp
        inc sp
        sep     RRET
;$$function end$$ _main
;$$function start$$ _includeser
_includeser:		;framesize=2
;void includeser(){
;	asm("BAUDRATE EQU 2400\n");
;	asm(" include VELFserial3.inc\n");
BAUDRATE EQU 2400
;**********************************************************************
;bit-bang Serial routines adapted from Josh Bensadon's VELFbios-v3.1.asm
;Transmit Byte via Q connected to RS232 driver
;call via SCRT
;Byte to send in r12.0
;Destroys r14
;17-11-22 regoobered to 
;----------------------------------------------------------------------
	align 32
_putcser:		;entry from C program with character in reg 12
	ldi 9		;9 bits to transmit (1 start + 8 data)
	plo r14
	glo r12
	shl		;set start bit
	rshr		;DF=0
.txcloop:
	bdf $+5		;10.5   jump to seq to send a 1 bit
	req		;11.5   send a 0 bit
	br $+5		;1      jump +5 to next shift
	seq		;11.5   send a 1 bit
	br $+2		;1      jump +2 to next shift (NOP for timing)
	rshr		;2      shift next bit to DF flag
	phi r14		;3      save D in r14.1
	DEC r14		;4      dec bit count
	glo r14		;5      get bit count
	bz .txcret	;6      if 0 then all 9 bits (start and data) sent
	ghi r14		;7      restore D
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        sex 2
	br .txcloop	;9.5    loop back to send next bit
.txcret: ghi r14		;7
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
	seq		;11.5 stop bit
        sep     RRET
;**********************************************************************
;rx_char
;Receive Byte via EF3 connected to RS232 receiver
;Receives 8 bits
;call via SCRT
;Returns with Byte received in D and rf.0
;Destroys r14.0
;----------------------------------------------------------------------
	align 64
_getcser:
 	ldi 8		;start bit +7 bits from loop, last bit on returning
	plo r14
	ldi 0
.rxcw:			;wait for start bit
	;bn4 $+4		;loop while high
	;br  RomLoad
	bn3 .rxcw	;each instr takes 9us, we need 104us = 11.5
			;delay 1/2 bit time to center samples
	NOP		;     Don't test for correct start bit
	NOP		;     it will work. if there's too much
	NOP		;     noise on the line, shorten the cable!
.rxcloop:
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        sex 2
	b3 $+6		;11.5 sample rx input bit
	ori 80h		;1
	br $+4		;2
	phi r14		;1
	phi r14		;2
	shr		;3
	phi r14		;4
	DEC r14		;5
	glo r14		;6
	bz .rxcret	;7
	ghi r14		;8
	br  .rxcloop	;9
.rxcret: ghi r14	;8
	ghi r14		;9
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        NOP
        sex 2
	b3 $+4		;11.5 sample last rx input bit
	ori 80h		;1
	plo r15
        sep     RRET
;}
L7:
        sep     RRET
;$$function end$$ _includeser
;$$function start$$ _delay
_delay:		;framesize=10
        glo     R6
        stxd
        ghi     R6
        stxd
        glo     R7
        stxd
        ghi     R7
        stxd
        dec sp
        dec sp
        dec sp
        dec sp
        glo     R12
        plo     R7
        ghi     R12
        phi     R7
;void delay(unsigned int howlong){
;	for (i=1;i!=howlong;i++){
        ldi     (1)&255
        plo     R6
        ldi     (1)>>8; was/256
        phi     R6
	lbr L14
L11:
;		oneMs();
        sep     RCALL
        dw      _ONEMS
;	}
L12:
;	for (i=1;i!=howlong;i++){
        inc     R6
L14:
        dec     sp
        glo     R7
        str     sp
        glo     R6
        sm
        inc     sp
        lbnz    L11
        dec     sp
        ghi     R7
        str     sp
        ghi     R6
        smb
        inc     sp
        lbnz    L11
;}
L10:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        lda     sp
        phi     R7
        lda     sp
        plo     R7
        lda     sp
        phi     R6
        ldn     sp
        plo     R6
        sep     RRET
;$$function end$$ _delay
;$$function start$$ _olduinoincluder
_olduinoincluder:		;framesize=2
;void olduinoincluder(){
;	asm("\tinclude olduino.inc\n");
;Feb 8 2013, first version of assembler routines for olduino support	
;may 31 - incredibly, there's an error in digitalWrite.  lda2 changed to ldAD
;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
	align 64	;needed to make sure all on same page
_digitalWrite:
	glo regArg1	;get the bit number
	adi $$bvtable&255	;add the table offset
	plo memaddr
	ghi RPC		;get the top byte of the current page
	phi memaddr	
	ldn memaddr	;pick up the bit pattern
	plo rt1		;save it in a temp
        ldi     (_PIN4)&255
        plo     MEMADDR
        ldi     (_PIN4)>>8; was/256
        phi     MEMADDR
	sex memaddr	;prepare to change it
	glo regArg2	;get on/off switch
	bz $$setbitoff
; here we have the bit pattern in rt1 and we're ready to apply it with OR
	glo rt1		;get the bit value back
	or		;apply it
	str memaddr	;and save it
	br $$outit	;go fnish up
$$setbitoff:
	glo rt1		;get the bit pattern
	xri 0xff	;reverse it
	and		;combine it with the existing pin value
	str memaddr	;and save it
;here we gave set/reset the correct bit in PIN4 and we just have to send it out
$$outit:
	out 4		;X was already set to memaddr
	sex sp		;reset X
        sep     RRET
$$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
;int digitalRead(unsigned char pin){//for now this will always read ef3
	align 8	;protect jump boundary
_digitalRead:
	ldi 0		;default is false
	plo R15
	phi R15
	b3 +		;i have to reverse the sense of the external line
	inc R15		;if external line is high, supply a 1
        sep     RRET
;}
L15:
        sep     RRET
;$$function end$$ _olduinoincluder
;$$function start$$ _strncmp
_strncmp:		;framesize=6
        glo     R6
        stxd
        ghi     R6
        stxd
        glo     R7
        stxd
        ghi     R7
        stxd
        glo     SP
        adi     ((10+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((10+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R7
        ldn     memAddr
        plo     R7
;{
;    for ( ; n > 0; s1++, s2++, --n)
	lbr L21
L18:
;	if (*s1 != *s2)
        ldn     R12
        plo     R11
        ldn     R13
        plo     R10
        glo     R10
        str     sp
        glo     R11
        sm
        lbz     L22
;	    return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1);
        ldn     R12
        plo     R11
        ldi     0
        phi     R11
        ldn     R13
        plo     R10
        ldi     0
        phi     R10
        glo     R10
        str     sp 
        glo     R11
        sm
        ghi     R10
        str     sp
        ghi     R11
        smb          ;that's a standard signed subtraction
        ghi     R11 ;
        xor           ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBDF    L25  ;execute 
        ldi     (-1)&255
        plo     R6
        ldi     (-1)>>8; was/256
        phi     R6
	lbr L26
L25:
        ldi     (1)&255
        plo     R6
        ldi     (1)>>8; was/256
        phi     R6
L26:
        glo     R6
        plo     R15
        ghi     R6
        phi     R15
	lbr L17
L22:
;	else if (*s1 == '\0')
        ldn     R12
        plo     R11
        glo     R11
        lbnz    L27
;	    return 0;
        ldi     0
        plo     R15
        phi     R15
	lbr L17
L27:
L19:
;    for ( ; n > 0; s1++, s2++, --n)
        inc     R12
        inc     R13
        dec     R7
L21:
        glo     R7
        lbnz    L18
        ghi     R7
        lbnz    L18
;    return 0;
        ldi     0
        plo     R15
        phi     R15
L17:
        inc     sp
        lda     sp
        phi     R7
        lda     sp
        plo     R7
        lda     sp
        phi     R6
        ldn     sp
        plo     R6
        sep     RRET
;$$function end$$ _strncmp
;$$function start$$ _strlen
_strlen:		;framesize=4
        glo     R7
        stxd
        ghi     R7
        stxd
;{
;	unsigned int slen = 0 ;
        ldi     0
        plo     R7
        phi     R7
	lbr L31
L30:
;	while (*str != 0) {
;      slen++ ;
        inc     R7
;      str++ ;
        inc     R12
;   }
L31:
;	while (*str != 0) {
        ldn     R12
        plo     R11
        glo     R11
        lbnz    L30
;   return slen;
        glo     R7
        plo     R15
        ghi     R7
        phi     R15
L29:
        inc     sp
        lda     sp
        phi     R7
        ldn     sp
        plo     R7
        sep     RRET
;$$function end$$ _strlen
;$$function start$$ _printstr
_printstr:		;framesize=8
        glo     R7
        stxd
        ghi     R7
        stxd
        dec sp
        dec sp
        dec sp
        dec sp
        glo     R12
        plo     R7
        ghi     R12
        phi     R7
;void printstr(char *ptr){
	lbr L35
L34:
;    while(*ptr){
;		putc(*ptr++); //jan 29
        glo     R7
        plo     R11
        ghi     R7
        phi     R11
        inc     R7
        ldn     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTCSER
;		asm(" nop1806\n nop1806\n nop1806\n"); //17-03-09
;	}
L35:
;    while(*ptr){
        ldn     R7
        plo     R11
        glo     R11
        lbnz    L34
;}
L33:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        lda     sp
        phi     R7
        ldn     sp
        plo     R7
        sep     RRET
;$$function end$$ _printstr
	align 4
_round_nums:
	dd 0x3f000000
	dd 0x3d4ccccd
	dd 0x3ba3d70a
	dd 0x3a03126f
	dd 0x3851b717
	dd 0x36a7c5ac
	dd 0x350637bd
	dd 0x3356bf95
	align 4
_mult_nums:
	dd 0x3f800000
	dd 0x41200000
	dd 0x42c80000
	dd 0x447a0000
	dd 0x461c4000
	dd 0x47c35000
	dd 0x49742400
	dd 0x4b189680
;$$function start$$ _ftoa
_ftoa:		;framesize=80
;this calculation looks awkward but we're adjusting the top byte of sp first 
;so if there's an interrupt in mid calculation the sp will be pointing to free memory
        glo sp          ;grab low byte of stack pointer
        smi 62&255 ;claculate new low byte
        plo memAddr     ;save it for a moment
        ghi sp          ;grab high byte
        smbi (62>>8)&255 ;calculate the new page
        phi sp          ;adjust page first
        glo memAddr     ;get new low byte
        plo sp          ;finish adjusting the stack pointer
        glo     R0
        stxd
        ghi     R0
        stxd
        glo     R1
        stxd
        ghi     R1
        stxd
        glo     R6
        stxd
        ghi     R6
        stxd
        glo     R7
        stxd
        ghi     R7
        stxd
        dec sp
        dec sp
        dec sp
        dec sp
        dec sp
        dec sp
        dec sp
        dec sp
        glo     RL12
        plo     RL6
        ghi     RL12
        phi     RL6
        glo     RL12-1
        plo     RL6-1
        ghi     RL12-1
        phi     RL6-1
        glo     SP
        adi     ((86+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((86+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R1
        ldn     memAddr
        plo     R1
;{
;   char *output = outbfr ;
        glo     SP
        adi     ((84+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((84+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R0
        ldn     memAddr
        plo     R0
;   if (flt < 0.0) {
        ldi     ((L41))&255
        plo     MEMADDR
        ldi     ((L41))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RL10-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RL10-1
        lda     memAddr
        phi     RL10
        ldn     memAddr
        plo     RL10
        ghi     RL6-1          ;see if first arg is -v
        shl
        lbnf    $$comp          ;if at least 1 reg positive, just compare
        ghi     RL10-1          ;check 2nd reg
        shl
        lbdf    $$rcomp
        dec     sp ;make a work area
        glo     RL10    ;lowest order byte
        str     sp 
        glo     RL6
        sm
        ghi     RL10
        str     sp
        ghi     RL6
        smb          ;that's a standard signed subtraction of one reg
        glo     RL10-1  ;lowest order byte of the top register
        str     sp 
        glo     RL6-1
        smb
        ghi     RL10-1
        str     sp
        ghi     RL6-1
        smb          ;that's a standard signed subtraction of a double register
        ghi     RL6-1 ;
        xor           ;sets the top bit if the signs are different
        inc     sp ;release the work area
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBDF    L39  ;execute 
        lbr     $$done
        dec     sp ;make a work area
        glo     RL6    ;lowest order byte
        str     sp 
        glo     RL10
        sm
        ghi     RL6
        str     sp
        ghi     RL10
        smb          ;that's a standard signed subtraction of one reg
        glo     RL6-1  ;lowest order byte of the top register
        str     sp 
        glo     RL10-1
        smb
        ghi     RL6-1
        str     sp
        ghi     RL10-1
        smb          ;that's a standard signed subtraction of a double register
        ghi     RL10-1 ;
        xor           ;sets the top bit if the signs are different
        inc     sp ;release the work area
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBDF    L39  ;execute 
$$done:
;      *output++ = '-' ;
        glo     R0
        plo     R11
        ghi     R0
        phi     R11
        inc     R0
        ldi     45
        str     R11
;      flt *= -1.0 ;
        ldi     ((L42))&255
        plo     MEMADDR
        ldi     ((L42))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RL8-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RL8-1
        lda     memAddr
        phi     RL8
        ldn     memAddr
        plo     RL8
        glo     RL6
        plo     RL10
        ghi     RL6
        phi     RL10
        glo     RL6-1
        plo     RL10-1
        ghi     RL6-1
        phi     RL10-1
        sep     RCALL
        dw      FP_MUL
        glo     RL8
        plo     RL6
        ghi     RL8
        phi     RL6
        glo     RL8-1
        plo     RL6-1
        ghi     RL8-1
        phi     RL6-1
;   } else {
	lbr L40
L39:
;      if (use_leading_plus) {
	lbr L43
;         *output++ = '+' ;
        glo     R0
        plo     R11
        ghi     R0
        phi     R11
        inc     R0
        ldi     43
        str     R11
;      }
L43:
;   }
L40:
;   if (dec_digits < 8) {
        glo     R1
        smi     (8)#256
        ghi     R1
        smbi    (8)>>8; was/256      ;that's a standard signed subtraction
        ghi     R1 ;
        xri     (8)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBDF    L45  ;execute 
;      flt += round_nums[dec_digits] ;
        glo     RL6
        plo     RL8
        ghi     RL6
        phi     RL8
        glo     RL6-1
        plo     RL8-1
        ghi     RL6-1
        phi     RL8-1
        glo     R1
        shl
        plo     R11
        ghi     R1
        shlc
        phi     R11
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        adi     ((_ROUND_NUMS))#256
        plo     MEMADDR
        ghi     R11
        adci    ((_ROUND_NUMS))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RL10-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RL10-1
        lda     memAddr
        phi     RL10
        ldn     memAddr
        plo     RL10
        sep     RCALL
        dw      FP_ADD
        glo     RL8
        plo     RL6
        ghi     RL8
        phi     RL6
        glo     RL8-1
        plo     RL6-1
        ghi     RL8-1
        phi     RL6-1
;   }
L45:
;	mult=mult_nums[dec_digits];
        glo     R1
        shl
        plo     R11
        ghi     R1
        shlc
        phi     R11
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        adi     ((_MULT_NUMS))#256
        plo     MEMADDR
        ghi     R11
        adci    ((_MULT_NUMS))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RL10-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RL10-1
        lda     memAddr
        phi     RL10
        ldn     memAddr
        plo     RL10
        glo     SP
        adi     ((68+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((68+1))>>8; was/256
        phi     MEMADDR
        ghi     RL10-1   ;long register pairs are addressed by their second member
        str     memAddr ;but load and store start with the 1st
        inc     memAddr
        glo     RL10-1
        str     memAddr
        inc     memAddr
        ghi     RL10
        str     memAddr
        inc     memAddr
        glo     RL10
        str     memAddr
;   wholeNum = flt;
        glo     RL6
        plo     RL8
        ghi     RL6
        phi     RL8
        glo     RL6-1
        plo     RL8-1
        ghi     RL6-1
        phi     RL8-1
        sep     RCALL
        dw      CVFI4
        glo     SP
        adi     ((72+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((72+1))>>8; was/256
        phi     MEMADDR
        ghi     RL8-1   ;long register pairs are addressed by their second member
        str     memAddr ;but load and store start with the 1st
        inc     memAddr
        glo     RL8-1
        str     memAddr
        inc     memAddr
        ghi     RL8
        str     memAddr
        inc     memAddr
        glo     RL8
        str     memAddr
;   decimalNum = ((flt - wholeNum) * mult);
        glo     RL6
        plo     RL8
        ghi     RL6
        phi     RL8
        glo     RL6-1
        plo     RL8-1
        ghi     RL6-1
        phi     RL8-1
        glo     SP
        adi     ((16+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((16+1))>>8; was/256
        phi     MEMADDR
        ghi     RL8-1   ;long register pairs are addressed by their second member
        str     memAddr ;but load and store start with the 1st
        inc     memAddr
        glo     RL8-1
        str     memAddr
        inc     memAddr
        ghi     RL8
        str     memAddr
        inc     memAddr
        glo     RL8
        str     memAddr
        glo     SP
        adi     ((72+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((72+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RL8-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RL8-1
        lda     memAddr
        phi     RL8
        ldn     memAddr
        plo     RL8
        sep     RCALL
        dw      CVIF4
        glo     RL8
        plo     RL10
        ghi     RL8
        phi     RL10
        glo     RL8-1
        plo     RL10-1
        ghi     RL8-1
        phi     RL10-1
        glo     SP
        adi     ((16+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((16+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RL8-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RL8-1
        lda     memAddr
        phi     RL8
        ldn     memAddr
        plo     RL8
        sep     RCALL
        dw      FP_SUB
        glo     SP
        adi     ((68+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((68+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RL10-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RL10-1
        lda     memAddr
        phi     RL10
        ldn     memAddr
        plo     RL10
        sep     RCALL
        dw      FP_MUL
        sep     RCALL
        dw      CVFI4
        glo     SP
        adi     ((64+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((64+1))>>8; was/256
        phi     MEMADDR
        ghi     RL8-1   ;long register pairs are addressed by their second member
        str     memAddr ;but load and store start with the 1st
        inc     memAddr
        glo     RL8-1
        str     memAddr
        inc     memAddr
        ghi     RL8
        str     memAddr
        inc     memAddr
        glo     RL8
        str     memAddr
;   strcpy(output,dubdabx(wholeNum,output,1));
        glo     SP
        adi     ((72+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((72+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RP1P2-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RP1P2-1
        lda     memAddr
        phi     RP1P2
        ldn     memAddr
        plo     RP1P2
        glo     SP
        adi     ((4+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((4+1))>>8; was/256
        phi     MEMADDR
        ghi     R0
        str     memAddr
        inc     memAddr
        glo     R0
        str     memAddr
        ldi     (1)&255
        plo     R11
        ldi     (1)>>8; was/256
        phi     R11
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
        sep     RCALL
        dw      _DUBDABX
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R0
        plo     R12
        ghi     R0
        phi     R12
        glo     R11
        plo     R13
        ghi     R11
        phi     R13
        sep     RCALL
        dw      _STRCPY
;   output+=strlen(output);
        glo     R0
        plo     R12
        ghi     R0
        phi     R12
        sep     RCALL
        dw      _STRLEN
        glo     R0
        str     sp
        glo     R15
        ADD             ;calculate the low order byte
        plo     R0
        ghi     R0
        str     sp
        ghi     R15
        ADC             ;calculate the high byte
        phi     R0
;   if (dec_digits > 0) {
        glo     R1
        lbnz    +
        ghi     R1
        lbz     L47
+
;		*output++ = '.' ;
        glo     R0
        plo     R11
        ghi     R0
        phi     R11
        inc     R0
        ldi     46
        str     R11
;		strcpy(output,dubdabx(decimalNum,output,dec_digits));
        glo     SP
        adi     ((64+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((64+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RP1P2-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RP1P2-1
        lda     memAddr
        phi     RP1P2
        ldn     memAddr
        plo     RP1P2
        glo     SP
        adi     ((4+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((4+1))>>8; was/256
        phi     MEMADDR
        ghi     R0
        str     memAddr
        inc     memAddr
        glo     R0
        str     memAddr
        glo     R1
        plo     R11
        ghi     R1
        phi     R11
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
        sep     RCALL
        dw      _DUBDABX
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R0
        plo     R12
        ghi     R0
        phi     R12
        glo     R11
        plo     R13
        ghi     R11
        phi     R13
        sep     RCALL
        dw      _STRCPY
;	}
L47:
;   return outbfr;
        glo     SP
        adi     ((84+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((84+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R15
        ldn     memAddr
        plo     R15
L38:
        inc sp
        inc sp
        inc sp
        inc sp
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        lda     sp
        phi     R7
        lda     sp
        plo     R7
        lda     sp
        phi     R6
        lda     sp
        plo     R6
        lda     sp
        phi     R1
        lda     sp
        plo     R1
        lda     sp
        phi     R0
        ldn     sp
        plo     R0
;for release we adjust the low byte first 
;so if there's an interrupt in mid calculation the sp will be pointing to free memory
        glo     SP
        ADI     (62)#256
        plo     SP
        ghi     SP
        ADCI     (62)>>8; was/256
        phi     SP
        sep     RRET
;$$function end$$ _ftoa
;$$function start$$ _itoa
_itoa:		;framesize=16
        dec sp
        dec sp
        glo     R0
        stxd
        ghi     R0
        stxd
        glo     R1
        stxd
        ghi     R1
        stxd
        glo     R6
        stxd
        ghi     R6
        stxd
        glo     R7
        stxd
        ghi     R7
        stxd
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((16+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((16+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
	inc memaddr				;opt16.1
        ghi     R13
        str     MEMADDR
        glo     R13
        inc     MEMADDR
        str     MEMADDR
        dec     MEMADDR
;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
;	unsigned int flag=0;
        ldi     0
        plo     R0
        phi     R0
;	char * bptr; bptr=buffer;
        glo     SP
        adi     ((18+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((18+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
;	if (s<0){
        glo     SP
        adi     ((16+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((16+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        smi     (0)#256
        ghi     R11
        smbi    (0)>>8; was/256      ;that's a standard signed subtraction
        ghi     R11 ;
        xri     (0)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBDF    L50  ;execute 
;		*bptr='-';bptr++;
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        ldi     45
        str     R11
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        inc     R11
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
;		n=-s;
        glo     SP
        adi     ((16+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((16+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11                     ;(flip all the bits and add 1)
        xri     0xff
        plo     R11
        ghi     R11
        xri     0xff
        phi     R11
        inc     R11
        glo     R11
        plo     R6
        ghi     R11
        phi     R6
;	} else{
	lbr L51
L50:
;		n=s;
        glo     SP
        adi     ((16+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((16+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        plo     R6
        ghi     R11
        phi     R6
;	}
L51:
;	k=10000;
        ldi     (10000)&255
        plo     R7
        ldi     (10000)>>8; was/256
        phi     R7
	lbr L53
L52:
;	while(k>0){
;		for(r=0;k<=n;r++,n-=k); // was r=n/k
        ldi     0
        plo     R1
        phi     R1
	lbr L58
L55:
L56:
        inc     R1
        glo     R7
        str     sp
        glo     R6
        SM             ;calculate the low order byte
        plo     R6
        ghi     R7
        str     sp
        ghi     R6
        SMB             ;calculate the high byte
        phi     R6
L58:
        dec     sp
        glo     R7
        str     sp
        glo     R6
        sm
        ghi     R7
        str     sp
        ghi     R6
        smb
        inc     sp
        LBDF    L55
;		if (flag || r>0||k==1){
        glo     R0
        lbnz    L62
        ghi     R0
        lbnz    L62
        glo     R1
        lbnz    L62
        ghi     R1
        lbnz    L62
        glo     R7
        smi     (1)#256
        lbnz    L59
        ghi     R7
        smbi    (1)>>8; was/256
        lbnz    L59
L62:
;			*bptr=('0'+r);bptr++;
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
;Oct 13 (48) added to ldAD call
        glo     R1
        adi     ((48))#256
        plo     R10
        ghi     R1
        adci    ((48))>>8; was/256
        phi     R10
        glo     R10
        str     R11
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        inc     R11
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
;			flag='y';
        ldi     (121)&255
        plo     R0
        ldi     (121)>>8; was/256
        phi     R0
;		}
L59:
;		k=k/10;
        glo     R7
        plo     R12
        ghi     R7
        phi     R12
        ldi     (10)&255
        plo     R13
        ldi     (10)>>8; was/256
        phi     R13
        sep     RCALL
        dw      _DIVU2
        glo     R15
        plo     R7
        ghi     R15
        phi     R7
;	}
L53:
;	while(k>0){
        glo     R7
        lbnz    L52
        ghi     R7
        lbnz    L52
;	*bptr='\0';
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        ldi     0
        str     R11
;	return buffer;
        glo     SP
        adi     ((18+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((18+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R15
        ldn     memAddr
        plo     R15
L49:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        lda     sp
        phi     R7
        lda     sp
        plo     R7
        lda     sp
        phi     R6
        lda     sp
        plo     R6
        lda     sp
        phi     R1
        lda     sp
        plo     R1
        lda     sp
        phi     R0
        ldn     sp
        plo     R0
        inc sp
        inc sp
        sep     RRET
;$$function end$$ _itoa
;$$function start$$ _ltoa
_ltoa:		;framesize=16
        glo     R1
        stxd
        ghi     R1
        stxd
        glo     R6
        stxd
        ghi     R6
        stxd
        glo     R7
        stxd
        ghi     R7
        stxd
        dec sp
        dec sp
        dec sp
        dec sp
        dec sp
        dec sp
        dec sp
        dec sp
        glo     RL12
        plo     RL6
        ghi     RL12
        phi     RL6
        glo     RL12-1
        plo     RL6-1
        ghi     RL12-1
        phi     RL6-1
;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
;	char* bptr=buffer;
        glo     SP
        adi     ((20+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((20+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R1
        ldn     memAddr
        plo     R1
;	if (s<0){
        ldi     (0)&255
        plo     RL10
        ldi     ((0)>>8)&255; 
        phi     RL10
        ldi     ((0)>>16)&255; 
        plo     RL10-1
        ldi     ((0)>>24)&255; 
        phi     RL10-1
        dec     sp ;make a work area
        glo     RL10    ;lowest order byte
        str     sp 
        glo     RL6
        sm
        ghi     RL10
        str     sp
        ghi     RL6
        smb          ;that's a standard signed subtraction of one reg
        glo     RL10-1  ;lowest order byte of the top register
        str     sp 
        glo     RL6-1
        smb
        ghi     RL10-1
        str     sp
        ghi     RL6-1
        smb          ;that's a standard signed subtraction of a double register
        ghi     RL6-1 ;
        xor           ;sets the top bit if the signs are different
        inc     sp ;release the work area
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBDF    L64  ;execute 
;		*bptr++='-';
        glo     R1
        plo     R11
        ghi     R1
        phi     R11
        inc     R1
        ldi     45
        str     R11
;		s=-s;
        glo     RL6    ;long regs are equated to the second reg which has the low order word 
        XRI     (0XFFFFFFFF)&255
        plo     RL6
        ghi     RL6
        XRI     ((0XFFFFFFFF)>>8)&255; 
        phi     RL6
        glo     RL6-1
        XRI     ((0XFFFFFFFF)>>16)&255; 
        plo     RL6-1
        ghi     RL6-1
        XRI     ((0XFFFFFFFF)>>24)&255; 
        phi     RL6-1
        glo     RL6    ;long regs are equated to the second reg which has the low order word 
        ADI     (1)&255
        plo     RL6
        ghi     RL6
        ADCI     ((1)>>8)&255; 
        phi     RL6
        glo     RL6-1
        ADCI     ((1)>>16)&255; 
        plo     RL6-1
        ghi     RL6-1
        ADCI     ((1)>>24)&255; 
        phi     RL6-1
;	}
L64:
;	strcpy(bptr,dubdabx(s,bptr,1)); //uses assembler double-dabble routine
        glo     RL6
        plo     RP1P2
        ghi     RL6
        phi     RP1P2
        glo     RL6-1
        plo     RP1P2-1
        ghi     RL6-1
        phi     RP1P2-1
        glo     SP
        adi     ((4+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((4+1))>>8; was/256
        phi     MEMADDR
        ghi     R1
        str     memAddr
        inc     memAddr
        glo     R1
        str     memAddr
        ldi     (1)&255
        plo     R11
        ldi     (1)>>8; was/256
        phi     R11
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
        sep     RCALL
        dw      _DUBDABX
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R1
        plo     R12
        ghi     R1
        phi     R12
        glo     R11
        plo     R13
        ghi     R11
        phi     R13
        sep     RCALL
        dw      _STRCPY
;	return buffer;
        glo     SP
        adi     ((20+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((20+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R15
        ldn     memAddr
        plo     R15
L63:
        inc sp
        inc sp
        inc sp
        inc sp
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        lda     sp
        phi     R7
        lda     sp
        plo     R7
        lda     sp
        phi     R6
        lda     sp
        plo     R6
        lda     sp
        phi     R1
        ldn     sp
        plo     R1
        sep     RRET
;$$function end$$ _ltoa
;$$function start$$ _printint
_printint:		;framesize=14
;this calculation looks awkward but we're adjusting the top byte of sp first 
;so if there's an interrupt in mid calculation the sp will be pointing to free memory
        glo sp          ;grab low byte of stack pointer
        smi 12&255 ;claculate new low byte
        plo memAddr     ;save it for a moment
        ghi sp          ;grab high byte
        smbi (12>>8)&255 ;calculate the new page
        phi sp          ;adjust page first
        glo memAddr     ;get new low byte
        plo sp          ;finish adjusting the stack pointer
        glo     SP
        adi     ((14+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((14+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
;void printint(int s){ //print an integer
;	itoa(s,buffer);
        glo     SP
        adi     ((14+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((14+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R12
        ldn     memAddr
        plo     R12
;Oct 13 (4+1) added to ldAD call
        glo     SP
        adi     ((4+1))#256
        plo     R13
        ghi     SP
        adci    ((4+1))>>8; was/256
        phi     R13
        sep     RCALL
        dw      _ITOA
;	printstr(buffer);
;Oct 13 (4+1) added to ldAD call
        glo     SP
        adi     ((4+1))#256
        plo     R12
        ghi     SP
        adci    ((4+1))>>8; was/256
        phi     R12
        sep     RCALL
        dw      _PRINTSTR
;}
L66:
;for release we adjust the low byte first 
;so if there's an interrupt in mid calculation the sp will be pointing to free memory
        glo     SP
        ADI     (12)#256
        plo     SP
        ghi     SP
        ADCI     (12)>>8; was/256
        phi     SP
        sep     RRET
;$$function end$$ _printint
;$$function start$$ _printlint
_printlint:		;framesize=20
;this calculation looks awkward but we're adjusting the top byte of sp first 
;so if there's an interrupt in mid calculation the sp will be pointing to free memory
        glo sp          ;grab low byte of stack pointer
        smi 18&255 ;claculate new low byte
        plo memAddr     ;save it for a moment
        ghi sp          ;grab high byte
        smbi (18>>8)&255 ;calculate the new page
        phi sp          ;adjust page first
        glo memAddr     ;get new low byte
        plo sp          ;finish adjusting the stack pointer
        glo     SP
        adi     ((20+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((20+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
	inc memaddr				;opt16.1
        ghi     R13
        str     MEMADDR
        glo     R13
        inc     MEMADDR
        str     MEMADDR
        dec     MEMADDR
;void printlint(long s){ //print a long integer
;	printstr(ltoa(s,buffer));
        glo     SP
        adi     ((20+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((20+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RP1P2-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RP1P2-1
        lda     memAddr
        phi     RP1P2
        ldn     memAddr
        plo     RP1P2
;Oct 13 (6+1) added to ldAD call
        glo     SP
        adi     ((6+1))#256
        plo     R11
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     R11
        glo     SP
        adi     ((4+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((4+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
        sep     RCALL
        dw      _LTOA
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R11
        plo     R12
        ghi     R11
        phi     R12
        sep     RCALL
        dw      _PRINTSTR
;}
L67:
;for release we adjust the low byte first 
;so if there's an interrupt in mid calculation the sp will be pointing to free memory
        glo     SP
        ADI     (18)#256
        plo     SP
        ghi     SP
        ADCI     (18)>>8; was/256
        phi     SP
        sep     RRET
;$$function end$$ _printlint
;$$function start$$ _printflt
_printflt:		;framesize=30
;this calculation looks awkward but we're adjusting the top byte of sp first 
;so if there's an interrupt in mid calculation the sp will be pointing to free memory
        glo sp          ;grab low byte of stack pointer
        smi 28&255 ;claculate new low byte
        plo memAddr     ;save it for a moment
        ghi sp          ;grab high byte
        smbi (28>>8)&255 ;calculate the new page
        phi sp          ;adjust page first
        glo memAddr     ;get new low byte
        plo sp          ;finish adjusting the stack pointer
        glo     SP
        adi     ((30+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((30+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
	inc memaddr				;opt16.1
        ghi     R13
        str     MEMADDR
        glo     R13
        inc     MEMADDR
        str     MEMADDR
        dec     MEMADDR
;void printflt(float s){ //print a float
;	printstr(ftoa(s,buffer,3));
        glo     SP
        adi     ((30+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((30+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RP1P2-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RP1P2-1
        lda     memAddr
        phi     RP1P2
        ldn     memAddr
        plo     RP1P2
;Oct 13 (8+1) added to ldAD call
        glo     SP
        adi     ((8+1))#256
        plo     R11
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     R11
        glo     SP
        adi     ((4+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((4+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
        ldi     (3)&255
        plo     R11
        ldi     (3)>>8; was/256
        phi     R11
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
        sep     RCALL
        dw      _FTOA
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R11
        plo     R12
        ghi     R11
        phi     R12
        sep     RCALL
        dw      _PRINTSTR
;}
L68:
;for release we adjust the low byte first 
;so if there's an interrupt in mid calculation the sp will be pointing to free memory
        glo     SP
        ADI     (28)#256
        plo     SP
        ghi     SP
        ADCI     (28)>>8; was/256
        phi     SP
        sep     RRET
;$$function end$$ _printflt
;$$function start$$ _putxn
_putxn:		;framesize=6
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
;Oct 13 (6+1) added to ldAD call
        glo     SP
        adi     ((6+1))#256
        plo     R11
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     R11
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R10
        ldn     memAddr
        plo     R10
        glo     R10
        str     R11
;void putxn(unsigned char x){ //print a nibble as ascii hex
;	if (x<10){
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        ldi     0
        phi     R11
        glo     R11
        smi     (10)#256
        ghi     R11
        smbi    (10)>>8; was/256      ;that's a standard signed subtraction
        ghi     R11 ;
        xri     (10)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBDF    L70  ;execute 
;		putc(x+'0');
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        ldi     0
        phi     R11
;Oct 13 (48) added to ldAD call
        glo     R11
        adi     ((48))#256
        plo     R11
        ghi     R11
        adci    ((48))>>8; was/256
        phi     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTCSER
;	} else {
	lbr L71
L70:
;		putc(x+'A'-10);
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        ldi     0
        phi     R11
;Oct 13 (65) added to ldAD call
        glo     R11
        adi     ((65))#256
        plo     R11
        ghi     R11
        adci    ((65))>>8; was/256
        phi     R11
        glo     R11
        SMI     (10)#256
        plo     R11
        ghi     R11
        SMBI     (10)>>8; was/256
        phi     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTCSER
;	}
L71:
;}
L69:
        inc sp
        inc sp
        inc sp
        inc sp
        sep     RRET
;$$function end$$ _putxn
;$$function start$$ _putx
_putx:		;framesize=6
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
;Oct 13 (6+1) added to ldAD call
        glo     SP
        adi     ((6+1))#256
        plo     R11
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     R11
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R10
        ldn     memAddr
        plo     R10
        glo     R10
        str     R11
;void putx(unsigned char x){ //print a unsigned char as ascii hex
;	putxn(x>>4);
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        ldi     0
        phi     R11
        ghi     R11
        shl             ;set DF to the sign
        ghi     R11     ;get the top byte back
        shrc            ;shift one bit extending the sign
        phi     R11
        glo     R11
        shrc
        plo     R11
        ghi     R11
        shl             ;set DF to the sign
        ghi     R11     ;get the top byte back
        shrc            ;shift one bit extending the sign
        phi     R11
        glo     R11
        shrc
        plo     R11
        ghi     R11
        shl             ;set DF to the sign
        ghi     R11     ;get the top byte back
        shrc            ;shift one bit extending the sign
        phi     R11
        glo     R11
        shrc
        plo     R11
        ghi     R11
        shl             ;set DF to the sign
        ghi     R11     ;get the top byte back
        shrc            ;shift one bit extending the sign
        phi     R11
        glo     R11
        shrc
        plo     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTXN
;	putxn(x & 0x0F);
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        ldi     0
        phi     R11
        glo     R11
        ANI     (15)#256
        plo     R11
        ghi     R11
        ANI     (15)>>8; was/256
        phi     R11
	;removed ?	cpy2 R11,R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTXN
;}
L72:
        inc sp
        inc sp
        inc sp
        inc sp
        sep     RRET
;$$function end$$ _putx
;$$function start$$ _printf
_printf:		;framesize=18
        dec sp
        dec sp
        dec sp
        dec sp
        glo     R0
        stxd
        ghi     R0
        stxd
        glo     R1
        stxd
        ghi     R1
        stxd
        glo     R6
        stxd
        ghi     R6
        stxd
        glo     R7
        stxd
        ghi     R7
        stxd
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((18+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((18+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
	inc memaddr				;opt16
        ghi     R13
        str     MEMADDR
        glo     R13
        inc     MEMADDR
        str     MEMADDR
        dec     MEMADDR
;void printf(char *pptr,...){ //limited implementation of printf
;	register char* ptr=pptr; //try to save on loads/spills
        glo     SP
        adi     ((18+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((18+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R7
        ldn     memAddr
        plo     R7
;	int argslot=0;	//used to align longs
        ldi     0
        plo     R0
        phi     R0
;	int * this=(int *)&pptr;
;Oct 13 (18+1) added to ldAD call
        glo     SP
        adi     ((18+1))#256
        plo     R1
        ghi     SP
        adci    ((18+1))>>8; was/256
        phi     R1
;	this++; argslot++; //advance argument pointer and slot #
        inc     R1
        inc     R1
        inc     R0
	lbr L75
L74:
;    while(*ptr) {
;		c=*ptr; ptr++;
        ldn     R7
        plo     R6
        inc     R7
;		if (c!='%'){
        glo     R6
        smi     (37)#256
        lbz     L77
;			putc(c);
        glo     R6
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTCSER
;			asm(" nop1806\n nop1806\n nop1806\n"); //17-03-13
;		} else{
	lbr L78
L77:
;			c=*ptr;ptr++;
        ldn     R7
        plo     R6
        inc     R7
;			switch (c){
        glo     R6
        plo     R11
        ldi     0
        phi     R11
        glo     SP
        adi     ((13+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((13+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
        glo     SP
        adi     ((13+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((13+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        smi     (99)#256
        ghi     R11
        smbi    (99)>>8; was/256      ;that's a standard signed subtraction
        ghi     R11 ;
        xri     (99)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L101  ;execute 
        glo     R11
        sdi     (108)#256      ;subtract d FROM immediate value
        ghi     R11
        sdbi    (108)>>8; was/256      ;that's a standard signed subtraction (of register FROM immediate)
        ghi     R11 ;
        xri     (108)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L102  ;execute 
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        adi     ((L103-198))#256
        plo     MEMADDR
        ghi     R11
        adci    ((L103-198))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R6
        stxd
        ghi     R6
        stxd
        glo     R11
        plo     R6
        ghi     R11
        phi     R6
        sep     RRET
L103:
	dw L85
	dw L83
	dw L80
	dw L96
	dw L80
	dw L80
	dw L83
	dw L80
	dw L80
	dw L89
L101:
        glo     SP
        adi     ((13+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((13+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        smi     (88)#256
        lbnz    $$nobr
        ghi     R11
        smbi    (88)>>8; was/256
        lbz     L88
$$nobr:
	lbr L80
L102:
        glo     SP
        adi     ((13+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((13+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        ldi     (115)&255
        plo     R10
        ldi     (115)>>8; was/256
        phi     R10
        glo     R10
        str     sp
        glo     R11
        sm
        lbnz    $$nobr
        ghi     R10
        str     sp
        ghi     R11
        smb
        lbz     L84
$$nobr:
        glo     R10
        str     sp 
        glo     R11
        sm
        ghi     R10
        str     sp
        ghi     R11
        smb          ;that's a standard signed subtraction
        ghi     R11 ;
        xor           ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L80  ;execute 
L105:
        glo     SP
        adi     ((13+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((13+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        smi     (120)#256
        lbnz    $$nobr
        ghi     R11
        smbi    (120)>>8; was/256
        lbz     L88
$$nobr:
	lbr L80
L83:
;					printint(*this++);
        glo     R1
        plo     R11
        ghi     R1
        phi     R11
        inc     R1
        inc     R1
        ;not safe to use for same register
        lda     R11 ;get 1st byte
        phi     R12     ;to destination
        ldn     R11 ;second byte
        dec     R11 ;restore address R12
        plo     R12     ;2nd byte to dest (5 instructions vs 10)
        sep     RCALL
        dw      _PRINTINT
;					argslot+=1; //next argument slot
        inc     R0
;					break;
	lbr L81
L84:
;					printstr((char*) *this++);
        glo     R1
        plo     R11
        ghi     R1
        phi     R11
        inc     R1
        inc     R1
        ;safe to use for same register
        lda     R11 ;get 1st byte
        phi     memaddr ;save it
        ldn     R11 ;second byte
        dec     R11 ;restore address R11
        plo     R11     ;1st byte to dest
        ghi     memaddr ;2nd byte
        phi     R11     ;to destination (7 instructions vs 10)
        glo     R11
        plo     R12
        ghi     R11
        phi     R12
        sep     RCALL
        dw      _PRINTSTR
;					argslot+=1; //next argument slot
        inc     R0
;					break;
	lbr L81
L85:
;					if (*ptr=='x'){ //if there's an x
        ldn     R7
        plo     R11
        glo     R11
        smi     120
        lbnz    L86
;						ptr++; //skip over the x
        inc     R7
;						putx(((unsigned int) *this++)&255); //print 1 byte as hex
        glo     R1
        plo     R11
        ghi     R1
        phi     R11
        inc     R1
        inc     R1
        ;safe to use for same register
        lda     R11 ;get 1st byte
        phi     memaddr ;save it
        ldn     R11 ;second byte
        dec     R11 ;restore address R11
        plo     R11     ;1st byte to dest
        ghi     memaddr ;2nd byte
        phi     R11     ;to destination (7 instructions vs 10)
        glo     R11
        ANI     (255)#256
        plo     R11
        ghi     R11
        ANI     (255)>>8; was/256
        phi     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTX
;					} else{
	lbr L87
L86:
;						putc((unsigned int) *this++);		//print as char
        glo     R1
        plo     R11
        ghi     R1
        phi     R11
        inc     R1
        inc     R1
        ;safe to use for same register
        lda     R11 ;get 1st byte
        phi     memaddr ;save it
        ldn     R11 ;second byte
        dec     R11 ;restore address R11
        plo     R11     ;1st byte to dest
        ghi     memaddr ;2nd byte
        phi     R11     ;to destination (7 instructions vs 10)
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTCSER
;					}
L87:
;					argslot+=1; //next argument slot
        inc     R0
;					break;
	lbr L81
L88:
;					putx(((unsigned int) *this)>>8);
        ;not safe to use for same register
        lda     R1 ;get 1st byte
        phi     R11     ;to destination
        ldn     R1 ;second byte
        dec     R1 ;restore address R11
        plo     R11     ;2nd byte to dest (5 instructions vs 10)
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTX
;					putx(((unsigned int) *this++)&255);
        glo     R1
        plo     R11
        ghi     R1
        phi     R11
        inc     R1
        inc     R1
        ;safe to use for same register
        lda     R11 ;get 1st byte
        phi     memaddr ;save it
        ldn     R11 ;second byte
        dec     R11 ;restore address R11
        plo     R11     ;1st byte to dest
        ghi     memaddr ;2nd byte
        phi     R11     ;to destination (7 instructions vs 10)
        glo     R11
        ANI     (255)#256
        plo     R11
        ghi     R11
        ANI     (255)>>8; was/256
        phi     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTX
;					argslot+=1; //next argument slot
        inc     R0
;					break;
	lbr L81
L89:
;					if (*ptr){ //as long as there's something there
        ldn     R7
        plo     R11
        ldi     0
        phi     R11
        glo     R11
        lbnz    +
        ghi     R11
        lbz     L90
+
;						xord=*ptr++;
        glo     R7
        plo     R11
        ghi     R7
        phi     R11
        inc     R7
;Oct 13 (15+1) added to ldAD call
        glo     SP
        adi     ((15+1))#256
        plo     R10
        ghi     SP
        adci    ((15+1))>>8; was/256
        phi     R10
        ldn     R11
        plo     R11
        glo     R11
        str     R10
;						if (argslot&1) {
        glo     R0
        ANI     (1)#256
        plo     R11
        ghi     R0
        ANI     (1)>>8; was/256
        phi     R11
	;removed ?	cpy2 R11,R0
        glo     R11
        lbnz    +
        ghi     R11
        lbz     L92
+
;							this++;
        inc     R1
        inc     R1
;							argslot++;
        inc     R0
;						}
L92:
;						if(xord=='d'){
        glo     SP
        adi     ((15+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((15+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        glo     R11
        smi     100
        lbnz    L94
;							printlint(*(long *)this);//treats "this" as a pointer to long
        glo     R1
        adi     (0)#256
        plo     MEMADDR
        ghi     R1
        adci    (0)>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RP1P2-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RP1P2-1
        lda     memAddr
        phi     RP1P2
        ldn     memAddr
        plo     RP1P2
        sep     RCALL
        dw      _PRINTLINT
;							this+=2;				// and advances it 4 bytes
        inc     R1
        inc     R1
        inc     R1
        inc     R1
;						} else{
	lbr L95
L94:
;							putx(((unsigned int) *this)>>8);
        ;not safe to use for same register
        lda     R1 ;get 1st byte
        phi     R11     ;to destination
        ldn     R1 ;second byte
        dec     R1 ;restore address R11
        plo     R11     ;2nd byte to dest (5 instructions vs 10)
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTX
;							putx(((unsigned int) *this++)&255);
        glo     R1
        plo     R11
        ghi     R1
        phi     R11
        inc     R1
        inc     R1
        ;safe to use for same register
        lda     R11 ;get 1st byte
        phi     memaddr ;save it
        ldn     R11 ;second byte
        dec     R11 ;restore address R11
        plo     R11     ;1st byte to dest
        ghi     memaddr ;2nd byte
        phi     R11     ;to destination (7 instructions vs 10)
        glo     R11
        ANI     (255)#256
        plo     R11
        ghi     R11
        ANI     (255)>>8; was/256
        phi     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTX
;							putx(((unsigned int) *this)>>8);
        ;not safe to use for same register
        lda     R1 ;get 1st byte
        phi     R11     ;to destination
        ldn     R1 ;second byte
        dec     R1 ;restore address R11
        plo     R11     ;2nd byte to dest (5 instructions vs 10)
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTX
;							putx(((unsigned int) *this++)&255);
        glo     R1
        plo     R11
        ghi     R1
        phi     R11
        inc     R1
        inc     R1
        ;safe to use for same register
        lda     R11 ;get 1st byte
        phi     memaddr ;save it
        ldn     R11 ;second byte
        dec     R11 ;restore address R11
        plo     R11     ;1st byte to dest
        ghi     memaddr ;2nd byte
        phi     R11     ;to destination (7 instructions vs 10)
        glo     R11
        ANI     (255)#256
        plo     R11
        ghi     R11
        ANI     (255)>>8; was/256
        phi     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTX
;						}
L95:
;						argslot+=2;
        inc     R0
        inc     R0
;						break;
	lbr L81
L90:
L96:
;					if (*ptr){ //as long as there's something there
        ldn     R7
        plo     R11
        ldi     0
        phi     R11
        glo     R11
        lbnz    +
        ghi     R11
        lbz     L97
+
;						if (argslot&1) { //adjust alignment
        glo     R0
        ANI     (1)#256
        plo     R11
        ghi     R0
        ANI     (1)>>8; was/256
        phi     R11
	;removed ?	cpy2 R11,R0
        glo     R11
        lbnz    +
        ghi     R11
        lbz     L99
+
;							this++;
        inc     R1
        inc     R1
;							argslot++;
        inc     R0
;						}
L99:
;						printflt(*(float *)this);//treats "this" as a pointer to float
        glo     R1
        adi     (0)#256
        plo     MEMADDR
        ghi     R1
        adci    (0)>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     RP1P2-1   ;long register pairs are addressed by their second member
        lda     memAddr ;but load and store start with the 1st
        plo     RP1P2-1
        lda     memAddr
        phi     RP1P2
        ldn     memAddr
        plo     RP1P2
        sep     RCALL
        dw      _PRINTFLT
;						this+=2;				// and advances it 4 bytes
        inc     R1
        inc     R1
        inc     R1
        inc     R1
;						argslot+=2;
        inc     R0
        inc     R0
;						break;
	lbr L81
L97:
L80:
;					putc('%');putc(c);
        ldi     (37)&255
        plo     R12
        ldi     (37)>>8; was/256
        phi     R12
        sep     RCALL
        dw      _PUTCSER
        glo     R6
        plo     R12
        ldi     0
        phi     R12
        sep     RCALL
        dw      _PUTCSER
;			} //switch
L81:
;		} //%
L78:
;	} //while
L75:
;    while(*ptr) {
        ldn     R7
        plo     R11
        glo     R11
        lbnz    L74
;} //prtf
L73:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        lda     sp
        phi     R7
        lda     sp
        plo     R7
        lda     sp
        phi     R6
        lda     sp
        plo     R6
        lda     sp
        phi     R1
        lda     sp
        plo     R1
        lda     sp
        phi     R0
        ldn     sp
        plo     R0
        inc sp
        inc sp
        inc sp
        inc sp
        sep     RRET
;$$function end$$ _printf
;$$function start$$ _exit
_exit:		;framesize=6
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
;void exit(int code){
;	printf("exit %d\n",code);
        ldi     (L107)&255
        plo     R12
        ldi     (L107)>>8; was/256
        phi     R12
        glo     SP
        adi     ((6+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((6+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R13
        ldn     memAddr
        plo     R13
        sep     RCALL
        dw      _PRINTF
L108:
;	while(1);
L109:
	lbr L108
;}
L106:
        inc sp
        inc sp
        inc sp
        inc sp
        sep     RRET
;$$function end$$ _exit
;$$function start$$ _memcmp
_memcmp:		;framesize=10
        glo     R0
        stxd
        ghi     R0
        stxd
        glo     R1
        stxd
        ghi     R1
        stxd
        glo     R6
        stxd
        ghi     R6
        stxd
        glo     R7
        stxd
        ghi     R7
        stxd
        glo     SP
        adi     ((14+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((14+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R7
        ldn     memAddr
        plo     R7
;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
;    int v = 0;
        ldi     0
        plo     R6
        phi     R6
;    p1 = (unsigned char *)Ptr1;
        glo     R12
        plo     R1
        ghi     R12
        phi     R1
;    p2 = (unsigned char *)Ptr2;
        glo     R13
        plo     R0
        ghi     R13
        phi     R0
	lbr L113
L112:
;    while(Count-- > 0 && v == 0) {
;        v = *(p1++) - *(p2++);
        glo     R1
        plo     R11
        ghi     R1
        phi     R11
        inc     R1
        glo     R0
        plo     R10
        ghi     R0
        phi     R10
        inc     R0
        ldn     R11
        plo     R11
        ldi     0
        phi     R11
        ldn     R10
        plo     R10
        ldi     0
        phi     R10
        glo     R10
        str     sp
        glo     R11
        SM             ;calculate the low order byte
        plo     R6
        ghi     R10
        str     sp
        ghi     R11
        SMB             ;calculate the high byte
        phi     R6
;    }
L113:
;    while(Count-- > 0 && v == 0) {
        glo     R7
        plo     R11
        ghi     R7
        phi     R11
        glo     R11
        plo     R7
        ghi     R11
        phi     R7
        dec     R7
        glo     R11
        lbnz    +
        ghi     R11
        lbz     L115
+
        glo     R6
        lbnz    +
        ghi     R6
        lbz     L112
+
L115:
;    return v;
        glo     R6
        plo     R15
        ghi     R6
        phi     R15
L111:
        inc     sp
        lda     sp
        phi     R7
        lda     sp
        plo     R7
        lda     sp
        phi     R6
        lda     sp
        plo     R6
        lda     sp
        phi     R1
        lda     sp
        plo     R1
        lda     sp
        phi     R0
        ldn     sp
        plo     R0
        sep     RRET
;$$function end$$ _memcmp
;$$function start$$ _memcpy
_memcpy:		;framesize=8
        glo     R1
        stxd
        ghi     R1
        stxd
        glo     R6
        stxd
        ghi     R6
        stxd
        glo     R7
        stxd
        ghi     R7
        stxd
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R7
        ldn     memAddr
        plo     R7
;void* memcpy(void* dest, const void* src, unsigned int count) {
;        char* dst8 = (char*)dest;
        glo     R12
        plo     R6
        ghi     R12
        phi     R6
;        char* src8 = (char*)src;
        glo     R13
        plo     R1
        ghi     R13
        phi     R1
	lbr L118
L117:
;        while (count--) {
;            *dst8++ = *src8++;
        glo     R6
        plo     R11
        ghi     R6
        phi     R11
        inc     R6
        glo     R1
        plo     R10
        ghi     R1
        phi     R10
        inc     R1
        ldn     R10
        plo     R10
        glo     R10
        str     R11
;        }
L118:
;        while (count--) {
        glo     R7
        plo     R11
        ghi     R7
        phi     R11
        glo     R11
        plo     R7
        ghi     R11
        phi     R7
        dec     R7
        glo     R11
        lbnz    L117
        ghi     R11
        lbnz    L117
;        return dest;
        glo     R12
        plo     R15
        ghi     R12
        phi     R15
L116:
        inc     sp
        lda     sp
        phi     R7
        lda     sp
        plo     R7
        lda     sp
        phi     R6
        lda     sp
        plo     R6
        lda     sp
        phi     R1
        ldn     sp
        plo     R1
        sep     RRET
;$$function end$$ _memcpy
;$$function start$$ _memset
_memset:		;framesize=6
        glo     R6
        stxd
        ghi     R6
        stxd
        glo     R7
        stxd
        ghi     R7
        stxd
        glo     SP
        adi     ((10+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((10+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R7
        ldn     memAddr
        plo     R7
;{
;    unsigned char* p=s;
        glo     R12
        plo     R6
        ghi     R12
        phi     R6
	lbr L122
L121:
;        *p++ = (unsigned char)c;
        glo     R6
        plo     R11
        ghi     R6
        phi     R11
        inc     R6
        glo     R13
        plo     R10
        ghi     R13
        phi     R10
        glo     R10
        str     R11
L122:
;    while(n--)
        glo     R7
        plo     R11
        ghi     R7
        phi     R11
        glo     R11
        plo     R7
        ghi     R11
        phi     R7
        dec     R7
        glo     R11
        lbnz    L121
        ghi     R11
        lbnz    L121
;    return s;
        glo     R12
        plo     R15
        ghi     R12
        phi     R15
L120:
        inc     sp
        lda     sp
        phi     R7
        lda     sp
        plo     R7
        lda     sp
        phi     R6
        ldn     sp
        plo     R6
        sep     RRET
;$$function end$$ _memset
;$$function start$$ _nstdlibincluder
_nstdlibincluder:		;framesize=2
;void nstdlibincluder(){
;	asm("\tinclude nstdlib.inc\n"); //strcpy, strcmp
;nstdlib.inc includes assembly versions of nstdlib routines strcpy, strcmp
;Oct 1 first test seems ok
;char * strcpy(char * to, const char *from)
	align 64
_strcpy:
;char *save = to; (to is R12, from is R13)
	glo R12	
	plo R15
	ghi R12
	phi R15
;for (; (*to = *from) != 0; ++from, ++to);
__strcpy: lda R13
	str R12
	inc R12
	bnz __strcpy
;return(save);
        sep     RRET
;}
;int strcmp(const char *s1, const char *s2){  s1 will be R12, s2 R13
_strcmp:	;entry point from C program
;  int ret = 0;
        ldi     0
        plo     R15
        phi     R15
;  while (!(ret = *(unsigned char *) s1 - *(unsigned char *) s2) && *s2) ++s1, ++s2;
	dec	sp	;make a work area
__strcmplp:
	lda	R13	;get string 2 character
	str	sp	;prep for compare
	lda	R12	;get string 1 character
	sm		;subtract string 2 char from string 1
	bnz	__strcmpne ;strings not equal quit
	ldn	sp	;check string 2 character
	bnz	__strcmplp ;back for more if not done
	inc	sp	;release the work area
        sep     RRET
__strcmpne:	;here I know they're not equal
	inc	sp		;release the work area
	bdf	__strcmpgt	;string1>string2
	dec	R15		;string 1<string 2, return -1
        sep     RRET
__strcmpgt:
	inc	R15		;string1>string2, return 1
        sep     RRET
;}
L124:
        sep     RRET
;$$function end$$ _nstdlibincluder
L107:
	db 101
	db 120
	db 105
	db 116
	db 32
	db 37
	db 100
	db 10
	db 0
	align 4
L42:
	dd 0xbf800000
	align 4
L41:
	dd 0x0
L3:
	db 85
	db 85
	db 85
	db 85
	db 85
	db 85
	db 85
	db 85
	db 0
;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
;this is the version published with the lcc1802121229 release
;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
;jan 2 removed test routines, moved code not needing short branches to before the align 256
;jan 11 going back to SCRT conventions for NG compiler
;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
;Jan 28 archived before beginning work on Birthday Compiler
;Feb 5 dubdab algorithm being brought in for ltoa itoa
;Feb 12 fixed bugs in modi2/u2
;feb 27 changed stack to start at 7fff
;mar 3, 2013 saved as epiloNO for optimization round
;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
;april 4 adding digit count argument to dubdabx
;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
;16-09-20 allow stack relocation 
;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
;17-03-07 adjusting stack offset for 1805/6 stack discipline
;17-03-13 protecting work areas in divi2,divi4 routines from 1806 SCAL
;17-03-15 onems compensates for reduced subroutine overhead in 1806
;17-04-09 don't include call/return for 1806
;17-10-17 SCRT routines changed to clean stack model i.e. push is stxd stxd, pop is inc lda inc ldn
;17-10-19 using CPUSPEED instead of LCC1802CPUSPEED, also STACKLOC instead of LCCSTACKLOC
;17-10-23 extending work area protection from 10-13 above for 1802 as well as 1805
rwork	equ	memAddr	;work register
lcc1802init:	
        ldi     (_CALL)&255
        plo     RCALL
        ldi     (_CALL)>>8; was/256
        phi     RCALL
        ldi     (_RETURN)&255
        plo     RRET
        ldi     (_RETURN)>>8; was/256
        phi     RRET
        ldi     (STACKLOC)&255
        plo     SP
        ldi     (STACKLOC)>>8; was/256
        phi     SP
	sex	SP
        ldi     ($$_00000)&255
        plo     RPC
        ldi     ($$_00000)>>8; was/256
        phi     RPC
	sep	RPC
$$_00000:
        sep     RCALL
        dw      _MAIN
$$_die:	lbr	$$_die		;loop here when main returns
	db	0xde,0xad
;the following routines don't have short jumps and don't need to worry about alignment
_setqOn:
	seq
        sep     RRET
_setqOff:
	req
        sep     RRET
_modU2:	;16 bit unsigned remainder
	; just calls the 16 bit division then puts remainder into return value
        sep     RCALL
        dw      _DIVU2
    glo regArg1
    plo retVal
    ghi regArg1
    phi retVal
        sep     RRET
_modI2:	;16 bit signed remainder
	; just calls the 16 bit division then puts remainder into return value
        sep     RCALL
        dw      _DIVI2
    glo regArg1
    plo retVal
    ghi regArg1
    phi retVal
        sep     RRET
_out4:	
	glo	regArg1
	dec	sp
	str	sp
	out	4
        sep     RRET
;the following routines have short branches so all the code has to stay within the same page
	align 16
;Standard Call routine invoked as D4xxxx - big-endian stack convention
	sep     R3 ;go to subroutine
_call	sex	SP ;make sure X=SP
	glo	retAddr ;save previous return pointer on stack
	stxd
	ghi	retAddr
	stxd	
	glo	RPC ;copy old PC to retAddr
	plo	retAddr
	ghi	RPC
	phi	retAddr
	lda	retAddr ;pick up subroutine address into RPC
	phi	RPC
	lda	retAddr
	plo	RPC
	br	_call-1
;Standard subroutine return 
	align 16
	sep	RPC	;return to the original program
_return	glo	retAddr	;transfer the current return address to RPC
	plo	RPC
	ghi	retAddr
	phi	RPC
	inc 	SP
	lda	SP	;pick up old return address
	phi	retAddr
	ldn	SP
	plo	retAddr
	br	_return-1
	align 8
_oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
;subroutine overhead soaks up 27 instruction time.
;each loop is 2 instruction times
;so the number of loops needed is 
;CPU speed/16000 less the 27 all divide by two
SUBOVHD  EQU 27		;default SCRT subroutine overhead
	ldi	(CPUSPEED/1000/16-SUBOVHD)/2
$$mslp:	smi	1
	bnz	$$mslp
        sep     RRET
	align 256
;16 bit right shifting multiply which is faster for smaller operands
; credit to http://map.grauw.nl/articles/mult_div_shifts.php#lrmultr
_mulU2:		;retval(product)=regarg1(multiplicand)*regarg2(multiplier)
        ldi     0
        plo     RETVAL
        phi     RETVAL
$$mulrlp:
        ghi     REGARG2
        shr
        phi     REGARG2
        glo     REGARG2
        shrc
        plo     REGARG2
	bnf $$mulrnoadd
;	bottom bit of multiplier is one so add multiplicand to product
        glo     REGARG1
        str     sp
        glo     RETVAL
        ADD             ;calculate the low order byte
        plo     RETVAL
        ghi     REGARG1
        str     sp
        ghi     RETVAL
        ADC             ;calculate the high byte
        phi     RETVAL
$$mulrnoadd:
	ghi regarg2	;check for all bits of multiplier shifted out
	bnz $$mulrshft	;nope, continue
	glo regarg2	;check bottom byte
	bz $$mulrdone
$$mulrshft:
        glo     REGARG1
        shl
        plo     REGARG1
        ghi     REGARG1
        shlc
        phi     REGARG1
	br $$mulrlp
$$mulrdone:		;here the product is in retval
        sep     RRET
;this is a divisor shifting algorithm which is faster for smaller operands
;credit to http://research.microsoft.com/pubs/70645/tr-2008-141.pdf
;changed oct 12 to save R10 & 1/2 R11 on stack
_divu2: ;retval=regarg1(x or dividend)/regarg2(y or divisor)
	;uses R14(rwork) to hold original divisor y0, 
	;regarg1 to hold develop remainder, 
	;R10 to hold working dividend R11.0 as a temp
;	pushf R10	;save R10 & leave stack down 1
        glo     R10
        stxd
        ghi     R10
        stxd
	glo R11		;and bottom
	stxd		;of R11 - leaves stack clear of work area
        glo     REGARG1
        plo     R10
        ghi     REGARG1
        phi     R10
        ldi     0
        plo     RETVAL
        phi     RETVAL
        glo     REGARG2
        plo     RWORK
        ghi     REGARG2
        phi     RWORK
                                ;result in D, rwork.hi, DF
        glo REGARG2
        str sp
        glo R10
        sm
        plo R11
        ghi REGARG2
        str sp
        ghi R10
        smb
	bnf $$computequot	;DF=0 means it didn't fit
	phi R10	;R10=R10-regarg2
	glo R11
	plo R10
$$again:	;this is the divisor doubling phase
                                ;result in D, rwork.hi, DF
        glo REGARG2
        str sp
        glo R10
        sm
        plo R11
        ghi REGARG2
        str sp
        ghi R10
        smb
 	bnf $$computequot	;df=0 means it didn't fit
	phi R10	;R10=R10-regarg2
	glo R11
	plo R10 	
        glo     REGARG2
        shl
        plo     REGARG2
        ghi     REGARG2
        shlc
        phi     REGARG2
 	br $$again
 $$computequot:	;here we're computing the quotient
                                ;result in D, rwork.hi, DF
        glo REGARG2
        str sp
        glo REGARG1
        sm
        plo R11
        ghi REGARG2
        str sp
        ghi REGARG1
        smb
 	bnf $$testexit
 	phi regarg1		;complete the subtraction
 	glo R11
 	plo regarg1
 	inc retval
 $$testexit:
 	ghi rwork
 	sm	;top of regarg2 is still on stack
 	bnz $$ney0y
 	glo regarg2
 	str sp
 	glo rwork
 	sm	;test low order bytes
 	bz	$$out	;if = we're done
 $$ney0y:
        glo     RETVAL
        shl
        plo     RETVAL
        ghi     RETVAL
        shlc
        phi     RETVAL
        ghi     REGARG2
        shr
        phi     REGARG2
        glo     REGARG2
        shrc
        plo     REGARG2
 	br $$computequot	;continue
 $$out:
 ;here the quotient is in retval, remainder in regarg1
  	inc sp	;release work area
	ldn sp	;recover
	plo R11	;bottom byte of R11
        inc     sp
        lda     sp
        phi     R10
        ldn     sp
        plo     R10
        sep     RRET
;signed integer division retVal=regArg1/regArg2, remainder in regArg1
;uses unsigned division of absolute values then negates the quotient if the signs were originally different
_divI2:
    dec	sp	;leave a work area available
    ghi regArg1
    str sp	;save the sign of the 1st arg
    shl
    bnf $$pos1	;if the 1st arg is -v
        glo     REGARG1                     ;(flip all the bits and add 1)
        xri     0xff
        plo     REGARG1
        ghi     REGARG1
        xri     0xff
        phi     REGARG1
        inc     REGARG1
$$pos1: ;1st is now +v, check 2nd
    ghi regArg2
    xor	
    str sp ;the stack now has bit 8 set if the signs are different
    ghi regArg2
    shl
    bnf $$pos2	;if the 2nd arg is -v
        glo     REGARG2                     ;(flip all the bits and add 1)
        xri     0xff
        plo     REGARG2
        ghi     REGARG2
        xri     0xff
        phi     REGARG2
        inc     REGARG2
$$pos2: ; both args now +v
    dec sp	;protect workarea on the 1802
        sep     RCALL
        dw      _DIVU2
    inc sp	;recover work area
;now the quotient is in retVal and the remainder is in regArg2
    lda	sp ;get back the sign bits and restore SP
    shl
    bnf $$done ;if the signs were different
        glo     RETVAL                     ;(flip all the bits and add 1)
        xri     0xff
        plo     RETVAL
        ghi     RETVAL
        xri     0xff
        phi     RETVAL
        inc     RETVAL
$$done:
        sep     RRET
	align 256    ;32 bit operations follow
_divu4:
;This is an unsigned 32 bit restoring division
;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
;Rp1p2:RL8 form a 64 bit work area A:Q
;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
	ldi 32		;set loop count
	plo memaddr	;in temp register
        ldi     (0)&255
        plo     RP1P2
        ldi     ((0)>>8)&255; 
        phi     RP1P2
        ldi     ((0)>>16)&255; 
        plo     RP1P2-1
        ldi     ((0)>>24)&255; 
        phi     RP1P2-1
$$loop:
        glo     RL8     ;start with low byte of second register
        shl             ;shift left once
        plo     RL8     ; save it
        ghi     RL8     ;high byte of second RL8
        shlc            ;shift one bit carrying
        phi     RL8     ;save it
        glo     RL8-1   ;now the bottom byte of top RL8
        shlc
        plo     RL8-1
        ghi     RL8-1   ;finally the top byte of the high order RL8
        shlc            ;gets the last shift
        phi     RL8-1   ;and we're done
        glo     RP1P2     ;start with low byte of second register
        shlc            ;shift left once continuing carry
        plo     RP1P2     ; save it
        ghi     RP1P2     ;high byte of second RP1P2
        shlc            ;shift one bit carrying
        phi     RP1P2     ;save it
        glo     RP1P2-1   ;now the bottom byte of top RP1P2
        shlc
        plo     RP1P2-1
        ghi     RP1P2-1   ;finally the top byte of the high order RP1P2
        shlc            ;gets the last shift
        phi     RP1P2-1   ;and we're done
        dec     sp ;make a work ares
        glo     RL10    ;long register pairs are addressed by their second member
        str     sp      ;so arithmetic operations start there
        glo     RP1P2
        SM             ;calculate the low order byte
        plo     RP1P2
        ghi     RL10
        str     sp
        ghi     RP1P2
        SMB             ;calculate the second byte
        phi     RP1P2
        glo     RL10-1
        str     sp
        glo     RP1P2-1
        SMB             ;calculate the third byte
        plo     RP1P2-1
        ghi     RL10-1
        str     sp
        ghi     RP1P2-1
        SMB             ;calculate the high byte
        phi     RP1P2-1
        inc     sp      ;release the work area
	ani 0x80	;check the top bit
	bz $$norestore	;if it's 0
		glo RL8
		ani 0xfe	;turn off the bottom bit
		plo RL8
        dec     sp ;make a work ares
        glo     RL10    ;long register pairs are addressed by their second member
        str     sp      ;so arithmetic operations start there
        glo     RP1P2
        ADD             ;calculate the low order byte
        plo     RP1P2
        ghi     RL10
        str     sp
        ghi     RP1P2
        ADC             ;calculate the second byte
        phi     RP1P2
        glo     RL10-1
        str     sp
        glo     RP1P2-1
        ADC             ;calculate the third byte
        plo     RP1P2-1
        ghi     RL10-1
        str     sp
        ghi     RP1P2-1
        ADC             ;calculate the high byte
        phi     RP1P2-1
        inc     sp      ;release the work area
	br $$endlp 	;else
$$norestore:
		glo RL8
		ori 1	;turn on the bottom bit
		plo RL8
	;end if
$$endlp:
	dec memaddr	;check the cycle count
	glo memaddr
	bnz $$loop	;back for more if needed
        sep     RRET
_mulu4:
	;this is a 32 bit signed multiplication using booth's algorithm
	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
	;the bottom byte of memaddr is used as a cycle count
	;initially	R12:13=0,	R8:R9=operand 1, DF=0
	;for 32 cycles we check the low bit of R8:R9 and DF
	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
	;for 10 we subtract and shift
	;for 00 and 11 we just shift
        ldi     (0)&255
        plo     RP1P2
        ldi     ((0)>>8)&255; 
        phi     RP1P2
        ldi     ((0)>>16)&255; 
        plo     RP1P2-1
        ldi     ((0)>>24)&255; 
        phi     RP1P2-1
    ldi 32
    plo memaddr		;cycle count
    adi 0		;clear df
$$mloop:
    glo RL8
    ani 1		;isolate bottom bit of result
    bnf	$$check_sub	;
    bnz	$$shift		;that would be the 11 case
;this is case 01: add second operand to top 32 bits and shift all 64 bits right
        dec     sp ;make a work ares
        glo     RL10    ;long register pairs are addressed by their second member
        str     sp      ;so arithmetic operations start there
        glo     RP1P2
        ADD             ;calculate the low order byte
        plo     RP1P2
        ghi     RL10
        str     sp
        ghi     RP1P2
        ADC             ;calculate the second byte
        phi     RP1P2
        glo     RL10-1
        str     sp
        glo     RP1P2-1
        ADC             ;calculate the third byte
        plo     RP1P2-1
        ghi     RL10-1
        str     sp
        ghi     RP1P2-1
        ADC             ;calculate the high byte
        phi     RP1P2-1
        inc     sp      ;release the work area
    br $$shift
$$check_sub:
    bz $$shift	;that would be the 00 case
;this is case 10: subtract 2nd operand from top 32 bits then shift right
        dec     sp ;make a work ares
        glo     RL10    ;long register pairs are addressed by their second member
        str     sp      ;so arithmetic operations start there
        glo     RP1P2
        SM             ;calculate the low order byte
        plo     RP1P2
        ghi     RL10
        str     sp
        ghi     RP1P2
        SMB             ;calculate the second byte
        phi     RP1P2
        glo     RL10-1
        str     sp
        glo     RP1P2-1
        SMB             ;calculate the third byte
        plo     RP1P2-1
        ghi     RL10-1
        str     sp
        ghi     RP1P2-1
        SMB             ;calculate the high byte
        phi     RP1P2-1
        inc     sp      ;release the work area
$$shift:
        ghi     RP1P2-1   ;long RP1P2 pairs start at RP1P2-1
        shl             ;set DF to the sign
        ghi     RP1P2-1   ;get the top byte back
        shrc            ;shift one bit extending the sign
        phi     RP1P2-1
        glo     RP1P2-1
        shrc
        plo     RP1P2-1
        ghi     RP1P2     ;get the top byte of the low order RP1P2
        shrc            ;shift one bit extending the sign
        phi     RP1P2
        glo     RP1P2     ;finish with the low byte of the 2nd RP1P2 of the pair
        shrc
        plo     RP1P2
        ghi     RL8-1   ;long RL8 pairs start at RL8-1
        shrc            ;shift one bit extending the sign
        phi     RL8-1
        glo     RL8-1
        shrc
        plo     RL8-1
        ghi     RL8     ;get the top byte of the low order RL8
        shrc            ;shift one bit extending the sign
        phi     RL8
        glo     RL8     ;finish with the low byte of the 2nd RL8 of the pair
        shrc
        plo     RL8
    dec memaddr		;cycle count
    glo memaddr
    bnz $$mloop		;repeat cycle once for each bit position
        sep     RRET
	align 256
;signed integer division RL8=RL8/RL10, remainder in Rp1p2
;uses unsigned division of absolute values then negates the quotient if the signs were originally different
_divI4:
    dec	sp	;leave a work area available
    ghi RL8-1	;get the top of the dividend
    str sp	;save the sign of the 1st arg
    shl
    bnf $$pos1	;if the 1st arg is -v
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        XRI     (0XFFFFFFFF)&255
        plo     RL8
        ghi     RL8
        XRI     ((0XFFFFFFFF)>>8)&255; 
        phi     RL8
        glo     RL8-1
        XRI     ((0XFFFFFFFF)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        XRI     ((0XFFFFFFFF)>>24)&255; 
        phi     RL8-1
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        ADI     (1)&255
        plo     RL8
        ghi     RL8
        ADCI     ((1)>>8)&255; 
        phi     RL8
        glo     RL8-1
        ADCI     ((1)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        ADCI     ((1)>>24)&255; 
        phi     RL8-1
$$pos1: ;1st is now +v, check 2nd
    ghi RL10-1
    xor	
    str sp ;the stack now has bit 8 set if the signs are different
    ghi RL10-1
    shl
    bnf $$pos2	;if the 2nd arg is -v
        glo     RL10    ;long regs are equated to the second reg which has the low order word 
        XRI     (0XFFFFFFFF)&255
        plo     RL10
        ghi     RL10
        XRI     ((0XFFFFFFFF)>>8)&255; 
        phi     RL10
        glo     RL10-1
        XRI     ((0XFFFFFFFF)>>16)&255; 
        plo     RL10-1
        ghi     RL10-1
        XRI     ((0XFFFFFFFF)>>24)&255; 
        phi     RL10-1
        glo     RL10    ;long regs are equated to the second reg which has the low order word 
        ADI     (1)&255
        plo     RL10
        ghi     RL10
        ADCI     ((1)>>8)&255; 
        phi     RL10
        glo     RL10-1
        ADCI     ((1)>>16)&255; 
        plo     RL10-1
        ghi     RL10-1
        ADCI     ((1)>>24)&255; 
        phi     RL10-1
$$pos2: ; both args now +v
    dec sp	;protect workarea on the 1802
        sep     RCALL
        dw      _DIVU4
    inc sp	;recover work area
;now the quotient is in RL8 and the remainder is in Rp1p2
    lda	sp ;get back the sign bits and restore SP
    shl
    bnf $$done ;if the signs were different
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        XRI     (0XFFFFFFFF)&255
        plo     RL8
        ghi     RL8
        XRI     ((0XFFFFFFFF)>>8)&255; 
        phi     RL8
        glo     RL8-1
        XRI     ((0XFFFFFFFF)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        XRI     ((0XFFFFFFFF)>>24)&255; 
        phi     RL8-1
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        ADI     (1)&255
        plo     RL8
        ghi     RL8
        ADCI     ((1)>>8)&255; 
        phi     RL8
        glo     RL8-1
        ADCI     ((1)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        ADCI     ((1)>>24)&255; 
        phi     RL8-1
$$done:
        sep     RRET
_dubdabx:	
;experimental binay-ascii conversion using the double-dabble algorithm
;thanks to Charles Richmond for the suggestion and code
;long interger is passed in rp1p2
;buffer pointer is passed at sp+2+4**+1 for 1806
;a pointer to the 1st non-zero byte in the buffer is passed back in r15
;r8-11 are used as temps
;r8 is the working pointer
;r15.0 is bit count(32) and the return value register
;r9.0 is digit count
;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
        glo     SP
        adi     ((2+4+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((2+4+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R8
        ldn     memAddr
        plo     R8
        glo     SP
        adi     ((2+4+2+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((2+4+2+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R10
        ldn     memAddr
        plo     R10
        glo     R8
        plo     R15
        ghi     R8
        phi     R15
	ldi 11	;digit count+1 for trailing 0
	plo r9
$$clrlp:	;clear the passed buffer
	ldi 0	
	str r8	;clear a byte
	inc r8
	dec r9
	glo r9	;check the count
	bnz $$clrlp ;back for more
        glo     R15
        plo     R8
        ghi     R15
        phi     R8
	ldi 32	;bit count
	plo r15
;now i'm going to spin off any leading 0's in the binary number
$$cktop:
	ghi rp1p2-1	;get the top bit of the number
	shl		;check for a 1
	bdf $$bitloop	;move on if we have one
        glo     RP1P2     ;start with low byte of second register
        shl             ;shift left once
        plo     RP1P2     ; save it
        ghi     RP1P2     ;high byte of second RP1P2
        shlc            ;shift one bit carrying
        phi     RP1P2     ;save it
        glo     RP1P2-1   ;now the bottom byte of top RP1P2
        shlc
        plo     RP1P2-1
        ghi     RP1P2-1   ;finally the top byte of the high order RP1P2
        shlc            ;gets the last shift
        phi     RP1P2-1   ;and we're done
	dec r15		;reduce the number of times to shift
	glo r15
	bnz $$cktop	;
	inc r15		;our whole number was 0 but force at least one pass
$$bitloop:
	ldi 10	;digit count
	plo r9
$$dcklp:
	ldn r8 	;pick up a digit
	smi 5	;see if it's greater than 4
	bnf $$dnoadd ;if not, bypass add
	adi 0x08	;add the 5 black and 3 more
	str r8	;put it back
$$dnoadd:
	inc r8
	dec r9	;decrement digit count
	glo r9
	bnz $$dcklp ;and back for next digit
        glo     RP1P2     ;start with low byte of second register
        shl             ;shift left once
        plo     RP1P2     ; save it
        ghi     RP1P2     ;high byte of second RP1P2
        shlc            ;shift one bit carrying
        phi     RP1P2     ;save it
        glo     RP1P2-1   ;now the bottom byte of top RP1P2
        shlc
        plo     RP1P2-1
        ghi     RP1P2-1   ;finally the top byte of the high order RP1P2
        shlc            ;gets the last shift
        phi     RP1P2-1   ;and we're done
	ldi 10	;load the digit count again
	plo r9
;r8 is now just past the units location and ready to walk back
$$dshlp:
	dec r8	;walk back from 0's position
	ldn r8	;get the digit back
	shlc	;continue the shift
	phi r15 ;save it for the carry test
	ani 0x0f ;clear the 10 bit
	str r8	;put the digit back
	ghi r15	;now test for carry
	smi 0x10 ; this will make df 1 if the 10 bit is set
	dec r9	;decrement the digit count
	glo r9
	bnz $$dshlp ;back for more if needed
	dec r15
	glo r15
	bnz $$bitloop
        glo     R8
        plo     R15
        ghi     R8
        phi     R15
	ldi 10		;digit count again
	plo r9
$$upnxt:
	ldn r8		;get digit
	ori 0x30	;make ascii
	str r8		;put it back
	inc r8		;next digit
	dec r9		;counter
	glo r9
	bnz $$upnxt	;upgrade all 10 spots
        glo     SP
        adi     ((2+4+2+1+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((2+4+2+1+1))>>8; was/256
        phi     MEMADDR
	sex memaddr	;set up
	ldi 10		;max number of 0's to skip
	sm		;desired number of digits to skip
	sex sp		;reset index register
	plo r9		;number of leading 0's to skip
$$cknext:
	ldn r15		;check digit
	smi 0x30	;for '0'
	bnz $$done
	inc r15		;next digit
	dec r9		;reduce count
	glo r9
	bnz $$cknext
$$done:
        sep     RRET
_modU4:	;32 bit unsigned remainder
	; just calls the 32 bit division then puts remainder into return value
        sep     RCALL
        dw      _DIVU4
        glo     RP1P2
        plo     RL8
        ghi     RP1P2
        phi     RL8
        glo     RP1P2-1
        plo     RL8-1
        ghi     RP1P2-1
        phi     RL8-1
        sep     RRET
_modI4:	;32 bit signed remainder
	; just calls the 32 bit division then puts remainder into return value
        sep     RCALL
        dw      _DIVI4
        glo     RP1P2
        plo     RL8
        ghi     RP1P2
        phi     RL8
        glo     RP1P2-1
        plo     RL8-1
        ghi     RP1P2-1
        phi     RL8-1
        sep     RRET
;17-03-06 changing sep rret to cretn, sep rcall to ccall
;from http://www.elf-emulation.com/software/fp.asm - thanks to mike Reilley
;maybe originally from RCA
;these routines use ALL the registers from 6-15!
;8-15 were more or less available to start with
;it saves 6 when it uses it
;I save 7 on entry and restore on exit
;to keep my sanity I renamed some register equates where I was changing them e.g. F7 used to be RB
FB	equ	11	;was R9
F9	equ	9	;was R7
F7	equ	7	;was RB
;April 1 added code to fp_add to restore resgisters when returning a 0 - around add_nz:
; *** Convert signed long to float
; *** RL8-1:RL8 is the number to convert(8:9)
; *** result in same register
; *** uses memaddr.1 for sign, .0 for shift count/exponent
	align 256
cvif4:	ldi	0
	phi	memaddr	;sign
	ldi	150	;150 is  the 127 exponent bias plus the 23 required to shift a long 1 to bit 23
	plo	memaddr	;
	ghi	RL8-1	;get sign and bits 7-1 of exponent
	bz	$$nxt	;keep testing for 0
	shl		;sign bit to df
	bnf	$$sgnpos ;number is >0
	shrc		;shift it back so we know byte is non-zerro
	phi	memaddr	;save it
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        XRI     (0XFFFFFFFF)&255
        plo     RL8
        ghi     RL8
        XRI     ((0XFFFFFFFF)>>8)&255; 
        phi     RL8
        glo     RL8-1
        XRI     ((0XFFFFFFFF)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        XRI     ((0XFFFFFFFF)>>24)&255; 
        phi     RL8-1
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        ADI     (1)&255
        plo     RL8
        ghi     RL8
        ADCI     ((1)>>8)&255; 
        phi     RL8
        glo     RL8-1
        ADCI     ((1)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        ADCI     ((1)>>24)&255; 
        phi     RL8-1
	br	$$sgnpos ;go handle positive long
$$nxt:	glo	RL8-1	;next byte
	bnz	$$sgnpos ;sign is positive, number is not 0
	ghi	RL8	;next byte
	bnz	$$sgnpos ;sign is positive, number is not 0
	glo	RL8	;last byte
	bz	$$done	;the whole thing is zero so we're done
$$sgnpos: ghi	RL8-1	;top byte - begin shifting right to clear it
	bz	$$shl	;if it's zero we're done right shifting
	inc	memaddr	;increase exponent 1 for each right shift
        ghi     RL8-1   ;long RL8 pairs start at RL8-1
        shr             ;shift one bit 
        phi     RL8-1
        glo     RL8-1
        shrc            ;continue the shift
        plo     RL8-1
        ghi     RL8     ;get the top byte of the low order RL8
        shrc            ;continue the shift
        phi     RL8
        glo     RL8     ;finish with the low byte of the 2nd RL8 of the pair
        shrc
        plo     RL8
	br	$$sgnpos
$$shl:	glo	RL8-1	;check bit 23
	ani	0x80	;isolate it
	bnz	$$shdn	;if it's on we're done here
	dec	memaddr	;decrease exponent 1 for each left shift
        glo     RL8     ;start with low byte of second register
        shl             ;shift left once
        plo     RL8     ; save it
        ghi     RL8     ;high byte of second RL8
        shlc            ;shift one bit carrying
        phi     RL8     ;save it
        glo     RL8-1   ;now the bottom byte of top RL8
        shlc
        plo     RL8-1
        ghi     RL8-1   ;finally the top byte of the high order RL8
        shlc            ;gets the last shift
        phi     RL8-1   ;and we're done
	br	$$shl
$$shdn:	glo	memaddr	;get the exponent
	shr		;shift right so it can go into bits 31-24
	phi	RL8-1	;put top bits of exponent into place
	bdf	$$setsgn ;if the bit 0 is on we're done
	glo	RL8-1	;get the byte
	ani	0x7f	;clear bit 23
	plo	RL8-1	;put it back
$$setsgn: ghi	memaddr	;get the original sign byte
	bz	$$done	;sign bit is already zero so we're done
	ghi	RL8-1	;get the sign byte
	ori	0x80	;set the sign bit
	phi	RL8-1	;place it
        sep     RRET
; *** Convert float to signed long
; *** RL8-1:RL8 is the number to convert(8:9)
; *** result in same register
	align 256
cvfi4:
	ghi	RL8-1	;get sign and bits 7-1 of exponent
	phi	memaddr ;save for later
	glo	RL8-1	;get bit 0 of exponent
	shl		;shift to df
	ghi	memaddr	;get exponent 7-1
	shlc		;combine with 0
;the following sequence is equivalent to sdi 150; I did it this way to coddle my emulator which doesn't do this properly.
	dec	sp
	str	sp
	ldi	150
	sm		;calculate shift count needed
;*******note - the df flag set here is tested later
	plo	memaddr
	inc	sp	;release work area
;end of sdi 150 sequence - now convert the mantissa to unsigned long
	ldi	0
	phi	RL8-1	;clear the top byte of the float
	glo	RL8-1	;get the next byte
	ori	0x80	;add in the implied 1 bit
	plo	RL8-1	;put it back
	glo	memaddr	;make sure there's at least 1 shift
	bz	$$sign
;**********note df is set from subtraction before setting mantissa
	bnf	$$lsh ; if the shift count is negative
        ghi     RL8-1   ;long RL8 pairs start at RL8-1
        shr             ;shift one bit 
        phi     RL8-1
        glo     RL8-1
        shrc            ;continue the shift
        plo     RL8-1
        ghi     RL8     ;get the top byte of the low order RL8
        shrc            ;continue the shift
        phi     RL8
        glo     RL8     ;finish with the low byte of the 2nd RL8 of the pair
        shrc
        plo     RL8
	dec	memaddr	;check shift count
	glo	memaddr
	bnz	$$shr	;complete the shift
	br	$$sign
;handle negative shift as best I can - gigo
        glo     RL8     ;start with low byte of second register
        shl             ;shift left once
        plo     RL8     ; save it
        ghi     RL8     ;high byte of second RL8
        shlc            ;shift one bit carrying
        phi     RL8     ;save it
        glo     RL8-1   ;now the bottom byte of top RL8
        shlc
        plo     RL8-1
        ghi     RL8-1   ;finally the top byte of the high order RL8
        shlc            ;gets the last shift
        phi     RL8-1   ;and we're done
	inc	memaddr
	glo	memaddr
	bnz	$$lsh	
$$sign:	ghi	memaddr	;now the sign
	shl		;shift sign bit into df
	bnf	$$done
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        XRI     (0XFFFFFFFF)&255
        plo     RL8
        ghi     RL8
        XRI     ((0XFFFFFFFF)>>8)&255; 
        phi     RL8
        glo     RL8-1
        XRI     ((0XFFFFFFFF)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        XRI     ((0XFFFFFFFF)>>24)&255; 
        phi     RL8-1
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        ADI     (1)&255
        plo     RL8
        ghi     RL8
        ADCI     ((1)>>8)&255; 
        phi     RL8
        glo     RL8-1
        ADCI     ((1)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        ADCI     ((1)>>24)&255; 
        phi     RL8-1
	br	$$done	; and return
        sep     RRET
; *** Check if character is numeric
; *** D - char to check
; *** Returns DF=1 if numeric
; ***         DF=0 if not
f_isnum:   plo     r14                 ; save a copy
           smi     '0'                 ; check for below zero
           bnf     fails               ; jump if below
           smi     10                  ; see if above
           bdf     fails               ; fails if so
passes:    smi     0                   ; signal success
           lskp
fails:     adi     0                   ; signal failure
           glo     r14                 ; recover character
        sep     RRET
; *** Shift R8:F9 right 1 bit ***
; *******************************
fp_shr_1:  ghi   r8                    ; shift high word right
           shr
           phi   r8
           glo   r8
           shrc
           plo   r8
           ghi   F9                    ; shift low word right
           shrc
           phi   F9
           glo   F9
           shrc
           plo   F9
        sep     RRET
; ******************************
; *** Shift R8:F9 left 1 bit ***
; ******************************
fp_shl_1:  glo   F9
           shl
           plo   F9
           ghi   F9
           shlc
           phi   F9
           glo   r8
           shlc
           plo   r8
           ghi   r8
           shlc
           phi   r8
        sep     RRET
; **********************
; *** R8:F9 += RA:FB ***
; **********************
fp_add_12: glo   FB
	   dec r2	;wjr - make a work area
           str   r2
           glo   F9
           add
           plo   F9
           ghi   FB
           str   r2
           ghi   F9
           adc
           phi   F9
           glo   R10
           str   r2
           glo   r8
           adc
           plo   r8
           ghi   R10
           str   r2
           ghi   r8
           adc
           phi   r8
           inc	r2	;wjr - release work area
        sep     RRET
; *******************************
; *** Shift RF:RD right 1 bit ***
; *******************************
fp_shr_fd: ghi   R15                    ; shift high word right
           shr
           phi   R15
           glo   R15
           shrc
           plo   R15
           ghi   R13                    ; shift low word right
           shrc
           phi   R13
           glo   R13
           shrc
           plo   R13
        sep     RRET
; *************************************
; *** Scale number to high bit is 1 ***
; *** R8:F9 - Number to scale       ***
; *** RF.1  - Exponent for number   ***
; *** F7.0  - Sign bit (bit 0) ***
; *** Returns: R8:F9 - final sp num ***
; *************************************
fp_sc_up:  glo   r8                    ; need high bit to be a 1
           ani   080h                  ; check it
           lbnz  fp_sc_cln             ; jump if good
        sep     RCALL
        dw      FP_SHL_1
           ghi   R15                    ; get exp1
           smi   1                     ; minus 1
           phi   R15                    ; and put it back
           lbr   fp_sc_up              ; loop back intil msbit is 1
fp_sc_cln: glo   r8                    ; get high byte
           shl                         ; shift out high 1 bit
           plo   r8                    ; set aside
           ghi   R15                    ; get exponent byte
           phi   r8                    ; write other 7 bits to r8.1
           shr                         ; shift bit 0 into DF
           glo   r8                    ; get high byte of mantissa
           shrc                        ; shift bit 0 of expnent in
           plo   r8                    ; and put it back
           glo   F7                   ; get signs
           shr                         ; get sign 1
           ghi   r8                    ; recover exponent
           shrc                        ; shift in sign
           phi   r8                    ; put it back
           inc	r2	;wjr release work area
        inc     sp
        lda     sp
        phi     R13
        ldn     sp
        plo     R13
        inc     sp
        lda     sp
        phi     R12
        ldn     sp
        plo     R12
        inc     sp
        lda     sp
        phi     F7
        ldn     sp
        plo     F7
        sep     RRET
; ************************************
; *** Get exponenst from arguments ***
; *** R8:F9 - Arg 1                ***
; *** RA:FB - Arg 2                ***
; *** Returns: RF.1 - exp1         ***
; ***          RF.0 - exp2         ***
; ************************************
fp_getexp: glo   r8                    ; get exponent of arg1 (bit 0)
           shl                         ; shift it into DF
           ghi   r8                    ; get top 7 bits
           shlc                        ; shift in first bit
           phi   R15                    ; put exp1 into RF.1
           ;str   r2    wjr - this is never used; place into memory as well
           glo   R10                    ; get exponent of arg2 (bit 0)
           shl                         ; shift it into DF
           ghi   R10                    ; get top 7 bits
           shlc                        ; shift in first bit
           plo   R15                    ; put into RF
        sep     RRET
; ************************************
; *** Get signs from arguments     ***
; *** R8:F9 - Arg 1                ***
; *** RA:FB - Arg 2                ***
; *** Returns: F7.0 - signs        ***
; ************************************
fp_getsgn: ghi   r8                    ; get sign of arg1
           shl                         ; shift into DF
           ghi   R10                    ; get sign of arg2
           shlc                        ; shift into DF, sign of arg1 to bit 0
           shlc                        ; now shift in sign of arg2
           plo   F7                    ; save them
        sep     RRET
; ***************************************
; *** Add 2 SP floating point numbers ***
; *** R8:F9 - Arg 1                   ***
; *** RA:FB - Arg 2                   ***
; *** Returns: R8:F9 - Answer         ***
; *** Usage: RF.0 - exponent of arg1  ***
; ***        RF.1 - exponent of arg2  ***
; ***        F7.0 - signs        ***
; ***************************************
fp_add:   ghi   r8                    ; check arg1 for zero
           lbnz  add_a1nz
           glo   r8
           lbnz  add_a1nz
           ghi   F9
           lbnz  add_a1nz
           glo   F9
           lbnz  add_a1nz
           ghi   R10                    ; transfer arg2 to answer
           phi   r8
           glo   R10
           plo   r8
           ghi   FB
           phi   F9
           glo   FB
           plo   F9
        sep     RRET
add_a1nz:  ghi   R10                    ; check arg2 for zero
           lbnz  add_a2nz
           glo   R10
           lbnz  add_a2nz
           ghi   FB
           lbnz  add_a2nz
           glo   FB
           lbnz  add_a2nz
        sep     RRET
        glo     F7
        stxd
        ghi     F7
        stxd
        glo     R12
        stxd
        ghi     R12
        stxd
        glo     R13
        stxd
        ghi     R13
        stxd
	   dec	r2	;wjr - make a work area
        sep     RCALL
        dw      FP_GETEXP
           ghi   R15
           str   r2
           glo   R15
           sm                          ; perfrom exp2 - exp1
           lbnf  add_ns                ; jump if no swap needed
           ghi   r8                    ; swap arg1 with arg2
           plo   R14
           ghi   R10
           phi   r8
           glo   R14
           phi   R10
           glo   r8
           plo   R14
           glo   R10
           plo   r8
           glo   R14
           plo   R10
           ghi   F9                    ; swap arg1 with arg2
           plo   R14
           ghi   FB
           phi   F9
           glo   R14
           phi   FB
           glo   F9
           plo   R14
           glo   FB
           plo   F9
           glo   R14
           plo   FB
           ghi   R15                    ; swap exponents
           plo   R14
           glo   R15
           phi   R15
           glo   R14
           plo   R15
        sep     RCALL
        dw      FP_GETSGN
           ldi   0                     ; setup mantissas
           phi   r8
           phi   R10
           ldi   128                   ; need to set high bit in mantissa
           str   r2
           glo   r8
           or
           plo   r8
           glo   R10
           or
           plo   R10
           ghi   R15                    ; get exp1
           str   r2                    ; place into memory
add_lp1:   glo   R15                    ; get exp2
           sm                          ; see if match to exp1
           lbz   add_lp1dn             ; jump if match
           glo   R15                    ; need to increase it
           adi   1
           plo   R15
           glo   R10                    ; now shift arg2 over 1 bit
           shr
           plo   R10
           ghi   FB
           shrc
           phi   FB
           glo   FB
           shrc
           plo   FB
           lbr   add_lp1               ; keep shifting until exponents match
add_lp1dn: glo   F7                    ; see if signs match
           str   r2
           shr
           xor
           ani   1                     ; keep only bottom bit
           lbnz  add_nm                ; jump if signs do not match
        sep     RCALL
        dw      FP_ADD_12
           lbr   add_fnl               ; jump to clean up
add_nm:    glo   FB                    ; perform arg1 - arg2
           str   r2
           glo   F9
           sm
           plo   R12                    ; place into RD:RC
           ghi   FB
           str   r2
           ghi   F9
           smb
           phi   R12
           glo   R10
           str   r2
           glo   r8
           smb
           plo   R13
           ghi   R10
           str   r2
           ghi   r8
           smb
           phi   R13
           lbnf  add_no                ; jump if arg2 was larger than arg1
           ghi   R13                    ; transfer result to arg1
           phi   r8
           glo   R13
           plo   r8
           ghi   R12
           phi   F9
           glo   R12
           plo   F9
           lbr   add_fnl               ; finalize
add_no:    glo   F9                    ; perform arg1 = arg2 - arg1
           str   r2
           glo   FB
           sm
           plo   F9
           ghi   F9
           str   r2
           ghi   FB
           smb
           phi   F9
           glo   r8
           str   r2
           glo   R10
           smb
           plo   r8
           ghi   r8
           str   r2
           ghi   R10
           smb
           phi   r8
           glo   F7                    ; move sign 2 to sign1
           shl
           plo   F7
add_fnl:   ghi   r8                    ; check for zero result
           lbnz  add_nz                ; jump if not
           glo   r8
           lbnz  add_nz
           ghi   F9
           lbnz  add_nz
           glo   F9
           lbnz  add_nz
           inc	r2	;wjr release work area
        inc     sp
        lda     sp
        phi     R13
        ldn     sp
        plo     R13
        inc     sp
        lda     sp
        phi     R12
        ldn     sp
        plo     R12
        inc     sp
        lda     sp
        phi     F7
        ldn     sp
        plo     F7
        sep     RRET
add_nz:    ghi   r8                    ; see if answer is beyond 24 bits
           lbz   add_nx                ; jump if not
        sep     RCALL
        dw      FP_SHR_1
           ghi   R15                    ; get exp1
           adi   1                     ; increment it
           phi   R15                    ; and put it back
           lbr   add_nz                ; keep going until not > 24 bits
add_nx:    glo   F7                    ; move sign 1 to low bit
           shr
           plo   F7
           lbr   fp_sc_up              ; scale number and build answer
; ***************************************
; *** sub 2 SP floating point numbers ***
; *** R8:F9 - Arg 1                   ***
; *** RA:FB - Arg 2                   ***
; *** Returns: R8:F9 - Answer         ***
; ***************************************
fp_sub:    ghi   R10                    ; change sign of arg2
           xri   080h
           phi   R10                    ; and put it back
           lbr   fp_add                ; now just add
; ***************************************
; *** Div 2 SP floating point numbers ***
; *** R8:F9 - Arg 1                   ***
; *** RA:FB - Arg 2                   ***
; *** Returns: R8:F9 - Answer         ***
; *** Usage: RF.0 - exponent of arg1  ***
; ***        RF.1 - exponent of arg2  ***
; ***        F7.0 - signs        ***
; ***************************************
fp_div:    ghi   r8                    ; check arg1 for zero
           lbnz  div_a1nz
           glo   r8
           lbnz  div_a1nz
           ghi   F9
           lbnz  div_a1nz
           glo   F9
           lbnz  div_a1nz
        sep     RRET
div_a1nz:  ghi   R10                    ; check arg2 for zero
           lbnz  div_a2nz
           glo   R10
           lbnz  div_a2nz
           ghi   FB
           lbnz  div_a2nz
           glo   FB
           lbnz  div_a2nz
           ghi   r8                    ; need sign of arg1
           ani   080h                  ; want only sign
           ori   07fh                  ; exponent will be all ones
           phi   r8                    ; put into answer
           ldi   080h                  ; build rest of answer
           plo   r8 
           ldi   0
           phi   F9
           plo   F9
        sep     RRET
        glo     F7
        stxd
        ghi     F7
        stxd
        glo     R12
        stxd
        ghi     R12
        stxd
        glo     R13
        stxd
        ghi     R13
        stxd
	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
        sep     RCALL
        dw      FP_GETEXP
        sep     RCALL
        dw      FP_GETSGN
           glo   R15                    ; get exp2
           smi   127                   ; remove bias
           str   r2                    ; place into memory
           ghi   R15                    ; get exp1
           smi   127                   ; remove bias
           sm                          ; perform exp1 - exp2
           adi   127                   ; put bias back in
           stxd                        ; save onto stack
           glo   F7                    ; determine sign for answer
           str   r2
           shr
           xor
           stxd                        ; place onto stack
           ldi   0                     ; setup man
           phi   R10
           glo   R10
           ori   080h
           plo   R10
           ldi   0                     ; setup div
           phi   r8
           glo   r8
           ori   080h
           plo   r8
           ldi   0                     ; setup result
           phi   R12
           plo   R12
           phi   F7
           plo   F7
           plo   R15                    ; setup quotient
           phi   R15
           phi   R13
           plo   R13
           ldi   080h
           plo   R15
div_lp:    ghi   r8                    ; check div for nonzero
           lbnz  div_go1
           glo   r8
           lbnz  div_go1
           ghi   F9
           lbnz  div_go1
           glo   F9
           lbnz  div_go1
           lbr   div_z
div_go1:   ghi   R10
           lbnz  div_go
           glo   R10
           lbnz  div_go
           ghi   FB
           lbnz  div_go
           glo   FB
           lbnz  div_go
           lbr   div_z                 ; nothing more to do
div_go:    glo   FB                    ; see if div > man
           str   r2
           glo   F9
           sm
           ghi   FB
           str   r2
           ghi   F9
           smb
           glo   R10
           str   r2
           glo   r8
           smb
           ghi   R10
           str   r2
           ghi   r8
           smb
           lbnf  div_nope              ; jump if div was smaller
           glo   FB                    ; div -= man
           str   r2
           glo   F9
           sm
           plo   F9
           ghi   FB
           str   r2
           ghi   F9
           smb
           phi   F9
           glo   R10
           str   r2
           glo   r8
           smb
           plo   r8
           ghi   R10
           str   r2
           ghi   r8
           smb
           phi   r8
           ghi   R15                    ; merge quotient into result
           str   r2
           ghi   R12
           or
           phi   R12
           glo   R15
           str   r2
           glo   R12
           or
           plo   R12
           ghi   R13
           str   r2
           ghi   F7
           or
           phi   F7
           glo   R13
           str   r2
           glo   F7
           or
           plo   F7
        sep     RCALL
        dw      FP_SHR_FD
           ghi   R10                    ; shift divisor right
           shr
           phi   R10
           glo   R10
           shrc
           plo   R10
           ghi   FB
           shrc
           phi   FB
           glo   FB
           shrc
           plo   FB
           lbr   div_lp                ; loop back until done
div_z:     ghi   R12                    ; move result to arg1
           phi   r8
           glo   R12
           plo   r8
           ghi   F7
           phi   F9
           glo   F7
           plo   F9
           irx                         ; recover sign
           ldxa
           plo   F7
           ldx                         ; recover answer exponent
           phi   R15
           lbr   fp_sc_up              ; scale number and build answer
; ***************************************
; *** Mul 2 SP floating point numbers ***
; *** R8:F9 - Arg 1                   ***
; *** RA:FB - Arg 2                   ***
; *** Returns: R8:F9 - Answer         ***
; *** Usage: RF.0 - exponent of arg1  ***
; ***        RF.1 - exponent of arg2  ***
; ***        F7.0 - signs             ***
; ***************************************
        glo     F7
        stxd
        ghi     F7
        stxd
        glo     R12
        stxd
        ghi     R12
        stxd
        glo     R13
        stxd
        ghi     R13
        stxd
	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
        sep     RCALL
        dw      FP_GETEXP
        sep     RCALL
        dw      FP_GETSGN
           glo   R15                    ; get exp2
           smi   127                   ; remove bias
           str   r2                    ; place into memory
           ghi   R15                    ; get exp1
           smi   127                   ; remove bias
           add                         ; add in exponent 2
           adi   127                   ; put bias back in
           stxd                        ; place onto stack
           glo   F7                    ; determine sign for answer
           str   r2
           shr
           xor
           stxd                        ; place onto stack
           ghi   R14                    ; get baud constant
           stxd                        ; save on stack
           ghi   r6                    ; save return position on stack
           stxd
           glo   r6
           stxd
           ldi   0                     ; initial value of ct
           stxd
           phi   R14                    ; set mulH to 0
           plo   R14
           phi   r6
           plo   r6
           phi   r8                    ; mulL = arg1 & 0xffffff
           glo   r8                    ; be sure high bit is set
           ori   080h
           plo   r8
           ldi   0
           phi   R12                    ; set result to 0
           plo   R12
           phi   F7
           plo   F7
           phi   R15
           plo   R15
           phi   R13
           plo   R13
           phi   R10                    ; arg2 &= 0ffffff
           glo   R10                    ; be sure high bit is set
           ori   080h
           plo   R10
mul_lp1:   glo   FB                    ; check for zero multiplier
           lbnz  mul_go1               ; jump if not zero
           ghi   FB
           lbnz  mul_go1
           glo   R10
           lbnz  mul_go1
           ghi   R10
           lbz   mul_dn                ; jump if muliplier is zero
mul_go1:   ghi   R10                    ; shift multiplier right
           shr
           phi   R10
           glo   R10
           shrc
           plo   R10
           ghi   FB
           shrc
           phi   FB
           glo   FB
           shrc
           plo   FB
           lbnf  mul_no                ; jump if low bit was zero
           glo   F9                    ; res += mul
           str   r2
           glo   F7
           add
           plo   F7
           ghi   F9
           str   r2
           ghi   F7
           adc
           phi   F7
           glo   r8
           str   r2
           glo   R12
           adc
           plo   R12
           ghi   r8
           str   r2
           ghi   R12
           adc
           phi   R12
           glo   r6                    ; now high 32 bits
           str   r2
           glo   R13
           add
           plo   R13
           ghi   r6
           str   r2
           ghi   r6
           str   r2
           ghi   R13
           adc
           phi   R13
           glo   R14
           str   r2
           glo   R15
           adc
           plo   R15
           ghi   R14
           str   r2
           ghi   R15
           adc
           phi   R15
           ghi   R12                    ; see if need carry from low to high
           lbz   mul_no                ; jump if no carry is needed
           glo   R13                    ; move the carry on over
           adi   1
           plo   R13
           ghi   R13
           adci  0
           phi   R13
           glo   R15
           adci  0
           plo   R15
           ghi   R15
           adci  0
           phi   R15
mul_no:    irx                         ; recover ct
           ldx
           adi   1                     ; increment by 1
           stxd                        ; and put it back
           glo   F9                    ; shift mulL left
           shl
           plo   F9
           ghi   F9
           shlc
           phi   F9
           glo   r8
           shlc
           plo   r8
           ghi   r8
           shlc
           phi   r8
           glo   r6                    ; shift mulH left
           shl
           plo   r6
           ghi   r6
           shlc
           phi   r6
           glo   R14
           shlc
           plo   R14
           ghi   R14
           shlc
           phi   R14
           ghi   r8                    ; see if a carry is needed
           lbz   mul_lp1               ; jump if not
           ldi   0                     ; zero the high byte
           phi   r8
           glo   r6                    ; add in the carry
           ori   1
           plo   r6
           lbr   mul_lp1               ; loop back for more
mul_dn:    irx                         ; recover ct
           ldxa
           plo   R14                    ; set aside
           ldxa
           plo   r6
           ldxa
           phi   r6
           ldx
           phi   R14
           ghi   R12                    ; transfer resL to arg1
           phi   r8
           glo   R12
           plo   r8
           ghi   F7
           phi   F9
           glo   F7
           plo   F9
           glo   R14
           plo   R12                    ; put ct into RC.0
mul_lp2:   glo   R12                    ; get ct
           smi   2                     ; see if <2
           lbnf  mul_nxt1              ; jump if so
        sep     RCALL
        dw      FP_SHR_1
        sep     RCALL
        dw      FP_SHR_FD
           lbnf  mul_lp2a              ; jump if no carry into low word
           glo   r8                    ; set high bit
           ori   080h
           plo   r8
mul_lp2a:  dec   R12                    ; decrement count
           lbr   mul_lp2               ; loop back to keep checking
mul_nxt1:  irx                         ; recover sign
           ldxa
           plo   F7
           ldx                         ; recover answer exponent
           plo   R12
mul_lp3:   ghi   R15                    ; check resH for nonzero
           lbnz  mul_lp3a
           glo   R15
           lbnz  mul_lp3a
           ghi   R13
           lbnz  mul_lp3a
           glo   R13
           lbnz  mul_lp3a
           lbr   mul_lp4               ; jump if no bits set in resH
mul_lp3a:  inc   R12                    ; increment exponent
        sep     RCALL
        dw      FP_SHR_1
        sep     RCALL
        dw      FP_SHR_FD
           lbnf  mul_lp3               ; jump if no carry into low word
           glo   r8                    ; set high bit
           ori   080h
           plo   r8
           lbr   mul_lp3
mul_lp4:   glo   R12                    ; transfer exponent
           phi   R15                    ; to high R15
           lbr   fp_sc_up              ; scale number and build answer
; ***************************************
; *** Convert ascii to floating point ***
; *** RF - buffer to ascii text       ***
; *** Returns: R8:F9 - number         ***
; ***************************************
fp_atof:   lda   R15                    ; get byte from buffer
           smi   ' '                   ; check for space
           lbz   fp_atof               ; move past any spaces
           dec   R15                    ; point back to nonspace chara
           ldn   R15                    ; check for possible sign
           smi   '-'                   ; first check for minus
           lbnz   atof_nm              ; jump if not minus
           ldi   080h                  ; high bit set for minus
           stxd                        ; place onto stack
           inc   R15                    ; move past sign
           lbr   atof_go1              ; and continue
atof_nm:   ldi   0                     ; indicate positive number
           stxd                        ; place onto stack
           ldn   R15                    ; now check for + sign
           smi   '+'
           lbnz  atof_go1              ; jump if not plus
           inc   R15                    ; move past plus sign
atof_go1:  ldi   0                     ; setup result
           phi   r8
           plo   r8
           phi   F9
           plo   F9
atof_lp1:  ldn   R15                    ; get next byte from buffer
        sep     RCALL
        dw      F_ISNUM
           lbnf  atof_no1              ; jump if not
           ghi   r8                    ; copy arg1 to arg2
           phi   R10
           glo   r8
           plo   R10
           ghi   F9
           phi   FB
           glo   F9
           plo   FB
        sep     RCALL
        dw      FP_SHL_1
        sep     RCALL
        dw      FP_SHL_1
        sep     RCALL
        dw      FP_ADD_12
        sep     RCALL
        dw      FP_SHL_1
           lda   R15                    ; get number
           smi   '0'                   ; convert to binary
           str   r2                    ; setup for add
           glo   F9                    ; add in next digit
           add
           plo   F9
           ghi   F9                    ; propagate carry
           adci  0
           phi   F9
           glo   r8
           adci  0
           plo   r8
           ghi   r8
           adci  0
           phi   r8
           lbr   atof_lp1              ; loop until no more digits
atof_no1:  ldn   R15                    ; check for decimal point
           smi   '.'
           lbnz  atof_ndp              ; jump if none
           inc   R15                    ; move past decimal
atof_ndp:  ldi   scratch>>8          ; point to scratch area
           phi   R10
           ldi   scratch&255
           plo   R10
           ldi   16                    ; 16 bytes to clear
           plo   R12
atof_lpx:  ldi   0
           str   R10
           inc   R10
           dec   R12
           glo   R12
           lbnz  atof_lpx
           ldi   (scratch+1)>>8      ; point to scratch area
           phi   R10
           ldi   (scratch+1)&255
           plo   R10
           ldi   1                     ; setup count
           plo   R12
           ldi   0                     ; setup exp flag
           phi   R12
atof_lp2:  glo   R12                    ; see if done making bcd
           smi   17
           lbz   atof_dn3              ; jump if so
           ldn   R15                    ; get character
        sep     RCALL
        dw      F_ISNUM
           lbnf  atof_dn3              ; jump if not
           lda   R15                    ; get character
           smi   '0'                   ; converto to binary
           str   R10                    ; write into bcd area
           inc   R10
           inc   R12                    ; increment count
           lbnz  atof_lp2              ; loop back until done
           ldi   1                     ; set non zero flag
           phi   R12
           lbr   atof_lp2
atof_dn3:  ghi   R12                    ; check for non-zero digits
           lbnz  atof_nz
           ghi   r8                    ; check for non-zero integer
           lbnz  atof_nz
           glo   r8
           lbnz  atof_nz
           ghi   F9
           lbnz  atof_nz
           glo   F9
           lbnz  atof_nz
           irx                         ; recover sign
           ldx
           phi   r8                    ; put in high of zero
           lbr	atof_end               ; and return
atof_nz:   ldi   0                     ; setup dp
           phi   R12
atof_lp3:  ghi   r8                    ; check for high bit set
           ani   080h
           lbnz  atof_dn4              ; jump if so
        sep     RCALL
        dw      FP_SHL_1
           ldi   scratch>>8          ; point to bcd number
           phi   R10
           ldi   255&scratch
           plo   R10
           ldi   0                     ; set high byte to zero
           str   R10
           ldi   (scratch+15)>>8     ; point to last cell
           phi   R10
           ldi   255&(scratch+15)
           plo   R10
           ldi   0                     ; set carry forward
           plo   R14
           ldi   16                    ; setup count
           plo   R12
atof_lp4:  glo   R14                    ; get carry
           str   r2                    ; in memory for add
           ldn   R10                    ; get bcd digit
           add                         ; add in carry
           str   r2                    ; place into memory
           ldn   R10                    ; recover bcd digit
           add                         ; digit now doubled with carry
           str   R10                    ; put it back
           smi   10
           lbnf  atof_no4              ; jump if below 10
           str   R10                    ; store value - 10
           ldi   1                     ; carry set to 1
           lskp                        ; skip next instruction
atof_no4:  ldi   0                     ; reset carry
           plo   R14
           dec   R10                    ; move to previous digit
           dec   R12                    ; decrement digit count
           glo   R12                    ; see if done
           lbnz  atof_lp4              ; jump if not
           ldi   scratch>>8	       ; point to first digit
           phi   R10
           ldi   255&scratch
           plo   R10
           ldn   R10                    ; retrieve it
           lbz   atof_nc4              ; jump if no carry
           glo   F9                    ; add in the carry
           ori   1
           plo   F9
atof_nc4:  ghi   R12                    ; increment dp
           adi   1
           phi   R12
           lbr   atof_lp3              ; loop until full
atof_dn4:  ghi   R12                    ; get dp
           str   r2                    ; into memory
           ldi   31                    ; need to subtract from 31
           sm
           adi   127                   ; add in bias
           phi   R13                    ; set aside
           ghi   F9                    ; shift result down 8 bits
           plo   F9
           glo   r8
           phi   F9
           ghi   r8
           shl                         ; shift out high bit
           plo   r8
           ghi   R13                    ; get bit 0 of exponent
           shr
           phi   r8                    ; bits 1-7 into high byte
           glo   r8                    ; get mantissa
           shrc                        ; shift in bit 0 of exponent
           plo   r8                    ; and write it
           irx                         ; point to sign
           ghi   r8                    ; high byte
           or                          ; set sign
           phi   r8                    ; done with base conversion
           ldn   R15                    ; get next byte
           smi   'e'                   ; check for exponents
           lbz   atof_exp
           ldn   R15
           smi   'E'
           lbnz  atof_end
atof_exp:  inc   R15                    ; move past E
           ldn   R15                    ; check for sign
           smi   '-'
           lbz   atof_n
           ldn   R15
           smi   '+'
           lbz   atof_p
           dec   R15                    ; positive if no sign
atof_p:    ldi   1                     ; indicate positive exponent
           lskp
atof_n:    ldi   0                     ; indicate negative exponent
           phi   R12                    ; place into sign variable
           inc   R15                    ; move past sign
           ldi   0                     ; setup intial count
           plo   R12
atof_lp5:  ldn   R15                    ; get next byte
        sep     RCALL
        dw      F_ISNUM
           lbnf  atof_dn5              ; jump if not
           glo   R12                    ; make copy of exponent
           str   r2
           shr                         ; multiply by 2
           shr                         ; by 4
           add                         ; by 5
           shr                         ; by 10
           str   r2                    ; put here for add
           lda   R15                    ; recover number
           smi   '0'                   ; convert to binary
           add                         ; add with total
           plo   R12                    ; copy back to R12
           lbr   atof_lp5              ; loop back until done reading exponent
atof_dn5:  glo   R12                    ; see if done
           lbz   atof_end              ; jump if so
           dec   R12                    ; otherwise decrement count
           glo   R12                    ; save count
           stxd
           ghi   R12                    ; save sign
           stxd
           glo   R15
           stxd
           ghi   R15
           stxd
           ldi   041h                  ; setup 10.0
           phi   R10
           ldi   020h
           plo   R10
           ldi   0
           phi   FB
           plo   FB
           ghi   R12
           lbz   atof_div              ; jump if negative
        sep     RCALL
        dw      FP_MUL
           lbr   atof_go5              ; clean up call
        sep     RCALL
        dw      FP_DIV
atof_go5:  irx                         ; recover variables
           ldxa
           phi   R15
           ldxa
           plo   R15
           ldxa
           phi   R12
           ldx
           plo   R12
           lbr   atof_dn5              ; loop until exponent is zero
atof_end:
	   inc	r2	;wjr release work area
        inc     sp
        lda     sp
        phi     R13
        ldn     sp
        plo     R13
        inc     sp
        lda     sp
        phi     R12
        ldn     sp
        plo     R12
        inc     sp
        lda     sp
        phi     F7
        ldn     sp
        plo     F7
        sep     RRET
scratch:   db	00,00
;IO1802.inc contains input/output runtime routines for LCC1802
;The port is in regArg1, the output byte is in regArg2
;17-10-16 adding _putcpace(port,byte) to limit output speed to the AVR
;         defaulting putc(x) to putcpace(7,x)
;17-11-22 removing putc altogether
_inp:		;raw port input
		;stores a small tailored program on the stack and executes it
	dec	sp	;work backwards
	ldi	0xD3	;return instruction
	stxd		
	glo	regarg1	;get the port number
	ani	0x07	;clean it
	bz	+	; inp(0) isn't valid
	ori	0x68	;make it an input instruction
	stxd		;store it for execution
        glo     SP
        plo     RT1
        ghi     SP
        phi     RT1
	inc	rt1	;rt1 points to the 6x instruction
	sep	rt1	;execute it
;we will come back to here with the input byte in D
	inc	sp	;step over the work area
	plo	retVal	;save it to return
	ldi	0
	phi	retval	;clear top byte
+	inc	sp	;need to get rid of the 6x instruction
	inc	sp	;and the D3
        sep     RRET
_out:		;raw port output
		;stores a small tailored program on the stack and executes it
		;this could be bolder:
		;store the program as 6x cc D5 where x is the port number and cc is the char
		;then SEP sp
		;the D5 would return to the calling program and finish fixing the stack.
		;saves 6 instructions but it's a bit tricky.
	dec	sp	;work backwards
	ldi	0xD3	;return instruction
	stxd		
        glo     SP
        plo     RT1
        ghi     SP
        phi     RT1
	glo	regarg1	;get the port number
	ani	0x07	;clean it
	ori	0x60	;make it an out instruction - 60 is harmless
	stxd		;store it for execution
	glo	regarg2	;get the byte to be written
	str	sp	;store it where sp points
	sep	rt1	;execute it
;we will come back to here with sp stepped up by one
+	inc	sp	;need to get rid of the 6x instruction
	inc	sp	;and the D3
        sep     RRET
