 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 1 - 11/6/2017 9:07:24


       1/       0 :                     ; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Mon Nov 06 09:07:13 2017
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1) 1060/       0 :                     	listing	on
(1) 1061/       0 : C0 06 33            	lbr	lcc1802Init
(1) 1062/       3 :                     	
(1) 1063/       3 :                     
      11/       3 :                     	listing on
      12/       3 :                     _PIN4:
      13/       3 : 00                  	db 0
      14/       4 :                     ;$$function start$$ _boydinc
      15/       4 :                     _boydinc:		;framesize=2
      16/       4 :                     ;void boydinc(){
      17/       4 :                     ;	asm(" include \"boydscan.inc\"\n");
      18/       4 :                      include "boydscan.inc"
(1)    1/       4 :                     _boydscan:			;SCAN THE KEYBOARD
(1)    2/       4 : EE                  		sex	r14 	;set up "don't care" X register
(1)    3/       5 : 68 CF 00 00         		rldi	r15,0	; r15 is return value
(1)    4/       9 : 61                  .scan:		OUT	1                     ;109: 61 	
(1)    5/       A : 34 50               		B1	.KEY_12                     ;10A: 34 50 	
(1)    6/       C : 35 60               		B2	.KEY_8                      ;10C: 35 60 	
(1)    7/       E : 36 70               		B3	.KEY_4                      ;10E: 36 70 	
(1)    8/      10 : 37 80               		B4	.KEY_0                      ;110: 37 80 	
(1)    9/      12 : 62                  		OUT	2                     ;112: 62 	
(1)   10/      13 : 34 54               		B1	.KEY_13                     ;113: 34 54 	
(1)   11/      15 : 35 64               		B2	.KEY_9                      ;115: 35 64 	
(1)   12/      17 : 36 74               		B3	.KEY_5                      ;117: 36 74 	
(1)   13/      19 : 37 84               		B4	.KEY_1                      ;119: 37 84 	
(1)   14/      1B : 63                  		OUT	3                     ;11B: 63 	
(1)   15/      1C : 34 58               		B1	.KEY_14                     ;11C: 34 58 	
(1)   16/      1E : 35 68               		B2	.KEY_10                     ;11E: 35 68 	
(1)   17/      20 : 36 78               		B3	.KEY_6                      ;120: 36 78 	
(1)   18/      22 : 37 88               		B4	.KEY_2                      ;122: 37 88 	
(1)   19/      24 : 64                  		OUT	4                     ;124: 64 	
(1)   20/      25 : 34 5C               		B1	.KEY_15                     ;125: 34 5C 	
(1)   21/      27 : 35 6C               		B2	.KEY_11                     ;127: 35 6C 	
(1)   22/      29 : 36 7C               		B3	.KEY_7                      ;129: 36 7C 	
(1)   23/      2B : 37 8C               		B4	.KEY_3                      ;12B: 37 8C 	
(1)   24/      2D : 65                  		OUT	5                     ;12D: 65 	
(1)   25/      2E : 34 AC               		B1	.KEY_DIV_WHOLE              ;12E: 34 99 	
(1)   26/      30 : 35 98               		B2	.KEY_MUL                    ;130: 35 96 	
(1)   27/      32 : 36 94               		B3	.KEY_SUB                    ;132: 36 93 	
(1)   28/      34 : 37 90               		B4	.KEY_ADD                    ;134: 37 90 	
(1)   29/      36 : 66                  		OUT	6                     ;136: 66 	
(1)   30/      37 : 34 A0               		B1	.KEY_REM                    ;137: 34 A5 	
(1)   31/      39 : 35 9C               		B2	.KEY_MEM_STORE              ;139: 35 A2 	
(1)   32/      3B : 36 AC               		B3	.KEY_MEM_RECALL             ;13B: 36 9F 	
(1)   33/      3D : 37 AC               		B4	.KEY_EQU                    ;13D: 37 9C 	
(1)   34/      3F : 7B                  		SEQ                                ;13F: 7B 	
(1)   35/      40 : 34 AB               		B1	.KEY_DIV_FIS                ;140: 34 B1 	
(1)   36/      42 : 35 A4               		B2	.KEY_CLEAR                  ;142: 35 AE 	
(1)   37/      44 : 36 AA               		B3	.KEY_CLR_ENTRY              ;144: 36 AB 	
(1)   38/      46 : 37 A9               		B4	.KEY_INV_SIGN               ;146: 37 A8 	
(1)   39/      48 : 7A                  		REQ                                ;148: 7A 	
(1)   40/      49 :                     ;here we have no keys pressed, if r15.0 has a value, return it -1
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(boydscan.inc) - page 2 - 11/6/2017 9:07:24


(1)   41/      49 : 8F                  		glo	r15
(1)   42/      4A : 32 09               		bz	.scan
(1)   43/      4C : 2F                  		dec	r15
(1)   44/      4D : E2                  		sex	r2	;restore the X register before returning
(1)   45/      4E : (MACRO)             		cretn
(1)   46/      50 :                     
(1)   47/      50 : F8 0D               .KEY_12		LDI	13                         ;150: F8  C 	
(1)   48/      52 : 30 AC               		BR	.KEY_SAVE                   ;152: 30 B4 	
(1)   49/      54 : F8 0E               .KEY_13		LDI	14                         ;154: F8  D 	
(1)   50/      56 : 30 AC               		BR	.KEY_SAVE                   ;156: 30 B4 	
(1)   51/      58 : F8 0F               .KEY_14		LDI	15                         ;158: F8  E 	
(1)   52/      5A : 30 AC               		BR	.KEY_SAVE                   ;15A: 30 B4 	
(1)   53/      5C : F8 10               .KEY_15		LDI	16                         ;15C: F8  F 	
(1)   54/      5E : 30 AC               		BR	.KEY_SAVE                   ;15E: 30 B4 	
(1)   55/      60 : F8 09               .KEY_8		LDI	 9                         ;160: F8  8 	
(1)   56/      62 : 30 AC               		BR	.KEY_SAVE                   ;162: 30 B4 	
(1)   57/      64 : F8 0A               .KEY_9		LDI	 10                         ;164: F8  9 	
(1)   58/      66 : 30 AC               		BR	.KEY_SAVE                   ;166: 30 B4 	
(1)   59/      68 : F8 0B               .KEY_10		LDI	11                         ;168: F8  A 	
(1)   60/      6A : 30 AC               		BR	.KEY_SAVE                   ;16A: 30 B4 	
(1)   61/      6C : F8 0C               .KEY_11		LDI	12                         ;16C: F8  B 	
(1)   62/      6E : 30 AC               		BR	.KEY_SAVE                   ;16E: 30 B4 	
(1)   63/      70 : F8 05               .KEY_4		LDI	 5                         ;170: F8  4 	
(1)   64/      72 : 30 AC               		BR	.KEY_SAVE                   ;172: 30 B4 	
(1)   65/      74 : F8 06               .KEY_5		LDI	 6                         ;174: F8  5 	
(1)   66/      76 : 30 AC               		BR	.KEY_SAVE                   ;176: 30 B4 	
(1)   67/      78 : F8 07               .KEY_6		LDI	 7                         ;178: F8  6 	
(1)   68/      7A : 30 AC               		BR	.KEY_SAVE                   ;17A: 30 B4 	
(1)   69/      7C : F8 08               .KEY_7		LDI	 8                         ;17C: F8  7 	
(1)   70/      7E : 30 AC               		BR	.KEY_SAVE                   ;17E: 30 B4 	
(1)   71/      80 : F8 01               .KEY_0		LDI	 1                         ;180: F8  0 	
(1)   72/      82 : 30 AC               		BR	.KEY_SAVE                   ;182: 30 B4 	
(1)   73/      84 : F8 02               .KEY_1		LDI	 2                         ;184: F8  1 	
(1)   74/      86 : 30 AC               		BR	.KEY_SAVE                   ;186: 30 B4 	
(1)   75/      88 : F8 03               .KEY_2		LDI	 3                         ;188: F8  2 	
(1)   76/      8A : 30 AC               		BR	.KEY_SAVE                   ;18A: 30 B4 	
(1)   77/      8C : F8 04               .KEY_3		LDI	 4                         ;18C: F8  3 	
(1)   78/      8E : 30 AC               		BR	.KEY_SAVE                   ;18E: 30 B4 	
(1)   79/      90 :                     		
(1)   80/      90 : F8 11               .KEY_ADD	ldi	16+1
(1)   81/      92 : 30 AC               		br	.key_save
(1)   82/      94 : F8 12               .KEY_SUB:	ldi	17+1
(1)   83/      96 : 30 AC               		br	.key_save
(1)   84/      98 : F8 15               .KEY_MUL:	ldi	20+1
(1)   85/      9A : 30 AC               		br	.key_save
(1)   86/      9C : F8 14               .KEY_MEM_STORE:	ldi	19+1
(1)   87/      9E : 30 AC               		br	.key_save
(1)   88/      A0 :                     
(1)   89/      A0 : F8 13               .KEY_REM:	ldi	18+1
(1)   90/      A2 : 30 AC               		br	.key_save
(1)   91/      A4 : 7A                  .KEY_CLEAR:	req
(1)   92/      A5 : F8 15               		ldi	20+1
(1)   93/      A7 : 30 AC               		br	.key_save
(1)   94/      A9 : 7A                  .KEY_INV_SIGN:	req
(1)   95/      AA : 7A                  .KEY_CLR_ENTRY:	req
(1)   96/      AB : 7A                  .KEY_DIV_FIS:	req
(1)   97/      AC :                     .KEY_EQU:
(1)   98/      AC :                     .KEY_DIV_WHOLE:
(1)   99/      AC :                     .KEY_MEM_RECALL:
(1)  100/      AC : AF                  .KEY_SAVE:	plo 15
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(boydscan.inc) - page 3 - 11/6/2017 9:07:24


(1)  101/      AD : 30 09               		br .scan
      19/      AF :                     ;}
      20/      AF :                     L1:
      21/      AF : (MACRO)             	Cretn
      22/      B1 :                     
      23/      B1 :                     ;$$function end$$ _boydinc
      24/      B1 :                     ;$$function start$$ _disp1
      25/      B1 :                     _disp1:		;framesize=2
      26/      B1 :                     ;void disp1(unsigned char d){//display a byte as two hex digits
      27/      B1 :                     ;	asm(" glo 12\n ani 0x0f\n" //prep bottom digit
      28/      B1 : 8C                   glo 12
      29/      B2 : FA 0F                ani 0x0f
      30/      B4 : 22                   dec 2
      31/      B5 : 52                   str 2
      32/      B6 : 67                   out 7
      33/      B7 : 8C                   glo 12
      34/      B8 : F6                   shr
      35/      B9 : F6                   shr
      36/      BA : F6                   shr
      37/      BB : F6                   shr
      38/      BC : 22                   dec 2
      39/      BD : 52                   str 2
      40/      BE : 67                   out 7
      41/      BF :                     ;}
      42/      BF :                     L3:
      43/      BF : (MACRO)             	Cretn
      44/      C1 :                     
      45/      C1 :                     ;$$function end$$ _disp1
      46/      C1 :                     ;$$function start$$ _dispmemloc
      47/      C1 :                     _dispmemloc:		;framesize=8
      48/      C1 : (MACRO)             	pushr R7
      49/      C3 : (MACRO)             	reserve 4; save room for outgoing arguments
      50/      C7 : (MACRO)             	st2 R12,'O',sp,(8+1); flag1 
      51/      D4 :                     ;void dispmemloc(unsigned char * loc){
      52/      D4 :                     ;	initleds();
      53/      D4 :                     ;	disp1(*(loc+1));
      54/      D4 : 7A                   req
      55/      D5 : 7B                   seq
      56/      D6 : 22                   dec 2
      57/      D7 : 67                   out 7
      58/      D8 : 7A                   req
      59/      D9 : (MACRO)             	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
      60/      E5 : (MACRO)             	ld1 R12,'O',R11,(1)
      61/      EF : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
      62/      F2 : (MACRO)             	Ccall _disp1
      63/      F6 :                     ;	disp1(*loc);
      64/      F6 : (MACRO)             	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
      65/     102 : (MACRO)             	ldn1 R12,R11	;opt14*
      66/     104 : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
      67/     107 : (MACRO)             	Ccall _disp1
      68/     10B :                     ;	lint=(unsigned int)loc;
      69/     10B : (MACRO)             	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
      70/     117 : (MACRO)             	cpy2 R7,R11 ;LOADU2*(reg)
      71/     11B :                     ;	disp1((unsigned int)loc&0xff);
      72/     11B : (MACRO)             	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
      73/     127 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
      74/     12F : (MACRO)             	cpy1 R12,R11
      75/     131 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
      76/     134 : (MACRO)             	Ccall _disp1
      77/     138 :                     ;	disp1(lint>>8);
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 4 - 11/6/2017 9:07:24


      78/     138 : (MACRO)             	cpy2 R11,R7
      79/     13C : 9B                  	ghi	R11	;opt2
      80/     13D : AB                  	plo	R11
      81/     13E : F8 00               	ldi	0
      82/     140 : BB                  	phi	R11	
      83/     141 : (MACRO)             	cpy1 R12,R11
      84/     143 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
      85/     146 : (MACRO)             	Ccall _disp1
      86/     14A :                     ;}
      87/     14A :                     L5:
      88/     14A : (MACRO)             	release 4; release room for outgoing arguments
      89/     14E : (MACRO)             	popr R7
      90/     153 : (MACRO)             	Cretn
      91/     155 :                     
      92/     155 :                     ;$$function end$$ _dispmemloc
      93/     155 :                     ;$$function start$$ _dispval
      94/     155 :                     _dispval:		;framesize=8
      95/     155 : (MACRO)             	pushr R7
      96/     157 : (MACRO)             	reserve 4; save room for outgoing arguments
      97/     15B : (MACRO)             	st2 R12,'O',sp,(8+1); flag1 
      98/     168 : (MACRO)             	ldA2 R11,'O',sp,(8+1); reg:addr
      99/     170 : (MACRO)             	ld2 R10,'O',sp,(8+1) ;reg:INDIRI2(addr)
     100/     17C : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     101/     17E :                     ;void dispval(unsigned char v){
     102/     17E :                     ;	initleds();
     103/     17E :                     ;	disp1(v);
     104/     17E : 7A                   req
     105/     17F : 7B                   seq
     106/     180 : 22                   dec 2
     107/     181 : 67                   out 7
     108/     182 : 7A                   req
     109/     183 : (MACRO)             	ld1 R12,'O',sp,(8+1)
     110/     18D : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     111/     190 : (MACRO)             	Ccall _disp1
     112/     194 :                     ;	for (i=6;i!=0;i--) out(7,0);
     113/     194 : (MACRO)             	ldaD R7,6; reg:acon
     114/     198 : C0 01 A8            	lbr L12
     115/     19B :                     L9:
     116/     19B : (MACRO)             	ldaD R12,7; reg:acon
     117/     19F : (MACRO)             	ld2z R13
     118/     1A3 : (MACRO)             	Ccall _out; CALLI2(ar)
     119/     1A7 :                     L10:
     120/     1A7 : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
     121/     1A8 :                     L12:
     122/     1A8 : (MACRO)             	jnzU2 R7,L9; NE 0 
     123/     1B0 :                     ;}
     124/     1B0 :                     L7:
     125/     1B0 : (MACRO)             	release 4; release room for outgoing arguments
     126/     1B4 : (MACRO)             	popr R7
     127/     1B9 : (MACRO)             	Cretn
     128/     1BB :                     
     129/     1BB :                     ;$$function end$$ _dispval
     130/     1BB :                     ;$$function start$$ _getsp
     131/     1BB :                     _getsp:		;framesize=2
     132/     1BB :                     ;unsigned int getsp(){//return stack pointer value
     133/     1BB :                     ;	asm(" cpy2 r15,sp\n"  	//copy stack pointer to return reg
     134/     1BB :                     ;	return 0;				//not executed
     135/     1BB : (MACRO)              cpy2 r15,sp
     136/     1BF : (MACRO)              cretn
     137/     1C1 : (MACRO)             	ld2z R15
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 5 - 11/6/2017 9:07:24


     138/     1C5 :                     L13:
     139/     1C5 : (MACRO)             	Cretn
     140/     1C7 :                     
     141/     1C7 :                     ;$$function end$$ _getsp
     142/     1C7 :                     ;$$function start$$ _execute
     143/     1C7 :                     _execute:		;framesize=16
     144/     1C7 : (MACRO)             	reserve 6; save room for local variables
     145/     1CD : (MACRO)             	pushr R6
     146/     1CF : (MACRO)             	pushr R7
     147/     1D1 : (MACRO)             	reserve 4; save room for outgoing arguments
     148/     1D5 : (MACRO)             	cpy2 R7,R12; function(2055) 1
     149/     1D9 :                     ;unsigned char * execute(unsigned char * loc){
     150/     1D9 : C0 03 4C            	lbr L17
     151/     1DC :                     L16:
     152/     1DC :                     ;	while(1){
     153/     1DC :                     ;		op=*loc; val=*(loc+1);
     154/     1DC : (MACRO)             	ldn1 R6,R7;reg:  INDIRU1(indaddr)
     155/     1DE : (MACRO)             	ldA2 R11,'O',sp,(13+1); reg:addr
     156/     1E6 : (MACRO)             	cpy2 R10,R7
     157/     1EA : (MACRO)             	incm R10,1
     158/     1EB : (MACRO)             	ldn1 R10,R10;reg:  INDIRU1(indaddr)
     159/     1ED : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     160/     1EF :                     ;		switch (op){
     161/     1EF : (MACRO)             	cpy1 R11,R6
     162/     1F1 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     163/     1F4 : (MACRO)             	st2 R11,'O',sp,(9+1); ASGNI2(addr,reg)
     164/     201 : (MACRO)             	ld2 R11,'O',sp,(9+1) ;reg:INDIRI2(addr)
     165/     20D : (MACRO)             	jcI2I R11,0,lbnf,L19  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     166/     21E : (MACRO)             	jnI2I R11,4,lbnf,L19; GT reverse  the subtraction
     167/     22F : (MACRO)             	shl2I R11,1
     168/     235 : (MACRO)             	ld2 R11,'O',R11,(L27) ;reg:INDIRP2(addr)
     169/     241 : (MACRO)             	jumpv R11; JUMPV(reg)
     170/     249 :                     L27:
     171/     249 : 02 53               	dw L22
     172/     24B : 02 95               	dw L23
     173/     24D : 02 CE               	dw L24
     174/     24F : 02 EC               	dw L25
     175/     251 : 03 10               	dw L26
     176/     253 :                     L22:
     177/     253 :                     ;				mp=(unsigned char *)(4096+val);
     178/     253 : (MACRO)             	ld1 R11,'O',sp,(13+1)
     179/     25D : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     180/     260 : (MACRO)             	ldA2 R11,'O',R11,(4096); reg:addr
     181/     268 : (MACRO)             	st2 R11,'O',sp,(11+1); ASGNP2(addr,reg)
     182/     275 :                     ;				dispval(*mp); delay(1000);
     183/     275 : (MACRO)             	ld2 R11,'O',sp,(11+1) ;reg:INDIRP2(addr)
     184/     281 : (MACRO)             	ldn1 R12,R11	;opt14*
     185/     283 : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     186/     286 : (MACRO)             	Ccall _dispval
     187/     28A : (MACRO)             	ldaD R12,1000; reg:acon
     188/     28E : (MACRO)             	Ccall _delay
     189/     292 :                     ;				break;
     190/     292 : C0 03 4A            	lbr L20
     191/     295 :                     L23:
     192/     295 :                     ;				mp=(unsigned char *)(4096+val);
     193/     295 : (MACRO)             	ld1 R11,'O',sp,(13+1)
     194/     29F : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     195/     2A2 : (MACRO)             	ldA2 R11,'O',R11,(4096); reg:addr
     196/     2AA : (MACRO)             	st2 R11,'O',sp,(11+1); ASGNP2(addr,reg)
     197/     2B7 :                     ;				*mp+=1;
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 6 - 11/6/2017 9:07:24


     198/     2B7 : (MACRO)             	ld2 R11,'O',sp,(11+1) ;reg:INDIRP2(addr)
     199/     2C3 : (MACRO)             	ldn1 R10,R11	;opt14*
     200/     2C5 : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     201/     2C8 : (MACRO)             	incm R10,1
     202/     2C9 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     203/     2CB :                     ;				break;
     204/     2CB : C0 03 4A            	lbr L20
     205/     2CE :                     L24:
     206/     2CE :                     ;				loc=(unsigned char *)(val+4096-2); //ugh
     207/     2CE : (MACRO)             	ld1 R11,'O',sp,(13+1)
     208/     2D8 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     209/     2DB : (MACRO)             	ldA2 R11,'O',R11,(4096); reg:addr
     210/     2E3 : (MACRO)             	decm R11,2	;SUBI2(reg,consm)
     211/     2E5 : (MACRO)             	cpy2 R7,R11 ;LOADP2(reg)
     212/     2E9 :                     ;				break;
     213/     2E9 : C0 03 4A            	lbr L20
     214/     2EC :                     L25:
     215/     2EC :                     ;				delay(val*4);
     216/     2EC : (MACRO)             	ld1 R11,'O',sp,(13+1)
     217/     2F6 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     218/     2F9 : (MACRO)             	shl2I R11,2
     219/     305 : (MACRO)             	cpy2 R12,R11 ;LOADU2*(reg)
     220/     309 : (MACRO)             	Ccall _delay
     221/     30D :                     ;				break;
     222/     30D : C0 03 4A            	lbr L20
     223/     310 :                     L26:
     224/     310 :                     ;				dispval(getsp());
     225/     310 : (MACRO)             	Ccall _getsp;CALLU2(ar)*
     226/     314 : (MACRO)             	cpy1 R11,R15;LOADU1(reg)
     227/     316 : (MACRO)             	cpy1 R12,R11
     228/     318 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     229/     31B : (MACRO)             	Ccall _dispval
     230/     31F :                     ;				delay(250);
     231/     31F : (MACRO)             	ldaD R12,250; reg:acon
     232/     323 : (MACRO)             	Ccall _delay
     233/     327 :                     ;				break;
     234/     327 : C0 03 4A            	lbr L20
     235/     32A :                     L19:
     236/     32A :                     ;				dispval(0x41); delay(250);
     237/     32A : (MACRO)             	ldaD R12,65; reg:acon
     238/     32E : (MACRO)             	Ccall _dispval
     239/     332 : (MACRO)             	ldaD R12,250; reg:acon
     240/     336 : (MACRO)             	Ccall _delay
     241/     33A :                     ;				dispmemloc(loc); delay(5000);
     242/     33A : (MACRO)             	cpy2 R12,R7 ;LOADP2(reg)
     243/     33E : (MACRO)             	Ccall _dispmemloc
     244/     342 : (MACRO)             	ldaD R12,5000; reg:acon
     245/     346 : (MACRO)             	Ccall _delay
     246/     34A :                     ;				break;
     247/     34A :                     L20:
     248/     34A :                     ;		loc+=2;
     249/     34A : (MACRO)             	incm R7,2
     250/     34C :                     ;	}
     251/     34C :                     L17:
     252/     34C :                     ;	while(1){
     253/     34C : C0 01 DC            	lbr L16
     254/     34F :                     ;	return loc;
     255/     34F : (MACRO)             	cpy2 R15,R7 ;LOADP2(reg)
     256/     353 :                     L15:
     257/     353 : (MACRO)             	release 4; release room for outgoing arguments
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 7 - 11/6/2017 9:07:24


     258/     357 : (MACRO)             	popf R7	;opt11.3
     259/     35A : (MACRO)             	popl R6	;opt11.3
     260/     35E : (MACRO)             	release 6; release room for local variables 
     261/     364 : (MACRO)             	Cretn
     262/     366 :                     
     263/     366 :                     ;$$function end$$ _execute
     264/     366 :                     ;$$function start$$ _hello
     265/     366 :                     _hello:		;framesize=2
     266/     366 :                     ;void hello(){
     267/     366 :                     ;	asm(" seq ;activate the printer\n"
     268/     366 : 7B                   seq ;activate the printer
     269/     367 : E3                   sex 3 ;inline output data
     270/     368 : C4                   nop
     271/     369 : C4                   nop
     272/     36A : C4                   nop
     273/     36B : C4                   nop
     274/     36C : C4                   nop
     275/     36D : C4                   nop
     276/     36E : C4                   nop
     277/     36F : C4                   nop
     278/     370 : 61                   out 1
     279/     371 : 34                   db '4'
     280/     372 : C4                   nop
     281/     373 : C4                   nop
     282/     374 : C4                   nop
     283/     375 : C4                   nop
     284/     376 : 61                   out 1
     285/     377 : 32                   db '2'
     286/     378 : C4                   nop
     287/     379 : C4                   nop
     288/     37A : C4                   nop
     289/     37B : C4                   nop
     290/     37C : 61                   out 1
     291/     37D : 34                   db '4'
     292/     37E : C4                   nop
     293/     37F : C4                   nop
     294/     380 : C4                   nop
     295/     381 : C4                   nop
     296/     382 : 61                   out 1
     297/     383 : 32                   db '2'
     298/     384 : C4                   nop
     299/     385 : C4                   nop
     300/     386 : C4                   nop
     301/     387 : C4                   nop
     302/     388 : 61                   out 1
     303/     389 : 34                   db '4'
     304/     38A : C4                   nop
     305/     38B : C4                   nop
     306/     38C : C4                   nop
     307/     38D : C4                   nop
     308/     38E : 61                   out 1
     309/     38F : 32                   db '2'
     310/     390 : C4                   nop
     311/     391 : C4                   nop
     312/     392 : C4                   nop
     313/     393 : C4                   nop
     314/     394 : 61                   out 1
     315/     395 : 34                   db '4'
     316/     396 : C4                   nop
     317/     397 : C4                   nop
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 8 - 11/6/2017 9:07:24


     318/     398 : C4                   nop
     319/     399 : C4                   nop
     320/     39A : 61                   out 1
     321/     39B : 32                   db '2'
     322/     39C : C4                   nop
     323/     39D : C4                   nop
     324/     39E : C4                   nop
     325/     39F : C4                   nop
     326/     3A0 : 61                   out 1
     327/     3A1 : 34                   db '4'
     328/     3A2 : C4                   nop
     329/     3A3 : C4                   nop
     330/     3A4 : C4                   nop
     331/     3A5 : C4                   nop
     332/     3A6 : 61                   out 1
     333/     3A7 : 32                   db '2'
     334/     3A8 : C4                   nop
     335/     3A9 : C4                   nop
     336/     3AA : C4                   nop
     337/     3AB : C4                   nop
     338/     3AC : 61                   out 1
     339/     3AD : 34                   db '4'
     340/     3AE : C4                   nop
     341/     3AF : C4                   nop
     342/     3B0 : C4                   nop
     343/     3B1 : C4                   nop
     344/     3B2 : 61                   out 1
     345/     3B3 : 32                   db '2'
     346/     3B4 : C4                   nop
     347/     3B5 : C4                   nop
     348/     3B6 : C4                   nop
     349/     3B7 : C4                   nop
     350/     3B8 : 61                   out 1
     351/     3B9 : 32                   db '2'
     352/     3BA : C4                   nop
     353/     3BB : C4                   nop
     354/     3BC : 7A                   req ;deactivate printer?
     355/     3BD : E2                   sex 2 ;reset X register!
     356/     3BE :                     ;}
     357/     3BE :                     L28:
     358/     3BE : (MACRO)             	Cretn
     359/     3C0 :                     
     360/     3C0 :                     ;$$function end$$ _hello
     361/     3C0 :                     ;$$function start$$ _main
     362/     3C0 :                     _main: ;copt is peeping your size 14 frame with oct 23 rules
     363/     3C0 : (MACRO)             	reserve 4; save room for local variables
     364/     3C4 : (MACRO)             	pushr R6
     365/     3C6 : (MACRO)             	pushr R7
     366/     3C8 : (MACRO)             	reserve 4; save room for outgoing arguments
     367/     3CC :                     ;{
     368/     3CC :                     ;	unsigned char * loc=0;
     369/     3CC : (MACRO)             	ldaD R6,0; reg:acon
     370/     3D0 :                     ;	unsigned char memtype='o'; //displaying o=eeprom,a=ram
     371/     3D0 : (MACRO)             	ldA2 R11,'O',sp,(11+1); reg:addr
     372/     3D8 : (MACRO)             	str1I 111,R11; ASGNU1(indaddr,acon)	DH
     373/     3DB :                     ;	dispval(0x43);
     374/     3DB : (MACRO)             	ldaD R12,67; reg:acon
     375/     3DF : (MACRO)             	Ccall _dispval
     376/     3E3 :                     ;	delay(1000);
     377/     3E3 : (MACRO)             	ldaD R12,1000; reg:acon
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 9 - 11/6/2017 9:07:24


     378/     3E7 : (MACRO)             	Ccall _delay
     379/     3EB :                     ;	dispval(0x44);
     380/     3EB : (MACRO)             	ldaD R12,68; reg:acon
     381/     3EF : (MACRO)             	Ccall _dispval
     382/     3F3 :                     ;	hello();
     383/     3F3 : (MACRO)             	Ccall _hello
     384/     3F7 :                     ;	dispval(0x45);
     385/     3F7 : (MACRO)             	ldaD R12,69; reg:acon
     386/     3FB : (MACRO)             	Ccall _dispval
     387/     3FF :                     ;	delay(5000);
     388/     3FF : (MACRO)             	ldaD R12,5000; reg:acon
     389/     403 : (MACRO)             	Ccall _delay
     390/     407 : C0 05 7A            	lbr L32
     391/     40A :                     L31:
     392/     40A :                     ;	while(1){
     393/     40A :                     ;		dispmemloc(loc);
     394/     40A : (MACRO)             	cpy2 R12,R6 ;LOADP2(reg)
     395/     40E : (MACRO)             	Ccall _dispmemloc
     396/     412 :                     ;		k=boydscan();
     397/     412 : (MACRO)             	Ccall _boydscan; CALLI2(ar)
     398/     416 : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     399/     41A : (MACRO)             	cpy1 R7,R11;LOADU1(reg)
     400/     41C :                     ;		switch(k){
     401/     41C : (MACRO)             	cpy1 R11,R7
     402/     41E : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     403/     421 : (MACRO)             	st2 R11,'O',sp,(8+1); ASGNI2(addr,reg)
     404/     42E : (MACRO)             	ld2 R11,'O',sp,(8+1) ;reg:INDIRI2(addr)
     405/     43A : (MACRO)             	jcI2I R11,16,lbnf,L34  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     406/     44B : (MACRO)             	jnI2I R11,20,lbnf,L34; GT reverse  the subtraction
     407/     45C : (MACRO)             	shl2I R11,1
     408/     462 : (MACRO)             	ld2 R11,'O',R11,(L44-32) ;reg:INDIRP2(addr)
     409/     46E : (MACRO)             	jumpv R11; JUMPV(reg)
     410/     476 :                     L44:
     411/     476 : 04 80               	dw L37
     412/     478 : 04 84               	dw L38
     413/     47A : 04 8F               	dw L39
     414/     47C : 04 C3               	dw L42
     415/     47E : 05 4A               	dw L43
     416/     480 :                     L37:
     417/     480 :                     ;				loc +=1;
     418/     480 : (MACRO)             	incm R6,1
     419/     481 :                     ;				break;
     420/     481 : C0 05 7A            	lbr L35
     421/     484 :                     L38:
     422/     484 :                     ;				loc -=1;
     423/     484 : (MACRO)             	ldA2 R6,'O',R6,(-1); reg:addr
     424/     48C :                     ;				break;
     425/     48C : C0 05 7A            	lbr L35
     426/     48F :                     L39:
     427/     48F :                     ;				if (memtype=='o'){
     428/     48F : (MACRO)             	ld1 R11,'O',sp,(11+1)
     429/     499 : (MACRO)             	jneU1I R11,111,L40	; DH 4
     430/     49F :                     ;					loc=(unsigned char *)4096;
     431/     49F : (MACRO)             	ldaD R6,0x1000; reg:acon
     432/     4A3 :                     ;					memtype='a';
     433/     4A3 : (MACRO)             	ldA2 R11,'O',sp,(11+1); reg:addr
     434/     4AB : (MACRO)             	str1I 97,R11; ASGNU1(indaddr,acon)	DH
     435/     4AE :                     ;				}else{
     436/     4AE : C0 05 7A            	lbr L35
     437/     4B1 :                     L40:
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 10 - 11/6/2017 9:07:24


     438/     4B1 :                     ;					loc=(unsigned char *)0;
     439/     4B1 : (MACRO)             	ldaD R6,0; reg:acon
     440/     4B5 :                     ;					memtype='o';
     441/     4B5 : (MACRO)             	ldA2 R11,'O',sp,(11+1); reg:addr
     442/     4BD : (MACRO)             	str1I 111,R11; ASGNU1(indaddr,acon)	DH
     443/     4C0 :                     ;				}
     444/     4C0 :                     ;				break;
     445/     4C0 : C0 05 7A            	lbr L35
     446/     4C3 :                     L42:
     447/     4C3 :                     ;				dispmemloc(loc); //makes a blink
     448/     4C3 : (MACRO)             	cpy2 R12,R6 ;LOADP2(reg)
     449/     4C7 : (MACRO)             	Ccall _dispmemloc
     450/     4CB :                     ;				k=boydscan(); dispval(k); delay(250);
     451/     4CB : (MACRO)             	Ccall _boydscan; CALLI2(ar)
     452/     4CF : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     453/     4D3 : (MACRO)             	cpy1 R7,R11;LOADU1(reg)
     454/     4D5 : (MACRO)             	cpy1 R12,R7
     455/     4D7 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     456/     4DA : (MACRO)             	Ccall _dispval
     457/     4DE : (MACRO)             	ldaD R12,250; reg:acon
     458/     4E2 : (MACRO)             	Ccall _delay
     459/     4E6 :                     ;				k2=boydscan(); dispval(k2); delay(250);
     460/     4E6 : (MACRO)             	Ccall _boydscan; CALLI2(ar)
     461/     4EA : (MACRO)             	ldA2 R10,'O',sp,(10+1); reg:addr
     462/     4F2 : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     463/     4F6 : (MACRO)             	str1 R11,R10; ASGNU1(indaddr,reg)		DH
     464/     4F8 : (MACRO)             	ld1 R12,'O',sp,(10+1)
     465/     502 : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     466/     505 : (MACRO)             	Ccall _dispval
     467/     509 : (MACRO)             	ldaD R12,250; reg:acon
     468/     50D : (MACRO)             	Ccall _delay
     469/     511 :                     ;				*loc=(k<<4)+k2;
     470/     511 : (MACRO)             	cpy1 R11,R7
     471/     513 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     472/     516 : (MACRO)             	shl2I R11,4
     473/     52E : (MACRO)             	ld1 R10,'O',sp,(10+1)
     474/     538 : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     475/     53B : (MACRO)             	alu2 R11,R11,R10,add,adc; ADDI2(r,r)
     476/     545 : (MACRO)             	str1 R11,R6; ASGNU1(indaddr,reg)		DH
     477/     547 :                     ;				break;
     478/     547 : C0 05 7A            	lbr L35
     479/     54A :                     L43:
     480/     54A :                     ;				dispval(0x45);
     481/     54A : (MACRO)             	ldaD R12,69; reg:acon
     482/     54E : (MACRO)             	Ccall _dispval
     483/     552 :                     ;				delay(250);
     484/     552 : (MACRO)             	ldaD R12,250; reg:acon
     485/     556 : (MACRO)             	Ccall _delay
     486/     55A :                     ;				loc=execute(loc);
     487/     55A : (MACRO)             	cpy2 R12,R6 ;LOADP2(reg)
     488/     55E : (MACRO)             	Ccall _execute
     489/     562 : (MACRO)             	cpy2 R6,R15 ;LOADP2(reg)
     490/     566 :                     ;				break;
     491/     566 : C0 05 7A            	lbr L35
     492/     569 :                     L34:
     493/     569 :                     ;				dispval(k);
     494/     569 : (MACRO)             	cpy1 R12,R7
     495/     56B : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     496/     56E : (MACRO)             	Ccall _dispval
     497/     572 :                     ;				delay(250);
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 11 - 11/6/2017 9:07:24


     498/     572 : (MACRO)             	ldaD R12,250; reg:acon
     499/     576 : (MACRO)             	Ccall _delay
     500/     57A :                     ;		}
     501/     57A :                     L35:
     502/     57A :                     ;	}
     503/     57A :                     L32:
     504/     57A :                     ;	while(1){
     505/     57A : C0 04 0A            	lbr L31
     506/     57D :                     ;}
     507/     57D :                     L30:
     508/     57D : (MACRO)             	release 4; release room for outgoing arguments
     509/     581 : (MACRO)             	popf R7	;opt11.3
     510/     584 : (MACRO)             	popl R6	;opt11.3
     511/     588 : (MACRO)             	release 4; release room for local variables 
     512/     58C : (MACRO)             	Cretn
     513/     58E :                     
     514/     58E :                     ;$$function end$$ _main
     515/     58E :                     ;$$function start$$ _delay
     516/     58E :                     _delay:		;framesize=10
     517/     58E : (MACRO)             	pushr R6
     518/     590 : (MACRO)             	pushr R7
     519/     592 : (MACRO)             	reserve 4; save room for outgoing arguments
     520/     596 : (MACRO)             	cpy2 R7,R12; function(2054) 1
     521/     59A :                     ;void delay(unsigned int howlong){
     522/     59A :                     ;	for (i=1;i!=howlong;i++){
     523/     59A : (MACRO)             	ldaD R6,1; reg:acon
     524/     59E : C0 05 A6            	lbr L50
     525/     5A1 :                     L47:
     526/     5A1 :                     ;		oneMs();
     527/     5A1 : (MACRO)             	Ccall _oneMs; CALLI2(ar)
     528/     5A5 :                     ;	}
     529/     5A5 :                     L48:
     530/     5A5 :                     ;	for (i=1;i!=howlong;i++){
     531/     5A5 : (MACRO)             	incm R6,1
     532/     5A6 :                     L50:
     533/     5A6 : (MACRO)             	jneU2 R6,R7,L47; NE
     534/     5B8 :                     ;}
     535/     5B8 :                     L46:
     536/     5B8 : (MACRO)             	release 4; release room for outgoing arguments
     537/     5BC : (MACRO)             	popf R7	;opt11.3
     538/     5BF : (MACRO)             	popl R6	;opt11.3
     539/     5C3 : (MACRO)             	Cretn
     540/     5C5 :                     
     541/     5C5 :                     ;$$function end$$ _delay
     542/     5C5 :                     ;$$function start$$ _olduinoincluder
     543/     5C5 :                     _olduinoincluder:		;framesize=2
     544/     5C5 :                     ;void olduinoincluder(){
     545/     5C5 :                     ;	asm("\tinclude olduino.inc\n");
     546/     5C5 :                     	include olduino.inc
(1)    1/     5C5 :                     ;Feb 8 2013, first version of assembler routines for olduino support	
(1)    2/     5C5 :                     ;may 31 - incredibly, there's an error in digitalWrite.  lda2 changed to ldAD
(1)    3/     5C5 :                     ;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
(1)    4/     5C5 :                     	align 64	;needed to make sure all on same page
(1)    5/     600 :                     _digitalWrite:
(1)    6/     600 : 8C                  	glo regArg1	;get the bit number
(1)    7/     601 : FC 1E               	adi $$bvtable&255	;add the table offset
(1)    8/     603 : AE                  	plo memaddr
(1)    9/     604 : 93                  	ghi RPC		;get the top byte of the current page
(1)   10/     605 : BE                  	phi memaddr	
(1)   11/     606 : 0E                  	ldn memaddr	;pick up the bit pattern
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(olduino.inc) - page 12 - 11/6/2017 9:07:24


(1)   12/     607 : A8                  	plo rt1		;save it in a temp
(1)   13/     608 : (MACRO)             	ldAD memaddr,_PIN4 ;address the current port value
(1)   14/     60C : EE                  	sex memaddr	;prepare to change it
(1)   15/     60D : 8D                  	glo regArg2	;get on/off switch
(1)   16/     60E : 32 15               	bz $$setbitoff
(1)   17/     610 :                     ; here we have the bit pattern in rt1 and we're ready to apply it with OR
(1)   18/     610 : 88                  	glo rt1		;get the bit value back
(1)   19/     611 : F1                  	or		;apply it
(1)   20/     612 : 5E                  	str memaddr	;and save it
(1)   21/     613 : 30 1A               	br $$outit	;go fnish up
(1)   22/     615 :                     $$setbitoff:
(1)   23/     615 : 88                  	glo rt1		;get the bit pattern
(1)   24/     616 : FB FF               	xri 0xff	;reverse it
(1)   25/     618 : F2                  	and		;combine it with the existing pin value
(1)   26/     619 : 5E                  	str memaddr	;and save it
(1)   27/     61A :                     ;here we gave set/reset the correct bit in PIN4 and we just have to send it out
(1)   28/     61A :                     $$outit:
(1)   29/     61A : 64                  	out 4		;X was already set to memaddr
(1)   30/     61B : E2                  	sex sp		;reset X
(1)   31/     61C : (MACRO)             	cretn
(1)   32/     61E : 01 02 04 08 10 20   $$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
                    40 80 
(1)   33/     626 :                     ;int digitalRead(unsigned char pin){//for now this will always read ef3
(1)   34/     626 :                     	align 8	;protect jump boundary
(1)   35/     628 :                     _digitalRead:
(1)   36/     628 : F8 00               	ldi 0		;default is false
(1)   37/     62A : AF                  	plo R15
(1)   38/     62B : BF                  	phi R15
(1)   39/     62C : 36 2F               	b3 +		;i have to reverse the sense of the external line
(1)   40/     62E : 1F                  	inc R15		;if external line is high, supply a 1
(1)   41/     62F : (MACRO)             +	cretn
(1)   42/     631 :                     
     547/     631 :                     ;}
     548/     631 :                     L51:
     549/     631 : (MACRO)             	Cretn
     550/     633 :                     
     551/     633 :                     ;$$function end$$ _olduinoincluder
     552/     633 :                     	include lcc1802epiloNW.inc
(1)    1/     633 :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/     633 :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/     633 :                     ;this is the version published with the lcc1802121229 release
(1)    4/     633 :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/     633 :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/     633 :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/     633 :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/     633 :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/     633 :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/     633 :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/     633 :                     ;feb 27 changed stack to start at 7fff
(1)   12/     633 :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/     633 :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/     633 :                     ;april 4 adding digit count argument to dubdabx
(1)   15/     633 :                     ;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
(1)   16/     633 :                     ;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
(1)   17/     633 :                     ;16-09-20 allow stack relocation 
(1)   18/     633 :                     ;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
(1)   19/     633 :                     ;17-03-07 adjusting stack offset for 1805/6 stack discipline
(1)   20/     633 :                     ;17-03-13 protecting work areas in divi2,divi4 routines from 1806 SCAL
(1)   21/     633 :                     ;17-03-15 onems compensates for reduced subroutine overhead in 1806
(1)   22/     633 :                     ;17-04-09 don't include call/return for 1806
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(lcc1802epiloNW.inc) - page 13 - 11/6/2017 9:07:24


(1)   23/     633 :                     ;17-10-17 SCRT routines changed to clean stack model i.e. push is stxd stxd, pop is inc lda inc ldn
(1)   24/     633 :                     ;17-10-19 using CPUSPEED instead of LCC1802CPUSPEED, also STACKLOC instead of LCCSTACKLOC
(1)   25/     633 :                     ;17-10-23 extending work area protection from 10-13 above for 1802 as well as 1805
(1)   26/     633 : =EH                 rwork	equ	memAddr	;work register
(1)   27/     633 :                     lcc1802init:	
(1)   28/     633 : =>FALSE               IF    MOMCPU<>$1805		;for 1806 use SCAL 
(1)   29/     633 :                     	ldiReg	RCALL,_call
(1)   30/     633 :                     	ldiReg	RRET,_return
(1)   31/     633 : =>TRUE                ELSE
(1)   32/     633 : (MACRO)             	ldiReg	RCALL,$$_die; _call
(1)   33/     637 : (MACRO)             	ldiReg	RRET,$$_die; _return
(1)   34/     63B : [28]                  ENDIF
(1)   35/     63B : =>UNDEFINED           IFNDEF  STACKLOC		;wjr 16-09-20 allow stack relocation
(1)   36/     63B : (MACRO)             	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1 as default
(1)   37/     63F : =>FALSE               ELSEIF				;wjr 16-09-20
(1)   38/     63F :                     	ldiReg	SP,STACKLOC	;wjr 16-09-20 start stack as specified
(1)   39/     63F : [35]                  ENDIF				;wjr 16-09-20
(1)   40/     63F : E2                  	sex	SP
(1)   41/     640 : (MACRO)             	ldiReg	RPC,$$_00000
(1)   42/     644 : D3                  	sep	RPC
(1)   43/     645 :                     $$_00000:
(1)   44/     645 : (MACRO)             	Ccall _main	;call the main routine
(1)   45/     649 : C0 06 49            $$_die:	lbr	$$_die		;loop here when main returns
(1)   46/     64C : DE AD               	db	0xde,0xad
(1)   47/     64E :                     
(1)   48/     64E :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   49/     64E :                     _setqOn:
(1)   50/     64E : 7B                  	seq
(1)   51/     64F : (MACRO)             	Cretn
(1)   52/     651 :                     _setqOff:
(1)   53/     651 : 7A                  	req
(1)   54/     652 : (MACRO)             	Cretn
(1)   55/     654 : =>DEFINED            IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math
(1)   56/     654 :                     _modU2:	;16 bit unsigned remainder
(1)   57/     654 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   58/     654 :                         Ccall _divU2
(1)   59/     654 :                         glo regArg1
(1)   60/     654 :                         plo retVal
(1)   61/     654 :                         ghi regArg1
(1)   62/     654 :                         phi retVal
(1)   63/     654 :                         Cretn
(1)   64/     654 :                         
(1)   65/     654 :                     _modI2:	;16 bit signed remainder
(1)   66/     654 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   67/     654 :                         Ccall _divI2
(1)   68/     654 :                         glo regArg1
(1)   69/     654 :                         plo retVal
(1)   70/     654 :                         ghi regArg1
(1)   71/     654 :                         phi retVal
(1)   72/     654 :                         Cretn
(1)   73/     654 : [55]                 ENDIF
(1)   74/     654 :                     _out4:	
(1)   75/     654 : 8C                  	glo	regArg1
(1)   76/     655 : 22                  	dec	sp
(1)   77/     656 : 52                  	str	sp
(1)   78/     657 : 64                  	out	4
(1)   79/     658 : (MACRO)             	Cretn
(1)   80/     65A :                     
(1)   81/     65A :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   82/     65A : =>FALSE               if MOMCPU<>$1805		;for 1806 use SCAL
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(lcc1802epiloNW.inc) - page 14 - 11/6/2017 9:07:24


(1)   83/     65A :                     	align 16
(1)   84/     65A :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)   85/     65A :                     	sep     R3 ;go to subroutine
(1)   86/     65A :                     _call	sex	SP ;make sure X=SP
(1)   87/     65A :                     	glo	retAddr ;save previous return pointer on stack
(1)   88/     65A :                     	stxd
(1)   89/     65A :                     	ghi	retAddr
(1)   90/     65A :                     	stxd	
(1)   91/     65A :                     	glo	RPC ;copy old PC to retAddr
(1)   92/     65A :                     	plo	retAddr
(1)   93/     65A :                     	ghi	RPC
(1)   94/     65A :                     	phi	retAddr
(1)   95/     65A :                     	lda	retAddr ;pick up subroutine address into RPC
(1)   96/     65A :                     	phi	RPC
(1)   97/     65A :                     	lda	retAddr
(1)   98/     65A :                     	plo	RPC
(1)   99/     65A :                     	br	_call-1
(1)  100/     65A :                     
(1)  101/     65A :                     ;Standard subroutine return 
(1)  102/     65A :                     	align 16
(1)  103/     65A :                     	sep	RPC	;return to the original program
(1)  104/     65A :                     _return	glo	retAddr	;transfer the current return address to RPC
(1)  105/     65A :                     	plo	RPC
(1)  106/     65A :                     	ghi	retAddr
(1)  107/     65A :                     	phi	RPC
(1)  108/     65A :                     	inc 	SP
(1)  109/     65A :                     	lda	SP	;pick up old return address
(1)  110/     65A :                     	phi	retAddr
(1)  111/     65A :                     	ldn	SP
(1)  112/     65A :                     	plo	retAddr
(1)  113/     65A :                     	br	_return-1
(1)  114/     65A : [82]                 ENDIF
(1)  115/     65A :                     	align 8
(1)  116/     660 :                     _oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
(1)  117/     660 :                     ;subroutine overhead soaks up 27 instruction time.
(1)  118/     660 :                     ;each loop is 2 instruction times
(1)  119/     660 :                     ;so the number of loops needed is 
(1)  120/     660 :                     ;CPU speed/16000 less the 27 all divide by two
(1)  121/     660 : =>UNDEFINED         	IFNDEF	CPUSPEED
(1)  122/     660 : =186A00H            CPUSPEED EQU 1600000	;1.6MHZ default
(1)  123/     660 : [121]               	ENDIF
(1)  124/     660 : =>TRUE               if MOMCPU=$1805		;for 1806 SCAL
(1)  125/     660 : =EH                 SUBOVHD  EQU 14		;1806 SCAL/SRET subroutine overhead
(1)  126/     660 : =>FALSE              else
(1)  127/     660 :                     SUBOVHD  EQU 27		;default SCRT subroutine overhead
(1)  128/     660 : [124]                endif 
(1)  129/     660 : =>TRUE                IF CPUSPEED<=8000000
(1)  130/     660 : F8 2B               	ldi	(CPUSPEED/1000/16-SUBOVHD)/2
(1)  131/     662 : FF 01               $$mslp:	smi	1
(1)  132/     664 : 3A 62               	bnz	$$mslp
(1)  133/     666 : =>FALSE               ELSE
(1)  134/     666 :                     	ldi	(CPUSPEED/1000/16-SUBOVHD)/4
(1)  135/     666 :                     $$mslf:	smi	1
(1)  136/     666 :                     	sex	2
(1)  137/     666 :                     	sex	2
(1)  138/     666 :                     	bnz	$$mslf
(1)  139/     666 : [129]                 ENDIF
(1)  140/     666 : (MACRO)             	Cretn
(1)  141/     668 :                     
(1)  142/     668 :                     
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(lcc1802epiloNW.inc) - page 15 - 11/6/2017 9:07:24


(1)  143/     668 : =>DEFINED            IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math	
(1)  144/     668 :                     	align 256
(1)  145/     668 :                     ;16 bit right shifting multiply which is faster for smaller operands
(1)  146/     668 :                     ; credit to http://map.grauw.nl/articles/mult_div_shifts.php#lrmultr
(1)  147/     668 :                     _mulU2:		;retval(product)=regarg1(multiplicand)*regarg2(multiplier)
(1)  148/     668 :                     	ld2z retval
(1)  149/     668 :                     $$mulrlp:
(1)  150/     668 :                     	shru2 regarg2
(1)  151/     668 :                     	bnf $$mulrnoadd
(1)  152/     668 :                     ;	bottom bit of multiplier is one so add multiplicand to product
(1)  153/     668 :                     	alu2 retval,retval,regarg1,add,adc
(1)  154/     668 :                     $$mulrnoadd:
(1)  155/     668 :                     	ghi regarg2	;check for all bits of multiplier shifted out
(1)  156/     668 :                     	bnz $$mulrshft	;nope, continue
(1)  157/     668 :                     	glo regarg2	;check bottom byte
(1)  158/     668 :                     	bz $$mulrdone
(1)  159/     668 :                     $$mulrshft:
(1)  160/     668 :                     	shl2 regarg1	;shift multiplicand left 1
(1)  161/     668 :                     	br $$mulrlp
(1)  162/     668 :                     $$mulrdone:		;here the product is in retval
(1)  163/     668 :                     	cretn
(1)  164/     668 :                     
(1)  165/     668 :                     ;this is a divisor shifting algorithm which is faster for smaller operands
(1)  166/     668 :                     ;credit to http://research.microsoft.com/pubs/70645/tr-2008-141.pdf
(1)  167/     668 :                     ;changed oct 12 to save R10 & 1/2 R11 on stack
(1)  168/     668 :                     _divu2: ;retval=regarg1(x or dividend)/regarg2(y or divisor)
(1)  169/     668 :                     	;uses R14(rwork) to hold original divisor y0, 
(1)  170/     668 :                     	;regarg1 to hold develop remainder, 
(1)  171/     668 :                     	;R10 to hold working dividend R11.0 as a temp
(1)  172/     668 :                     testsub: macro reg1,reg2	;test subtraction of reg2 from reg1
(1)  173/     668 :                     				;result in D, rwork.hi, DF
(1)  174/     668 :                     	glo reg2
(1)  175/     668 :                     	str sp
(1)  176/     668 :                     	glo reg1
(1)  177/     668 :                     	sm
(1)  178/     668 :                     	plo R11
(1)  179/     668 :                     	ghi reg2
(1)  180/     668 :                     	str sp
(1)  181/     668 :                     	ghi reg1
(1)  182/     668 :                     	smb
(1)  183/     668 :                     	endm
(1)  184/     668 :                     	
(1)  185/     668 :                     ;	pushf R10	;save R10 & leave stack down 1
(1)  186/     668 :                     	pushr R10	;default push leaves stack clean
(1)  187/     668 :                     	glo R11		;and bottom
(1)  188/     668 :                     	stxd		;of R11 - leaves stack clear of work area
(1)  189/     668 :                     	cpy2 R10,regarg1
(1)  190/     668 :                     	ld2z retval	;quotient
(1)  191/     668 :                     	cpy2 rwork,regarg2
(1)  192/     668 :                     	
(1)  193/     668 :                     	testsub R10,regarg2
(1)  194/     668 :                     	bnf $$computequot	;DF=0 means it didn't fit
(1)  195/     668 :                     	phi R10	;R10=R10-regarg2
(1)  196/     668 :                     	glo R11
(1)  197/     668 :                     	plo R10
(1)  198/     668 :                     	
(1)  199/     668 :                     $$again:	;this is the divisor doubling phase
(1)  200/     668 :                      	testsub R10,regarg2
(1)  201/     668 :                      	bnf $$computequot	;df=0 means it didn't fit
(1)  202/     668 :                     	phi R10	;R10=R10-regarg2
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(lcc1802epiloNW.inc) - page 16 - 11/6/2017 9:07:24


(1)  203/     668 :                     	glo R11
(1)  204/     668 :                     	plo R10 	
(1)  205/     668 :                      	shl2 regarg2	;y=y+y
(1)  206/     668 :                      	br $$again
(1)  207/     668 :                      	
(1)  208/     668 :                      $$computequot:	;here we're computing the quotient
(1)  209/     668 :                      	testsub regarg1,regarg2
(1)  210/     668 :                      	bnf $$testexit
(1)  211/     668 :                      	phi regarg1		;complete the subtraction
(1)  212/     668 :                      	glo R11
(1)  213/     668 :                      	plo regarg1
(1)  214/     668 :                      	inc retval
(1)  215/     668 :                      $$testexit:
(1)  216/     668 :                      	ghi rwork
(1)  217/     668 :                      	sm	;top of regarg2 is still on stack
(1)  218/     668 :                      	bnz $$ney0y
(1)  219/     668 :                      	glo regarg2
(1)  220/     668 :                      	str sp
(1)  221/     668 :                      	glo rwork
(1)  222/     668 :                      	sm	;test low order bytes
(1)  223/     668 :                      	bz	$$out	;if = we're done
(1)  224/     668 :                      $$ney0y:
(1)  225/     668 :                      	shl2 retval	;double quotient
(1)  226/     668 :                      	shrU2 regarg2	;halve divisor
(1)  227/     668 :                      	br $$computequot	;continue
(1)  228/     668 :                      $$out:
(1)  229/     668 :                      ;here the quotient is in retval, remainder in regarg1
(1)  230/     668 :                       	inc sp	;release work area
(1)  231/     668 :                     	ldn sp	;recover
(1)  232/     668 :                     	plo R11	;bottom byte of R11
(1)  233/     668 :                     	popr R10 ;and all of R10
(1)  234/     668 :                     	cretn	;and we're done
(1)  235/     668 :                     
(1)  236/     668 :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  237/     668 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  238/     668 :                     _divI2:
(1)  239/     668 :                         dec	sp	;leave a work area available
(1)  240/     668 :                         ghi regArg1
(1)  241/     668 :                         str sp	;save the sign of the 1st arg
(1)  242/     668 :                         shl
(1)  243/     668 :                         bnf $$pos1	;if the 1st arg is -v
(1)  244/     668 :                         negI2 regArg1,regArg1 ;flip it to positive
(1)  245/     668 :                     $$pos1: ;1st is now +v, check 2nd
(1)  246/     668 :                         ghi regArg2
(1)  247/     668 :                         xor	
(1)  248/     668 :                         str sp ;the stack now has bit 8 set if the signs are different
(1)  249/     668 :                         ghi regArg2
(1)  250/     668 :                         shl
(1)  251/     668 :                         bnf $$pos2	;if the 2nd arg is -v
(1)  252/     668 :                         negI2 regArg2,regArg2 ;flip it to +v
(1)  253/     668 :                     $$pos2: ; both args now +v
(1)  254/     668 :                         dec sp	;protect workarea on the 1802
(1)  255/     668 :                         Ccall _divU2	;call unsigned division
(1)  256/     668 :                         inc sp	;recover work area
(1)  257/     668 :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  258/     668 :                         lda	sp ;get back the sign bits and restore SP
(1)  259/     668 :                         shl
(1)  260/     668 :                         bnf $$done ;if the signs were different
(1)  261/     668 :                         negI2 retVal,retVal ;negate the quotient
(1)  262/     668 :                     $$done:
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(lcc1802epiloNW.inc) - page 17 - 11/6/2017 9:07:24


(1)  263/     668 :                         Cretn ;and we're done - I hope!
(1)  264/     668 : [143]                ENDIF
(1)  265/     668 : =>DEFINED            IFNDEF  LCCNOLONG		;wjr 17-04-09 disable 32 bit math
(1)  266/     668 :                     	align 256    ;32 bit operations follow
(1)  267/     668 :                     _divu4:
(1)  268/     668 :                     ;This is an unsigned 32 bit restoring division
(1)  269/     668 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  270/     668 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  271/     668 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  272/     668 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  273/     668 :                     
(1)  274/     668 :                     	ldi 32		;set loop count
(1)  275/     668 :                     	plo memaddr	;in temp register
(1)  276/     668 :                     	ldi4 Rp1p2,0	;clear Rp1p2
(1)  277/     668 :                     $$loop:
(1)  278/     668 :                     	shL4 RL8	;shift bottom 32 bits left 1
(1)  279/     668 :                     	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  280/     668 :                     
(1)  281/     668 :                     	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  282/     668 :                     
(1)  283/     668 :                     	ani 0x80	;check the top bit
(1)  284/     668 :                     	bz $$norestore	;if it's 0
(1)  285/     668 :                     		glo RL8
(1)  286/     668 :                     		ani 0xfe	;turn off the bottom bit
(1)  287/     668 :                     		plo RL8
(1)  288/     668 :                     		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  289/     668 :                     	br $$endlp 	;else
(1)  290/     668 :                     $$norestore:
(1)  291/     668 :                     		glo RL8
(1)  292/     668 :                     		ori 1	;turn on the bottom bit
(1)  293/     668 :                     		plo RL8
(1)  294/     668 :                     	;end if
(1)  295/     668 :                     $$endlp:
(1)  296/     668 :                     	dec memaddr	;check the cycle count
(1)  297/     668 :                     	glo memaddr
(1)  298/     668 :                     	bnz $$loop	;back for more if needed
(1)  299/     668 :                     	
(1)  300/     668 :                     	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  301/     668 :                     		
(1)  302/     668 :                     
(1)  303/     668 :                     _mulu4:
(1)  304/     668 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  305/     668 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  306/     668 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  307/     668 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  308/     668 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  309/     668 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  310/     668 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  311/     668 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  312/     668 :                     	;for 10 we subtract and shift
(1)  313/     668 :                     	;for 00 and 11 we just shift
(1)  314/     668 :                     
(1)  315/     668 :                         ldi4 rp1p2,0	;eventual product top 32 bits
(1)  316/     668 :                         ldi 32
(1)  317/     668 :                         plo memaddr		;cycle count
(1)  318/     668 :                         adi 0		;clear df
(1)  319/     668 :                     $$mloop:
(1)  320/     668 :                         glo RL8
(1)  321/     668 :                         ani 1		;isolate bottom bit of result
(1)  322/     668 :                         bnf	$$check_sub	;
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(lcc1802epiloNW.inc) - page 18 - 11/6/2017 9:07:24


(1)  323/     668 :                         bnz	$$shift		;that would be the 11 case
(1)  324/     668 :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  325/     668 :                         alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  326/     668 :                         br $$shift
(1)  327/     668 :                     $$check_sub:
(1)  328/     668 :                         bz $$shift	;that would be the 00 case
(1)  329/     668 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  330/     668 :                         alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  331/     668 :                     $$shift:
(1)  332/     668 :                         shRI4 Rp1p2		;shift the top 32 bits
(1)  333/     668 :                         shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  334/     668 :                     
(1)  335/     668 :                         dec memaddr		;cycle count
(1)  336/     668 :                         glo memaddr
(1)  337/     668 :                         bnz $$mloop		;repeat cycle once for each bit position
(1)  338/     668 :                         
(1)  339/     668 :                         cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  340/     668 :                     
(1)  341/     668 :                     	align 256
(1)  342/     668 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  343/     668 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  344/     668 :                     _divI4:
(1)  345/     668 :                         dec	sp	;leave a work area available
(1)  346/     668 :                         ghi RL8-1	;get the top of the dividend
(1)  347/     668 :                         str sp	;save the sign of the 1st arg
(1)  348/     668 :                         shl
(1)  349/     668 :                         bnf $$pos1	;if the 1st arg is -v
(1)  350/     668 :                         negI4 RL8,RL8 ;flip it to positive
(1)  351/     668 :                     $$pos1: ;1st is now +v, check 2nd
(1)  352/     668 :                         ghi RL10-1
(1)  353/     668 :                         xor	
(1)  354/     668 :                         str sp ;the stack now has bit 8 set if the signs are different
(1)  355/     668 :                         ghi RL10-1
(1)  356/     668 :                         shl
(1)  357/     668 :                         bnf $$pos2	;if the 2nd arg is -v
(1)  358/     668 :                         negI4 RL10,RL10 ;flip it to +v
(1)  359/     668 :                     $$pos2: ; both args now +v
(1)  360/     668 :                         dec sp	;protect workarea on the 1802
(1)  361/     668 :                         Ccall _divU4	;call unsigned division
(1)  362/     668 :                         inc sp	;recover work area
(1)  363/     668 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  364/     668 :                         lda	sp ;get back the sign bits and restore SP
(1)  365/     668 :                         shl
(1)  366/     668 :                         bnf $$done ;if the signs were different
(1)  367/     668 :                         negI4 RL8,RL8 ;negate the quotient
(1)  368/     668 :                     $$done:
(1)  369/     668 :                         Cretn ;and we're done - I hope!
(1)  370/     668 : [265]                ENDIF
(1)  371/     668 : =>DEFINED            IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math
(1)  372/     668 :                     _dubdabx:	
(1)  373/     668 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  374/     668 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  375/     668 :                     ;long interger is passed in rp1p2
(1)  376/     668 :                     ;buffer pointer is passed at sp+2+4**+1 for 1806
(1)  377/     668 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
(1)  378/     668 :                     ;r8-11 are used as temps
(1)  379/     668 :                     ;r8 is the working pointer
(1)  380/     668 :                     ;r15.0 is bit count(32) and the return value register
(1)  381/     668 :                     ;r9.0 is digit count
(1)  382/     668 :                     ;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(lcc1802epiloNW.inc) - page 19 - 11/6/2017 9:07:24


(1)  383/     668 :                     	ld2 r8,'O',sp,(2+4+1); pick up the buffer pointer
(1)  384/     668 :                     	ld2 r10,'O',sp,(2+4+2+1); pick up the number of digits wanted
(1)  385/     668 :                     	cpy2 r15,r8 ;save address for now
(1)  386/     668 :                     	ldi 11	;digit count+1 for trailing 0
(1)  387/     668 :                     	plo r9
(1)  388/     668 :                     $$clrlp:	;clear the passed buffer
(1)  389/     668 :                     	ldi 0	
(1)  390/     668 :                     	str r8	;clear a byte
(1)  391/     668 :                     	inc r8
(1)  392/     668 :                     	dec r9
(1)  393/     668 :                     	glo r9	;check the count
(1)  394/     668 :                     	bnz $$clrlp ;back for more
(1)  395/     668 :                     	cpy2 r8,r15 ;get the address back
(1)  396/     668 :                     
(1)  397/     668 :                     	ldi 32	;bit count
(1)  398/     668 :                     	plo r15
(1)  399/     668 :                     ;now i'm going to spin off any leading 0's in the binary number
(1)  400/     668 :                     $$cktop:
(1)  401/     668 :                     	ghi rp1p2-1	;get the top bit of the number
(1)  402/     668 :                     	shl		;check for a 1
(1)  403/     668 :                     	bdf $$bitloop	;move on if we have one
(1)  404/     668 :                     	shl4 rp1p2	;shift the input number
(1)  405/     668 :                     	dec r15		;reduce the number of times to shift
(1)  406/     668 :                     	glo r15
(1)  407/     668 :                     	bnz $$cktop	;
(1)  408/     668 :                     	inc r15		;our whole number was 0 but force at least one pass
(1)  409/     668 :                     $$bitloop:
(1)  410/     668 :                     	ldi 10	;digit count
(1)  411/     668 :                     	plo r9
(1)  412/     668 :                     $$dcklp:
(1)  413/     668 :                     	ldn r8 	;pick up a digit
(1)  414/     668 :                     	smi 5	;see if it's greater than 4
(1)  415/     668 :                     	bnf $$dnoadd ;if not, bypass add
(1)  416/     668 :                     	adi 0x08	;add the 5 black and 3 more
(1)  417/     668 :                     	str r8	;put it back
(1)  418/     668 :                     $$dnoadd:
(1)  419/     668 :                     	inc r8
(1)  420/     668 :                     	dec r9	;decrement digit count
(1)  421/     668 :                     	glo r9
(1)  422/     668 :                     	bnz $$dcklp ;and back for next digit
(1)  423/     668 :                     	
(1)  424/     668 :                     	shl4 rp1p2 ;shift the input number
(1)  425/     668 :                     	
(1)  426/     668 :                     	ldi 10	;load the digit count again
(1)  427/     668 :                     	plo r9
(1)  428/     668 :                     ;r8 is now just past the units location and ready to walk back
(1)  429/     668 :                     $$dshlp:
(1)  430/     668 :                     	dec r8	;walk back from 0's position
(1)  431/     668 :                     	ldn r8	;get the digit back
(1)  432/     668 :                     	shlc	;continue the shift
(1)  433/     668 :                     	phi r15 ;save it for the carry test
(1)  434/     668 :                     	ani 0x0f ;clear the 10 bit
(1)  435/     668 :                     	str r8	;put the digit back
(1)  436/     668 :                     	ghi r15	;now test for carry
(1)  437/     668 :                     	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  438/     668 :                     	dec r9	;decrement the digit count
(1)  439/     668 :                     	glo r9
(1)  440/     668 :                     	bnz $$dshlp ;back for more if needed
(1)  441/     668 :                     	
(1)  442/     668 :                     	dec r15
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(lcc1802epiloNW.inc) - page 20 - 11/6/2017 9:07:24


(1)  443/     668 :                     	glo r15
(1)  444/     668 :                     	bnz $$bitloop
(1)  445/     668 :                     	
(1)  446/     668 :                     	cpy2 r15,r8	;save the starting location of the digits
(1)  447/     668 :                     	ldi 10		;digit count again
(1)  448/     668 :                     	plo r9
(1)  449/     668 :                     $$upnxt:
(1)  450/     668 :                     	ldn r8		;get digit
(1)  451/     668 :                     	ori 0x30	;make ascii
(1)  452/     668 :                     	str r8		;put it back
(1)  453/     668 :                     	inc r8		;next digit
(1)  454/     668 :                     	dec r9		;counter
(1)  455/     668 :                     	glo r9
(1)  456/     668 :                     	bnz $$upnxt	;upgrade all 10 spots
(1)  457/     668 :                     	ldaX memaddr,sp,(2+4+2+1+1)	;point to lsb of desired digit count
(1)  458/     668 :                     	sex memaddr	;set up
(1)  459/     668 :                     	ldi 10		;max number of 0's to skip
(1)  460/     668 :                     	sm		;desired number of digits to skip
(1)  461/     668 :                     	sex sp		;reset index register
(1)  462/     668 :                     	plo r9		;number of leading 0's to skip
(1)  463/     668 :                     $$cknext:
(1)  464/     668 :                     	ldn r15		;check digit
(1)  465/     668 :                     	smi 0x30	;for '0'
(1)  466/     668 :                     	bnz $$done
(1)  467/     668 :                     	inc r15		;next digit
(1)  468/     668 :                     	dec r9		;reduce count
(1)  469/     668 :                     	glo r9
(1)  470/     668 :                     	bnz $$cknext
(1)  471/     668 :                     $$done:
(1)  472/     668 :                     	cretn
(1)  473/     668 : [371]                ENDIF	
(1)  474/     668 : =>DEFINED            IFNDEF  LCCNOLONG		;wjr 17-04-09 disable 32 bit math	
(1)  475/     668 :                     _modU4:	;32 bit unsigned remainder
(1)  476/     668 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  477/     668 :                         Ccall _divU4
(1)  478/     668 :                         cpy4 RL8,Rp1p2
(1)  479/     668 :                         Cretn
(1)  480/     668 :                         
(1)  481/     668 :                     _modI4:	;32 bit signed remainder
(1)  482/     668 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  483/     668 :                         Ccall _divI4
(1)  484/     668 :                         cpy4 RL8,Rp1p2
(1)  485/     668 :                         Cretn
(1)  486/     668 : [474]                ENDIF	
(1)  487/     668 :                     
     553/     668 :                     	include IO1802.inc
(1)    1/     668 :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/     668 :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/     668 :                     ;17-10-16 adding _putcpace(port,byte) to limit output speed to the AVR
(1)    4/     668 :                     ;         defaulting putc(x) to putcpace(7,x)
(1)    5/     668 :                     	align 64
(1)    6/     680 :                     _putc:		;default putc(x) is paced output on port 7
(1)    7/     680 : (MACRO)             	cpy2 	13,12	;move data to second param reg
(1)    8/     684 : (MACRO)             	ldad	12,7	;select port 7
(1)    9/     688 : 30 8A               	br	_putcpace ;drop into paced output	
(1)   10/     68A :                     _putcpace:	;putcpace(x,y) does host output on port x at no more than about 57600 baud
(1)   11/     68A :                     		;i'm doing the pacing before the output so i can branch to _out when done.
(1)   12/     68A : =>TRUE               if MOMCPU=$1805	;first balance off the call path for the 1806
(1)   13/     68A : C4                  	nop
(1)   14/     68B : C4                  	nop
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(IO1802.inc) - page 21 - 11/6/2017 9:07:24


(1)   15/     68C : C4                  	nop
(1)   16/     68D : [12]                 endif
(1)   17/     68D : =>DEFINED            ifdef CPUSPEED
(1)   18/     68D : =>FALSE                if CPUSPEED>4000000	;now deal with the processor speed
(1)   19/     68D :                           ;targetting a thruput of 57600 baud - 5760 characters per second
(1)   20/     68D :                           ;each character needs CPUSPEED/5760/16 instruction times
(1)   21/     68D :                           ;the baseline out() is 42 instructions including call/return
(1)   22/     68D :                            NEEDINST: equ (CPUSPEED/5760/16)
(1)   23/     68D :                            ldi (NEEDINST-42+1)/2
(1)   24/     68D :                     -:     smi 1
(1)   25/     68D :                            bnz -
(1)   26/     68D : [18]                    endif
(1)   27/     68D : [17]                  endif
(1)   28/     68D : 30 AA                 br _out
(1)   29/     68F :                     
(1)   30/     68F :                     _inp:		;raw port input
(1)   31/     68F :                     		;stores a small tailored program on the stack and executes it
(1)   32/     68F : 22                  	dec	sp	;work backwards
(1)   33/     690 : F8 D3               	ldi	0xD3	;return instruction
(1)   34/     692 : 73                  	stxd		
(1)   35/     693 : 8C                  	glo	regarg1	;get the port number
(1)   36/     694 : FA 07               	ani	0x07	;clean it
(1)   37/     696 : 32 A6               	bz	+	; inp(0) isn't valid
(1)   38/     698 : F9 68               	ori	0x68	;make it an input instruction
(1)   39/     69A : 73                  	stxd		;store it for execution
(1)   40/     69B : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   41/     69F : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   42/     6A0 : D8                  	sep	rt1	;execute it
(1)   43/     6A1 :                     ;we will come back to here with the input byte in D
(1)   44/     6A1 : 12                  	inc	sp	;step over the work area
(1)   45/     6A2 : AF                  	plo	retVal	;save it to return
(1)   46/     6A3 : F8 00               	ldi	0
(1)   47/     6A5 : BF                  	phi	retval	;clear top byte
(1)   48/     6A6 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   49/     6A7 : 12                  	inc	sp	;and the D3
(1)   50/     6A8 : (MACRO)             	Cretn		;and we're done
(1)   51/     6AA :                     	
(1)   52/     6AA :                     _out:		;raw port output
(1)   53/     6AA :                     		;stores a small tailored program on the stack and executes it
(1)   54/     6AA :                     		;this could be bolder:
(1)   55/     6AA :                     		;store the program as 6x cc D5 where x is the port number and cc is the char
(1)   56/     6AA :                     		;then SEP sp
(1)   57/     6AA :                     		;the D5 would return to the calling program and finish fixing the stack.
(1)   58/     6AA :                     		;saves 6 instructions but it's a bit tricky.
(1)   59/     6AA : 22                  	dec	sp	;work backwards
(1)   60/     6AB : F8 D3               	ldi	0xD3	;return instruction
(1)   61/     6AD : 73                  	stxd		
(1)   62/     6AE : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the OUT instruction
(1)   63/     6B2 : 8C                  	glo	regarg1	;get the port number
(1)   64/     6B3 : FA 07               	ani	0x07	;clean it
(1)   65/     6B5 : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   66/     6B7 : 73                  	stxd		;store it for execution
(1)   67/     6B8 : 8D                  	glo	regarg2	;get the byte to be written
(1)   68/     6B9 : 52                  	str	sp	;store it where sp points
(1)   69/     6BA : D8                  	sep	rt1	;execute it
(1)   70/     6BB :                     ;we will come back to here with sp stepped up by one
(1)   71/     6BB : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   72/     6BC : 12                  	inc	sp	;and the D3
(1)   73/     6BD : (MACRO)             	Cretn		;and we're done
(1)   74/     6BF :                     	
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm(IO1802.inc) - page 22 - 11/6/2017 9:07:24


(1)   75/     6BF :                     	
(1)   76/     6BF :                     
     554/     6BF :                     
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 23 - 11/6/2017 9:07:25


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :  i386-unknown-win32 - | *BIGENDIAN :                      0 - |
*BRANCHEXT :                      0 - |  BVTABLE118 :                   61E C |
*CASESENSITIVE :                  0 - | *CONSTPI :        3.141592653589793 - |
 CPUSPEED :                  186A00 - | *DATE :                   11/6/2017 - |
*FALSE :                          0 - | *FULLPMMU :                       1 - |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - | *INSRCMODE :                      0 - |
*INSUPMODE :                      0 - | *L1 :                            AF C |
*L10 :                          1A7 C |  L12 :                          1A8 C |
*L13 :                          1C5 C | *L15 :                          353 C |
 L16 :                          1DC C |  L17 :                          34C C |
 L19 :                          32A C |  L20 :                          34A C |
 L22 :                          253 C |  L23 :                          295 C |
 L24 :                          2CE C |  L25 :                          2EC C |
 L26 :                          310 C |  L27 :                          249 C |
*L28 :                          3BE C | *L3 :                            BF C |
*L30 :                          57D C |  L31 :                          40A C |
 L32 :                          57A C |  L34 :                          569 C |
 L35 :                          57A C |  L37 :                          480 C |
 L38 :                          484 C |  L39 :                          48F C |
 L40 :                          4B1 C |  L42 :                          4C3 C |
 L43 :                          54A C |  L44 :                          476 C |
*L46 :                          5B8 C |  L47 :                          5A1 C |
*L48 :                          5A5 C | *L5 :                           14A C |
 L50 :                          5A6 C | *L51 :                          631 C |
*L7 :                           1B0 C |  L9 :                           19B C |
*LCC1802CPUSPEED :            493E0 - |  LCC1802INIT :                  633 C |
*LCCCODELOC :                     0 - | *LCCNOLONG :                      1 - |
*LCCNOMATH :                      1 - | *LCCSTACKLOC :                 103F - |
*LISTON :                         1 - | *MACEXP :                         0 - |
 MEMADDR :                        E - |  MOMCPU :                      1805 - |
*MOMCPUNAME :                  1805 - |  MSLP129 :                      662 C |
*NESTMAX :                      100 - |  OUTIT118 :                     61A C |
*PACKING :                        0 - | *PADDING :                        1 - |
*R0 :                             0 - | *R1 :                             1 - |
 R10 :                            A - |  R11 :                            B - |
 R12 :                            C - |  R13 :                            D - |
 R14 :                            E - |  R15 :                            F - |
 R2 :                             2 - | *R3 :                             3 - |
*R4 :                             4 - | *R5 :                             5 - |
 R6 :                             6 - |  R7 :                             7 - |
*R8 :                             8 - | *R9 :                             9 - |
 RCALL :                          4 - |  REGARG1 :                        C - |
 REGARG2 :                        D - | *RELAXED :                        1 - |
*RETADDR :                        6 - |  RETVAL :                         F - |
*RL0 :                            1 - | *RL10 :                           B - |
*RL12 :                           D - | *RL4 :                            5 - |
*RL6 :                            7 - | *RL8 :                            9 - |
*RP1P2 :                          D - |  RPC :                            3 - |
 RRET :                           5 - |  RT1 :                            8 - |
*RT2 :                            9 - | *RWORK :                          E - |
 SETBITOFF118 :                 615 C |  SP :                             2 - |
 SUBOVHD :                        E - | *TIME :                     9:07:22 - |
*TRUE :                           1 - | *VERSION :                     142F - |
 _00000123 :                    645 C | *_BOYDINC :                       4 C |
 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 24 - 11/6/2017 9:07:25


 _BOYDSCAN :                      4 C |  _BOYDSCAN.KEY_0 :               80 C |
 _BOYDSCAN.KEY_1 :               84 C |  _BOYDSCAN.KEY_10 :              68 C |
 _BOYDSCAN.KEY_11 :              6C C |  _BOYDSCAN.KEY_12 :              50 C |
 _BOYDSCAN.KEY_13 :              54 C |  _BOYDSCAN.KEY_14 :              58 C |
 _BOYDSCAN.KEY_15 :              5C C |  _BOYDSCAN.KEY_2 :               88 C |
 _BOYDSCAN.KEY_3 :               8C C |  _BOYDSCAN.KEY_4 :               70 C |
 _BOYDSCAN.KEY_5 :               74 C |  _BOYDSCAN.KEY_6 :               78 C |
 _BOYDSCAN.KEY_7 :               7C C |  _BOYDSCAN.KEY_8 :               60 C |
 _BOYDSCAN.KEY_9 :               64 C |  _BOYDSCAN.KEY_ADD :             90 C |
 _BOYDSCAN.KEY_CLEAR :           A4 C |  _BOYDSCAN.KEY_CLR_ENTRY :       AA C |
 _BOYDSCAN.KEY_DIV_FIS :         AB C |  _BOYDSCAN.KEY_DIV_WHOLE :       AC C |
 _BOYDSCAN.KEY_EQU :             AC C |  _BOYDSCAN.KEY_INV_SIGN :        A9 C |
 _BOYDSCAN.KEY_MEM_RECALL :      AC C |  _BOYDSCAN.KEY_MEM_STORE :       9C C |
 _BOYDSCAN.KEY_MUL :             98 C |  _BOYDSCAN.KEY_REM :             A0 C |
 _BOYDSCAN.KEY_SAVE :            AC C |  _BOYDSCAN.KEY_SUB :             94 C |
 _BOYDSCAN.SCAN :                 9 C |  _DELAY :                       58E C |
 _DIE123 :                      649 C | *_DIGITALREAD :                 628 C |
*_DIGITALWRITE :                600 C |  _DISP1 :                        B1 C |
 _DISPMEMLOC :                   C1 C |  _DISPVAL :                     155 C |
 _EXECUTE :                     1C7 C |  _GETSP :                       1BB C |
 _HELLO :                       366 C | *_INP :                         68F C |
 _MAIN :                        3C0 C | *_OLDUINOINCLUDER :             5C5 C |
 _ONEMS :                       660 C |  _OUT :                         6AA C |
*_OUT4 :                        654 C |  _PIN4 :                          3 C |
*_PUTC :                        680 C |  _PUTCPACE :                    68A C |
*_SETQOFF :                     651 C | *_SETQON :                      64E C |
 __FORW0 :                      62F C |  __FORW1 :                      6A6 C |
*__FORW2 :                      6BB C |

    169 symbols
     71 unused symbols

 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 25 - 11/6/2017 9:07:25


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU2RRS                               | ALU4                                 
ALU4I                                 | BLKCPY                               
CCALL                                 | CPY1                                 
CPY2                                  | CPY4                                 
CRETN                                 | DECM                                 
DEMOTE                                | INC4                                 
INCM                                  | JCF4                                 
JCI2                                  | JCI2I                                
JCI4                                  | JCU2                                 
JCU2I                                 | JCU4                                 
JEQI1                                 | JEQI2                                
JEQI4                                 | JEQU1I                               
JEQU2I                                | JNEU1I                               
JNEU2                                 | JNEU2I                               
JNEU2NI                               | JNEU4                                
JNI2I                                 | JNU2I                                
JNZU1                                 | JNZU2                                
JUMPV                                 | JZU1                                 
JZU2                                  | LD1                                  
LD2                                   | LD2Z                                 
LD4                                   | LDA2                                 
LDAD                                  | LDAX                                 
LDAXS                                 | LDI4                                 
LDIREG                                | LDN1                                 
LDN2                                  | LDN2S                                
MVC1                                  | MVC2                                 
MVCN1                                 | MVCN2                                
NEGI2                                 | NEGI4                                
NOP1806                               | POPF                                 
POPL                                  | POPM                                 
POPR                                  | PUSHR                                
RELEASE                               | RELEASEL                             
RELEASES                              | RESERVE                              
RESERVEL                              | RESERVES                             
SEXT                                  | SEXT4                                
SHL2                                  | SHL2I                                
SHL2R                                 | SHL4                                 
SHL4I                                 | SHL4R                                
SHLC4                                 | SHLR2R                               
SHRC4                                 | SHRI2                                
SHRI2I                                | SHRI2R                               
SHRI4                                 | SHRI4I                               
SHRI4R                                | SHRU2                                
SHRU2I                                | SHRU2R                               
SHRU4                                 | SHRU4I                               
SHRU4R                                | ST1                                  
ST2                                   | ST2I                                 
ST4                                   | STR1                                 
STR1I                                 | STR2                                 
STR2I                                 | XUSHF                                
XUSHL                                 | XUSHM                                
ZEXT                                  | ZEXT4                                

    106 macros

 AS V1.42 Beta [Bld 87] - source file boydmon1103.oasm - page 26 - 11/6/2017 9:07:25


  codepages:
  ----------

STANDARD (0 changed characters)


2.39 seconds assembly time

   2323 lines source file
   4082 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
