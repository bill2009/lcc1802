; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Sun Jan 28 16:05:51 2018
SP:	equ	2 ;stack pointer
memAddr: equ	14
retAddr: equ	6
retVal:	equ	15
regArg1: equ	12
regArg2: equ	13
	listing off
	RELAXED ON
;definitions and prolog functions needed for smc1802 programs (Hi Bill)
;dec 21 packaged version for the christmas compiler (Ho Ho Ho)
;Dec 24 fixed shift macros to use memaddr as a work register and not corrupt the shift count
;jan 6 fixed shift left macro as above
;jan 11 saving as lcc1802epiloNG.inc for the NG compiler
;jan 12 minor correction to rldmi
;jan 14 minor correction to ldi4
;jan 16 adding shri4I
;jan20 correct error in shl2r
;jan21 moved 4 byte macros to bottom and added shrc4
;Jan 28 archived before beginning work on Birthday Compiler
;Feb 7 adding nointerrupts/interrupts to control interruptability
;Feb 13 changing address mode macros
;Feb 14 removing nointerrupts, adding reserve/release for stack frame, ld2z macro
;Mar 3 changing reserve/release to use inc/dec for 8 or less bytes
;Mar 4 adding incm macro for multiple increments
;mar 5 adding jzi2 macro to speed up if processing
;mar 6 adding ldn1, str1 for register indirect addressing
;mar 17 adding decm macro
;mar 28 adding jumpv macro
;may 15 adding jnzu1, jzu1 macros
;june 21 adding demote macro
;Oct 2, 2013 DH version for dhrystone optimization 
;Oct 2, 2013 added str2 macro 2 byte store at addr pointed to by register
;oct 4,	added st2i 2 byte immediate sore, pushf,pushm,pushl sequences, 
;oct 24, added ldaXs for stack pointed addresses, added mvcn1, mvc1 for 1 byte storage to storage moves, jneu1i for single byte immediate compare
;Feb 17 2014 added "inc sp" to restore stack pointer in jeqI1, affected strncmp.
;Feb 18 2017 added org to LCCCODELOC to allow for non-zero origin
;Feb 19 2017 beginning to adapt for 1806
;17-03-06 remove inc/dec from ccall, cretn6, add inc to popr
;17-03-07 add popf,popm,popl for optimization
;17-03-14 removed savemi, rldmi,cretn6
;17-03-27 added jequ1i
;17-10-17 compatability with clean stack discipline
;         changed pushr, removed pushf pushr pushm, removed many dec/inc sp's for work areas
;17-10-19 changed LCCCODELOC to CODELOC
;18-01-11 changed MACEXP OFF to MACEXP_DFT for version 1.42 of the assembler
;18-01-25 changed syntax for SCAL
	org	CODELOC		;wjr 17-02-18 allow code relocation
R0:	equ	0
R1:	equ	1
R2:	equ	2
R3:	equ	3
R4:	equ	4
R5:	equ	5
R6:	equ	6
R7:	equ	7
R8:	equ	8
R9:	equ	9
R10:	equ	10
R11:	equ	11
R12:	equ	12
R13:	equ	13
R14:	equ	14
R15:	equ	15
RL0:	equ	1 ;long register pairs are identified by their odd numbered register
RL4:	equ	5 ;17-10-20 RL4/5 register pair is permitted for 1806 only.
RL6:	equ	7 
RL8:	equ	9 ;temp 1
RL10:	equ	11;temp 2
RL12:	equ	13 ;return value register for longs
Rp1p2:	equ	13 ;argument register for longs
Rt1:	equ	8  ;1st temp register
Rt2:	equ	9  ;2nd temp register
RCALL:	equ 	4 ;standard call routine
RRET:	equ 	5 ;standard return register
RPC:	equ 	3 ; standard program counter
;	listing	off
		MACEXP_DFT OFF
;macro definitions
;more natural 1802 macros
	listing	on
	lbr	lcc1802Init
	listing on
_PIN4:
	db 0
_boydsegments:
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 34
	db 0
	db 0
	db 0
	db 0
	db 32
	db 0
	db 0
	db 0
	db 0
	db 17
	db 4
	db 0
	db 44
	db 123
	db 48
	db 109
	db 117
	db 54
	db 87
	db 95
	db 112
	db 127
	db 119
	db 65
	db 81
	db 0
	db 0
	db 0
	db 0
	db 111
	db 126
	db 31
	db 75
	db 61
	db 79
	db 78
	db 91
	db 62
	db 16
	db 57
	db 94
	db 11
	db 88
	db 28
	db 29
	db 110
	db 103
	db 12
	db 83
	db 15
	db 59
	db 25
	db 35
	db 92
	db 55
	db 105
	db 0
	db 22
	db 0
	db 0
	db 1
	db 6
	db 126
	db 31
	db 75
	db 61
	db 79
	db 78
	db 91
	db 62
	db 16
	db 57
	db 94
	db 11
	db 88
	db 28
	db 29
	db 110
	db 103
	db 12
	db 83
	db 15
	db 59
	db 25
	db 35
	db 92
	db 55
	db 105
	db 0
	db 0
	db 0
	db 0
	db 0
;$$function start$$ _disp1
_disp1:		;framesize=2
;void disp1(unsigned char d){//display a byte as two hex digits
;	asm(" glo 12\n ani 0x0f\n" //prep bottom digit
 glo 12
 ani 0x0f
 dec 2
 str 2
 out 7
 glo 12
 shr
 shr
 shr
 shr
 dec 2
 str 2
 out 7
;}
L1:
        sret    6
;$$function end$$ _disp1
;$$function start$$ _dispmemloc
_dispmemloc:		;framesize=8
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
;void dispmemloc(unsigned char * loc){
;	initleds(0b11010000); //LEDs in hex decode mode
;	disp1(*(loc+1));
 req
 seq
 dec 2
 ldi 0b11010000
 str 2
 out 7
 req
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        adi     ((1))#256
        plo     MEMADDR
        ghi     R11
        adci    ((1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISP1
;	disp1(*loc);
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        ldn     R11
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISP1
;	lint=(unsigned int)loc;
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        plo     R7
        ghi     R11
        phi     R7
;	disp1((unsigned int)loc&0xff);
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        ANI     (255)#256
        plo     R11
        ghi     R11
        ANI     (255)>>8; was/256
        phi     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISP1
;	disp1(lint>>8);
        glo     R7
        plo     R11
        ghi     R7
        phi     R11
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
        glo     R11
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISP1
;}
L3:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        lda     sp
        phi     R7
        ldn     sp
        plo     R7
        sret    6
;$$function end$$ _dispmemloc
;$$function start$$ _dispval
_dispval:		;framesize=8
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
;Oct 13 (8+1) added to ldAD call
        glo     SP
        adi     ((8+1))#256
        plo     R11
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     R11
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R10
        ldn     memAddr
        plo     R10
        glo     R10
        str     R11
;void dispval(unsigned char v){
;	initleds(0b11010000); //LEDs in hex decode mode
;	disp1(v);
 req
 seq
 dec 2
 ldi 0b11010000
 str 2
 out 7
 req
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISP1
;	for (i=6;i!=0;i--) out(7,0);
        RLDI    R7,6
	lbr L10
L7:
        RLDI    R12,7
        ldi     0
        plo     R13
        phi     R13
                SCAL    6,_OUT
L8:
        dec     R7
L10:
        glo     R7
        lbnz    L7
        ghi     R7
        lbnz    L7
;}
L5:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        lda     sp
        phi     R7
        ldn     sp
        plo     R7
        sret    6
;$$function end$$ _dispval
;$$function start$$ _getsp
_getsp:		;framesize=2
;unsigned int getsp(){//return stack pointer value
;	asm(" cpy2 r15,sp\n"  	//copy stack pointer to return reg
;	return 0;				//not executed
        glo     SP
        plo     R15
        ghi     SP
        phi     R15
        sret    6
        ldi     0
        plo     R15
        phi     R15
L11:
        sret    6
;$$function end$$ _getsp
;$$function start$$ _execute
_execute:		;framesize=16
        dec sp
        dec sp
        RSXD    R0
        RSXD    R1
        RSXD    R6
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
        glo     R12
        plo     R7
        ghi     R12
        phi     R7
;unsigned char * execute(unsigned char * loc){
	lbr L15
L14:
;	while(1){
;		op=*loc; val=*(loc+1);
        ldn     R7
        plo     R6
        glo     R7
        plo     R11
        ghi     R7
        phi     R11
        inc     R11
        ldn     R11
        plo     R1
;		switch (op){
        glo     R6
        plo     R11
        ldi     0
        phi     R11
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        smi     (0)#256
        ghi     R11
        smbi    (0)>>8; was/256      ;that's a standard signed subtraction
        ghi     R11 ;
        xri     (0)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L17  ;execute 
        glo     R11
        sdi     (4)#256      ;subtract d FROM immediate value
        ghi     R11
        sdbi    (4)>>8; was/256      ;that's a standard signed subtraction (of register FROM immediate)
        ghi     R11 ;
        xri     (4)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L17  ;execute 
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        adi     ((L25))#256
        plo     MEMADDR
        ghi     R11
        adci    ((L25))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        RSXD    R6
        glo     R11
        plo     R6
        ghi     R11
        phi     R6
        sret    6
L25:
	dw L20
	dw L21
	dw L22
	dw L23
	dw L24
L20:
;				mp=(unsigned char *)(4096+val);
        glo     R1
        plo     R11
        ldi     0
        phi     R11
;Oct 13 (4096) added to ldAD call
        glo     R11
        adi     ((4096))#256
        plo     R11
        ghi     R11
        adci    ((4096))>>8; was/256
        phi     R11
        glo     R11
        plo     R0
        ghi     R11
        phi     R0
;				dispval(*mp); delay(1000);
        glo     R0
        adi     (0)#256
        plo     MEMADDR
        ghi     R0
        adci    (0)>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISPVAL
        RLDI    R12,1000
                SCAL    6,_DELAY
;				break;
	lbr L18
L21:
;				mp=(unsigned char *)(4096+val);
        glo     R1
        plo     R11
        ldi     0
        phi     R11
;Oct 13 (4096) added to ldAD call
        glo     R11
        adi     ((4096))#256
        plo     R11
        ghi     R11
        adci    ((4096))>>8; was/256
        phi     R11
        glo     R11
        plo     R0
        ghi     R11
        phi     R0
;				*mp+=1;
        glo     R0
        adi     (0)#256
        plo     MEMADDR
        ghi     R0
        adci    (0)>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        ldi     0
        phi     R11
        inc     R11
        glo     R11
        str     R0
;				break;
	lbr L18
L22:
;				loc=(unsigned char *)(val+4096-2); //ugh
        glo     R1
        plo     R11
        ldi     0
        phi     R11
;Oct 13 (4096) added to ldAD call
        glo     R11
        adi     ((4096))#256
        plo     R11
        ghi     R11
        adci    ((4096))>>8; was/256
        phi     R11
        dec     R11
        dec     R11
        glo     R11
        plo     R7
        ghi     R11
        phi     R7
;				break;
	lbr L18
L23:
;				delay(val*4);
        glo     R1
        plo     R11
        ldi     0
        phi     R11
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        plo     R12
        ghi     R11
        phi     R12
                SCAL    6,_DELAY
;				break;
	lbr L18
L24:
;				dispval(getsp());
                SCAL    6,_GETSP
        glo     R15
        plo     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISPVAL
;				delay(250);
        RLDI    R12,250
                SCAL    6,_DELAY
;				break;
	lbr L18
L17:
;				dispval(0x41); delay(250);
        RLDI    R12,65
                SCAL    6,_DISPVAL
        RLDI    R12,250
                SCAL    6,_DELAY
;				dispmemloc(loc); delay(5000);
        glo     R7
        plo     R12
        ghi     R7
        phi     R12
                SCAL    6,_DISPMEMLOC
        RLDI    R12,5000
                SCAL    6,_DELAY
;				break;
L18:
;		loc+=2;
        inc     R7
        inc     R7
;	}
L15:
;	while(1){
	lbr L14
;	return loc;
        glo     R7
        plo     R15
        ghi     R7
        phi     R15
L13:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        RLXA    R7
        RLXA    R6
        RLXA    R1
        lda     sp
        phi     R0
        ldn     sp
        plo     R0
        inc sp
        inc sp
        sret    6
;$$function end$$ _execute
;$$function start$$ _dispalpha
_dispalpha:		;framesize=8
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
;void dispalpha(unsigned char data[]){
;	dispval(getsp()); //display
                SCAL    6,_GETSP
        glo     R15
        plo     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISPVAL
;	delay(100);
        RLDI    R12,100
                SCAL    6,_DELAY
;	initleds(0b11110000); //LEDs in no-decode mode
;	for (i=8;i!=0;i--){
 req
 seq
 dec 2
 ldi 0b11110000
 str 2
 out 7
 req
        RLDI    R7,8
	lbr L31
L28:
;		out(7,boydsegments[data[i]]);
        RLDI    R12,7
;Oct 13 (8+1)+1 added to ldAD call
        glo     SP
        adi     ((8+1)+1)#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1)+1)>>8; was/256
        phi     MEMADDR
        sex     memaddr
        glo     R7
        ADD
        plo     R11
        dec     memaddr
        ghi     R7
        ADC
        phi     R11
        sex     sp
        ldn     R11
        plo     R11
        ldi     0
        phi     R11
        glo     R11
        adi     ((_BOYDSEGMENTS))#256
        plo     MEMADDR
        ghi     R11
        adci    ((_BOYDSEGMENTS))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R13
        ldi     0
        phi     R13
                SCAL    6,_OUT
;	}
L29:
;	for (i=8;i!=0;i--){
        dec     R7
L31:
        glo     R7
        lbnz    L28
        ghi     R7
        lbnz    L28
;}
L26:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        lda     sp
        phi     R7
        ldn     sp
        plo     R7
        sret    6
;$$function end$$ _dispalpha
;$$function start$$ _strlen
_strlen:		;framesize=4
        RSXD    R7
;{
;	unsigned int slen = 0 ;
        ldi     0
        plo     R7
        phi     R7
	lbr L34
L33:
;	while (*str != 0) {
;      slen++ ;
        inc     R7
;      str++ ;
        inc     R12
;   }
L34:
;	while (*str != 0) {
        ldn     R12
        plo     R11
        glo     R11
        lbnz    L33
;   return slen;
        glo     R7
        plo     R15
        ghi     R7
        phi     R15
L32:
        inc     sp
        lda     sp
        phi     R7
        ldn     sp
        plo     R7
        sret    6
;$$function end$$ _strlen
;$$function start$$ _dispstr
_dispstr:		;framesize=12
        RSXD    R1
        RSXD    R6
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
;void dispstr(unsigned char * str){//display 8 or fewer characters on the boyd LEDs
;	L=min(strlen((char *)str),8);//length to display
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R12
        ldn     memAddr
        plo     R12
                SCAL    6,_STRLEN
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R11
        smi     (8)#256
        ghi     R11
        smbi    (8)>>8; was/256      ;that's a standard signed subtraction
        ghi     R11 ;
        xri     (8)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBDF    L38  ;execute 
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R12
        ldn     memAddr
        plo     R12
                SCAL    6,_STRLEN
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R11
        plo     R1
        ghi     R11
        phi     R1
	lbr L39
L38:
        RLDI    R1,8
L39:
        glo     R1
        plo     R6
        ghi     R1
        phi     R6
;	initleds(0b11110000); //LEDs in no-decode mode
;	if (L<8){
 req
 seq
 dec 2
 ldi 0b11110000
 str 2
 out 7
 req
        glo     R6
        smi     (8)#256
        ghi     R6
        smbi    (8)>>8; was/256      ;that's a standard signed subtraction
        ghi     R6 ;
        xri     (8)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBDF    L41  ;execute 
;		for(i=(L-8); i>0;i--){
        glo     R6
        SMI     (8)#256
        plo     R7
        ghi     R6
        SMBI     (8)>>8; was/256
        phi     R7
	lbr L46
L43:
;			out(7,255);
        RLDI    R12,7
        RLDI    R13,255
                SCAL    6,_OUT
;		}
L44:
;		for(i=(L-8); i>0;i--){
        dec     R7
L46:
        glo     R7
        lbnz    L43
        ghi     R7
        lbnz    L43
;	}
L41:
;	for (i=L;i>0;i--){
        glo     R6
        plo     R7
        ghi     R6
        phi     R7
	lbr L50
L47:
;		out(7,boydsegments[str[i-1]]);
        RLDI    R12,7
        glo     R7
        plo     R11
        ghi     R7
        phi     R11
        dec     R11
;Oct 13 (12+1)+1 added to ldAD call
        glo     SP
        adi     ((12+1)+1)#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1)+1)>>8; was/256
        phi     MEMADDR
        sex     memaddr
        glo     R11
        ADD
        plo     R11
        dec     memaddr
        ghi     R11
        ADC
        phi     R11
        sex     sp
        ldn     R11
        plo     R11
        ldi     0
        phi     R11
        glo     R11
        adi     ((_BOYDSEGMENTS))#256
        plo     MEMADDR
        ghi     R11
        adci    ((_BOYDSEGMENTS))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R13
        ldi     0
        phi     R13
                SCAL    6,_OUT
;	}
L48:
;	for (i=L;i>0;i--){
        dec     R7
L50:
        glo     R7
        lbnz    L47
        ghi     R7
        lbnz    L47
;}
L36:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        RLXA    R7
        RLXA    R6
        lda     sp
        phi     R1
        ldn     sp
        plo     R1
        sret    6
;$$function end$$ _dispstr
;$$function start$$ _main
_main: ;copt is peeping your size 16 frame with oct 23 rules
        dec sp
        dec sp
        RSXD    R0
        RSXD    R1
        RSXD    R6
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
;{
;	unsigned char * loc=0;
        RLDI    R6,0
;	unsigned char memtype='o'; //displaying o=eeprom,a=ram
        RLDI    R1,111
;	dispval(0x42);
        RLDI    R12,66
                SCAL    6,_DISPVAL
;	delay(100);
        RLDI    R12,100
                SCAL    6,_DELAY
;	dispstr((unsigned char *)"BARRY");
        RLDI    R12,L52
                SCAL    6,_DISPSTR
;	delay(5000);
        RLDI    R12,5000
                SCAL    6,_DELAY
;	dispstr((unsigned char *)"01234567");
        RLDI    R12,L53
                SCAL    6,_DISPSTR
;	delay(5000);
        RLDI    R12,5000
                SCAL    6,_DELAY
	lbr L55
L54:
;	while(1){
;		dispmemloc(loc);
        glo     R6
        plo     R12
        ghi     R6
        phi     R12
                SCAL    6,_DISPMEMLOC
;		k=boydscan();
                SCAL    6,_BOYDSCAN
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R11
        plo     R7
;		switch(k){
        glo     R7
        plo     R11
        ldi     0
        phi     R11
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
        glo     SP
        adi     ((12+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((12+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        smi     (16)#256
        ghi     R11
        smbi    (16)>>8; was/256      ;that's a standard signed subtraction
        ghi     R11 ;
        xri     (16)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L57  ;execute 
        glo     R11
        sdi     (20)#256      ;subtract d FROM immediate value
        ghi     R11
        sdbi    (20)>>8; was/256      ;that's a standard signed subtraction (of register FROM immediate)
        ghi     R11 ;
        xri     (20)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L57  ;execute 
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        adi     ((L67-32))#256
        plo     MEMADDR
        ghi     R11
        adci    ((L67-32))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        RSXD    R6
        glo     R11
        plo     R6
        ghi     R11
        phi     R6
        sret    6
L67:
	dw L60
	dw L61
	dw L62
	dw L65
	dw L66
L60:
;				loc +=1;
        inc     R6
;				break;
	lbr L58
L61:
;				loc -=1;
;Oct 13 (-1) added to ldAD call
        glo     R6
        adi     ((-1))#256
        plo     R6
        ghi     R6
        adci    ((-1))>>8; was/256
        phi     R6
;				break;
	lbr L58
L62:
;				if (memtype=='o'){
        glo     R1
        smi     111
        lbnz    L63
;					loc=(unsigned char *)4096;
        RLDI    R6,0X1000
;					memtype='a';
        RLDI    R1,97
;				}else{
	lbr L58
L63:
;					loc=(unsigned char *)0;
        RLDI    R6,0
;					memtype='o';
        RLDI    R1,111
;				}
;				break;
	lbr L58
L65:
;				dispmemloc(loc); //makes a blink
        glo     R6
        plo     R12
        ghi     R6
        phi     R12
                SCAL    6,_DISPMEMLOC
;				k=boydscan(); dispval(k); delay(250);
                SCAL    6,_BOYDSCAN
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R11
        plo     R7
        glo     R7
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISPVAL
        RLDI    R12,250
                SCAL    6,_DELAY
;				k2=boydscan(); dispval(k2); delay(250);
                SCAL    6,_BOYDSCAN
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R11
        plo     R0
        glo     R0
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISPVAL
        RLDI    R12,250
                SCAL    6,_DELAY
;				*loc=(k<<4)+k2;
        glo     R7
        plo     R11
        ldi     0
        phi     R11
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R0
        plo     R10
        ldi     0
        phi     R10
        glo     R10
        str     sp
        glo     R11
        ADD             ;calculate the low order byte
        plo     R11
        ghi     R10
        str     sp
        ghi     R11
        ADC             ;calculate the high byte
        phi     R11
        glo     R11
        str     R6
;				break;
	lbr L58
L66:
;				dispval(0x45);
        RLDI    R12,69
                SCAL    6,_DISPVAL
;				delay(250);
        RLDI    R12,250
                SCAL    6,_DELAY
;				loc=execute(loc);
        glo     R6
        plo     R12
        ghi     R6
        phi     R12
                SCAL    6,_EXECUTE
        glo     R15
        plo     R6
        ghi     R15
        phi     R6
;				break;
	lbr L58
L57:
;				dispval(k);
        glo     R7
        plo     R12
        ldi     0
        phi     R12
                SCAL    6,_DISPVAL
;				delay(250);
        RLDI    R12,250
                SCAL    6,_DELAY
;		}
L58:
;	}
L55:
;	while(1){
	lbr L54
;}
L51:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        RLXA    R7
        RLXA    R6
        RLXA    R1
        lda     sp
        phi     R0
        ldn     sp
        plo     R0
        inc sp
        inc sp
        sret    6
;$$function end$$ _main
;$$function start$$ _delay
_delay:		;framesize=10
        RSXD    R6
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
        glo     R12
        plo     R7
        ghi     R12
        phi     R7
;void delay(unsigned int howlong){
;	for (i=1;i!=howlong;i++){
        RLDI    R6,1
	lbr L73
L70:
;		oneMs();
                SCAL    6,_ONEMS
;	}
L71:
;	for (i=1;i!=howlong;i++){
        inc     R6
L73:
        dec     sp
        glo     R7
        str     sp
        glo     R6
        sm
        inc     sp
        lbnz    L70
        dec     sp
        ghi     R7
        str     sp
        ghi     R6
        smb
        inc     sp
        lbnz    L70
;}
L69:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        RLXA    R7
        lda     sp
        phi     R6
        ldn     sp
        plo     R6
        sret    6
;$$function end$$ _delay
;$$function start$$ _olduinoincluder
_olduinoincluder:		;framesize=2
;void olduinoincluder(){
;	asm("\tinclude olduino.inc\n");
;Feb 8 2013, first version of assembler routines for olduino support	
;may 31 - incredibly, there's an error in digitalWrite.  lda2 changed to ldAD
;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
	align 64	;needed to make sure all on same page
_digitalWrite:
	glo regArg1	;get the bit number
	adi $$bvtable&255	;add the table offset
	plo memaddr
	ghi RPC		;get the top byte of the current page
	phi memaddr	
	ldn memaddr	;pick up the bit pattern
	plo rt1		;save it in a temp
        RLDI    MEMADDR,_PIN4
	sex memaddr	;prepare to change it
	glo regArg2	;get on/off switch
	bz $$setbitoff
; here we have the bit pattern in rt1 and we're ready to apply it with OR
	glo rt1		;get the bit value back
	or		;apply it
	str memaddr	;and save it
	br $$outit	;go fnish up
$$setbitoff:
	glo rt1		;get the bit pattern
	xri 0xff	;reverse it
	and		;combine it with the existing pin value
	str memaddr	;and save it
;here we gave set/reset the correct bit in PIN4 and we just have to send it out
$$outit:
	out 4		;X was already set to memaddr
	sex sp		;reset X
        sret    6
$$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
;int digitalRead(unsigned char pin){//for now this will always read ef3
	align 8	;protect jump boundary
_digitalRead:
	ldi 0		;default is false
	plo R15
	phi R15
	b3 +		;i have to reverse the sense of the external line
	inc R15		;if external line is high, supply a 1
        sret    6
;}
L74:
        sret    6
;$$function end$$ _olduinoincluder
;$$function start$$ _boydinc
_boydinc:		;framesize=2
;void boydinc(){
;	asm(" align 256\n");
;	asm(" include \"boydscan.inc\"\n");
 align 256
_boydscan:			;SCAN THE KEYBOARD
		sex	r14 	;set up "don't care" X register
		rldi	r15,0	; r15 is return value
.scan:		OUT	1                     ;109: 61 	
		B1	.KEY_12                     ;10A: 34 50 	
		B2	.KEY_8                      ;10C: 35 60 	
		B3	.KEY_4                      ;10E: 36 70 	
		B4	.KEY_0                      ;110: 37 80 	
		OUT	2                     ;112: 62 	
		B1	.KEY_13                     ;113: 34 54 	
		B2	.KEY_9                      ;115: 35 64 	
		B3	.KEY_5                      ;117: 36 74 	
		B4	.KEY_1                      ;119: 37 84 	
		OUT	3                     ;11B: 63 	
		B1	.KEY_14                     ;11C: 34 58 	
		B2	.KEY_10                     ;11E: 35 68 	
		B3	.KEY_6                      ;120: 36 78 	
		B4	.KEY_2                      ;122: 37 88 	
		OUT	4                     ;124: 64 	
		B1	.KEY_15                     ;125: 34 5C 	
		B2	.KEY_11                     ;127: 35 6C 	
		B3	.KEY_7                      ;129: 36 7C 	
		B4	.KEY_3                      ;12B: 37 8C 	
		OUT	5                     ;12D: 65 	
		B1	.KEY_DIV_WHOLE              ;12E: 34 99 	
		B2	.KEY_MUL                    ;130: 35 96 	
		B3	.KEY_SUB                    ;132: 36 93 	
		B4	.KEY_ADD                    ;134: 37 90 	
		OUT	6                     ;136: 66 	
		B1	.KEY_REM                    ;137: 34 A5 	
		B2	.KEY_MEM_STORE              ;139: 35 A2 	
		B3	.KEY_MEM_RECALL             ;13B: 36 9F 	
		B4	.KEY_EQU                    ;13D: 37 9C 	
		SEQ                                ;13F: 7B 	
		B1	.KEY_DIV_FIS                ;140: 34 B1 	
		B2	.KEY_CLEAR                  ;142: 35 AE 	
		B3	.KEY_CLR_ENTRY              ;144: 36 AB 	
		B4	.KEY_INV_SIGN               ;146: 37 A8 	
		REQ                                ;148: 7A 	
;here we have no keys pressed, if r15.0 has a value, return it -1
		glo	r15
		bz	.scan
		dec	r15
		sex	r2	;restore the X register before returning
        sret    6
.KEY_12		LDI	13                         ;150: F8  C 	
		BR	.KEY_SAVE                   ;152: 30 B4 	
.KEY_13		LDI	14                         ;154: F8  D 	
		BR	.KEY_SAVE                   ;156: 30 B4 	
.KEY_14		LDI	15                         ;158: F8  E 	
		BR	.KEY_SAVE                   ;15A: 30 B4 	
.KEY_15		LDI	16                         ;15C: F8  F 	
		BR	.KEY_SAVE                   ;15E: 30 B4 	
.KEY_8		LDI	 9                         ;160: F8  8 	
		BR	.KEY_SAVE                   ;162: 30 B4 	
.KEY_9		LDI	 10                         ;164: F8  9 	
		BR	.KEY_SAVE                   ;166: 30 B4 	
.KEY_10		LDI	11                         ;168: F8  A 	
		BR	.KEY_SAVE                   ;16A: 30 B4 	
.KEY_11		LDI	12                         ;16C: F8  B 	
		BR	.KEY_SAVE                   ;16E: 30 B4 	
.KEY_4		LDI	 5                         ;170: F8  4 	
		BR	.KEY_SAVE                   ;172: 30 B4 	
.KEY_5		LDI	 6                         ;174: F8  5 	
		BR	.KEY_SAVE                   ;176: 30 B4 	
.KEY_6		LDI	 7                         ;178: F8  6 	
		BR	.KEY_SAVE                   ;17A: 30 B4 	
.KEY_7		LDI	 8                         ;17C: F8  7 	
		BR	.KEY_SAVE                   ;17E: 30 B4 	
.KEY_0		LDI	 1                         ;180: F8  0 	
		BR	.KEY_SAVE                   ;182: 30 B4 	
.KEY_1		LDI	 2                         ;184: F8  1 	
		BR	.KEY_SAVE                   ;186: 30 B4 	
.KEY_2		LDI	 3                         ;188: F8  2 	
		BR	.KEY_SAVE                   ;18A: 30 B4 	
.KEY_3		LDI	 4                         ;18C: F8  3 	
		BR	.KEY_SAVE                   ;18E: 30 B4 	
.KEY_ADD	ldi	16+1
		br	.key_save
.KEY_SUB:	ldi	17+1
		br	.key_save
.KEY_MUL:	ldi	20+1
		br	.key_save
.KEY_MEM_STORE:	ldi	19+1
		br	.key_save
.KEY_REM:	ldi	18+1
		br	.key_save
.KEY_CLEAR:	req
		ldi	20+1
		br	.key_save
.KEY_INV_SIGN:	req
.KEY_CLR_ENTRY:	req
.KEY_DIV_FIS:	req
.KEY_EQU:
.KEY_DIV_WHOLE:
.KEY_MEM_RECALL:
.KEY_SAVE:	plo 15
		br .scan
;}
L76:
        sret    6
;$$function end$$ _boydinc
L53:
	db 48
	db 49
	db 50
	db 51
	db 52
	db 53
	db 54
	db 55
	db 0
L52:
	db 66
	db 65
	db 82
	db 82
	db 89
	db 0
;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
;this is the version published with the lcc1802121229 release
;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
;jan 2 removed test routines, moved code not needing short branches to before the align 256
;jan 11 going back to SCRT conventions for NG compiler
;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
;Jan 28 archived before beginning work on Birthday Compiler
;Feb 5 dubdab algorithm being brought in for ltoa itoa
;Feb 12 fixed bugs in modi2/u2
;feb 27 changed stack to start at 7fff
;mar 3, 2013 saved as epiloNO for optimization round
;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
;april 4 adding digit count argument to dubdabx
;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
;16-09-20 allow stack relocation 
;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
;17-03-07 adjusting stack offset for 1805/6 stack discipline
;17-03-13 protecting work areas in divi2,divi4 routines from 1806 SCAL
;17-03-15 onems compensates for reduced subroutine overhead in 1806
;17-04-09 don't include call/return for 1806
;17-10-17 SCRT routines changed to clean stack model i.e. push is stxd stxd, pop is inc lda inc ldn
;17-10-19 using CPUSPEED instead of LCC1802CPUSPEED, also STACKLOC instead of LCCSTACKLOC
;17-10-23 extending work area protection from 10-13 above for 1802 as well as 1805
;17-11-25 conditional include for register saves
;18-01-28 changed onems() to always use 4 instruction loop, accommodate slower CPU speed
rwork	equ	memAddr	;work register
lcc1802init:
        RLDI    RCALL,$$_DIE
        RLDI    RRET,$$_DIE
        RLDI    SP,STACKLOC
	sex	SP
        RLDI    RPC,$$_00000
	sep	RPC
$$_00000:
                SCAL    6,_MAIN
$$_die:	lbr	$$_die		;loop here when main returns
	db	0xde,0xad
;the following routines don't have short jumps and don't need to worry about alignment
_setqOn:
	seq
        sret    6
_setqOff:
	req
        sret    6
_modU2:	;16 bit unsigned remainder
	; just calls the 16 bit division then puts remainder into return value
                SCAL    6,_DIVU2
    glo regArg1
    plo retVal
    ghi regArg1
    phi retVal
        sret    6
_modI2:	;16 bit signed remainder
	; just calls the 16 bit division then puts remainder into return value
                SCAL    6,_DIVI2
    glo regArg1
    plo retVal
    ghi regArg1
    phi retVal
        sret    6
_out4:	
	glo	regArg1
	dec	sp
	str	sp
	out	4
        sret    6
;the following routines have short branches so all the code has to stay within the same page
	align 8
_oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
;subroutine overhead soaks up 27 instruction time.
;each loop is 2 instruction times
;so the number of loops needed is 
;CPU speed/16000 less the 27 all divide by two
SUBOVHD  EQU 14		;1806 SCAL/SRET subroutine overhead
        sret    6
	align 256
;16 bit right shifting multiply which is faster for smaller operands
; credit to http://map.grauw.nl/articles/mult_div_shifts.php#lrmultr
_mulU2:		;retval(product)=regarg1(multiplicand)*regarg2(multiplier)
        ldi     0
        plo     RETVAL
        phi     RETVAL
$$mulrlp:
        ghi     REGARG2
        shr
        phi     REGARG2
        glo     REGARG2
        shrc
        plo     REGARG2
	bnf $$mulrnoadd
;	bottom bit of multiplier is one so add multiplicand to product
        glo     REGARG1
        str     sp
        glo     RETVAL
        ADD             ;calculate the low order byte
        plo     RETVAL
        ghi     REGARG1
        str     sp
        ghi     RETVAL
        ADC             ;calculate the high byte
        phi     RETVAL
$$mulrnoadd:
	ghi regarg2	;check for all bits of multiplier shifted out
	bnz $$mulrshft	;nope, continue
	glo regarg2	;check bottom byte
	bz $$mulrdone
$$mulrshft:
        glo     REGARG1
        shl
        plo     REGARG1
        ghi     REGARG1
        shlc
        phi     REGARG1
	br $$mulrlp
$$mulrdone:		;here the product is in retval
        sret    6
;this is a divisor shifting algorithm which is faster for smaller operands
;credit to http://research.microsoft.com/pubs/70645/tr-2008-141.pdf
;changed oct 12 to save R10 & 1/2 R11 on stack
_divu2: ;retval=regarg1(x or dividend)/regarg2(y or divisor)
	;uses R14(rwork) to hold original divisor y0, 
	;regarg1 to hold develop remainder, 
	;R10 to hold working dividend R11.0 as a temp
;	pushf R10	;save R10 & leave stack down 1
        RSXD    R10
	glo R11		;and bottom
	stxd		;of R11 - leaves stack clear of work area
        glo     REGARG1
        plo     R10
        ghi     REGARG1
        phi     R10
        ldi     0
        plo     RETVAL
        phi     RETVAL
        glo     REGARG2
        plo     RWORK
        ghi     REGARG2
        phi     RWORK
                                ;result in D, rwork.hi, DF
        glo REGARG2
        str sp
        glo R10
        sm
        plo R11
        ghi REGARG2
        str sp
        ghi R10
        smb
	bnf $$computequot	;DF=0 means it didn't fit
	phi R10	;R10=R10-regarg2
	glo R11
	plo R10
$$again:	;this is the divisor doubling phase
                                ;result in D, rwork.hi, DF
        glo REGARG2
        str sp
        glo R10
        sm
        plo R11
        ghi REGARG2
        str sp
        ghi R10
        smb
 	bnf $$computequot	;df=0 means it didn't fit
	phi R10	;R10=R10-regarg2
	glo R11
	plo R10 	
        glo     REGARG2
        shl
        plo     REGARG2
        ghi     REGARG2
        shlc
        phi     REGARG2
 	br $$again
 $$computequot:	;here we're computing the quotient
                                ;result in D, rwork.hi, DF
        glo REGARG2
        str sp
        glo REGARG1
        sm
        plo R11
        ghi REGARG2
        str sp
        ghi REGARG1
        smb
 	bnf $$testexit
 	phi regarg1		;complete the subtraction
 	glo R11
 	plo regarg1
 	inc retval
 $$testexit:
 	ghi rwork
 	sm	;top of regarg2 is still on stack
 	bnz $$ney0y
 	glo regarg2
 	str sp
 	glo rwork
 	sm	;test low order bytes
 	bz	$$out	;if = we're done
 $$ney0y:
        glo     RETVAL
        shl
        plo     RETVAL
        ghi     RETVAL
        shlc
        phi     RETVAL
        ghi     REGARG2
        shr
        phi     REGARG2
        glo     REGARG2
        shrc
        plo     REGARG2
 	br $$computequot	;continue
 $$out:
 ;here the quotient is in retval, remainder in regarg1
  	inc sp	;release work area
	ldn sp	;recover
	plo R11	;bottom byte of R11
        inc     sp
        lda     sp
        phi     R10
        ldn     sp
        plo     R10
        sret    6
;signed integer division retVal=regArg1/regArg2, remainder in regArg1
;uses unsigned division of absolute values then negates the quotient if the signs were originally different
_divI2:
    dec	sp	;leave a work area available
    ghi regArg1
    str sp	;save the sign of the 1st arg
    shl
    bnf $$pos1	;if the 1st arg is -v
        glo     REGARG1                     ;(flip all the bits and add 1)
        xri     0xff
        plo     REGARG1
        ghi     REGARG1
        xri     0xff
        phi     REGARG1
        inc     REGARG1
$$pos1: ;1st is now +v, check 2nd
    ghi regArg2
    xor	
    str sp ;the stack now has bit 8 set if the signs are different
    ghi regArg2
    shl
    bnf $$pos2	;if the 2nd arg is -v
        glo     REGARG2                     ;(flip all the bits and add 1)
        xri     0xff
        plo     REGARG2
        ghi     REGARG2
        xri     0xff
        phi     REGARG2
        inc     REGARG2
$$pos2: ; both args now +v
    dec sp	;protect workarea on the 1802
                SCAL    6,_DIVU2
    inc sp	;recover work area
;now the quotient is in retVal and the remainder is in regArg2
    lda	sp ;get back the sign bits and restore SP
    shl
    bnf $$done ;if the signs were different
        glo     RETVAL                     ;(flip all the bits and add 1)
        xri     0xff
        plo     RETVAL
        ghi     RETVAL
        xri     0xff
        phi     RETVAL
        inc     RETVAL
$$done:
        sret    6
	align 256    ;32 bit operations follow
_divu4:
;This is an unsigned 32 bit restoring division
;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
;Rp1p2:RL8 form a 64 bit work area A:Q
;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
	ldi 32		;set loop count
	plo memaddr	;in temp register
        ldi     (0)&255
        plo     RP1P2
        ldi     ((0)>>8)&255; 
        phi     RP1P2
        ldi     ((0)>>16)&255; 
        plo     RP1P2-1
        ldi     ((0)>>24)&255; 
        phi     RP1P2-1
$$loop:
        glo     RL8     ;start with low byte of second register
        shl             ;shift left once
        plo     RL8     ; save it
        ghi     RL8     ;high byte of second RL8
        shlc            ;shift one bit carrying
        phi     RL8     ;save it
        glo     RL8-1   ;now the bottom byte of top RL8
        shlc
        plo     RL8-1
        ghi     RL8-1   ;finally the top byte of the high order RL8
        shlc            ;gets the last shift
        phi     RL8-1   ;and we're done
        glo     RP1P2     ;start with low byte of second register
        shlc            ;shift left once continuing carry
        plo     RP1P2     ; save it
        ghi     RP1P2     ;high byte of second RP1P2
        shlc            ;shift one bit carrying
        phi     RP1P2     ;save it
        glo     RP1P2-1   ;now the bottom byte of top RP1P2
        shlc
        plo     RP1P2-1
        ghi     RP1P2-1   ;finally the top byte of the high order RP1P2
        shlc            ;gets the last shift
        phi     RP1P2-1   ;and we're done
        dec     sp ;make a work ares
        glo     RL10    ;long register pairs are addressed by their second member
        str     sp      ;so arithmetic operations start there
        glo     RP1P2
        SM             ;calculate the low order byte
        plo     RP1P2
        ghi     RL10
        str     sp
        ghi     RP1P2
        SMB             ;calculate the second byte
        phi     RP1P2
        glo     RL10-1
        str     sp
        glo     RP1P2-1
        SMB             ;calculate the third byte
        plo     RP1P2-1
        ghi     RL10-1
        str     sp
        ghi     RP1P2-1
        SMB             ;calculate the high byte
        phi     RP1P2-1
        inc     sp      ;release the work area
	ani 0x80	;check the top bit
	bz $$norestore	;if it's 0
		glo RL8
		ani 0xfe	;turn off the bottom bit
		plo RL8
        dec     sp ;make a work ares
        glo     RL10    ;long register pairs are addressed by their second member
        str     sp      ;so arithmetic operations start there
        glo     RP1P2
        ADD             ;calculate the low order byte
        plo     RP1P2
        ghi     RL10
        str     sp
        ghi     RP1P2
        ADC             ;calculate the second byte
        phi     RP1P2
        glo     RL10-1
        str     sp
        glo     RP1P2-1
        ADC             ;calculate the third byte
        plo     RP1P2-1
        ghi     RL10-1
        str     sp
        ghi     RP1P2-1
        ADC             ;calculate the high byte
        phi     RP1P2-1
        inc     sp      ;release the work area
	br $$endlp 	;else
$$norestore:
		glo RL8
		ori 1	;turn on the bottom bit
		plo RL8
	;end if
$$endlp:
	dec memaddr	;check the cycle count
	glo memaddr
	bnz $$loop	;back for more if needed
        sret    6
_mulu4:
	;this is a 32 bit signed multiplication using booth's algorithm
	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
	;the bottom byte of memaddr is used as a cycle count
	;initially	R12:13=0,	R8:R9=operand 1, DF=0
	;for 32 cycles we check the low bit of R8:R9 and DF
	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
	;for 10 we subtract and shift
	;for 00 and 11 we just shift
        ldi     (0)&255
        plo     RP1P2
        ldi     ((0)>>8)&255; 
        phi     RP1P2
        ldi     ((0)>>16)&255; 
        plo     RP1P2-1
        ldi     ((0)>>24)&255; 
        phi     RP1P2-1
    ldi 32
    plo memaddr		;cycle count
    adi 0		;clear df
$$mloop:
    glo RL8
    ani 1		;isolate bottom bit of result
    bnf	$$check_sub	;
    bnz	$$shift		;that would be the 11 case
;this is case 01: add second operand to top 32 bits and shift all 64 bits right
        dec     sp ;make a work ares
        glo     RL10    ;long register pairs are addressed by their second member
        str     sp      ;so arithmetic operations start there
        glo     RP1P2
        ADD             ;calculate the low order byte
        plo     RP1P2
        ghi     RL10
        str     sp
        ghi     RP1P2
        ADC             ;calculate the second byte
        phi     RP1P2
        glo     RL10-1
        str     sp
        glo     RP1P2-1
        ADC             ;calculate the third byte
        plo     RP1P2-1
        ghi     RL10-1
        str     sp
        ghi     RP1P2-1
        ADC             ;calculate the high byte
        phi     RP1P2-1
        inc     sp      ;release the work area
    br $$shift
$$check_sub:
    bz $$shift	;that would be the 00 case
;this is case 10: subtract 2nd operand from top 32 bits then shift right
        dec     sp ;make a work ares
        glo     RL10    ;long register pairs are addressed by their second member
        str     sp      ;so arithmetic operations start there
        glo     RP1P2
        SM             ;calculate the low order byte
        plo     RP1P2
        ghi     RL10
        str     sp
        ghi     RP1P2
        SMB             ;calculate the second byte
        phi     RP1P2
        glo     RL10-1
        str     sp
        glo     RP1P2-1
        SMB             ;calculate the third byte
        plo     RP1P2-1
        ghi     RL10-1
        str     sp
        ghi     RP1P2-1
        SMB             ;calculate the high byte
        phi     RP1P2-1
        inc     sp      ;release the work area
$$shift:
        ghi     RP1P2-1   ;long RP1P2 pairs start at RP1P2-1
        shl             ;set DF to the sign
        ghi     RP1P2-1   ;get the top byte back
        shrc            ;shift one bit extending the sign
        phi     RP1P2-1
        glo     RP1P2-1
        shrc
        plo     RP1P2-1
        ghi     RP1P2     ;get the top byte of the low order RP1P2
        shrc            ;shift one bit extending the sign
        phi     RP1P2
        glo     RP1P2     ;finish with the low byte of the 2nd RP1P2 of the pair
        shrc
        plo     RP1P2
        ghi     RL8-1   ;long RL8 pairs start at RL8-1
        shrc            ;shift one bit extending the sign
        phi     RL8-1
        glo     RL8-1
        shrc
        plo     RL8-1
        ghi     RL8     ;get the top byte of the low order RL8
        shrc            ;shift one bit extending the sign
        phi     RL8
        glo     RL8     ;finish with the low byte of the 2nd RL8 of the pair
        shrc
        plo     RL8
    dec memaddr		;cycle count
    glo memaddr
    bnz $$mloop		;repeat cycle once for each bit position
        sret    6
	align 256
;signed integer division RL8=RL8/RL10, remainder in Rp1p2
;uses unsigned division of absolute values then negates the quotient if the signs were originally different
_divI4:
    dec	sp	;leave a work area available
    ghi RL8-1	;get the top of the dividend
    str sp	;save the sign of the 1st arg
    shl
    bnf $$pos1	;if the 1st arg is -v
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        XRI     (0XFFFFFFFF)&255
        plo     RL8
        ghi     RL8
        XRI     ((0XFFFFFFFF)>>8)&255; 
        phi     RL8
        glo     RL8-1
        XRI     ((0XFFFFFFFF)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        XRI     ((0XFFFFFFFF)>>24)&255; 
        phi     RL8-1
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        ADI     (1)&255
        plo     RL8
        ghi     RL8
        ADCI     ((1)>>8)&255; 
        phi     RL8
        glo     RL8-1
        ADCI     ((1)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        ADCI     ((1)>>24)&255; 
        phi     RL8-1
$$pos1: ;1st is now +v, check 2nd
    ghi RL10-1
    xor	
    str sp ;the stack now has bit 8 set if the signs are different
    ghi RL10-1
    shl
    bnf $$pos2	;if the 2nd arg is -v
        glo     RL10    ;long regs are equated to the second reg which has the low order word 
        XRI     (0XFFFFFFFF)&255
        plo     RL10
        ghi     RL10
        XRI     ((0XFFFFFFFF)>>8)&255; 
        phi     RL10
        glo     RL10-1
        XRI     ((0XFFFFFFFF)>>16)&255; 
        plo     RL10-1
        ghi     RL10-1
        XRI     ((0XFFFFFFFF)>>24)&255; 
        phi     RL10-1
        glo     RL10    ;long regs are equated to the second reg which has the low order word 
        ADI     (1)&255
        plo     RL10
        ghi     RL10
        ADCI     ((1)>>8)&255; 
        phi     RL10
        glo     RL10-1
        ADCI     ((1)>>16)&255; 
        plo     RL10-1
        ghi     RL10-1
        ADCI     ((1)>>24)&255; 
        phi     RL10-1
$$pos2: ; both args now +v
    dec sp	;protect workarea on the 1802
                SCAL    6,_DIVU4
    inc sp	;recover work area
;now the quotient is in RL8 and the remainder is in Rp1p2
    lda	sp ;get back the sign bits and restore SP
    shl
    bnf $$done ;if the signs were different
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        XRI     (0XFFFFFFFF)&255
        plo     RL8
        ghi     RL8
        XRI     ((0XFFFFFFFF)>>8)&255; 
        phi     RL8
        glo     RL8-1
        XRI     ((0XFFFFFFFF)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        XRI     ((0XFFFFFFFF)>>24)&255; 
        phi     RL8-1
        glo     RL8    ;long regs are equated to the second reg which has the low order word 
        ADI     (1)&255
        plo     RL8
        ghi     RL8
        ADCI     ((1)>>8)&255; 
        phi     RL8
        glo     RL8-1
        ADCI     ((1)>>16)&255; 
        plo     RL8-1
        ghi     RL8-1
        ADCI     ((1)>>24)&255; 
        phi     RL8-1
$$done:
        sret    6
_dubdabx:	
;experimental binay-ascii conversion using the double-dabble algorithm
;thanks to Charles Richmond for the suggestion and code
;long interger is passed in rp1p2
;buffer pointer is passed at sp+2+4**+1 for 1806
;a pointer to the 1st non-zero byte in the buffer is passed back in r15
;r8-11 are used as temps
;r8 is the working pointer
;r15.0 is bit count(32) and the return value register
;r9.0 is digit count
;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
        glo     SP
        adi     ((2+4+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((2+4+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R8
        ldn     memAddr
        plo     R8
        glo     SP
        adi     ((2+4+2+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((2+4+2+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R10
        ldn     memAddr
        plo     R10
        glo     R8
        plo     R15
        ghi     R8
        phi     R15
	ldi 11	;digit count+1 for trailing 0
	plo r9
$$clrlp:	;clear the passed buffer
	ldi 0	
	str r8	;clear a byte
	inc r8
	dec r9
	glo r9	;check the count
	bnz $$clrlp ;back for more
        glo     R15
        plo     R8
        ghi     R15
        phi     R8
	ldi 32	;bit count
	plo r15
;now i'm going to spin off any leading 0's in the binary number
$$cktop:
	ghi rp1p2-1	;get the top bit of the number
	shl		;check for a 1
	bdf $$bitloop	;move on if we have one
        glo     RP1P2     ;start with low byte of second register
        shl             ;shift left once
        plo     RP1P2     ; save it
        ghi     RP1P2     ;high byte of second RP1P2
        shlc            ;shift one bit carrying
        phi     RP1P2     ;save it
        glo     RP1P2-1   ;now the bottom byte of top RP1P2
        shlc
        plo     RP1P2-1
        ghi     RP1P2-1   ;finally the top byte of the high order RP1P2
        shlc            ;gets the last shift
        phi     RP1P2-1   ;and we're done
	dec r15		;reduce the number of times to shift
	glo r15
	bnz $$cktop	;
	inc r15		;our whole number was 0 but force at least one pass
$$bitloop:
	ldi 10	;digit count
	plo r9
$$dcklp:
	ldn r8 	;pick up a digit
	smi 5	;see if it's greater than 4
	bnf $$dnoadd ;if not, bypass add
	adi 0x08	;add the 5 black and 3 more
	str r8	;put it back
$$dnoadd:
	inc r8
	dec r9	;decrement digit count
	glo r9
	bnz $$dcklp ;and back for next digit
        glo     RP1P2     ;start with low byte of second register
        shl             ;shift left once
        plo     RP1P2     ; save it
        ghi     RP1P2     ;high byte of second RP1P2
        shlc            ;shift one bit carrying
        phi     RP1P2     ;save it
        glo     RP1P2-1   ;now the bottom byte of top RP1P2
        shlc
        plo     RP1P2-1
        ghi     RP1P2-1   ;finally the top byte of the high order RP1P2
        shlc            ;gets the last shift
        phi     RP1P2-1   ;and we're done
	ldi 10	;load the digit count again
	plo r9
;r8 is now just past the units location and ready to walk back
$$dshlp:
	dec r8	;walk back from 0's position
	ldn r8	;get the digit back
	shlc	;continue the shift
	phi r15 ;save it for the carry test
	ani 0x0f ;clear the 10 bit
	str r8	;put the digit back
	ghi r15	;now test for carry
	smi 0x10 ; this will make df 1 if the 10 bit is set
	dec r9	;decrement the digit count
	glo r9
	bnz $$dshlp ;back for more if needed
	dec r15
	glo r15
	bnz $$bitloop
        glo     R8
        plo     R15
        ghi     R8
        phi     R15
	ldi 10		;digit count again
	plo r9
$$upnxt:
	ldn r8		;get digit
	ori 0x30	;make ascii
	str r8		;put it back
	inc r8		;next digit
	dec r9		;counter
	glo r9
	bnz $$upnxt	;upgrade all 10 spots
        glo     SP
        adi     ((2+4+2+1+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((2+4+2+1+1))>>8; was/256
        phi     MEMADDR
	sex memaddr	;set up
	ldi 10		;max number of 0's to skip
	sm		;desired number of digits to skip
	sex sp		;reset index register
	plo r9		;number of leading 0's to skip
$$cknext:
	ldn r15		;check digit
	smi 0x30	;for '0'
	bnz $$done
	inc r15		;next digit
	dec r9		;reduce count
	glo r9
	bnz $$cknext
$$done:
        sret    6
_modU4:	;32 bit unsigned remainder
	; just calls the 32 bit division then puts remainder into return value
                SCAL    6,_DIVU4
        glo     RP1P2
        plo     RL8
        ghi     RP1P2
        phi     RL8
        glo     RP1P2-1
        plo     RL8-1
        ghi     RP1P2-1
        phi     RL8-1
        sret    6
_modI4:	;32 bit signed remainder
	; just calls the 32 bit division then puts remainder into return value
                SCAL    6,_DIVI4
        glo     RP1P2
        plo     RL8
        ghi     RP1P2
        phi     RL8
        glo     RP1P2-1
        plo     RL8-1
        ghi     RP1P2-1
        phi     RL8-1
        sret    6
;IO1802.inc contains input/output runtime routines for LCC1802
;The port is in regArg1, the output byte is in regArg2
;17-10-16 adding _putcpace(port,byte) to limit output speed to the AVR
;         defaulting putc(x) to putcpace(7,x)
;17-11-22 removing putc altogether
_inp:		;raw port input
		;stores a small tailored program on the stack and executes it
	dec	sp	;work backwards
	ldi	0xD3	;return instruction
	stxd		
	glo	regarg1	;get the port number
	ani	0x07	;clean it
	bz	+	; inp(0) isn't valid
	ori	0x68	;make it an input instruction
	stxd		;store it for execution
        glo     SP
        plo     RT1
        ghi     SP
        phi     RT1
	inc	rt1	;rt1 points to the 6x instruction
	sep	rt1	;execute it
;we will come back to here with the input byte in D
	inc	sp	;step over the work area
	plo	retVal	;save it to return
	ldi	0
	phi	retval	;clear top byte
+	inc	sp	;need to get rid of the 6x instruction
	inc	sp	;and the D3
        sret    6
_out:		;raw port output
		;stores a small tailored program on the stack and executes it
		;this could be bolder:
		;store the program as 6x cc D5 where x is the port number and cc is the char
		;then SEP sp
		;the D5 would return to the calling program and finish fixing the stack.
		;saves 6 instructions but it's a bit tricky.
	dec	sp	;work backwards
	ldi	0xD3	;return instruction
	stxd		
        glo     SP
        plo     RT1
        ghi     SP
        phi     RT1
	glo	regarg1	;get the port number
	ani	0x07	;clean it
	ori	0x60	;make it an out instruction - 60 is harmless
	stxd		;store it for execution
	glo	regarg2	;get the byte to be written
	str	sp	;store it where sp points
	sep	rt1	;execute it
;we will come back to here with sp stepped up by one
+	inc	sp	;need to get rid of the 6x instruction
	inc	sp	;and the D3
        sret    6
