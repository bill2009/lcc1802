 AS V1.42 Beta [Bld 123] - source file segtest.asm - page 1 - 1/24/2018 15:06:07


       1/       0 :                     ; generated by lcc-xr18DH $Version: 5.0 - XR18DH $ on Wed Jan 24 15:06:02 2018
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1) 1025/       0 :                     	listing	on
(1) 1026/       0 : C0 00 29            	lbr	lcc1802Init
(1) 1027/       3 :                     	
(1) 1028/       3 :                     
      11/       3 :                     	listing on
      12/       3 :                     _test:
      13/       3 : 0F                  	db 15
      14/       4 : 0F                  	db 15
      15/       5 : 0F                  	db 15
      16/       6 : 0F                  	db 15
      17/       7 : 05                  	db 5
      18/       8 : 00                  	db 0
      19/       9 : 08                  	db 8
      20/       A : 01                  	db 1
      21/       B :                     _main: ;copt is peeping your size 2 frame with oct 23 rules
      22/       B :                     ;{
      23/       B :                     ;	asm(" req\n seq\n"
      24/       B : 7A                   req
      25/       C : 7B                   seq
      26/       D : E3                   sex 3
      27/       E : 67                   out 7
      28/       F : D0                   db 0b11010000
      29/      10 : 7A                   req
      30/      11 : (MACRO)              ldad r11,_test
      31/      17 : (MACRO)              ldad r10,8
      32/      1D : EB                   sex 11
      33/      1E : 67                   out 7
      34/      1F : 67                   out 7
      35/      20 : 67                   out 7
      36/      21 : 67                   out 7
      37/      22 : 67                   out 7
      38/      23 : 67                   out 7
      39/      24 : 67                   out 7
      40/      25 : 67                   out 7
      41/      26 : 30 26                br $
      42/      28 :                     ;}
      43/      28 :                     L1:
      44/      28 : (MACRO)             	Cretn
      45/      29 :                     
      46/      29 :                     	include lcc1802epiloDH.inc
(1)    1/      29 :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/      29 :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/      29 :                     ;this is the version published with the lcc1802121229 release
(1)    4/      29 :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/      29 :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/      29 :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/      29 :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/      29 :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/      29 :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/      29 :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/      29 :                     ;feb 27 changed stack to start at 7fff
(1)   12/      29 :                     ;mar 3, 2013 saved as epiloNO for optimization round
 AS V1.42 Beta [Bld 123] - source file segtest.asm(lcc1802epiloDH.inc) - page 2 - 1/24/2018 15:06:07


(1)   13/      29 :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/      29 :                     ;april 4 adding digit count argument to dubdabx
(1)   15/      29 :                     ;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
(1)   16/      29 :                     ;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
(1)   17/      29 :                     ;16-09-20 allow stack relocation 
(1)   18/      29 :                     ;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
(1)   19/      29 :                     ;17-10-17 allow for cpu speed >8MHz in ms calculation!
(1)   20/      29 : =EH                 rwork	equ	memAddr	;work register
(1)   21/      29 :                     lcc1802init:	
(1)   22/      29 : (MACRO)             	ldiReg	RCALL,_call
(1)   23/      2F : (MACRO)             	ldiReg	RRET,_return
(1)   24/      35 : =>UNDEFINED           IFNDEF  LCCSTACKLOC		;wjr 16-09-20 allow stack relocation
(1)   25/      35 : (MACRO)             	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1 as default
(1)   26/      3B : =>FALSE               ELSEIF				;wjr 16-09-20
(1)   27/      3B :                     	ldiReg	SP,LCCSTACKLOC	;wjr 16-09-20 start stack as specified
(1)   28/      3B : [24]                  ENDIF				;wjr 16-09-20
(1)   29/      3B : E2                  	sex	SP
(1)   30/      3C : (MACRO)             	ldiReg	RPC,$$_00000
(1)   31/      42 : D3                  	sep	RPC
(1)   32/      43 :                     $$_00000:
(1)   33/      43 : (MACRO)             	Ccall _main	;call the main routine
(1)   34/      46 : C0 00 46            $$_die:	lbr	$$_die		;loop here when main returns
(1)   35/      49 : DE AD               	db	0xde,0xad
(1)   36/      4B :                     
(1)   37/      4B :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   38/      4B :                     _setqOn:
(1)   39/      4B : 7B                  	seq
(1)   40/      4C : (MACRO)             	Cretn
(1)   41/      4D :                     _setqOff:
(1)   42/      4D : 7A                  	req
(1)   43/      4E : (MACRO)             	Cretn
(1)   44/      4F :                     
(1)   45/      4F :                     _modU2:	;16 bit unsigned remainder
(1)   46/      4F :                     	; just calls the 16 bit division then puts remainder into return value
(1)   47/      4F : (MACRO)                 Ccall _divU2
(1)   48/      52 : 8C                      glo regArg1
(1)   49/      53 : AF                      plo retVal
(1)   50/      54 : 9C                      ghi regArg1
(1)   51/      55 : BF                      phi retVal
(1)   52/      56 : (MACRO)                 Cretn
(1)   53/      57 :                         
(1)   54/      57 :                     _modI2:	;16 bit signed remainder
(1)   55/      57 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   56/      57 : (MACRO)                 Ccall _divI2
(1)   57/      5A : 8C                      glo regArg1
(1)   58/      5B : AF                      plo retVal
(1)   59/      5C : 9C                      ghi regArg1
(1)   60/      5D : BF                      phi retVal
(1)   61/      5E : (MACRO)                 Cretn
(1)   62/      5F :                     
(1)   63/      5F :                     _out4:	
(1)   64/      5F : 8C                  	glo	regArg1
(1)   65/      60 : 22                  	dec	sp
(1)   66/      61 : 52                  	str	sp
(1)   67/      62 : 64                  	out	4
(1)   68/      63 : (MACRO)             	Cretn
(1)   69/      64 :                     
(1)   70/      64 :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   71/      64 :                     	align 256
(1)   72/     100 :                     ;non-standard Call routine invoked as D4xxxx - using z80 stack convention
 AS V1.42 Beta [Bld 123] - source file segtest.asm(lcc1802epiloDH.inc) - page 3 - 1/24/2018 15:06:07


(1)   73/     100 :                     ;requires programs to save the return address if they destroy it (by using call for example)
(1)   74/     100 :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)   75/     100 : D3                  	sep     R3 ;go to subroutine
(1)   76/     101 : E2                  _call	sex	SP ;make sure X=SP
(1)   77/     102 : 86                  	glo	retAddr ;save previous return pointer on stack
(1)   78/     103 : 22                  	dec	sp
(1)   79/     104 : 73                  	stxd
(1)   80/     105 : 96                  	ghi	retAddr
(1)   81/     106 : 52                  	str	sp	
(1)   82/     107 : 83                  	glo	RPC ;copy old PC to retAddr
(1)   83/     108 : A6                  	plo	retAddr
(1)   84/     109 : 93                  	ghi	RPC
(1)   85/     10A : B6                  	phi	retAddr
(1)   86/     10B : 46                  	lda	retAddr ;pick up subroutine address into RPC
(1)   87/     10C : B3                  	phi	RPC
(1)   88/     10D : 46                  	lda	retAddr
(1)   89/     10E : A3                  	plo	RPC
(1)   90/     10F : 30 00               	br	_call-1
(1)   91/     111 :                     
(1)   92/     111 :                     ;Standard subroutine return 
(1)   93/     111 : D3                  	sep	RPC	;return to the original program
(1)   94/     112 : 86                  _return	glo	retAddr	;transfer the current return address to RPC
(1)   95/     113 : A3                  	plo	RPC
(1)   96/     114 : 96                  	ghi	retAddr
(1)   97/     115 : B3                  	phi	RPC
(1)   98/     116 : 42                  	lda	SP	;pick up old return address
(1)   99/     117 : B6                  	phi	retAddr
(1)  100/     118 : 42                  	lda	SP
(1)  101/     119 : A6                  	plo	retAddr
(1)  102/     11A : 30 11               	br	_return-1
(1)  103/     11C :                     
(1)  104/     11C :                     _oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
(1)  105/     11C :                     ;subroutine overhead soaks up 27 instruction time.
(1)  106/     11C :                     ;each loop is 2 instruction times
(1)  107/     11C :                     ;so the number of loops needed is 
(1)  108/     11C :                     ;CPU speed/16000 less the 27 all divide by two
(1)  109/     11C : =>UNDEFINED           IFNDEF LCC1802CPUSPEED
(1)  110/     11C : =186A00H            LCC1802CPUSPEED EQU 1600000	;1.6MHZ default
(1)  111/     11C : [109]                 ENDIF
(1)  112/     11C :                       
(1)  113/     11C : =>TRUE                IF LCC1802CPUSPEED<=8000000
(1)  114/     11C : F8 24               	ldi	(LCC1802CPUSPEED/1000/16-15-10-2)/2
(1)  115/     11E : FF 01               $$mslp:	smi	1
(1)  116/     120 : 3A 1E               	bnz	$$mslp
(1)  117/     122 : =>FALSE               ELSE
(1)  118/     122 :                     	ldi	(LCC1802CPUSPEED/1000/16-15-10-2)/4
(1)  119/     122 :                     $$mslf:	smi	1
(1)  120/     122 :                     	sex	2
(1)  121/     122 :                     	sex	2
(1)  122/     122 :                     	bnz	$$mslf
(1)  123/     122 : [113]                 ENDIF
(1)  124/     122 : (MACRO)             	Cretn
(1)  125/     123 :                     
(1)  126/     123 :                     
(1)  127/     123 :                     	
(1)  128/     123 :                     ;16 bit right shifting multiply which is faster for smaller operands
(1)  129/     123 :                     ; credit to http://map.grauw.nl/articles/mult_div_shifts.php#lrmultr
(1)  130/     123 :                     _mulU2:		;retval(product)=regarg1(multiplicand)*regarg2(multiplier)
(1)  131/     123 : (MACRO)             	ld2z retval
(1)  132/     127 :                     $$mulrlp:
 AS V1.42 Beta [Bld 123] - source file segtest.asm(lcc1802epiloDH.inc) - page 4 - 1/24/2018 15:06:07


(1)  133/     127 : (MACRO)             	shru2 regarg2
(1)  134/     12D : 3B 3B               	bnf $$mulrnoadd
(1)  135/     12F :                     ;	bottom bit of multiplier is one so add multiplicand to product
(1)  136/     12F : (MACRO)             	alu2 retval,retval,regarg1,add,adc
(1)  137/     13B :                     $$mulrnoadd:
(1)  138/     13B : 9D                  	ghi regarg2	;check for all bits of multiplier shifted out
(1)  139/     13C : 3A 41               	bnz $$mulrshft	;nope, continue
(1)  140/     13E : 8D                  	glo regarg2	;check bottom byte
(1)  141/     13F : 32 49               	bz $$mulrdone
(1)  142/     141 :                     $$mulrshft:
(1)  143/     141 : (MACRO)             	shl2 regarg1	;shift multiplicand left 1
(1)  144/     147 : 30 27               	br $$mulrlp
(1)  145/     149 :                     $$mulrdone:		;here the product is in retval
(1)  146/     149 : (MACRO)             	cretn
(1)  147/     14A :                     
(1)  148/     14A :                     ;this is a divisor shifting algorithm which is faster for smaller operands
(1)  149/     14A :                     ;credit to http://research.microsoft.com/pubs/70645/tr-2008-141.pdf
(1)  150/     14A :                     ;changed oct 12 to save R10 & 1/2 R11 on stack
(1)  151/     14A :                     _divu2: ;retval=regarg1(x or dividend)/regarg2(y or divisor)
(1)  152/     14A :                     	;uses R14(rwork) to hold original divisor y0, 
(1)  153/     14A :                     	;regarg1 to hold develop remainder, 
(1)  154/     14A :                     	;R10 to hold working dividend R11.0 as a temp
(1)  155/     14A :                     testsub: macro reg1,reg2	;test subtraction of reg2 from reg1
(1)  156/     14A :                     				;result in D, rwork.hi, DF
(1)  157/     14A :                     	glo reg2
(1)  158/     14A :                     	str sp
(1)  159/     14A :                     	glo reg1
(1)  160/     14A :                     	sm
(1)  161/     14A :                     	plo R11
(1)  162/     14A :                     	ghi reg2
(1)  163/     14A :                     	str sp
(1)  164/     14A :                     	ghi reg1
(1)  165/     14A :                     	smb
(1)  166/     14A :                     	endm
(1)  167/     14A :                     	
(1)  168/     14A : (MACRO)             	pushf R10	;save R10 & leave stack down 1
(1)  169/     14F : 8B                  	glo R11		;and bottom
(1)  170/     150 : 73                  	stxd		;of R11 - leaves stack clear of work area
(1)  171/     151 : (MACRO)             	cpy2 R10,regarg1
(1)  172/     155 : (MACRO)             	ld2z retval	;quotient
(1)  173/     159 : (MACRO)             	cpy2 rwork,regarg2
(1)  174/     15D :                     	
(1)  175/     15D : (MACRO)             	testsub R10,regarg2
(1)  176/     166 : 3B 81               	bnf $$computequot	;DF=0 means it didn't fit
(1)  177/     168 : BA                  	phi R10	;R10=R10-regarg2
(1)  178/     169 : 8B                  	glo R11
(1)  179/     16A : AA                  	plo R10
(1)  180/     16B :                     	
(1)  181/     16B :                     $$again:	;this is the divisor doubling phase
(1)  182/     16B : (MACRO)              	testsub R10,regarg2
(1)  183/     174 : 3B 81                	bnf $$computequot	;df=0 means it didn't fit
(1)  184/     176 : BA                  	phi R10	;R10=R10-regarg2
(1)  185/     177 : 8B                  	glo R11
(1)  186/     178 : AA                  	plo R10 	
(1)  187/     179 : (MACRO)              	shl2 regarg2	;y=y+y
(1)  188/     17F : 30 6B                	br $$again
(1)  189/     181 :                      	
(1)  190/     181 :                      $$computequot:	;here we're computing the quotient
(1)  191/     181 : (MACRO)              	testsub regarg1,regarg2
(1)  192/     18A : 3B 90                	bnf $$testexit
 AS V1.42 Beta [Bld 123] - source file segtest.asm(lcc1802epiloDH.inc) - page 5 - 1/24/2018 15:06:07


(1)  193/     18C : BC                   	phi regarg1		;complete the subtraction
(1)  194/     18D : 8B                   	glo R11
(1)  195/     18E : AC                   	plo regarg1
(1)  196/     18F : 1F                   	inc retval
(1)  197/     190 :                      $$testexit:
(1)  198/     190 : 9E                   	ghi rwork
(1)  199/     191 : F7                   	sm	;top of regarg2 is still on stack
(1)  200/     192 : 3A 9A                	bnz $$ney0y
(1)  201/     194 : 8D                   	glo regarg2
(1)  202/     195 : 52                   	str sp
(1)  203/     196 : 8E                   	glo rwork
(1)  204/     197 : F7                   	sm	;test low order bytes
(1)  205/     198 : 32 A8                	bz	$$out	;if = we're done
(1)  206/     19A :                      $$ney0y:
(1)  207/     19A : (MACRO)              	shl2 retval	;double quotient
(1)  208/     1A0 : (MACRO)              	shrU2 regarg2	;halve divisor
(1)  209/     1A6 : 30 81                	br $$computequot	;continue
(1)  210/     1A8 :                      $$out:
(1)  211/     1A8 :                      ;here the quotient is in retval, remainder in regarg1
(1)  212/     1A8 : 12                    	inc sp	;release work area
(1)  213/     1A9 : 42                  	lda sp	;recover
(1)  214/     1AA : AB                  	plo R11	;bottom byte of R11
(1)  215/     1AB : (MACRO)             	popr R10 ;and all of R10
(1)  216/     1AF : (MACRO)             	cretn	;and we're done
(1)  217/     1B0 :                     
(1)  218/     1B0 :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  219/     1B0 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  220/     1B0 :                     _divI2:
(1)  221/     1B0 :                         ;pushr retAddr	;save the return address NG doesnot need
(1)  222/     1B0 : 22                      dec	sp	;leave a work area available
(1)  223/     1B1 : 9C                      ghi regArg1
(1)  224/     1B2 : 52                      str sp	;save the sign of the 1st arg
(1)  225/     1B3 : FE                      shl
(1)  226/     1B4 : 3B BF                   bnf $$pos1	;if the 1st arg is -v
(1)  227/     1B6 : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
(1)  228/     1BF :                     $$pos1: ;1st is now +v, check 2nd
(1)  229/     1BF : 9D                      ghi regArg2
(1)  230/     1C0 : F3                      xor	
(1)  231/     1C1 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  232/     1C2 : 9D                      ghi regArg2
(1)  233/     1C3 : FE                      shl
(1)  234/     1C4 : 3B CF                   bnf $$pos2	;if the 2nd arg is -v
(1)  235/     1C6 : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  236/     1CF :                     $$pos2: ; both args now +v
(1)  237/     1CF : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  238/     1D2 :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  239/     1D2 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  240/     1D3 : FE                      shl
(1)  241/     1D4 : 3B DF                   bnf $$done ;if the signs were different
(1)  242/     1D6 : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  243/     1DF :                     $$done:
(1)  244/     1DF :                         ;popr RetAddr ;restore the return address NG doesnot need
(1)  245/     1DF : (MACRO)                 Cretn ;and we're done - I hope!
(1)  246/     1E0 :                     
(1)  247/     1E0 :                     
(1)  248/     1E0 :                     	align 256    ;32 bit operations follow
(1)  249/     200 :                     _divu4:
(1)  250/     200 :                     ;This is an unsigned 32 bit restoring division
(1)  251/     200 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  252/     200 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
 AS V1.42 Beta [Bld 123] - source file segtest.asm(lcc1802epiloDH.inc) - page 6 - 1/24/2018 15:06:07


(1)  253/     200 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  254/     200 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  255/     200 :                     
(1)  256/     200 : F8 20               	ldi 32		;set loop count
(1)  257/     202 : AE                  	plo memaddr	;in temp register
(1)  258/     203 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  259/     20F :                     $$loop:
(1)  260/     20F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  261/     21B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  262/     227 :                     
(1)  263/     227 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  264/     23D :                     
(1)  265/     23D : FA 80               	ani 0x80	;check the top bit
(1)  266/     23F : 32 5D               	bz $$norestore	;if it's 0
(1)  267/     241 : 89                  		glo RL8
(1)  268/     242 : FA FE               		ani 0xfe	;turn off the bottom bit
(1)  269/     244 : A9                  		plo RL8
(1)  270/     245 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  271/     25B : 30 61               	br $$endlp 	;else
(1)  272/     25D :                     $$norestore:
(1)  273/     25D : 89                  		glo RL8
(1)  274/     25E : F9 01               		ori 1	;turn on the bottom bit
(1)  275/     260 : A9                  		plo RL8
(1)  276/     261 :                     	;end if
(1)  277/     261 :                     $$endlp:
(1)  278/     261 : 2E                  	dec memaddr	;check the cycle count
(1)  279/     262 : 8E                  	glo memaddr
(1)  280/     263 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  281/     265 :                     	
(1)  282/     265 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  283/     266 :                     		
(1)  284/     266 :                     
(1)  285/     266 :                     _mulu4:
(1)  286/     266 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  287/     266 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  288/     266 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  289/     266 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  290/     266 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  291/     266 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  292/     266 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  293/     266 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  294/     266 :                     	;for 10 we subtract and shift
(1)  295/     266 :                     	;for 00 and 11 we just shift
(1)  296/     266 :                     
(1)  297/     266 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  298/     272 : F8 20                   ldi 32
(1)  299/     274 : AE                      plo memaddr		;cycle count
(1)  300/     275 : FC 00                   adi 0		;clear df
(1)  301/     277 :                     $$mloop:
(1)  302/     277 : 89                      glo RL8
(1)  303/     278 : FA 01                   ani 1		;isolate bottom bit of result
(1)  304/     27A : 3B 96                   bnf	$$check_sub	;
(1)  305/     27C : 3A AE                   bnz	$$shift		;that would be the 11 case
(1)  306/     27E :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  307/     27E : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  308/     294 : 30 AE                   br $$shift
(1)  309/     296 :                     $$check_sub:
(1)  310/     296 : 32 AE                   bz $$shift	;that would be the 00 case
(1)  311/     298 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  312/     298 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
 AS V1.42 Beta [Bld 123] - source file segtest.asm(lcc1802epiloDH.inc) - page 7 - 1/24/2018 15:06:07


(1)  313/     2AE :                     $$shift:
(1)  314/     2AE : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  315/     2BC : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  316/     2C8 :                     
(1)  317/     2C8 : 2E                      dec memaddr		;cycle count
(1)  318/     2C9 : 8E                      glo memaddr
(1)  319/     2CA : 3A 77                   bnz $$mloop		;repeat cycle once for each bit position
(1)  320/     2CC :                         
(1)  321/     2CC : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  322/     2CD :                     
(1)  323/     2CD :                     	align 256
(1)  324/     300 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  325/     300 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  326/     300 :                     _divI4:
(1)  327/     300 : 22                      dec	sp	;leave a work area available
(1)  328/     301 : 98                      ghi RL8-1	;get the top of the dividend
(1)  329/     302 : 52                      str sp	;save the sign of the 1st arg
(1)  330/     303 : FE                      shl
(1)  331/     304 : 3B 26                   bnf $$pos1	;if the 1st arg is -v
(1)  332/     306 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  333/     326 :                     $$pos1: ;1st is now +v, check 2nd
(1)  334/     326 : 9A                      ghi RL10-1
(1)  335/     327 : F3                      xor	
(1)  336/     328 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  337/     329 : 9A                      ghi RL10-1
(1)  338/     32A : FE                      shl
(1)  339/     32B : 3B 4D                   bnf $$pos2	;if the 2nd arg is -v
(1)  340/     32D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  341/     34D :                     $$pos2: ; both args now +v
(1)  342/     34D : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  343/     350 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  344/     350 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  345/     351 : FE                      shl
(1)  346/     352 : 3B 74                   bnf $$done ;if the signs were different
(1)  347/     354 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  348/     374 :                     $$done:
(1)  349/     374 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  350/     375 :                     
(1)  351/     375 :                     _dubdabx:	
(1)  352/     375 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  353/     375 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  354/     375 :                     ;long interger is passed in rp1p2
(1)  355/     375 :                     ;buffer pointer is passed at sp+2+4
(1)  356/     375 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
(1)  357/     375 :                     ;r8-11 are used as temps
(1)  358/     375 :                     ;r8 is the working pointer
(1)  359/     375 :                     ;r15.0 is bit count(32) and the return value register
(1)  360/     375 :                     ;r9.0 is digit count
(1)  361/     375 :                     ;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
(1)  362/     375 : (MACRO)             	ld2 r8,'O',sp,(2+4); pick up the buffer pointer
(1)  363/     381 : (MACRO)             	ld2 r10,'O',sp,(2+4+2); pick up the number of digits wanted
(1)  364/     38D : (MACRO)             	cpy2 r15,r8 ;save address for now
(1)  365/     391 : F8 0B               	ldi 11	;digit count+1 for trailing 0
(1)  366/     393 : A9                  	plo r9
(1)  367/     394 :                     $$clrlp:	;clear the passed buffer
(1)  368/     394 : F8 00               	ldi 0	
(1)  369/     396 : 58                  	str r8	;clear a byte
(1)  370/     397 : 18                  	inc r8
(1)  371/     398 : 29                  	dec r9
(1)  372/     399 : 89                  	glo r9	;check the count
 AS V1.42 Beta [Bld 123] - source file segtest.asm(lcc1802epiloDH.inc) - page 8 - 1/24/2018 15:06:07


(1)  373/     39A : 3A 94               	bnz $$clrlp ;back for more
(1)  374/     39C : (MACRO)             	cpy2 r8,r15 ;get the address back
(1)  375/     3A0 :                     
(1)  376/     3A0 : F8 20               	ldi 32	;bit count
(1)  377/     3A2 : AF                  	plo r15
(1)  378/     3A3 :                     ;now i'm going to spin off any leading 0's in the binary number
(1)  379/     3A3 :                     $$cktop:
(1)  380/     3A3 : 9C                  	ghi rp1p2-1	;get the top bit of the number
(1)  381/     3A4 : FE                  	shl		;check for a 1
(1)  382/     3A5 : 33 B8               	bdf $$bitloop	;move on if we have one
(1)  383/     3A7 : (MACRO)             	shl4 rp1p2	;shift the input number
(1)  384/     3B3 : 2F                  	dec r15		;reduce the number of times to shift
(1)  385/     3B4 : 8F                  	glo r15
(1)  386/     3B5 : 3A A3               	bnz $$cktop	;
(1)  387/     3B7 : 1F                  	inc r15		;our whole number was 0 but force at least one pass
(1)  388/     3B8 :                     $$bitloop:
(1)  389/     3B8 : F8 0A               	ldi 10	;digit count
(1)  390/     3BA : A9                  	plo r9
(1)  391/     3BB :                     $$dcklp:
(1)  392/     3BB : 08                  	ldn r8 	;pick up a digit
(1)  393/     3BC : FF 05               	smi 5	;see if it's greater than 4
(1)  394/     3BE : 3B C3               	bnf $$dnoadd ;if not, bypass add
(1)  395/     3C0 : FC 08               	adi 0x08	;add the 5 black and 3 more
(1)  396/     3C2 : 58                  	str r8	;put it back
(1)  397/     3C3 :                     $$dnoadd:
(1)  398/     3C3 : 18                  	inc r8
(1)  399/     3C4 : 29                  	dec r9	;decrement digit count
(1)  400/     3C5 : 89                  	glo r9
(1)  401/     3C6 : 3A BB               	bnz $$dcklp ;and back for next digit
(1)  402/     3C8 :                     	
(1)  403/     3C8 : (MACRO)             	shl4 rp1p2 ;shift the input number
(1)  404/     3D4 :                     	
(1)  405/     3D4 : F8 0A               	ldi 10	;load the digit count again
(1)  406/     3D6 : A9                  	plo r9
(1)  407/     3D7 :                     ;r8 is now just past the units location and ready to walk back
(1)  408/     3D7 :                     $$dshlp:
(1)  409/     3D7 : 28                  	dec r8	;walk back from 0's position
(1)  410/     3D8 : 08                  	ldn r8	;get the digit back
(1)  411/     3D9 : 7E                  	shlc	;continue the shift
(1)  412/     3DA : BF                  	phi r15 ;save it for the carry test
(1)  413/     3DB : FA 0F               	ani 0x0f ;clear the 10 bit
(1)  414/     3DD : 58                  	str r8	;put the digit back
(1)  415/     3DE : 9F                  	ghi r15	;now test for carry
(1)  416/     3DF : FF 10               	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  417/     3E1 : 29                  	dec r9	;decrement the digit count
(1)  418/     3E2 : 89                  	glo r9
(1)  419/     3E3 : 3A D7               	bnz $$dshlp ;back for more if needed
(1)  420/     3E5 :                     	
(1)  421/     3E5 : 2F                  	dec r15
(1)  422/     3E6 : 8F                  	glo r15
(1)  423/     3E7 : 3A B8               	bnz $$bitloop
(1)  424/     3E9 :                     	
(1)  425/     3E9 : (MACRO)             	cpy2 r15,r8	;save the starting location of the digits
(1)  426/     3ED : F8 0A               	ldi 10		;digit count again
(1)  427/     3EF : A9                  	plo r9
(1)  428/     3F0 :                     $$upnxt:
(1)  429/     3F0 : 08                  	ldn r8		;get digit
(1)  430/     3F1 : F9 30               	ori 0x30	;make ascii
(1)  431/     3F3 : 58                  	str r8		;put it back
(1)  432/     3F4 : 18                  	inc r8		;next digit
 AS V1.42 Beta [Bld 123] - source file segtest.asm(lcc1802epiloDH.inc) - page 9 - 1/24/2018 15:06:07


(1)  433/     3F5 : 29                  	dec r9		;counter
(1)  434/     3F6 : 89                  	glo r9
(1)  435/     3F7 : 3A F0               	bnz $$upnxt	;upgrade all 10 spots
(1)  436/     3F9 :                     	
(1)  437/     3F9 : (MACRO)             	ldaX memaddr,sp,(2+4+2+1)	;point to lsb of desired digit count
(1)  438/     401 : EE                  	sex memaddr	;set up
(1)  439/     402 : F8 0A               	ldi 10		;max number of 0's to skip
(1)  440/     404 : F7                  	sm		;desired number of digits to skip
(1)  441/     405 : E2                  	sex sp		;reset index register
(1)  442/     406 : A9                  	plo r9		;number of leading 0's to skip
(1)  443/     407 :                     $$cknext:
(1)  444/     407 : 0F                  	ldn r15		;check digit
(1)  445/     408 : FF 30               	smi 0x30	;for '0'
(1)  446/     40A : 3A 11               	bnz $$done
(1)  447/     40C : 1F                  	inc r15		;next digit
(1)  448/     40D : 29                  	dec r9		;reduce count
(1)  449/     40E : 89                  	glo r9
(1)  450/     40F : 3A 07               	bnz $$cknext
(1)  451/     411 :                     $$done:
(1)  452/     411 : (MACRO)             	cretn
(1)  453/     412 :                     	
(1)  454/     412 :                     	
(1)  455/     412 :                     _modU4:	;32 bit unsigned remainder
(1)  456/     412 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  457/     412 : (MACRO)                 Ccall _divU4
(1)  458/     415 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  459/     41D : (MACRO)                 Cretn
(1)  460/     41E :                         
(1)  461/     41E :                     _modI4:	;32 bit signed remainder
(1)  462/     41E :                     	; just calls the 32 bit division then puts remainder into return value
(1)  463/     41E : (MACRO)                 Ccall _divI4
(1)  464/     421 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  465/     429 : (MACRO)                 Cretn
(1)  466/     42A :                     	
(1)  467/     42A :                     
      47/     42A :                     	include IO1802.inc
(1)    1/     42A :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/     42A :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/     42A :                     ;17-10-16 adding _putcpace(port,byte) to limit output speed to the AVR
(1)    4/     42A :                     ;         defaulting putc(x) to putcpace(7,x)
(1)    5/     42A :                     ;17-11-22 removing putc altogether
(1)    6/     42A :                     
(1)    7/     42A :                     _inp:		;raw port input
(1)    8/     42A :                     		;stores a small tailored program on the stack and executes it
(1)    9/     42A : 22                  	dec	sp	;work backwards
(1)   10/     42B : F8 D3               	ldi	0xD3	;return instruction
(1)   11/     42D : 73                  	stxd		
(1)   12/     42E : 8C                  	glo	regarg1	;get the port number
(1)   13/     42F : FA 07               	ani	0x07	;clean it
(1)   14/     431 : 32 41               	bz	+	; inp(0) isn't valid
(1)   15/     433 : F9 68               	ori	0x68	;make it an input instruction
(1)   16/     435 : 73                  	stxd		;store it for execution
(1)   17/     436 : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   18/     43A : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   19/     43B : D8                  	sep	rt1	;execute it
(1)   20/     43C :                     ;we will come back to here with the input byte in D
(1)   21/     43C : 12                  	inc	sp	;step over the work area
(1)   22/     43D : AF                  	plo	retVal	;save it to return
(1)   23/     43E : F8 00               	ldi	0
(1)   24/     440 : BF                  	phi	retval	;clear top byte
 AS V1.42 Beta [Bld 123] - source file segtest.asm(IO1802.inc) - page 10 - 1/24/2018 15:06:07


(1)   25/     441 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   26/     442 : 12                  	inc	sp	;and the D3
(1)   27/     443 : (MACRO)             	Cretn		;and we're done
(1)   28/     444 :                     	
(1)   29/     444 :                     _out:		;raw port output
(1)   30/     444 :                     		;stores a small tailored program on the stack and executes it
(1)   31/     444 :                     		;this could be bolder:
(1)   32/     444 :                     		;store the program as 6x cc D5 where x is the port number and cc is the char
(1)   33/     444 :                     		;then SEP sp
(1)   34/     444 :                     		;the D5 would return to the calling program and finish fixing the stack.
(1)   35/     444 :                     		;saves 6 instructions but it's a bit tricky.
(1)   36/     444 : 22                  	dec	sp	;work backwards
(1)   37/     445 : F8 D3               	ldi	0xD3	;return instruction
(1)   38/     447 : 73                  	stxd		
(1)   39/     448 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the OUT instruction
(1)   40/     44C : 8C                  	glo	regarg1	;get the port number
(1)   41/     44D : FA 07               	ani	0x07	;clean it
(1)   42/     44F : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   43/     451 : 73                  	stxd		;store it for execution
(1)   44/     452 : 8D                  	glo	regarg2	;get the byte to be written
(1)   45/     453 : 52                  	str	sp	;store it where sp points
(1)   46/     454 : D8                  	sep	rt1	;execute it
(1)   47/     455 :                     ;we will come back to here with sp stepped up by one
(1)   48/     455 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   49/     456 : 12                  	inc	sp	;and the D3
(1)   50/     457 : (MACRO)             	Cretn		;and we're done
(1)   51/     458 :                     	
(1)   52/     458 :                     	
(1)   53/     458 :                     
      48/     458 :                     
 AS V1.42 Beta [Bld 123] - source file segtest.asm - page 11 - 1/24/2018 15:06:07


  symbol table (* = unused):
  ------------------------

 AGAIN55 :                      16B C | *ARCHITECTURE :  i386-unknown-win32 - |
*BIGENDIAN :                      0 - |  BITLOOP60 :                    3B8 C |
*BRANCHEXT :                      0 - | *CASESENSITIVE :                  0 - |
 CHECK_SUB58 :                  296 C |  CKNEXT60 :                     407 C |
 CKTOP60 :                      3A3 C |  CLRLP60 :                      394 C |
 COMPUTEQUOT55 :                181 C | *CONSTPI :        3.141592653589793 - |
*DATE :                   1/24/2018 - |  DCKLP60 :                      3BB C |
 DNOADD60 :                     3C3 C |  DONE56 :                       1DF C |
 DONE59 :                       374 C |  DONE60 :                       411 C |
 DSHLP60 :                      3D7 C |  ENDLP57 :                      261 C |
*FALSE :                          0 - | *FULLPMMU :                       1 - |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - | *INSRCMODE :                      0 - |
*INSUPMODE :                      0 - | *L1 :                            28 C |
 LCC1802CPUSPEED :           186A00 - |  LCC1802INIT :                   29 C |
*LISTON :                         1 - |  LOOP57 :                       20F C |
*MACEXP :                         0 - |  MEMADDR :                        E - |
 MLOOP58 :                      277 C | *MOMCPU :                      1802 - |
*MOMCPUNAME :                  1802 - |  MSLP53 :                       11E C |
 MULRDONE54 :                   149 C |  MULRLP54 :                     127 C |
 MULRNOADD54 :                  13B C |  MULRSHFT54 :                   141 C |
*NESTMAX :                      100 - |  NEY0Y55 :                      19A C |
 NORESTORE57 :                  25D C |  OUT55 :                        1A8 C |
*PACKING :                        0 - | *PADDING :                        1 - |
 POS156 :                       1BF C |  POS159 :                       326 C |
 POS256 :                       1CF C |  POS259 :                       34D C |
*R0 :                             0 - | *R1 :                             1 - |
 R10 :                            A - |  R11 :                            B - |
*R12 :                            C - | *R13 :                            D - |
*R14 :                            E - |  R15 :                            F - |
*R2 :                             2 - |  R3 :                             3 - |
*R4 :                             4 - | *R5 :                             5 - |
*R6 :                             6 - | *R7 :                             7 - |
 R8 :                             8 - |  R9 :                             9 - |
 RCALL :                          4 - |  REGARG1 :                        C - |
 REGARG2 :                        D - | *RELAXED :                        1 - |
 RETADDR :                        6 - |  RETVAL :                         F - |
*RL0 :                            1 - |  RL10 :                           B - |
*RL12 :                           D - | *RL6 :                            7 - |
 RL8 :                            9 - |  RP1P2 :                          D - |
 RPC :                            3 - |  RRET :                           5 - |
 RT1 :                            8 - | *RT2 :                            9 - |
 RWORK :                          E - |  SHIFT58 :                      2AE C |
 SP :                             2 - |  TESTEXIT55 :                   190 C |
*TIME :                    15:06:06 - | *TRUE :                           1 - |
 UPNXT60 :                      3F0 C |  VERSION :                     142F - |
 _0000044 :                      43 C |  _CALL :                        101 C |
 _DIE44 :                        46 C |  _DIVI2 :                       1B0 C |
 _DIVI4 :                       300 C |  _DIVU2 :                       14A C |
 _DIVU4 :                       200 C | *_DUBDABX :                     375 C |
*_INP :                         42A C |  _MAIN :                          B C |
*_MODI2 :                        57 C | *_MODI4 :                       41E C |
*_MODU2 :                        4F C | *_MODU4 :                       412 C |
*_MULU2 :                       123 C | *_MULU4 :                       266 C |
*_ONEMS :                       11C C | *_OUT :                         444 C |
 AS V1.42 Beta [Bld 123] - source file segtest.asm - page 12 - 1/24/2018 15:06:07


*_OUT4 :                         5F C |  _RETURN :                      112 C |
*_SETQOFF :                      4D C | *_SETQON :                       4B C |
 _TEST :                          3 C |  __FORW0 :                      441 C |
*__FORW1 :                      455 C |

    121 symbols
     56 unused symbols

 AS V1.42 Beta [Bld 123] - source file segtest.asm - page 13 - 1/24/2018 15:06:07


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU2RRS                               | ALU4                                 
ALU4I                                 | BLKCPY                               
CCALL                                 | CPY1                                 
CPY2                                  | CPY4                                 
CRETN                                 | DECM                                 
DEMOTE                                | INC4                                 
INCM                                  | JCF4                                 
JCI2                                  | JCI2I                                
JCI4                                  | JCU2                                 
JCU2I                                 | JCU4                                 
JEQI1                                 | JEQI2                                
JEQI4                                 | JEQU2I                               
JNEU1I                                | JNEU2                                
JNEU2I                                | JNEU2NI                              
JNEU4                                 | JNI2I                                
JNU2I                                 | JNZU1                                
JNZU2                                 | JUMPV                                
JZU1                                  | JZU2                                 
LD1                                   | LD2                                  
LD2Z                                  | LD4                                  
LDA2                                  | LDAD                                 
LDAX                                  | LDAXS                                
LDI4                                  | LDIREG                               
LDN1                                  | LDN2                                 
LDN2S                                 | MVC1                                 
MVC2                                  | MVCN1                                
MVCN2                                 | NEGI2                                
NEGI4                                 | NOP1806                              
POPR                                  | PUSHF                                
PUSHL                                 | PUSHM                                
PUSHR                                 | RELEASE                              
RELEASEL                              | RELEASES                             
RESERVE                               | RESERVEL                             
RESERVES                              | RLDMI                                
SAVMI                                 | SEXT                                 
SEXT4                                 | SHL2                                 
SHL2I                                 | SHL2R                                
SHL4                                  | SHL4I                                
SHL4R                                 | SHLC4                                
SHLR2R                                | SHRC4                                
SHRI2                                 | SHRI2I                               
SHRI2R                                | SHRI4                                
SHRI4I                                | SHRI4R                               
SHRU2                                 | SHRU2I                               
SHRU2R                                | SHRU4                                
SHRU4I                                | SHRU4R                               
ST1                                   | ST2                                  
ST2I                                  | ST4                                  
STR1                                  | STR1I                                
STR2                                  | STR2I                                
TESTSUB                               | ZEXT                                 
ZEXT4                                 |

    105 macros

 AS V1.42 Beta [Bld 123] - source file segtest.asm - page 14 - 1/24/2018 15:06:07


  codepages:
  ----------

STANDARD (0 changed characters)


0.18 seconds assembly time

   1596 lines source file
   2100 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
