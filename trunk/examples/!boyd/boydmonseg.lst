 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 1 - 1/28/2018 16:05:51


       1/       0 :                     ; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Sun Jan 28 16:05:51 2018
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1) 1071/       0 :                     	listing	on
(1) 1072/       0 : C0 07 BC            	lbr	lcc1802Init
(1) 1073/       3 :                     	
(1) 1074/       3 :                     
      11/       3 :                     	listing on
      12/       3 :                     _PIN4:
      13/       3 : 00                  	db 0
      14/       4 :                     _boydsegments:
      15/       4 : 00                  	db 0
      16/       5 : 00                  	db 0
      17/       6 : 00                  	db 0
      18/       7 : 00                  	db 0
      19/       8 : 00                  	db 0
      20/       9 : 00                  	db 0
      21/       A : 00                  	db 0
      22/       B : 00                  	db 0
      23/       C : 00                  	db 0
      24/       D : 00                  	db 0
      25/       E : 00                  	db 0
      26/       F : 00                  	db 0
      27/      10 : 00                  	db 0
      28/      11 : 00                  	db 0
      29/      12 : 00                  	db 0
      30/      13 : 00                  	db 0
      31/      14 : 00                  	db 0
      32/      15 : 00                  	db 0
      33/      16 : 00                  	db 0
      34/      17 : 00                  	db 0
      35/      18 : 00                  	db 0
      36/      19 : 00                  	db 0
      37/      1A : 00                  	db 0
      38/      1B : 00                  	db 0
      39/      1C : 00                  	db 0
      40/      1D : 00                  	db 0
      41/      1E : 00                  	db 0
      42/      1F : 00                  	db 0
      43/      20 : 00                  	db 0
      44/      21 : 00                  	db 0
      45/      22 : 00                  	db 0
      46/      23 : 00                  	db 0
      47/      24 : 00                  	db 0
      48/      25 : 00                  	db 0
      49/      26 : 22                  	db 34
      50/      27 : 00                  	db 0
      51/      28 : 00                  	db 0
      52/      29 : 00                  	db 0
      53/      2A : 00                  	db 0
      54/      2B : 20                  	db 32
      55/      2C : 00                  	db 0
      56/      2D : 00                  	db 0
      57/      2E : 00                  	db 0
      58/      2F : 00                  	db 0
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 2 - 1/28/2018 16:05:51


      59/      30 : 11                  	db 17
      60/      31 : 04                  	db 4
      61/      32 : 00                  	db 0
      62/      33 : 2C                  	db 44
      63/      34 : 7B                  	db 123
      64/      35 : 30                  	db 48
      65/      36 : 6D                  	db 109
      66/      37 : 75                  	db 117
      67/      38 : 36                  	db 54
      68/      39 : 57                  	db 87
      69/      3A : 5F                  	db 95
      70/      3B : 70                  	db 112
      71/      3C : 7F                  	db 127
      72/      3D : 77                  	db 119
      73/      3E : 41                  	db 65
      74/      3F : 51                  	db 81
      75/      40 : 00                  	db 0
      76/      41 : 00                  	db 0
      77/      42 : 00                  	db 0
      78/      43 : 00                  	db 0
      79/      44 : 6F                  	db 111
      80/      45 : 7E                  	db 126
      81/      46 : 1F                  	db 31
      82/      47 : 4B                  	db 75
      83/      48 : 3D                  	db 61
      84/      49 : 4F                  	db 79
      85/      4A : 4E                  	db 78
      86/      4B : 5B                  	db 91
      87/      4C : 3E                  	db 62
      88/      4D : 10                  	db 16
      89/      4E : 39                  	db 57
      90/      4F : 5E                  	db 94
      91/      50 : 0B                  	db 11
      92/      51 : 58                  	db 88
      93/      52 : 1C                  	db 28
      94/      53 : 1D                  	db 29
      95/      54 : 6E                  	db 110
      96/      55 : 67                  	db 103
      97/      56 : 0C                  	db 12
      98/      57 : 53                  	db 83
      99/      58 : 0F                  	db 15
     100/      59 : 3B                  	db 59
     101/      5A : 19                  	db 25
     102/      5B : 23                  	db 35
     103/      5C : 5C                  	db 92
     104/      5D : 37                  	db 55
     105/      5E : 69                  	db 105
     106/      5F : 00                  	db 0
     107/      60 : 16                  	db 22
     108/      61 : 00                  	db 0
     109/      62 : 00                  	db 0
     110/      63 : 01                  	db 1
     111/      64 : 06                  	db 6
     112/      65 : 7E                  	db 126
     113/      66 : 1F                  	db 31
     114/      67 : 4B                  	db 75
     115/      68 : 3D                  	db 61
     116/      69 : 4F                  	db 79
     117/      6A : 4E                  	db 78
     118/      6B : 5B                  	db 91
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 3 - 1/28/2018 16:05:51


     119/      6C : 3E                  	db 62
     120/      6D : 10                  	db 16
     121/      6E : 39                  	db 57
     122/      6F : 5E                  	db 94
     123/      70 : 0B                  	db 11
     124/      71 : 58                  	db 88
     125/      72 : 1C                  	db 28
     126/      73 : 1D                  	db 29
     127/      74 : 6E                  	db 110
     128/      75 : 67                  	db 103
     129/      76 : 0C                  	db 12
     130/      77 : 53                  	db 83
     131/      78 : 0F                  	db 15
     132/      79 : 3B                  	db 59
     133/      7A : 19                  	db 25
     134/      7B : 23                  	db 35
     135/      7C : 5C                  	db 92
     136/      7D : 37                  	db 55
     137/      7E : 69                  	db 105
     138/      7F : 00                  	db 0
     139/      80 : 00                  	db 0
     140/      81 : 00                  	db 0
     141/      82 : 00                  	db 0
     142/      83 : 00                  	db 0
     143/      84 :                     ;$$function start$$ _disp1
     144/      84 :                     _disp1:		;framesize=2
     145/      84 :                     ;void disp1(unsigned char d){//display a byte as two hex digits
     146/      84 :                     ;	asm(" glo 12\n ani 0x0f\n" //prep bottom digit
     147/      84 : 8C                   glo 12
     148/      85 : FA 0F                ani 0x0f
     149/      87 : 22                   dec 2
     150/      88 : 52                   str 2
     151/      89 : 67                   out 7
     152/      8A : 8C                   glo 12
     153/      8B : F6                   shr
     154/      8C : F6                   shr
     155/      8D : F6                   shr
     156/      8E : F6                   shr
     157/      8F : 22                   dec 2
     158/      90 : 52                   str 2
     159/      91 : 67                   out 7
     160/      92 :                     ;}
     161/      92 :                     L1:
     162/      92 : (MACRO)             	Cretn
     163/      94 :                     
     164/      94 :                     ;$$function end$$ _disp1
     165/      94 :                     ;$$function start$$ _dispmemloc
     166/      94 :                     _dispmemloc:		;framesize=8
     167/      94 : (MACRO)             	pushr R7
     168/      96 : (MACRO)             	reserve 4; save room for outgoing arguments
     169/      9A : (MACRO)             	st2 R12,'O',sp,(8+1); flag1 
     170/      A7 :                     ;void dispmemloc(unsigned char * loc){
     171/      A7 :                     ;	initleds(0b11010000); //LEDs in hex decode mode
     172/      A7 :                     ;	disp1(*(loc+1));
     173/      A7 : 7A                   req
     174/      A8 : 7B                   seq
     175/      A9 : 22                   dec 2
     176/      AA : F8 D0                ldi 0b11010000
     177/      AC : 52                   str 2
     178/      AD : 67                   out 7
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 4 - 1/28/2018 16:05:51


     179/      AE : 7A                   req
     180/      AF : (MACRO)             	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
     181/      BB : (MACRO)             	ld1 R12,'O',R11,(1)
     182/      C5 : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     183/      C8 : (MACRO)             	Ccall _disp1
     184/      CC :                     ;	disp1(*loc);
     185/      CC : (MACRO)             	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
     186/      D8 : (MACRO)             	ldn1 R12,R11	;opt14*
     187/      DA : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     188/      DD : (MACRO)             	Ccall _disp1
     189/      E1 :                     ;	lint=(unsigned int)loc;
     190/      E1 : (MACRO)             	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
     191/      ED : (MACRO)             	cpy2 R7,R11 ;LOADU2*(reg)
     192/      F1 :                     ;	disp1((unsigned int)loc&0xff);
     193/      F1 : (MACRO)             	ld2 R11,'O',sp,(8+1) ;reg:INDIRP2(addr)
     194/      FD : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     195/     105 : (MACRO)             	cpy1 R12,R11
     196/     107 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     197/     10A : (MACRO)             	Ccall _disp1
     198/     10E :                     ;	disp1(lint>>8);
     199/     10E : (MACRO)             	cpy2 R11,R7
     200/     112 : 9B                  	ghi	R11	;opt2
     201/     113 : AB                  	plo	R11
     202/     114 : F8 00               	ldi	0
     203/     116 : BB                  	phi	R11	
     204/     117 : (MACRO)             	cpy1 R12,R11
     205/     119 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     206/     11C : (MACRO)             	Ccall _disp1
     207/     120 :                     ;}
     208/     120 :                     L3:
     209/     120 : (MACRO)             	release 4; release room for outgoing arguments
     210/     124 : (MACRO)             	popr R7
     211/     129 : (MACRO)             	Cretn
     212/     12B :                     
     213/     12B :                     ;$$function end$$ _dispmemloc
     214/     12B :                     ;$$function start$$ _dispval
     215/     12B :                     _dispval:		;framesize=8
     216/     12B : (MACRO)             	pushr R7
     217/     12D : (MACRO)             	reserve 4; save room for outgoing arguments
     218/     131 : (MACRO)             	st2 R12,'O',sp,(8+1); flag1 
     219/     13E : (MACRO)             	ldA2 R11,'O',sp,(8+1); reg:addr
     220/     146 : (MACRO)             	ld2 R10,'O',sp,(8+1) ;reg:INDIRI2(addr)
     221/     152 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     222/     154 :                     ;void dispval(unsigned char v){
     223/     154 :                     ;	initleds(0b11010000); //LEDs in hex decode mode
     224/     154 :                     ;	disp1(v);
     225/     154 : 7A                   req
     226/     155 : 7B                   seq
     227/     156 : 22                   dec 2
     228/     157 : F8 D0                ldi 0b11010000
     229/     159 : 52                   str 2
     230/     15A : 67                   out 7
     231/     15B : 7A                   req
     232/     15C : (MACRO)             	ld1 R12,'O',sp,(8+1)
     233/     166 : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     234/     169 : (MACRO)             	Ccall _disp1
     235/     16D :                     ;	for (i=6;i!=0;i--) out(7,0);
     236/     16D : (MACRO)             	ldaD R7,6; reg:acon
     237/     171 : C0 01 81            	lbr L10
     238/     174 :                     L7:
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 5 - 1/28/2018 16:05:51


     239/     174 : (MACRO)             	ldaD R12,7; reg:acon
     240/     178 : (MACRO)             	ld2z R13
     241/     17C : (MACRO)             	Ccall _out; CALLI2(ar)
     242/     180 :                     L8:
     243/     180 : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
     244/     181 :                     L10:
     245/     181 : (MACRO)             	jnzU2 R7,L7; NE 0 
     246/     189 :                     ;}
     247/     189 :                     L5:
     248/     189 : (MACRO)             	release 4; release room for outgoing arguments
     249/     18D : (MACRO)             	popr R7
     250/     192 : (MACRO)             	Cretn
     251/     194 :                     
     252/     194 :                     ;$$function end$$ _dispval
     253/     194 :                     ;$$function start$$ _getsp
     254/     194 :                     _getsp:		;framesize=2
     255/     194 :                     ;unsigned int getsp(){//return stack pointer value
     256/     194 :                     ;	asm(" cpy2 r15,sp\n"  	//copy stack pointer to return reg
     257/     194 :                     ;	return 0;				//not executed
     258/     194 : (MACRO)              cpy2 r15,sp
     259/     198 : (MACRO)              cretn
     260/     19A : (MACRO)             	ld2z R15
     261/     19E :                     L11:
     262/     19E : (MACRO)             	Cretn
     263/     1A0 :                     
     264/     1A0 :                     ;$$function end$$ _getsp
     265/     1A0 :                     ;$$function start$$ _execute
     266/     1A0 :                     _execute:		;framesize=16
     267/     1A0 : (MACRO)             	reserve 2; save room for local variables
     268/     1A2 : (MACRO)             	pushr R0
     269/     1A4 : (MACRO)             	pushr R1
     270/     1A6 : (MACRO)             	pushr R6
     271/     1A8 : (MACRO)             	pushr R7
     272/     1AA : (MACRO)             	reserve 4; save room for outgoing arguments
     273/     1AE : (MACRO)             	cpy2 R7,R12; function(2055) 1
     274/     1B2 :                     ;unsigned char * execute(unsigned char * loc){
     275/     1B2 : C0 02 E1            	lbr L15
     276/     1B5 :                     L14:
     277/     1B5 :                     ;	while(1){
     278/     1B5 :                     ;		op=*loc; val=*(loc+1);
     279/     1B5 : (MACRO)             	ldn1 R6,R7;reg:  INDIRU1(indaddr)
     280/     1B7 : (MACRO)             	cpy2 R11,R7
     281/     1BB : (MACRO)             	incm R11,1
     282/     1BC : (MACRO)             	ldn1 R1,R11;reg:  INDIRU1(indaddr)
     283/     1BE :                     ;		switch (op){
     284/     1BE : (MACRO)             	cpy1 R11,R6
     285/     1C0 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     286/     1C3 : (MACRO)             	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
     287/     1D0 : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
     288/     1DC : (MACRO)             	jcI2I R11,0,lbnf,L17  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     289/     1ED : (MACRO)             	jnI2I R11,4,lbnf,L17; GT reverse  the subtraction
     290/     1FE : (MACRO)             	shl2I R11,1
     291/     204 : (MACRO)             	ld2 R11,'O',R11,(L25) ;reg:INDIRP2(addr)
     292/     210 : (MACRO)             	jumpv R11; JUMPV(reg)
     293/     218 :                     L25:
     294/     218 : 02 22               	dw L20
     295/     21A : 02 4F               	dw L21
     296/     21C : 02 73               	dw L22
     297/     21E : 02 89               	dw L23
     298/     220 : 02 A5               	dw L24
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 6 - 1/28/2018 16:05:51


     299/     222 :                     L20:
     300/     222 :                     ;				mp=(unsigned char *)(4096+val);
     301/     222 : (MACRO)             	cpy1 R11,R1
     302/     224 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     303/     227 : (MACRO)             	ldA2 R11,'O',R11,(4096); reg:addr
     304/     22F : (MACRO)             	cpy2 R0,R11 ;LOADP2(reg)
     305/     233 :                     ;				dispval(*mp); delay(1000);
     306/     233 : (MACRO)             	ld1 R12,'O',R0,0 ;opt14 would generate ldn1 0 which is illegal
     307/     23D : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     308/     240 : (MACRO)             	Ccall _dispval
     309/     244 : (MACRO)             	ldaD R12,1000; reg:acon
     310/     248 : (MACRO)             	Ccall _delay
     311/     24C :                     ;				break;
     312/     24C : C0 02 DF            	lbr L18
     313/     24F :                     L21:
     314/     24F :                     ;				mp=(unsigned char *)(4096+val);
     315/     24F : (MACRO)             	cpy1 R11,R1
     316/     251 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     317/     254 : (MACRO)             	ldA2 R11,'O',R11,(4096); reg:addr
     318/     25C : (MACRO)             	cpy2 R0,R11 ;LOADP2(reg)
     319/     260 :                     ;				*mp+=1;
     320/     260 : (MACRO)             	ld1 R11,'O',R0,0 ;opt14 would generate ldn1 0 which is illegal
     321/     26A : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     322/     26D : (MACRO)             	incm R11,1
     323/     26E : (MACRO)             	str1 R11,R0; ASGNU1(indaddr,reg)		DH
     324/     270 :                     ;				break;
     325/     270 : C0 02 DF            	lbr L18
     326/     273 :                     L22:
     327/     273 :                     ;				loc=(unsigned char *)(val+4096-2); //ugh
     328/     273 : (MACRO)             	cpy1 R11,R1
     329/     275 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     330/     278 : (MACRO)             	ldA2 R11,'O',R11,(4096); reg:addr
     331/     280 : (MACRO)             	decm R11,2	;SUBI2(reg,consm)
     332/     282 : (MACRO)             	cpy2 R7,R11 ;LOADP2(reg)
     333/     286 :                     ;				break;
     334/     286 : C0 02 DF            	lbr L18
     335/     289 :                     L23:
     336/     289 :                     ;				delay(val*4);
     337/     289 : (MACRO)             	cpy1 R11,R1
     338/     28B : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     339/     28E : (MACRO)             	shl2I R11,2
     340/     29A : (MACRO)             	cpy2 R12,R11 ;LOADU2*(reg)
     341/     29E : (MACRO)             	Ccall _delay
     342/     2A2 :                     ;				break;
     343/     2A2 : C0 02 DF            	lbr L18
     344/     2A5 :                     L24:
     345/     2A5 :                     ;				dispval(getsp());
     346/     2A5 : (MACRO)             	Ccall _getsp;CALLU2(ar)*
     347/     2A9 : (MACRO)             	cpy1 R11,R15;LOADU1(reg)
     348/     2AB : (MACRO)             	cpy1 R12,R11
     349/     2AD : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     350/     2B0 : (MACRO)             	Ccall _dispval
     351/     2B4 :                     ;				delay(250);
     352/     2B4 : (MACRO)             	ldaD R12,250; reg:acon
     353/     2B8 : (MACRO)             	Ccall _delay
     354/     2BC :                     ;				break;
     355/     2BC : C0 02 DF            	lbr L18
     356/     2BF :                     L17:
     357/     2BF :                     ;				dispval(0x41); delay(250);
     358/     2BF : (MACRO)             	ldaD R12,65; reg:acon
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 7 - 1/28/2018 16:05:51


     359/     2C3 : (MACRO)             	Ccall _dispval
     360/     2C7 : (MACRO)             	ldaD R12,250; reg:acon
     361/     2CB : (MACRO)             	Ccall _delay
     362/     2CF :                     ;				dispmemloc(loc); delay(5000);
     363/     2CF : (MACRO)             	cpy2 R12,R7 ;LOADP2(reg)
     364/     2D3 : (MACRO)             	Ccall _dispmemloc
     365/     2D7 : (MACRO)             	ldaD R12,5000; reg:acon
     366/     2DB : (MACRO)             	Ccall _delay
     367/     2DF :                     ;				break;
     368/     2DF :                     L18:
     369/     2DF :                     ;		loc+=2;
     370/     2DF : (MACRO)             	incm R7,2
     371/     2E1 :                     ;	}
     372/     2E1 :                     L15:
     373/     2E1 :                     ;	while(1){
     374/     2E1 : C0 01 B5            	lbr L14
     375/     2E4 :                     ;	return loc;
     376/     2E4 : (MACRO)             	cpy2 R15,R7 ;LOADP2(reg)
     377/     2E8 :                     L13:
     378/     2E8 : (MACRO)             	release 4; release room for outgoing arguments
     379/     2EC : (MACRO)             	popf R7	;opt11.3
     380/     2EF : (MACRO)             	popm R6	;opt11.4
     381/     2F1 : (MACRO)             	popm R1	;opt11.4
     382/     2F3 : (MACRO)             	popl R0	;opt11.4
     383/     2F7 : (MACRO)             	release 2; release room for local variables 
     384/     2F9 : (MACRO)             	Cretn
     385/     2FB :                     
     386/     2FB :                     ;$$function end$$ _execute
     387/     2FB :                     ;$$function start$$ _dispalpha
     388/     2FB :                     _dispalpha:		;framesize=8
     389/     2FB : (MACRO)             	pushr R7
     390/     2FD : (MACRO)             	reserve 4; save room for outgoing arguments
     391/     301 : (MACRO)             	st2 R12,'O',sp,(8+1); flag1 
     392/     30E :                     ;void dispalpha(unsigned char data[]){
     393/     30E :                     ;	dispval(getsp()); //display
     394/     30E : (MACRO)             	Ccall _getsp;CALLU2(ar)*
     395/     312 : (MACRO)             	cpy1 R11,R15;LOADU1(reg)
     396/     314 : (MACRO)             	cpy1 R12,R11
     397/     316 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     398/     319 : (MACRO)             	Ccall _dispval
     399/     31D :                     ;	delay(100);
     400/     31D : (MACRO)             	ldaD R12,100; reg:acon
     401/     321 : (MACRO)             	Ccall _delay
     402/     325 :                     ;	initleds(0b11110000); //LEDs in no-decode mode
     403/     325 :                     ;	for (i=8;i!=0;i--){
     404/     325 : 7A                   req
     405/     326 : 7B                   seq
     406/     327 : 22                   dec 2
     407/     328 : F8 F0                ldi 0b11110000
     408/     32A : 52                   str 2
     409/     32B : 67                   out 7
     410/     32C : 7A                   req
     411/     32D : (MACRO)             	ldaD R7,8; reg:acon
     412/     331 : C0 03 60            	lbr L31
     413/     334 :                     L28:
     414/     334 :                     ;		out(7,boydsegments[data[i]]);
     415/     334 : (MACRO)             	ldaD R12,7; reg:acon
     416/     338 : (MACRO)             	alu2RRS R11,R7,'O',sp,(8+1),add,adc; ADDI2(r,INDIRP2(addr))	DH3.1
     417/     349 : (MACRO)             	ldn1 R11,R11	;opt14*
     418/     34B : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 8 - 1/28/2018 16:05:51


     419/     34E : (MACRO)             	ld1 R13,'O',R11,(_boydsegments)
     420/     358 : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     421/     35B : (MACRO)             	Ccall _out; CALLI2(ar)
     422/     35F :                     ;	}
     423/     35F :                     L29:
     424/     35F :                     ;	for (i=8;i!=0;i--){
     425/     35F : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
     426/     360 :                     L31:
     427/     360 : (MACRO)             	jnzU2 R7,L28; NE 0 
     428/     368 :                     ;}
     429/     368 :                     L26:
     430/     368 : (MACRO)             	release 4; release room for outgoing arguments
     431/     36C : (MACRO)             	popr R7
     432/     371 : (MACRO)             	Cretn
     433/     373 :                     
     434/     373 :                     ;$$function end$$ _dispalpha
     435/     373 :                     ;$$function start$$ _strlen
     436/     373 :                     _strlen:		;framesize=4
     437/     373 : (MACRO)             	pushr R7
     438/     375 :                     ;{
     439/     375 :                     ;	unsigned int slen = 0 ;
     440/     375 : (MACRO)             	ld2z R7
     441/     379 : C0 03 7E            	lbr L34
     442/     37C :                     L33:
     443/     37C :                     ;	while (*str != 0) {
     444/     37C :                     ;      slen++ ;
     445/     37C : (MACRO)             	incm R7,1
     446/     37D :                     ;      str++ ;
     447/     37D : (MACRO)             	incm R12,1
     448/     37E :                     ;   }
     449/     37E :                     L34:
     450/     37E :                     ;	while (*str != 0) {
     451/     37E : (MACRO)             	ldn1 R11,R12;reg:  INDIRU1(indaddr)
     452/     380 : (MACRO)             	jnzU1 R11,L33; NEI2(CVUI2(reg),con0)
     453/     384 :                     ;   return slen;
     454/     384 : (MACRO)             	cpy2 R15,R7 ;LOADU2*(reg)
     455/     388 :                     L32:
     456/     388 : (MACRO)             	popr R7
     457/     38D : (MACRO)             	Cretn
     458/     38F :                     
     459/     38F :                     ;$$function end$$ _strlen
     460/     38F :                     ;$$function start$$ _dispstr
     461/     38F :                     _dispstr:		;framesize=12
     462/     38F : (MACRO)             	pushr R1
     463/     391 : (MACRO)             	pushr R6
     464/     393 : (MACRO)             	pushr R7
     465/     395 : (MACRO)             	reserve 4; save room for outgoing arguments
     466/     399 : (MACRO)             	st2 R12,'O',sp,(12+1); flag1 
     467/     3A6 :                     ;void dispstr(unsigned char * str){//display 8 or fewer characters on the boyd LEDs
     468/     3A6 :                     ;	L=min(strlen((char *)str),8);//length to display
     469/     3A6 : (MACRO)             	ld2 R12,'O',sp,(12+1) ;reg:INDIRP2(addr)
     470/     3B2 : (MACRO)             	Ccall _strlen;CALLU2(ar)*
     471/     3B6 : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     472/     3BA : (MACRO)             	jcI2I R11,8,lbdf,L38; GE is flipped test from LT
     473/     3CB : (MACRO)             	ld2 R12,'O',sp,(12+1) ;reg:INDIRP2(addr)
     474/     3D7 : (MACRO)             	Ccall _strlen;CALLU2(ar)*
     475/     3DB : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     476/     3DF : (MACRO)             	cpy2 R1,R11 ;LOADU2*(reg)
     477/     3E3 : C0 03 EA            	lbr L39
     478/     3E6 :                     L38:
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 9 - 1/28/2018 16:05:51


     479/     3E6 : (MACRO)             	ldaD R1,8; reg:acon
     480/     3EA :                     L39:
     481/     3EA : (MACRO)             	cpy2 R6,R1 ;LOADU2*(reg)
     482/     3EE :                     ;	initleds(0b11110000); //LEDs in no-decode mode
     483/     3EE :                     ;	if (L<8){
     484/     3EE : 7A                   req
     485/     3EF : 7B                   seq
     486/     3F0 : 22                   dec 2
     487/     3F1 : F8 F0                ldi 0b11110000
     488/     3F3 : 52                   str 2
     489/     3F4 : 67                   out 7
     490/     3F5 : 7A                   req
     491/     3F6 : (MACRO)             	jcI2I R6,8,lbdf,L41; GE is flipped test from LT
     492/     407 :                     ;		for(i=(L-8); i>0;i--){
     493/     407 : (MACRO)             	alu2I R7,R6,8,smi,smbi
     494/     40F : C0 04 1F            	lbr L46
     495/     412 :                     L43:
     496/     412 :                     ;			out(7,255);
     497/     412 : (MACRO)             	ldaD R12,7; reg:acon
     498/     416 : (MACRO)             	ldaD R13,255; reg:acon
     499/     41A : (MACRO)             	Ccall _out; CALLI2(ar)
     500/     41E :                     ;		}
     501/     41E :                     L44:
     502/     41E :                     ;		for(i=(L-8); i>0;i--){
     503/     41E : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
     504/     41F :                     L46:
     505/     41F : (MACRO)             	jnzU2 R7,L43; NE 0 
     506/     427 :                     ;	}
     507/     427 :                     L41:
     508/     427 :                     ;	for (i=L;i>0;i--){
     509/     427 : (MACRO)             	cpy2 R7,R6 ;LOADU2*(reg)
     510/     42B : C0 04 5F            	lbr L50
     511/     42E :                     L47:
     512/     42E :                     ;		out(7,boydsegments[str[i-1]]);
     513/     42E : (MACRO)             	ldaD R12,7; reg:acon
     514/     432 : (MACRO)             	cpy2 R11,R7	;SUBU2(reg,consm)
     515/     436 : (MACRO)             	decm R11,1	;SUBU2(reg,consm)
     516/     437 : (MACRO)             	alu2RRS R11,R11,'O',sp,(12+1),add,adc; ADDI2(r,INDIRP2(addr))	DH3.1
     517/     448 : (MACRO)             	ldn1 R11,R11	;opt14*
     518/     44A : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     519/     44D : (MACRO)             	ld1 R13,'O',R11,(_boydsegments)
     520/     457 : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     521/     45A : (MACRO)             	Ccall _out; CALLI2(ar)
     522/     45E :                     ;	}
     523/     45E :                     L48:
     524/     45E :                     ;	for (i=L;i>0;i--){
     525/     45E : (MACRO)             	decm R7,1	;SUBU2(reg,consm)
     526/     45F :                     L50:
     527/     45F : (MACRO)             	jnzU2 R7,L47; NE 0 
     528/     467 :                     ;}
     529/     467 :                     L36:
     530/     467 : (MACRO)             	release 4; release room for outgoing arguments
     531/     46B : (MACRO)             	popf R7	;opt11.3
     532/     46E : (MACRO)             	popm R6	;opt11.4
     533/     470 : (MACRO)             	popl R1	;opt11.4
     534/     474 : (MACRO)             	Cretn
     535/     476 :                     
     536/     476 :                     ;$$function end$$ _dispstr
     537/     476 :                     ;$$function start$$ _main
     538/     476 :                     _main: ;copt is peeping your size 16 frame with oct 23 rules
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 10 - 1/28/2018 16:05:51


     539/     476 : (MACRO)             	reserve 2; save room for local variables
     540/     478 : (MACRO)             	pushr R0
     541/     47A : (MACRO)             	pushr R1
     542/     47C : (MACRO)             	pushr R6
     543/     47E : (MACRO)             	pushr R7
     544/     480 : (MACRO)             	reserve 4; save room for outgoing arguments
     545/     484 :                     ;{
     546/     484 :                     ;	unsigned char * loc=0;
     547/     484 : (MACRO)             	ldaD R6,0; reg:acon
     548/     488 :                     ;	unsigned char memtype='o'; //displaying o=eeprom,a=ram
     549/     488 : (MACRO)             	ldaD R1,111; reg:acon
     550/     48C :                     ;	dispval(0x42);
     551/     48C : (MACRO)             	ldaD R12,66; reg:acon
     552/     490 : (MACRO)             	Ccall _dispval
     553/     494 :                     ;	delay(100);
     554/     494 : (MACRO)             	ldaD R12,100; reg:acon
     555/     498 : (MACRO)             	Ccall _delay
     556/     49C :                     ;	dispstr((unsigned char *)"BARRY");
     557/     49C : (MACRO)             	ldaD R12,L52; reg:acon
     558/     4A0 : (MACRO)             	Ccall _dispstr
     559/     4A4 :                     ;	delay(5000);
     560/     4A4 : (MACRO)             	ldaD R12,5000; reg:acon
     561/     4A8 : (MACRO)             	Ccall _delay
     562/     4AC :                     ;	dispstr((unsigned char *)"01234567");
     563/     4AC : (MACRO)             	ldaD R12,L53; reg:acon
     564/     4B0 : (MACRO)             	Ccall _dispstr
     565/     4B4 :                     ;	delay(5000);
     566/     4B4 : (MACRO)             	ldaD R12,5000; reg:acon
     567/     4B8 : (MACRO)             	Ccall _delay
     568/     4BC : C0 05 FF            	lbr L55
     569/     4BF :                     L54:
     570/     4BF :                     ;	while(1){
     571/     4BF :                     ;		dispmemloc(loc);
     572/     4BF : (MACRO)             	cpy2 R12,R6 ;LOADP2(reg)
     573/     4C3 : (MACRO)             	Ccall _dispmemloc
     574/     4C7 :                     ;		k=boydscan();
     575/     4C7 : (MACRO)             	Ccall _boydscan; CALLI2(ar)
     576/     4CB : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     577/     4CF : (MACRO)             	cpy1 R7,R11;LOADU1(reg)
     578/     4D1 :                     ;		switch(k){
     579/     4D1 : (MACRO)             	cpy1 R11,R7
     580/     4D3 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     581/     4D6 : (MACRO)             	st2 R11,'O',sp,(12+1); ASGNI2(addr,reg)
     582/     4E3 : (MACRO)             	ld2 R11,'O',sp,(12+1) ;reg:INDIRI2(addr)
     583/     4EF : (MACRO)             	jcI2I R11,16,lbnf,L57  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     584/     500 : (MACRO)             	jnI2I R11,20,lbnf,L57; GT reverse  the subtraction
     585/     511 : (MACRO)             	shl2I R11,1
     586/     517 : (MACRO)             	ld2 R11,'O',R11,(L67-32) ;reg:INDIRP2(addr)
     587/     523 : (MACRO)             	jumpv R11; JUMPV(reg)
     588/     52B :                     L67:
     589/     52B : 05 35               	dw L60
     590/     52D : 05 39               	dw L61
     591/     52F : 05 44               	dw L62
     592/     531 : 05 60               	dw L65
     593/     533 : 05 CF               	dw L66
     594/     535 :                     L60:
     595/     535 :                     ;				loc +=1;
     596/     535 : (MACRO)             	incm R6,1
     597/     536 :                     ;				break;
     598/     536 : C0 05 FF            	lbr L58
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 11 - 1/28/2018 16:05:51


     599/     539 :                     L61:
     600/     539 :                     ;				loc -=1;
     601/     539 : (MACRO)             	ldA2 R6,'O',R6,(-1); reg:addr
     602/     541 :                     ;				break;
     603/     541 : C0 05 FF            	lbr L58
     604/     544 :                     L62:
     605/     544 :                     ;				if (memtype=='o'){
     606/     544 : (MACRO)             	jneU1I R1,111,L63	; DH 4
     607/     54A :                     ;					loc=(unsigned char *)4096;
     608/     54A : (MACRO)             	ldaD R6,0x1000; reg:acon
     609/     54E :                     ;					memtype='a';
     610/     54E : (MACRO)             	ldaD R1,97; reg:acon
     611/     552 :                     ;				}else{
     612/     552 : C0 05 FF            	lbr L58
     613/     555 :                     L63:
     614/     555 :                     ;					loc=(unsigned char *)0;
     615/     555 : (MACRO)             	ldaD R6,0; reg:acon
     616/     559 :                     ;					memtype='o';
     617/     559 : (MACRO)             	ldaD R1,111; reg:acon
     618/     55D :                     ;				}
     619/     55D :                     ;				break;
     620/     55D : C0 05 FF            	lbr L58
     621/     560 :                     L65:
     622/     560 :                     ;				dispmemloc(loc); //makes a blink
     623/     560 : (MACRO)             	cpy2 R12,R6 ;LOADP2(reg)
     624/     564 : (MACRO)             	Ccall _dispmemloc
     625/     568 :                     ;				k=boydscan(); dispval(k); delay(250);
     626/     568 : (MACRO)             	Ccall _boydscan; CALLI2(ar)
     627/     56C : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     628/     570 : (MACRO)             	cpy1 R7,R11;LOADU1(reg)
     629/     572 : (MACRO)             	cpy1 R12,R7
     630/     574 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     631/     577 : (MACRO)             	Ccall _dispval
     632/     57B : (MACRO)             	ldaD R12,250; reg:acon
     633/     57F : (MACRO)             	Ccall _delay
     634/     583 :                     ;				k2=boydscan(); dispval(k2); delay(250);
     635/     583 : (MACRO)             	Ccall _boydscan; CALLI2(ar)
     636/     587 : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     637/     58B : (MACRO)             	cpy1 R0,R11;LOADU1(reg)
     638/     58D : (MACRO)             	cpy1 R12,R0
     639/     58F : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     640/     592 : (MACRO)             	Ccall _dispval
     641/     596 : (MACRO)             	ldaD R12,250; reg:acon
     642/     59A : (MACRO)             	Ccall _delay
     643/     59E :                     ;				*loc=(k<<4)+k2;
     644/     59E : (MACRO)             	cpy1 R11,R7
     645/     5A0 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     646/     5A3 : (MACRO)             	shl2I R11,4
     647/     5BB : (MACRO)             	cpy1 R10,R0
     648/     5BD : (MACRO)             	zExt R10 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     649/     5C0 : (MACRO)             	alu2 R11,R11,R10,add,adc; ADDI2(r,r)
     650/     5CA : (MACRO)             	str1 R11,R6; ASGNU1(indaddr,reg)		DH
     651/     5CC :                     ;				break;
     652/     5CC : C0 05 FF            	lbr L58
     653/     5CF :                     L66:
     654/     5CF :                     ;				dispval(0x45);
     655/     5CF : (MACRO)             	ldaD R12,69; reg:acon
     656/     5D3 : (MACRO)             	Ccall _dispval
     657/     5D7 :                     ;				delay(250);
     658/     5D7 : (MACRO)             	ldaD R12,250; reg:acon
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 12 - 1/28/2018 16:05:51


     659/     5DB : (MACRO)             	Ccall _delay
     660/     5DF :                     ;				loc=execute(loc);
     661/     5DF : (MACRO)             	cpy2 R12,R6 ;LOADP2(reg)
     662/     5E3 : (MACRO)             	Ccall _execute
     663/     5E7 : (MACRO)             	cpy2 R6,R15 ;LOADP2(reg)
     664/     5EB :                     ;				break;
     665/     5EB : C0 05 FF            	lbr L58
     666/     5EE :                     L57:
     667/     5EE :                     ;				dispval(k);
     668/     5EE : (MACRO)             	cpy1 R12,R7
     669/     5F0 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     670/     5F3 : (MACRO)             	Ccall _dispval
     671/     5F7 :                     ;				delay(250);
     672/     5F7 : (MACRO)             	ldaD R12,250; reg:acon
     673/     5FB : (MACRO)             	Ccall _delay
     674/     5FF :                     ;		}
     675/     5FF :                     L58:
     676/     5FF :                     ;	}
     677/     5FF :                     L55:
     678/     5FF :                     ;	while(1){
     679/     5FF : C0 04 BF            	lbr L54
     680/     602 :                     ;}
     681/     602 :                     L51:
     682/     602 : (MACRO)             	release 4; release room for outgoing arguments
     683/     606 : (MACRO)             	popf R7	;opt11.3
     684/     609 : (MACRO)             	popm R6	;opt11.4
     685/     60B : (MACRO)             	popm R1	;opt11.4
     686/     60D : (MACRO)             	popl R0	;opt11.4
     687/     611 : (MACRO)             	release 2; release room for local variables 
     688/     613 : (MACRO)             	Cretn
     689/     615 :                     
     690/     615 :                     ;$$function end$$ _main
     691/     615 :                     ;$$function start$$ _delay
     692/     615 :                     _delay:		;framesize=10
     693/     615 : (MACRO)             	pushr R6
     694/     617 : (MACRO)             	pushr R7
     695/     619 : (MACRO)             	reserve 4; save room for outgoing arguments
     696/     61D : (MACRO)             	cpy2 R7,R12; function(2054) 1
     697/     621 :                     ;void delay(unsigned int howlong){
     698/     621 :                     ;	for (i=1;i!=howlong;i++){
     699/     621 : (MACRO)             	ldaD R6,1; reg:acon
     700/     625 : C0 06 2D            	lbr L73
     701/     628 :                     L70:
     702/     628 :                     ;		oneMs();
     703/     628 : (MACRO)             	Ccall _oneMs; CALLI2(ar)
     704/     62C :                     ;	}
     705/     62C :                     L71:
     706/     62C :                     ;	for (i=1;i!=howlong;i++){
     707/     62C : (MACRO)             	incm R6,1
     708/     62D :                     L73:
     709/     62D : (MACRO)             	jneU2 R6,R7,L70; NE
     710/     63F :                     ;}
     711/     63F :                     L69:
     712/     63F : (MACRO)             	release 4; release room for outgoing arguments
     713/     643 : (MACRO)             	popf R7	;opt11.3
     714/     646 : (MACRO)             	popl R6	;opt11.3
     715/     64A : (MACRO)             	Cretn
     716/     64C :                     
     717/     64C :                     ;$$function end$$ _delay
     718/     64C :                     ;$$function start$$ _olduinoincluder
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 13 - 1/28/2018 16:05:51


     719/     64C :                     _olduinoincluder:		;framesize=2
     720/     64C :                     ;void olduinoincluder(){
     721/     64C :                     ;	asm("\tinclude olduino.inc\n");
     722/     64C :                     	include olduino.inc
(1)    1/     64C :                     ;Feb 8 2013, first version of assembler routines for olduino support	
(1)    2/     64C :                     ;may 31 - incredibly, there's an error in digitalWrite.  lda2 changed to ldAD
(1)    3/     64C :                     ;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
(1)    4/     64C :                     	align 64	;needed to make sure all on same page
(1)    5/     680 :                     _digitalWrite:
(1)    6/     680 : 8C                  	glo regArg1	;get the bit number
(1)    7/     681 : FC 9E               	adi $$bvtable&255	;add the table offset
(1)    8/     683 : AE                  	plo memaddr
(1)    9/     684 : 93                  	ghi RPC		;get the top byte of the current page
(1)   10/     685 : BE                  	phi memaddr	
(1)   11/     686 : 0E                  	ldn memaddr	;pick up the bit pattern
(1)   12/     687 : A8                  	plo rt1		;save it in a temp
(1)   13/     688 : (MACRO)             	ldAD memaddr,_PIN4 ;address the current port value
(1)   14/     68C : EE                  	sex memaddr	;prepare to change it
(1)   15/     68D : 8D                  	glo regArg2	;get on/off switch
(1)   16/     68E : 32 95               	bz $$setbitoff
(1)   17/     690 :                     ; here we have the bit pattern in rt1 and we're ready to apply it with OR
(1)   18/     690 : 88                  	glo rt1		;get the bit value back
(1)   19/     691 : F1                  	or		;apply it
(1)   20/     692 : 5E                  	str memaddr	;and save it
(1)   21/     693 : 30 9A               	br $$outit	;go fnish up
(1)   22/     695 :                     $$setbitoff:
(1)   23/     695 : 88                  	glo rt1		;get the bit pattern
(1)   24/     696 : FB FF               	xri 0xff	;reverse it
(1)   25/     698 : F2                  	and		;combine it with the existing pin value
(1)   26/     699 : 5E                  	str memaddr	;and save it
(1)   27/     69A :                     ;here we gave set/reset the correct bit in PIN4 and we just have to send it out
(1)   28/     69A :                     $$outit:
(1)   29/     69A : 64                  	out 4		;X was already set to memaddr
(1)   30/     69B : E2                  	sex sp		;reset X
(1)   31/     69C : (MACRO)             	cretn
(1)   32/     69E : 01 02 04 08 10 20   $$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
                    40 80 
(1)   33/     6A6 :                     ;int digitalRead(unsigned char pin){//for now this will always read ef3
(1)   34/     6A6 :                     	align 8	;protect jump boundary
(1)   35/     6A8 :                     _digitalRead:
(1)   36/     6A8 : F8 00               	ldi 0		;default is false
(1)   37/     6AA : AF                  	plo R15
(1)   38/     6AB : BF                  	phi R15
(1)   39/     6AC : 36 AF               	b3 +		;i have to reverse the sense of the external line
(1)   40/     6AE : 1F                  	inc R15		;if external line is high, supply a 1
(1)   41/     6AF : (MACRO)             +	cretn
(1)   42/     6B1 :                     
     723/     6B1 :                     ;}
     724/     6B1 :                     L74:
     725/     6B1 : (MACRO)             	Cretn
     726/     6B3 :                     
     727/     6B3 :                     ;$$function end$$ _olduinoincluder
     728/     6B3 :                     ;$$function start$$ _boydinc
     729/     6B3 :                     _boydinc:		;framesize=2
     730/     6B3 :                     ;void boydinc(){
     731/     6B3 :                     ;	asm(" align 256\n");
     732/     6B3 :                     ;	asm(" include \"boydscan.inc\"\n");
     733/     6B3 :                      align 256
     734/     700 :                      include "boydscan.inc"
(1)    1/     700 :                     _boydscan:			;SCAN THE KEYBOARD
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(boydscan.inc) - page 14 - 1/28/2018 16:05:51


(1)    2/     700 : EE                  		sex	r14 	;set up "don't care" X register
(1)    3/     701 : 68 CF 00 00         		rldi	r15,0	; r15 is return value
(1)    4/     705 : 61                  .scan:		OUT	1                     ;109: 61 	
(1)    5/     706 : 34 4C               		B1	.KEY_12                     ;10A: 34 50 	
(1)    6/     708 : 35 5C               		B2	.KEY_8                      ;10C: 35 60 	
(1)    7/     70A : 36 6C               		B3	.KEY_4                      ;10E: 36 70 	
(1)    8/     70C : 37 7C               		B4	.KEY_0                      ;110: 37 80 	
(1)    9/     70E : 62                  		OUT	2                     ;112: 62 	
(1)   10/     70F : 34 50               		B1	.KEY_13                     ;113: 34 54 	
(1)   11/     711 : 35 60               		B2	.KEY_9                      ;115: 35 64 	
(1)   12/     713 : 36 70               		B3	.KEY_5                      ;117: 36 74 	
(1)   13/     715 : 37 80               		B4	.KEY_1                      ;119: 37 84 	
(1)   14/     717 : 63                  		OUT	3                     ;11B: 63 	
(1)   15/     718 : 34 54               		B1	.KEY_14                     ;11C: 34 58 	
(1)   16/     71A : 35 64               		B2	.KEY_10                     ;11E: 35 68 	
(1)   17/     71C : 36 74               		B3	.KEY_6                      ;120: 36 78 	
(1)   18/     71E : 37 84               		B4	.KEY_2                      ;122: 37 88 	
(1)   19/     720 : 64                  		OUT	4                     ;124: 64 	
(1)   20/     721 : 34 58               		B1	.KEY_15                     ;125: 34 5C 	
(1)   21/     723 : 35 68               		B2	.KEY_11                     ;127: 35 6C 	
(1)   22/     725 : 36 78               		B3	.KEY_7                      ;129: 36 7C 	
(1)   23/     727 : 37 88               		B4	.KEY_3                      ;12B: 37 8C 	
(1)   24/     729 : 65                  		OUT	5                     ;12D: 65 	
(1)   25/     72A : 34 A8               		B1	.KEY_DIV_WHOLE              ;12E: 34 99 	
(1)   26/     72C : 35 94               		B2	.KEY_MUL                    ;130: 35 96 	
(1)   27/     72E : 36 90               		B3	.KEY_SUB                    ;132: 36 93 	
(1)   28/     730 : 37 8C               		B4	.KEY_ADD                    ;134: 37 90 	
(1)   29/     732 : 66                  		OUT	6                     ;136: 66 	
(1)   30/     733 : 34 9C               		B1	.KEY_REM                    ;137: 34 A5 	
(1)   31/     735 : 35 98               		B2	.KEY_MEM_STORE              ;139: 35 A2 	
(1)   32/     737 : 36 A8               		B3	.KEY_MEM_RECALL             ;13B: 36 9F 	
(1)   33/     739 : 37 A8               		B4	.KEY_EQU                    ;13D: 37 9C 	
(1)   34/     73B : 7B                  		SEQ                                ;13F: 7B 	
(1)   35/     73C : 34 A7               		B1	.KEY_DIV_FIS                ;140: 34 B1 	
(1)   36/     73E : 35 A0               		B2	.KEY_CLEAR                  ;142: 35 AE 	
(1)   37/     740 : 36 A6               		B3	.KEY_CLR_ENTRY              ;144: 36 AB 	
(1)   38/     742 : 37 A5               		B4	.KEY_INV_SIGN               ;146: 37 A8 	
(1)   39/     744 : 7A                  		REQ                                ;148: 7A 	
(1)   40/     745 :                     ;here we have no keys pressed, if r15.0 has a value, return it -1
(1)   41/     745 : 8F                  		glo	r15
(1)   42/     746 : 32 05               		bz	.scan
(1)   43/     748 : 2F                  		dec	r15
(1)   44/     749 : E2                  		sex	r2	;restore the X register before returning
(1)   45/     74A : (MACRO)             		cretn
(1)   46/     74C :                     
(1)   47/     74C : F8 0D               .KEY_12		LDI	13                         ;150: F8  C 	
(1)   48/     74E : 30 A8               		BR	.KEY_SAVE                   ;152: 30 B4 	
(1)   49/     750 : F8 0E               .KEY_13		LDI	14                         ;154: F8  D 	
(1)   50/     752 : 30 A8               		BR	.KEY_SAVE                   ;156: 30 B4 	
(1)   51/     754 : F8 0F               .KEY_14		LDI	15                         ;158: F8  E 	
(1)   52/     756 : 30 A8               		BR	.KEY_SAVE                   ;15A: 30 B4 	
(1)   53/     758 : F8 10               .KEY_15		LDI	16                         ;15C: F8  F 	
(1)   54/     75A : 30 A8               		BR	.KEY_SAVE                   ;15E: 30 B4 	
(1)   55/     75C : F8 09               .KEY_8		LDI	 9                         ;160: F8  8 	
(1)   56/     75E : 30 A8               		BR	.KEY_SAVE                   ;162: 30 B4 	
(1)   57/     760 : F8 0A               .KEY_9		LDI	 10                         ;164: F8  9 	
(1)   58/     762 : 30 A8               		BR	.KEY_SAVE                   ;166: 30 B4 	
(1)   59/     764 : F8 0B               .KEY_10		LDI	11                         ;168: F8  A 	
(1)   60/     766 : 30 A8               		BR	.KEY_SAVE                   ;16A: 30 B4 	
(1)   61/     768 : F8 0C               .KEY_11		LDI	12                         ;16C: F8  B 	
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(boydscan.inc) - page 15 - 1/28/2018 16:05:51


(1)   62/     76A : 30 A8               		BR	.KEY_SAVE                   ;16E: 30 B4 	
(1)   63/     76C : F8 05               .KEY_4		LDI	 5                         ;170: F8  4 	
(1)   64/     76E : 30 A8               		BR	.KEY_SAVE                   ;172: 30 B4 	
(1)   65/     770 : F8 06               .KEY_5		LDI	 6                         ;174: F8  5 	
(1)   66/     772 : 30 A8               		BR	.KEY_SAVE                   ;176: 30 B4 	
(1)   67/     774 : F8 07               .KEY_6		LDI	 7                         ;178: F8  6 	
(1)   68/     776 : 30 A8               		BR	.KEY_SAVE                   ;17A: 30 B4 	
(1)   69/     778 : F8 08               .KEY_7		LDI	 8                         ;17C: F8  7 	
(1)   70/     77A : 30 A8               		BR	.KEY_SAVE                   ;17E: 30 B4 	
(1)   71/     77C : F8 01               .KEY_0		LDI	 1                         ;180: F8  0 	
(1)   72/     77E : 30 A8               		BR	.KEY_SAVE                   ;182: 30 B4 	
(1)   73/     780 : F8 02               .KEY_1		LDI	 2                         ;184: F8  1 	
(1)   74/     782 : 30 A8               		BR	.KEY_SAVE                   ;186: 30 B4 	
(1)   75/     784 : F8 03               .KEY_2		LDI	 3                         ;188: F8  2 	
(1)   76/     786 : 30 A8               		BR	.KEY_SAVE                   ;18A: 30 B4 	
(1)   77/     788 : F8 04               .KEY_3		LDI	 4                         ;18C: F8  3 	
(1)   78/     78A : 30 A8               		BR	.KEY_SAVE                   ;18E: 30 B4 	
(1)   79/     78C :                     		
(1)   80/     78C : F8 11               .KEY_ADD	ldi	16+1
(1)   81/     78E : 30 A8               		br	.key_save
(1)   82/     790 : F8 12               .KEY_SUB:	ldi	17+1
(1)   83/     792 : 30 A8               		br	.key_save
(1)   84/     794 : F8 15               .KEY_MUL:	ldi	20+1
(1)   85/     796 : 30 A8               		br	.key_save
(1)   86/     798 : F8 14               .KEY_MEM_STORE:	ldi	19+1
(1)   87/     79A : 30 A8               		br	.key_save
(1)   88/     79C :                     
(1)   89/     79C : F8 13               .KEY_REM:	ldi	18+1
(1)   90/     79E : 30 A8               		br	.key_save
(1)   91/     7A0 : 7A                  .KEY_CLEAR:	req
(1)   92/     7A1 : F8 15               		ldi	20+1
(1)   93/     7A3 : 30 A8               		br	.key_save
(1)   94/     7A5 : 7A                  .KEY_INV_SIGN:	req
(1)   95/     7A6 : 7A                  .KEY_CLR_ENTRY:	req
(1)   96/     7A7 : 7A                  .KEY_DIV_FIS:	req
(1)   97/     7A8 :                     .KEY_EQU:
(1)   98/     7A8 :                     .KEY_DIV_WHOLE:
(1)   99/     7A8 :                     .KEY_MEM_RECALL:
(1)  100/     7A8 : AF                  .KEY_SAVE:	plo 15
(1)  101/     7A9 : 30 05               		br .scan
     735/     7AB :                     ;}
     736/     7AB :                     L76:
     737/     7AB : (MACRO)             	Cretn
     738/     7AD :                     
     739/     7AD :                     ;$$function end$$ _boydinc
     740/     7AD :                     L53:
     741/     7AD : 30                  	db 48
     742/     7AE : 31                  	db 49
     743/     7AF : 32                  	db 50
     744/     7B0 : 33                  	db 51
     745/     7B1 : 34                  	db 52
     746/     7B2 : 35                  	db 53
     747/     7B3 : 36                  	db 54
     748/     7B4 : 37                  	db 55
     749/     7B5 : 00                  	db 0
     750/     7B6 :                     L52:
     751/     7B6 : 42                  	db 66
     752/     7B7 : 41                  	db 65
     753/     7B8 : 52                  	db 82
     754/     7B9 : 52                  	db 82
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 16 - 1/28/2018 16:05:51


     755/     7BA : 59                  	db 89
     756/     7BB : 00                  	db 0
     757/     7BC :                     	include lcc1802epiloNW.inc
(1)    1/     7BC :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/     7BC :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/     7BC :                     ;this is the version published with the lcc1802121229 release
(1)    4/     7BC :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/     7BC :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/     7BC :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/     7BC :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/     7BC :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/     7BC :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/     7BC :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/     7BC :                     ;feb 27 changed stack to start at 7fff
(1)   12/     7BC :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/     7BC :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/     7BC :                     ;april 4 adding digit count argument to dubdabx
(1)   15/     7BC :                     ;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
(1)   16/     7BC :                     ;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
(1)   17/     7BC :                     ;16-09-20 allow stack relocation 
(1)   18/     7BC :                     ;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
(1)   19/     7BC :                     ;17-03-07 adjusting stack offset for 1805/6 stack discipline
(1)   20/     7BC :                     ;17-03-13 protecting work areas in divi2,divi4 routines from 1806 SCAL
(1)   21/     7BC :                     ;17-03-15 onems compensates for reduced subroutine overhead in 1806
(1)   22/     7BC :                     ;17-04-09 don't include call/return for 1806
(1)   23/     7BC :                     ;17-10-17 SCRT routines changed to clean stack model i.e. push is stxd stxd, pop is inc lda inc ldn
(1)   24/     7BC :                     ;17-10-19 using CPUSPEED instead of LCC1802CPUSPEED, also STACKLOC instead of LCCSTACKLOC
(1)   25/     7BC :                     ;17-10-23 extending work area protection from 10-13 above for 1802 as well as 1805
(1)   26/     7BC :                     ;17-11-25 conditional include for register saves
(1)   27/     7BC :                     ;18-01-28 changed onems() to always use 4 instruction loop, accommodate slower CPU speed
(1)   28/     7BC : =EH                 rwork	equ	memAddr	;work register
(1)   29/     7BC :                     lcc1802init:
(1)   30/     7BC : =>UNDEFINED           IFDEF SAVEREGS
(1)   31/     7BC :                         include "saveregs.inc"
(1)   32/     7BC : [30]                  ENDIF
(1)   33/     7BC : =>FALSE               IF    MOMCPU<>$1805		;for 1806 use SCAL 
(1)   34/     7BC :                     	ldiReg	RCALL,_call
(1)   35/     7BC :                     	ldiReg	RRET,_return
(1)   36/     7BC : =>TRUE                ELSE
(1)   37/     7BC : (MACRO)             	ldiReg	RCALL,$$_die; _call
(1)   38/     7C0 : (MACRO)             	ldiReg	RRET,$$_die; _return
(1)   39/     7C4 : [33]                  ENDIF
(1)   40/     7C4 : =>DEFINED             IFNDEF  STACKLOC		;wjr 16-09-20 allow stack relocation
(1)   41/     7C4 :                     	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1 as default
(1)   42/     7C4 : =>TRUE                ELSEIF				;wjr 16-09-20
(1)   43/     7C4 : (MACRO)             	ldiReg	SP,STACKLOC	;wjr 16-09-20 start stack as specified
(1)   44/     7C8 : [40]                  ENDIF				;wjr 16-09-20
(1)   45/     7C8 : E2                  	sex	SP
(1)   46/     7C9 : (MACRO)             	ldiReg	RPC,$$_00000
(1)   47/     7CD : D3                  	sep	RPC
(1)   48/     7CE :                     $$_00000:
(1)   49/     7CE : (MACRO)             	Ccall _main	;call the main routine
(1)   50/     7D2 : C0 07 D2            $$_die:	lbr	$$_die		;loop here when main returns
(1)   51/     7D5 : DE AD               	db	0xde,0xad
(1)   52/     7D7 :                     
(1)   53/     7D7 :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   54/     7D7 :                     _setqOn:
(1)   55/     7D7 : 7B                  	seq
(1)   56/     7D8 : (MACRO)             	Cretn
(1)   57/     7DA :                     _setqOff:
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(lcc1802epiloNW.inc) - page 17 - 1/28/2018 16:05:51


(1)   58/     7DA : 7A                  	req
(1)   59/     7DB : (MACRO)             	Cretn
(1)   60/     7DD : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math
(1)   61/     7DD :                     _modU2:	;16 bit unsigned remainder
(1)   62/     7DD :                     	; just calls the 16 bit division then puts remainder into return value
(1)   63/     7DD : (MACRO)                 Ccall _divU2
(1)   64/     7E1 : 8C                      glo regArg1
(1)   65/     7E2 : AF                      plo retVal
(1)   66/     7E3 : 9C                      ghi regArg1
(1)   67/     7E4 : BF                      phi retVal
(1)   68/     7E5 : (MACRO)                 Cretn
(1)   69/     7E7 :                         
(1)   70/     7E7 :                     _modI2:	;16 bit signed remainder
(1)   71/     7E7 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   72/     7E7 : (MACRO)                 Ccall _divI2
(1)   73/     7EB : 8C                      glo regArg1
(1)   74/     7EC : AF                      plo retVal
(1)   75/     7ED : 9C                      ghi regArg1
(1)   76/     7EE : BF                      phi retVal
(1)   77/     7EF : (MACRO)                 Cretn
(1)   78/     7F1 : [60]                 ENDIF
(1)   79/     7F1 :                     _out4:	
(1)   80/     7F1 : 8C                  	glo	regArg1
(1)   81/     7F2 : 22                  	dec	sp
(1)   82/     7F3 : 52                  	str	sp
(1)   83/     7F4 : 64                  	out	4
(1)   84/     7F5 : (MACRO)             	Cretn
(1)   85/     7F7 :                     
(1)   86/     7F7 :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   87/     7F7 : =>FALSE               if MOMCPU<>$1805		;for 1806 use SCAL
(1)   88/     7F7 :                     	align 16
(1)   89/     7F7 :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)   90/     7F7 :                     	sep     R3 ;go to subroutine
(1)   91/     7F7 :                     _call	sex	SP ;make sure X=SP
(1)   92/     7F7 :                     	glo	retAddr ;save previous return pointer on stack
(1)   93/     7F7 :                     	stxd
(1)   94/     7F7 :                     	ghi	retAddr
(1)   95/     7F7 :                     	stxd	
(1)   96/     7F7 :                     	glo	RPC ;copy old PC to retAddr
(1)   97/     7F7 :                     	plo	retAddr
(1)   98/     7F7 :                     	ghi	RPC
(1)   99/     7F7 :                     	phi	retAddr
(1)  100/     7F7 :                     	lda	retAddr ;pick up subroutine address into RPC
(1)  101/     7F7 :                     	phi	RPC
(1)  102/     7F7 :                     	lda	retAddr
(1)  103/     7F7 :                     	plo	RPC
(1)  104/     7F7 :                     	br	_call-1
(1)  105/     7F7 :                     
(1)  106/     7F7 :                     ;Standard subroutine return 
(1)  107/     7F7 :                     	align 16
(1)  108/     7F7 :                     	sep	RPC	;return to the original program
(1)  109/     7F7 :                     _return	glo	retAddr	;transfer the current return address to RPC
(1)  110/     7F7 :                     	plo	RPC
(1)  111/     7F7 :                     	ghi	retAddr
(1)  112/     7F7 :                     	phi	RPC
(1)  113/     7F7 :                     	inc 	SP
(1)  114/     7F7 :                     	lda	SP	;pick up old return address
(1)  115/     7F7 :                     	phi	retAddr
(1)  116/     7F7 :                     	ldn	SP
(1)  117/     7F7 :                     	plo	retAddr
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(lcc1802epiloNW.inc) - page 18 - 1/28/2018 16:05:51


(1)  118/     7F7 :                     	br	_return-1
(1)  119/     7F7 : [87]                 ENDIF
(1)  120/     7F7 :                     	align 8
(1)  121/     7F8 :                     _oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
(1)  122/     7F8 :                     ;subroutine overhead soaks up 27 instruction time.
(1)  123/     7F8 :                     ;each loop is 2 instruction times
(1)  124/     7F8 :                     ;so the number of loops needed is 
(1)  125/     7F8 :                     ;CPU speed/16000 less the 27 all divide by two
(1)  126/     7F8 : =>DEFINED           	IFNDEF	CPUSPEED
(1)  127/     7F8 :                     CPUSPEED EQU 1600000	;1.6MHZ default
(1)  128/     7F8 : [126]               	ENDIF
(1)  129/     7F8 : =>TRUE               if MOMCPU=$1805		;for 1806 SCAL
(1)  130/     7F8 : =EH                 SUBOVHD  EQU 14		;1806 SCAL/SRET subroutine overhead
(1)  131/     7F8 : =>FALSE              else
(1)  132/     7F8 :                     SUBOVHD  EQU 27		;default SCRT subroutine overhead
(1)  133/     7F8 : [129]                endif 
(1)  134/     7F8 : =>FALSE                   IF (CPUSPEED/16000)>=(SUBOVHD+4);fast enough to need more than subroutine overhead
(1)  135/     7F8 :                     	ldi	(CPUSPEED/1000/16-SUBOVHD)/4
(1)  136/     7F8 :                     $$mslf:	smi	1
(1)  137/     7F8 :                     	sex	2
(1)  138/     7F8 :                     	sex	2
(1)  139/     7F8 :                     	bnz	$$mslf
(1)  140/     7F8 : [134]                 ENDIF
(1)  141/     7F8 : (MACRO)             	Cretn
(1)  142/     7FA :                     
(1)  143/     7FA :                     
(1)  144/     7FA : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math	
(1)  145/     7FA :                     	align 256
(1)  146/     800 :                     ;16 bit right shifting multiply which is faster for smaller operands
(1)  147/     800 :                     ; credit to http://map.grauw.nl/articles/mult_div_shifts.php#lrmultr
(1)  148/     800 :                     _mulU2:		;retval(product)=regarg1(multiplicand)*regarg2(multiplier)
(1)  149/     800 : (MACRO)             	ld2z retval
(1)  150/     804 :                     $$mulrlp:
(1)  151/     804 : (MACRO)             	shru2 regarg2
(1)  152/     80A : 3B 16               	bnf $$mulrnoadd
(1)  153/     80C :                     ;	bottom bit of multiplier is one so add multiplicand to product
(1)  154/     80C : (MACRO)             	alu2 retval,retval,regarg1,add,adc
(1)  155/     816 :                     $$mulrnoadd:
(1)  156/     816 : 9D                  	ghi regarg2	;check for all bits of multiplier shifted out
(1)  157/     817 : 3A 1C               	bnz $$mulrshft	;nope, continue
(1)  158/     819 : 8D                  	glo regarg2	;check bottom byte
(1)  159/     81A : 32 24               	bz $$mulrdone
(1)  160/     81C :                     $$mulrshft:
(1)  161/     81C : (MACRO)             	shl2 regarg1	;shift multiplicand left 1
(1)  162/     822 : 30 04               	br $$mulrlp
(1)  163/     824 :                     $$mulrdone:		;here the product is in retval
(1)  164/     824 : (MACRO)             	cretn
(1)  165/     826 :                     
(1)  166/     826 :                     ;this is a divisor shifting algorithm which is faster for smaller operands
(1)  167/     826 :                     ;credit to http://research.microsoft.com/pubs/70645/tr-2008-141.pdf
(1)  168/     826 :                     ;changed oct 12 to save R10 & 1/2 R11 on stack
(1)  169/     826 :                     _divu2: ;retval=regarg1(x or dividend)/regarg2(y or divisor)
(1)  170/     826 :                     	;uses R14(rwork) to hold original divisor y0, 
(1)  171/     826 :                     	;regarg1 to hold develop remainder, 
(1)  172/     826 :                     	;R10 to hold working dividend R11.0 as a temp
(1)  173/     826 :                     testsub: macro reg1,reg2	;test subtraction of reg2 from reg1
(1)  174/     826 :                     				;result in D, rwork.hi, DF
(1)  175/     826 :                     	glo reg2
(1)  176/     826 :                     	str sp
(1)  177/     826 :                     	glo reg1
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(lcc1802epiloNW.inc) - page 19 - 1/28/2018 16:05:51


(1)  178/     826 :                     	sm
(1)  179/     826 :                     	plo R11
(1)  180/     826 :                     	ghi reg2
(1)  181/     826 :                     	str sp
(1)  182/     826 :                     	ghi reg1
(1)  183/     826 :                     	smb
(1)  184/     826 :                     	endm
(1)  185/     826 :                     	
(1)  186/     826 :                     ;	pushf R10	;save R10 & leave stack down 1
(1)  187/     826 : (MACRO)             	pushr R10	;default push leaves stack clean
(1)  188/     828 : 8B                  	glo R11		;and bottom
(1)  189/     829 : 73                  	stxd		;of R11 - leaves stack clear of work area
(1)  190/     82A : (MACRO)             	cpy2 R10,regarg1
(1)  191/     82E : (MACRO)             	ld2z retval	;quotient
(1)  192/     832 : (MACRO)             	cpy2 rwork,regarg2
(1)  193/     836 :                     	
(1)  194/     836 : (MACRO)             	testsub R10,regarg2
(1)  195/     83F : 3B 5A               	bnf $$computequot	;DF=0 means it didn't fit
(1)  196/     841 : BA                  	phi R10	;R10=R10-regarg2
(1)  197/     842 : 8B                  	glo R11
(1)  198/     843 : AA                  	plo R10
(1)  199/     844 :                     	
(1)  200/     844 :                     $$again:	;this is the divisor doubling phase
(1)  201/     844 : (MACRO)              	testsub R10,regarg2
(1)  202/     84D : 3B 5A                	bnf $$computequot	;df=0 means it didn't fit
(1)  203/     84F : BA                  	phi R10	;R10=R10-regarg2
(1)  204/     850 : 8B                  	glo R11
(1)  205/     851 : AA                  	plo R10 	
(1)  206/     852 : (MACRO)              	shl2 regarg2	;y=y+y
(1)  207/     858 : 30 44                	br $$again
(1)  208/     85A :                      	
(1)  209/     85A :                      $$computequot:	;here we're computing the quotient
(1)  210/     85A : (MACRO)              	testsub regarg1,regarg2
(1)  211/     863 : 3B 69                	bnf $$testexit
(1)  212/     865 : BC                   	phi regarg1		;complete the subtraction
(1)  213/     866 : 8B                   	glo R11
(1)  214/     867 : AC                   	plo regarg1
(1)  215/     868 : 1F                   	inc retval
(1)  216/     869 :                      $$testexit:
(1)  217/     869 : 9E                   	ghi rwork
(1)  218/     86A : F7                   	sm	;top of regarg2 is still on stack
(1)  219/     86B : 3A 73                	bnz $$ney0y
(1)  220/     86D : 8D                   	glo regarg2
(1)  221/     86E : 52                   	str sp
(1)  222/     86F : 8E                   	glo rwork
(1)  223/     870 : F7                   	sm	;test low order bytes
(1)  224/     871 : 32 81                	bz	$$out	;if = we're done
(1)  225/     873 :                      $$ney0y:
(1)  226/     873 : (MACRO)              	shl2 retval	;double quotient
(1)  227/     879 : (MACRO)              	shrU2 regarg2	;halve divisor
(1)  228/     87F : 30 5A                	br $$computequot	;continue
(1)  229/     881 :                      $$out:
(1)  230/     881 :                      ;here the quotient is in retval, remainder in regarg1
(1)  231/     881 : 12                    	inc sp	;release work area
(1)  232/     882 : 02                  	ldn sp	;recover
(1)  233/     883 : AB                  	plo R11	;bottom byte of R11
(1)  234/     884 : (MACRO)             	popr R10 ;and all of R10
(1)  235/     889 : (MACRO)             	cretn	;and we're done
(1)  236/     88B :                     
(1)  237/     88B :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(lcc1802epiloNW.inc) - page 20 - 1/28/2018 16:05:51


(1)  238/     88B :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  239/     88B :                     _divI2:
(1)  240/     88B : 22                      dec	sp	;leave a work area available
(1)  241/     88C : 9C                      ghi regArg1
(1)  242/     88D : 52                      str sp	;save the sign of the 1st arg
(1)  243/     88E : FE                      shl
(1)  244/     88F : 3B 9A                   bnf $$pos1	;if the 1st arg is -v
(1)  245/     891 : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
(1)  246/     89A :                     $$pos1: ;1st is now +v, check 2nd
(1)  247/     89A : 9D                      ghi regArg2
(1)  248/     89B : F3                      xor	
(1)  249/     89C : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  250/     89D : 9D                      ghi regArg2
(1)  251/     89E : FE                      shl
(1)  252/     89F : 3B AA                   bnf $$pos2	;if the 2nd arg is -v
(1)  253/     8A1 : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  254/     8AA :                     $$pos2: ; both args now +v
(1)  255/     8AA : 22                      dec sp	;protect workarea on the 1802
(1)  256/     8AB : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  257/     8AF : 12                      inc sp	;recover work area
(1)  258/     8B0 :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  259/     8B0 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  260/     8B1 : FE                      shl
(1)  261/     8B2 : 3B BD                   bnf $$done ;if the signs were different
(1)  262/     8B4 : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  263/     8BD :                     $$done:
(1)  264/     8BD : (MACRO)                 Cretn ;and we're done - I hope!
(1)  265/     8BF : [144]                ENDIF
(1)  266/     8BF : =>UNDEFINED          IFNDEF  LCCNOLONG		;wjr 17-04-09 disable 32 bit math
(1)  267/     8BF :                     	align 256    ;32 bit operations follow
(1)  268/     900 :                     _divu4:
(1)  269/     900 :                     ;This is an unsigned 32 bit restoring division
(1)  270/     900 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  271/     900 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  272/     900 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  273/     900 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  274/     900 :                     
(1)  275/     900 : F8 20               	ldi 32		;set loop count
(1)  276/     902 : AE                  	plo memaddr	;in temp register
(1)  277/     903 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  278/     90F :                     $$loop:
(1)  279/     90F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  280/     91B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  281/     927 :                     
(1)  282/     927 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  283/     93D :                     
(1)  284/     93D : FA 80               	ani 0x80	;check the top bit
(1)  285/     93F : 32 5D               	bz $$norestore	;if it's 0
(1)  286/     941 : 89                  		glo RL8
(1)  287/     942 : FA FE               		ani 0xfe	;turn off the bottom bit
(1)  288/     944 : A9                  		plo RL8
(1)  289/     945 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  290/     95B : 30 61               	br $$endlp 	;else
(1)  291/     95D :                     $$norestore:
(1)  292/     95D : 89                  		glo RL8
(1)  293/     95E : F9 01               		ori 1	;turn on the bottom bit
(1)  294/     960 : A9                  		plo RL8
(1)  295/     961 :                     	;end if
(1)  296/     961 :                     $$endlp:
(1)  297/     961 : 2E                  	dec memaddr	;check the cycle count
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(lcc1802epiloNW.inc) - page 21 - 1/28/2018 16:05:51


(1)  298/     962 : 8E                  	glo memaddr
(1)  299/     963 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  300/     965 :                     	
(1)  301/     965 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  302/     967 :                     		
(1)  303/     967 :                     
(1)  304/     967 :                     _mulu4:
(1)  305/     967 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  306/     967 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  307/     967 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  308/     967 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  309/     967 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  310/     967 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  311/     967 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  312/     967 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  313/     967 :                     	;for 10 we subtract and shift
(1)  314/     967 :                     	;for 00 and 11 we just shift
(1)  315/     967 :                     
(1)  316/     967 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  317/     973 : F8 20                   ldi 32
(1)  318/     975 : AE                      plo memaddr		;cycle count
(1)  319/     976 : FC 00                   adi 0		;clear df
(1)  320/     978 :                     $$mloop:
(1)  321/     978 : 89                      glo RL8
(1)  322/     979 : FA 01                   ani 1		;isolate bottom bit of result
(1)  323/     97B : 3B 97                   bnf	$$check_sub	;
(1)  324/     97D : 3A AF                   bnz	$$shift		;that would be the 11 case
(1)  325/     97F :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  326/     97F : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  327/     995 : 30 AF                   br $$shift
(1)  328/     997 :                     $$check_sub:
(1)  329/     997 : 32 AF                   bz $$shift	;that would be the 00 case
(1)  330/     999 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  331/     999 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  332/     9AF :                     $$shift:
(1)  333/     9AF : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  334/     9BD : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  335/     9C9 :                     
(1)  336/     9C9 : 2E                      dec memaddr		;cycle count
(1)  337/     9CA : 8E                      glo memaddr
(1)  338/     9CB : 3A 78                   bnz $$mloop		;repeat cycle once for each bit position
(1)  339/     9CD :                         
(1)  340/     9CD : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  341/     9CF :                     
(1)  342/     9CF :                     	align 256
(1)  343/     A00 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  344/     A00 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  345/     A00 :                     _divI4:
(1)  346/     A00 : 22                      dec	sp	;leave a work area available
(1)  347/     A01 : 98                      ghi RL8-1	;get the top of the dividend
(1)  348/     A02 : 52                      str sp	;save the sign of the 1st arg
(1)  349/     A03 : FE                      shl
(1)  350/     A04 : 3B 26                   bnf $$pos1	;if the 1st arg is -v
(1)  351/     A06 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  352/     A26 :                     $$pos1: ;1st is now +v, check 2nd
(1)  353/     A26 : 9A                      ghi RL10-1
(1)  354/     A27 : F3                      xor	
(1)  355/     A28 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  356/     A29 : 9A                      ghi RL10-1
(1)  357/     A2A : FE                      shl
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(lcc1802epiloNW.inc) - page 22 - 1/28/2018 16:05:51


(1)  358/     A2B : 3B 4D                   bnf $$pos2	;if the 2nd arg is -v
(1)  359/     A2D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  360/     A4D :                     $$pos2: ; both args now +v
(1)  361/     A4D : 22                      dec sp	;protect workarea on the 1802
(1)  362/     A4E : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  363/     A52 : 12                      inc sp	;recover work area
(1)  364/     A53 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  365/     A53 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  366/     A54 : FE                      shl
(1)  367/     A55 : 3B 77                   bnf $$done ;if the signs were different
(1)  368/     A57 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  369/     A77 :                     $$done:
(1)  370/     A77 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  371/     A79 : [266]                ENDIF
(1)  372/     A79 : =>UNDEFINED          IFNDEF  LCCNOMATH		;wjr 17-04-09 disable 16 bit math
(1)  373/     A79 :                     _dubdabx:	
(1)  374/     A79 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  375/     A79 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  376/     A79 :                     ;long interger is passed in rp1p2
(1)  377/     A79 :                     ;buffer pointer is passed at sp+2+4**+1 for 1806
(1)  378/     A79 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
(1)  379/     A79 :                     ;r8-11 are used as temps
(1)  380/     A79 :                     ;r8 is the working pointer
(1)  381/     A79 :                     ;r15.0 is bit count(32) and the return value register
(1)  382/     A79 :                     ;r9.0 is digit count
(1)  383/     A79 :                     ;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
(1)  384/     A79 : (MACRO)             	ld2 r8,'O',sp,(2+4+1); pick up the buffer pointer
(1)  385/     A85 : (MACRO)             	ld2 r10,'O',sp,(2+4+2+1); pick up the number of digits wanted
(1)  386/     A91 : (MACRO)             	cpy2 r15,r8 ;save address for now
(1)  387/     A95 : F8 0B               	ldi 11	;digit count+1 for trailing 0
(1)  388/     A97 : A9                  	plo r9
(1)  389/     A98 :                     $$clrlp:	;clear the passed buffer
(1)  390/     A98 : F8 00               	ldi 0	
(1)  391/     A9A : 58                  	str r8	;clear a byte
(1)  392/     A9B : 18                  	inc r8
(1)  393/     A9C : 29                  	dec r9
(1)  394/     A9D : 89                  	glo r9	;check the count
(1)  395/     A9E : 3A 98               	bnz $$clrlp ;back for more
(1)  396/     AA0 : (MACRO)             	cpy2 r8,r15 ;get the address back
(1)  397/     AA4 :                     
(1)  398/     AA4 : F8 20               	ldi 32	;bit count
(1)  399/     AA6 : AF                  	plo r15
(1)  400/     AA7 :                     ;now i'm going to spin off any leading 0's in the binary number
(1)  401/     AA7 :                     $$cktop:
(1)  402/     AA7 : 9C                  	ghi rp1p2-1	;get the top bit of the number
(1)  403/     AA8 : FE                  	shl		;check for a 1
(1)  404/     AA9 : 33 BC               	bdf $$bitloop	;move on if we have one
(1)  405/     AAB : (MACRO)             	shl4 rp1p2	;shift the input number
(1)  406/     AB7 : 2F                  	dec r15		;reduce the number of times to shift
(1)  407/     AB8 : 8F                  	glo r15
(1)  408/     AB9 : 3A A7               	bnz $$cktop	;
(1)  409/     ABB : 1F                  	inc r15		;our whole number was 0 but force at least one pass
(1)  410/     ABC :                     $$bitloop:
(1)  411/     ABC : F8 0A               	ldi 10	;digit count
(1)  412/     ABE : A9                  	plo r9
(1)  413/     ABF :                     $$dcklp:
(1)  414/     ABF : 08                  	ldn r8 	;pick up a digit
(1)  415/     AC0 : FF 05               	smi 5	;see if it's greater than 4
(1)  416/     AC2 : 3B C7               	bnf $$dnoadd ;if not, bypass add
(1)  417/     AC4 : FC 08               	adi 0x08	;add the 5 black and 3 more
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(lcc1802epiloNW.inc) - page 23 - 1/28/2018 16:05:51


(1)  418/     AC6 : 58                  	str r8	;put it back
(1)  419/     AC7 :                     $$dnoadd:
(1)  420/     AC7 : 18                  	inc r8
(1)  421/     AC8 : 29                  	dec r9	;decrement digit count
(1)  422/     AC9 : 89                  	glo r9
(1)  423/     ACA : 3A BF               	bnz $$dcklp ;and back for next digit
(1)  424/     ACC :                     	
(1)  425/     ACC : (MACRO)             	shl4 rp1p2 ;shift the input number
(1)  426/     AD8 :                     	
(1)  427/     AD8 : F8 0A               	ldi 10	;load the digit count again
(1)  428/     ADA : A9                  	plo r9
(1)  429/     ADB :                     ;r8 is now just past the units location and ready to walk back
(1)  430/     ADB :                     $$dshlp:
(1)  431/     ADB : 28                  	dec r8	;walk back from 0's position
(1)  432/     ADC : 08                  	ldn r8	;get the digit back
(1)  433/     ADD : 7E                  	shlc	;continue the shift
(1)  434/     ADE : BF                  	phi r15 ;save it for the carry test
(1)  435/     ADF : FA 0F               	ani 0x0f ;clear the 10 bit
(1)  436/     AE1 : 58                  	str r8	;put the digit back
(1)  437/     AE2 : 9F                  	ghi r15	;now test for carry
(1)  438/     AE3 : FF 10               	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  439/     AE5 : 29                  	dec r9	;decrement the digit count
(1)  440/     AE6 : 89                  	glo r9
(1)  441/     AE7 : 3A DB               	bnz $$dshlp ;back for more if needed
(1)  442/     AE9 :                     	
(1)  443/     AE9 : 2F                  	dec r15
(1)  444/     AEA : 8F                  	glo r15
(1)  445/     AEB : 3A BC               	bnz $$bitloop
(1)  446/     AED :                     	
(1)  447/     AED : (MACRO)             	cpy2 r15,r8	;save the starting location of the digits
(1)  448/     AF1 : F8 0A               	ldi 10		;digit count again
(1)  449/     AF3 : A9                  	plo r9
(1)  450/     AF4 :                     $$upnxt:
(1)  451/     AF4 : 08                  	ldn r8		;get digit
(1)  452/     AF5 : F9 30               	ori 0x30	;make ascii
(1)  453/     AF7 : 58                  	str r8		;put it back
(1)  454/     AF8 : 18                  	inc r8		;next digit
(1)  455/     AF9 : 29                  	dec r9		;counter
(1)  456/     AFA : 89                  	glo r9
(1)  457/     AFB : 3A F4               	bnz $$upnxt	;upgrade all 10 spots
(1)  458/     AFD : (MACRO)             	ldaX memaddr,sp,(2+4+2+1+1)	;point to lsb of desired digit count
(1)  459/     B05 : EE                  	sex memaddr	;set up
(1)  460/     B06 : F8 0A               	ldi 10		;max number of 0's to skip
(1)  461/     B08 : F7                  	sm		;desired number of digits to skip
(1)  462/     B09 : E2                  	sex sp		;reset index register
(1)  463/     B0A : A9                  	plo r9		;number of leading 0's to skip
(1)  464/     B0B :                     $$cknext:
(1)  465/     B0B : 0F                  	ldn r15		;check digit
(1)  466/     B0C : FF 30               	smi 0x30	;for '0'
(1)  467/     B0E : 3A 15               	bnz $$done
(1)  468/     B10 : 1F                  	inc r15		;next digit
(1)  469/     B11 : 29                  	dec r9		;reduce count
(1)  470/     B12 : 89                  	glo r9
(1)  471/     B13 : 3A 0B               	bnz $$cknext
(1)  472/     B15 :                     $$done:
(1)  473/     B15 : (MACRO)             	cretn
(1)  474/     B17 : [372]                ENDIF	
(1)  475/     B17 : =>UNDEFINED          IFNDEF  LCCNOLONG		;wjr 17-04-09 disable 32 bit math	
(1)  476/     B17 :                     _modU4:	;32 bit unsigned remainder
(1)  477/     B17 :                     	; just calls the 32 bit division then puts remainder into return value
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(lcc1802epiloNW.inc) - page 24 - 1/28/2018 16:05:51


(1)  478/     B17 : (MACRO)                 Ccall _divU4
(1)  479/     B1B : (MACRO)                 cpy4 RL8,Rp1p2
(1)  480/     B23 : (MACRO)                 Cretn
(1)  481/     B25 :                         
(1)  482/     B25 :                     _modI4:	;32 bit signed remainder
(1)  483/     B25 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  484/     B25 : (MACRO)                 Ccall _divI4
(1)  485/     B29 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  486/     B31 : (MACRO)                 Cretn
(1)  487/     B33 : [475]                ENDIF	
(1)  488/     B33 :                     
     758/     B33 :                     	include IO1802.inc
(1)    1/     B33 :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/     B33 :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/     B33 :                     ;17-10-16 adding _putcpace(port,byte) to limit output speed to the AVR
(1)    4/     B33 :                     ;         defaulting putc(x) to putcpace(7,x)
(1)    5/     B33 :                     ;17-11-22 removing putc altogether
(1)    6/     B33 :                     
(1)    7/     B33 :                     _inp:		;raw port input
(1)    8/     B33 :                     		;stores a small tailored program on the stack and executes it
(1)    9/     B33 : 22                  	dec	sp	;work backwards
(1)   10/     B34 : F8 D3               	ldi	0xD3	;return instruction
(1)   11/     B36 : 73                  	stxd		
(1)   12/     B37 : 8C                  	glo	regarg1	;get the port number
(1)   13/     B38 : FA 07               	ani	0x07	;clean it
(1)   14/     B3A : 32 4A               	bz	+	; inp(0) isn't valid
(1)   15/     B3C : F9 68               	ori	0x68	;make it an input instruction
(1)   16/     B3E : 73                  	stxd		;store it for execution
(1)   17/     B3F : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   18/     B43 : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   19/     B44 : D8                  	sep	rt1	;execute it
(1)   20/     B45 :                     ;we will come back to here with the input byte in D
(1)   21/     B45 : 12                  	inc	sp	;step over the work area
(1)   22/     B46 : AF                  	plo	retVal	;save it to return
(1)   23/     B47 : F8 00               	ldi	0
(1)   24/     B49 : BF                  	phi	retval	;clear top byte
(1)   25/     B4A : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   26/     B4B : 12                  	inc	sp	;and the D3
(1)   27/     B4C : (MACRO)             	Cretn		;and we're done
(1)   28/     B4E :                     	
(1)   29/     B4E :                     _out:		;raw port output
(1)   30/     B4E :                     		;stores a small tailored program on the stack and executes it
(1)   31/     B4E :                     		;this could be bolder:
(1)   32/     B4E :                     		;store the program as 6x cc D5 where x is the port number and cc is the char
(1)   33/     B4E :                     		;then SEP sp
(1)   34/     B4E :                     		;the D5 would return to the calling program and finish fixing the stack.
(1)   35/     B4E :                     		;saves 6 instructions but it's a bit tricky.
(1)   36/     B4E : 22                  	dec	sp	;work backwards
(1)   37/     B4F : F8 D3               	ldi	0xD3	;return instruction
(1)   38/     B51 : 73                  	stxd		
(1)   39/     B52 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the OUT instruction
(1)   40/     B56 : 8C                  	glo	regarg1	;get the port number
(1)   41/     B57 : FA 07               	ani	0x07	;clean it
(1)   42/     B59 : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   43/     B5B : 73                  	stxd		;store it for execution
(1)   44/     B5C : 8D                  	glo	regarg2	;get the byte to be written
(1)   45/     B5D : 52                  	str	sp	;store it where sp points
(1)   46/     B5E : D8                  	sep	rt1	;execute it
(1)   47/     B5F :                     ;we will come back to here with sp stepped up by one
(1)   48/     B5F : 12                  +	inc	sp	;need to get rid of the 6x instruction
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm(IO1802.inc) - page 25 - 1/28/2018 16:05:51


(1)   49/     B60 : 12                  	inc	sp	;and the D3
(1)   50/     B61 : (MACRO)             	Cretn		;and we're done
(1)   51/     B63 :                     	
(1)   52/     B63 :                     	
(1)   53/     B63 :                     
     759/     B63 :                     
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 26 - 1/28/2018 16:05:51


  symbol table (* = unused):
  ------------------------

 AGAIN153 :                     844 C | *ARCHITECTURE :  i386-unknown-win32 - |
*BIGENDIAN :                      0 - |  BITLOOP158 :                   ABC C |
*BRANCHEXT :                      0 - |  BVTABLE104 :                   69E C |
*CASESENSITIVE :                  0 - |  CHECK_SUB156 :                 997 C |
 CKNEXT158 :                    B0B C |  CKTOP158 :                     AA7 C |
 CLRLP158 :                     A98 C |  CODELOC :                        0 - |
 COMPUTEQUOT153 :               85A C | *CONSTPI :        3.141592653589793 - |
 CPUSPEED :                   30D40 - | *DATE :                   1/28/2018 - |
 DCKLP158 :                     ABF C |  DNOADD158 :                    AC7 C |
 DONE154 :                      8BD C |  DONE157 :                      A77 C |
 DONE158 :                      B15 C |  DSHLP158 :                     ADB C |
 ENDLP155 :                     961 C | *FALSE :                          0 - |
*FULLPMMU :                       1 - | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*L1 :                            92 C |  L10 :                          181 C |
*L11 :                          19E C | *L13 :                          2E8 C |
 L14 :                          1B5 C |  L15 :                          2E1 C |
 L17 :                          2BF C |  L18 :                          2DF C |
 L20 :                          222 C |  L21 :                          24F C |
 L22 :                          273 C |  L23 :                          289 C |
 L24 :                          2A5 C |  L25 :                          218 C |
*L26 :                          368 C |  L28 :                          334 C |
*L29 :                          35F C | *L3 :                           120 C |
 L31 :                          360 C | *L32 :                          388 C |
 L33 :                          37C C |  L34 :                          37E C |
*L36 :                          467 C |  L38 :                          3E6 C |
 L39 :                          3EA C |  L41 :                          427 C |
 L43 :                          412 C | *L44 :                          41E C |
 L46 :                          41F C |  L47 :                          42E C |
*L48 :                          45E C | *L5 :                           189 C |
 L50 :                          45F C | *L51 :                          602 C |
 L52 :                          7B6 C |  L53 :                          7AD C |
 L54 :                          4BF C |  L55 :                          5FF C |
 L57 :                          5EE C |  L58 :                          5FF C |
 L60 :                          535 C |  L61 :                          539 C |
 L62 :                          544 C |  L63 :                          555 C |
 L65 :                          560 C |  L66 :                          5CF C |
 L67 :                          52B C | *L69 :                          63F C |
 L7 :                           174 C |  L70 :                          628 C |
*L71 :                          62C C |  L73 :                          62D C |
*L74 :                          6B1 C | *L76 :                          7AB C |
*L8 :                           180 C |  LCC1802INIT :                  7BC C |
*LISTON :                         1 - |  LOOP155 :                      90F C |
*MACEXP :                         0 - |  MEMADDR :                        E - |
 MLOOP156 :                     978 C |  MOMCPU :                      1805 - |
*MOMCPUNAME :                  1805 - |  MULRDONE152 :                  824 C |
 MULRLP152 :                    804 C |  MULRNOADD152 :                 816 C |
 MULRSHFT152 :                  81C C | *NESTMAX :                      100 - |
 NEY0Y153 :                     873 C |  NORESTORE155 :                 95D C |
 OUT153 :                       881 C |  OUTIT104 :                     69A C |
*PACKING :                        0 - | *PADDING :                        1 - |
 POS1154 :                      89A C |  POS1157 :                      A26 C |
 POS2154 :                      8AA C |  POS2157 :                      A4D C |
 R0 :                             0 - |  R1 :                             1 - |
 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 27 - 1/28/2018 16:05:51


 R10 :                            A - |  R11 :                            B - |
 R12 :                            C - |  R13 :                            D - |
 R14 :                            E - |  R15 :                            F - |
 R2 :                             2 - | *R3 :                             3 - |
*R4 :                             4 - | *R5 :                             5 - |
 R6 :                             6 - |  R7 :                             7 - |
 R8 :                             8 - |  R9 :                             9 - |
 RCALL :                          4 - |  REGARG1 :                        C - |
 REGARG2 :                        D - | *RELAXED :                        1 - |
*RETADDR :                        6 - |  RETVAL :                         F - |
*RL0 :                            1 - |  RL10 :                           B - |
*RL12 :                           D - | *RL4 :                            5 - |
*RL6 :                            7 - |  RL8 :                            9 - |
 RP1P2 :                          D - |  RPC :                            3 - |
 RRET :                           5 - |  RT1 :                            8 - |
*RT2 :                            9 - |  RWORK :                          E - |
 SETBITOFF104 :                 695 C |  SHIFT156 :                     9AF C |
 SP :                             2 - |  STACKLOC :                    10FF - |
 SUBOVHD :                        E - |  TESTEXIT153 :                  869 C |
*TIME :                    16:05:51 - | *TRUE :                           1 - |
 UPNXT158 :                     AF4 C |  VERSION :                     142F - |
 _00000144 :                    7CE C | *_BOYDINC :                     6B3 C |
 _BOYDSCAN :                    700 C |  _BOYDSCAN.KEY_0 :              77C C |
 _BOYDSCAN.KEY_1 :              780 C |  _BOYDSCAN.KEY_10 :             764 C |
 _BOYDSCAN.KEY_11 :             768 C |  _BOYDSCAN.KEY_12 :             74C C |
 _BOYDSCAN.KEY_13 :             750 C |  _BOYDSCAN.KEY_14 :             754 C |
 _BOYDSCAN.KEY_15 :             758 C |  _BOYDSCAN.KEY_2 :              784 C |
 _BOYDSCAN.KEY_3 :              788 C |  _BOYDSCAN.KEY_4 :              76C C |
 _BOYDSCAN.KEY_5 :              770 C |  _BOYDSCAN.KEY_6 :              774 C |
 _BOYDSCAN.KEY_7 :              778 C |  _BOYDSCAN.KEY_8 :              75C C |
 _BOYDSCAN.KEY_9 :              760 C |  _BOYDSCAN.KEY_ADD :            78C C |
 _BOYDSCAN.KEY_CLEAR :          7A0 C |  _BOYDSCAN.KEY_CLR_ENTRY :      7A6 C |
 _BOYDSCAN.KEY_DIV_FIS :        7A7 C |  _BOYDSCAN.KEY_DIV_WHOLE :      7A8 C |
 _BOYDSCAN.KEY_EQU :            7A8 C |  _BOYDSCAN.KEY_INV_SIGN :       7A5 C |
 _BOYDSCAN.KEY_MEM_RECALL :     7A8 C |  _BOYDSCAN.KEY_MEM_STORE :      798 C |
 _BOYDSCAN.KEY_MUL :            794 C |  _BOYDSCAN.KEY_REM :            79C C |
 _BOYDSCAN.KEY_SAVE :           7A8 C |  _BOYDSCAN.KEY_SUB :            790 C |
 _BOYDSCAN.SCAN :               705 C |  _BOYDSEGMENTS :                  4 C |
 _DELAY :                       615 C |  _DIE144 :                      7D2 C |
*_DIGITALREAD :                 6A8 C | *_DIGITALWRITE :                680 C |
 _DISP1 :                        84 C | *_DISPALPHA :                   2FB C |
 _DISPMEMLOC :                   94 C |  _DISPSTR :                     38F C |
 _DISPVAL :                     12B C |  _DIVI2 :                       88B C |
 _DIVI4 :                       A00 C |  _DIVU2 :                       826 C |
 _DIVU4 :                       900 C | *_DUBDABX :                     A79 C |
 _EXECUTE :                     1A0 C |  _GETSP :                       194 C |
*_INP :                         B33 C |  _MAIN :                        476 C |
*_MODI2 :                       7E7 C | *_MODI4 :                       B25 C |
*_MODU2 :                       7DD C | *_MODU4 :                       B17 C |
*_MULU2 :                       800 C | *_MULU4 :                       967 C |
*_OLDUINOINCLUDER :             64C C |  _ONEMS :                       7F8 C |
 _OUT :                         B4E C | *_OUT4 :                        7F1 C |
 _PIN4 :                          3 C | *_SETQOFF :                     7DA C |
*_SETQON :                      7D7 C |  _STRLEN :                      373 C |
 __FORW0 :                      6AF C |  __FORW1 :                      B4A C |
*__FORW2 :                      B5F C |

    225 symbols
     69 unused symbols

 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 28 - 1/28/2018 16:05:51


 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 29 - 1/28/2018 16:05:51


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU2RRS                               | ALU4                                 
ALU4I                                 | BLKCPY                               
CCALL                                 | CPY1                                 
CPY2                                  | CPY4                                 
CRETN                                 | DECM                                 
DEMOTE                                | INC4                                 
INCM                                  | JCF4                                 
JCI2                                  | JCI2I                                
JCI4                                  | JCU2                                 
JCU2I                                 | JCU4                                 
JEQI1                                 | JEQI2                                
JEQI4                                 | JEQU1I                               
JEQU2I                                | JNEU1I                               
JNEU2                                 | JNEU2I                               
JNEU2NI                               | JNEU4                                
JNI2I                                 | JNU2I                                
JNZU1                                 | JNZU2                                
JUMPV                                 | JZU1                                 
JZU2                                  | LD1                                  
LD2                                   | LD2Z                                 
LD4                                   | LDA2                                 
LDAD                                  | LDAX                                 
LDAXS                                 | LDI4                                 
LDIREG                                | LDN1                                 
LDN2                                  | LDN2S                                
MVC1                                  | MVC2                                 
MVCN1                                 | MVCN2                                
NEGI2                                 | NEGI4                                
NOP1806                               | POPF                                 
POPL                                  | POPM                                 
POPR                                  | PUSHR                                
RELEASE                               | RELEASEL                             
RELEASES                              | RESERVE                              
RESERVEL                              | RESERVES                             
SEXT                                  | SEXT4                                
SHL2                                  | SHL2I                                
SHL2R                                 | SHL4                                 
SHL4I                                 | SHL4R                                
SHLC4                                 | SHLR2R                               
SHRC4                                 | SHRI2                                
SHRI2I                                | SHRI2R                               
SHRI4                                 | SHRI4I                               
SHRI4R                                | SHRU2                                
SHRU2I                                | SHRU2R                               
SHRU4                                 | SHRU4I                               
SHRU4R                                | ST1                                  
ST2                                   | ST2I                                 
ST4                                   | STR1                                 
STR1I                                 | STR2                                 
STR2I                                 | TESTSUB                              
XUSHF                                 | XUSHL                                
XUSHM                                 | ZEXT                                 
ZEXT4                                 |

    107 macros

 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 30 - 1/28/2018 16:05:51


 AS V1.42 Beta [Bld 123] - source file boydmonseg.oasm - page 31 - 1/28/2018 16:05:51


  codepages:
  ----------

STANDARD (0 changed characters)


0.15 seconds assembly time

   2517 lines source file
   5459 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
