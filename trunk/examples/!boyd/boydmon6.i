; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Fri Apr 14 12:13:58 2017
SP:	equ	2 ;stack pointer
memAddr: equ	14
retAddr: equ	6
retVal:	equ	15
regArg1: equ	12
regArg2: equ	13
	listing off
	RELAXED ON
;definitions and prolog functions needed for smc1802 programs (Hi Bill)
;dec 21 packaged version for the christmas compiler (Ho Ho Ho)
;Dec 24 fixed shift macros to use memaddr as a work register and not corrupt the shift count
;jan 6 fixed shift left macro as above
;jan 11 saving as lcc1802epiloNG.inc for the NG compiler
;jan 12 minor correction to rldmi
;jan 14 minor correction to ldi4
;jan 16 adding shri4I
;jan20 correct error in shl2r
;jan21 moved 4 byte macros to bottom and added shrc4
;Jan 28 archived before beginning work on Birthday Compiler
;Feb 7 adding nointerrupts/interrupts to control interruptability
;Feb 13 changing address mode macros
;Feb 14 removing nointerrupts, adding reserve/release for stack frame, ld2z macro
;Mar 3 changing reserve/release to use inc/dec for 8 or less bytes
;Mar 4 adding incm macro for multiple increments
;mar 5 adding jzi2 macro to speed up if processing
;mar 6 adding ldn1, str1 for register indirect addressing
;mar 17 adding decm macro
;mar 28 adding jumpv macro
;may 15 adding jnzu1, jzu1 macros
;june 21 adding demote macro
;Oct 2, 2013 DH version for dhrystone optimization 
;Oct 2, 2013 added str2 macro 2 byte store at addr pointed to by register
;oct 4,	added st2i 2 byte immediate sore, pushf,pushm,pushl sequences, 
;oct 24, added ldaXs for stack pointed addresses, added mvcn1, mvc1 for 1 byte storage to storage moves, jneu1i for single byte immediate compare
;Feb 17 2014 added "inc sp" to restore stack pointer in jeqI1, affected strncmp.
;Feb 18 2017 added org to LCCCODELOC to allow for non-zero origin
;Feb 19 2017 beginning to adapt for 1806
;17-03-06 remove inc/dec from ccall, cretn6, add inc to popr
;17-03-07 add popf,popm,popl for optimization
;17-03-14 removed savemi, rldmi,cretn6
;17-03-27 added jequ1i
	org	LCCCODELOC	;wjr 17-02-18 allow code relocation
R0:	equ	0
R1:	equ	1
R2:	equ	2
R3:	equ	3
R4:	equ	4
R5:	equ	5
R6:	equ	6
R7:	equ	7
R8:	equ	8
R9:	equ	9
R10:	equ	10
R11:	equ	11
R12:	equ	12
R13:	equ	13
R14:	equ	14
R15:	equ	15
RL0:	equ	1 ;long register pairs are identified by their odd numbered register
RL6:	equ	7 
RL8:	equ	9 ;temp 1
RL10:	equ	11;temp 2
RL12:	equ	13 ;return value register for longs
Rp1p2:	equ	13 ;argument register for longs
Rt1:	equ	8  ;1st temp register
Rt2:	equ	9  ;2nd temp register
RCALL:	equ 	4 ;standard call routine
RRET:	equ 	5 ;standard return register
RPC:	equ 	3 ; standard program counter
;	listing	off
	macexp off	;this seems to have to go before the definitions
;macro definitions
;more natural 1802 macros
	listing	on
	lbr	lcc1802Init
	listing on
_PIN4:
	db 0
;$$function start$$ _boydinc
_boydinc:		;framesize=2
;void boydinc(){
;	asm(" include \"boydscan.inc\"\n");
_boydscan:			;SCAN THE KEYBOARD
		sex	r14 	;set up "don't care" X register
		rldi	r15,0	; r15 is return value
.scan:		OUT	1                     ;109: 61 	
		B1	.KEY_12                     ;10A: 34 50 	
		B2	.KEY_8                      ;10C: 35 60 	
		B3	.KEY_4                      ;10E: 36 70 	
		B4	.KEY_0                      ;110: 37 80 	
		OUT	2                     ;112: 62 	
		B1	.KEY_13                     ;113: 34 54 	
		B2	.KEY_9                      ;115: 35 64 	
		B3	.KEY_5                      ;117: 36 74 	
		B4	.KEY_1                      ;119: 37 84 	
		OUT	3                     ;11B: 63 	
		B1	.KEY_14                     ;11C: 34 58 	
		B2	.KEY_10                     ;11E: 35 68 	
		B3	.KEY_6                      ;120: 36 78 	
		B4	.KEY_2                      ;122: 37 88 	
		OUT	4                     ;124: 64 	
		B1	.KEY_15                     ;125: 34 5C 	
		B2	.KEY_11                     ;127: 35 6C 	
		B3	.KEY_7                      ;129: 36 7C 	
		B4	.KEY_3                      ;12B: 37 8C 	
		OUT	5                     ;12D: 65 	
		B1	.KEY_DIV_WHOLE              ;12E: 34 99 	
		B2	.KEY_MUL                    ;130: 35 96 	
		B3	.KEY_SUB                    ;132: 36 93 	
		B4	.KEY_ADD                    ;134: 37 90 	
		OUT	6                     ;136: 66 	
		B1	.KEY_REM                    ;137: 34 A5 	
		B2	.KEY_MEM_STORE              ;139: 35 A2 	
		B3	.KEY_MEM_RECALL             ;13B: 36 9F 	
		B4	.KEY_EQU                    ;13D: 37 9C 	
		SEQ                                ;13F: 7B 	
		B1	.KEY_DIV_FIS                ;140: 34 B1 	
		B2	.KEY_CLEAR                  ;142: 35 AE 	
		B3	.KEY_CLR_ENTRY              ;144: 36 AB 	
		B4	.KEY_INV_SIGN               ;146: 37 A8 	
		REQ                                ;148: 7A 	
;here we have no keys pressed, if r15.0 has a value, return it -1
		glo	r15
		bz	.scan
		dec	r15
		sex	r2	;restore the X register before returning
        sret    6
.KEY_12		LDI	13                         ;150: F8  C 	
		BR	.KEY_SAVE                   ;152: 30 B4 	
.KEY_13		LDI	14                         ;154: F8  D 	
		BR	.KEY_SAVE                   ;156: 30 B4 	
.KEY_14		LDI	15                         ;158: F8  E 	
		BR	.KEY_SAVE                   ;15A: 30 B4 	
.KEY_15		LDI	16                         ;15C: F8  F 	
		BR	.KEY_SAVE                   ;15E: 30 B4 	
.KEY_8		LDI	 9                         ;160: F8  8 	
		BR	.KEY_SAVE                   ;162: 30 B4 	
.KEY_9		LDI	 10                         ;164: F8  9 	
		BR	.KEY_SAVE                   ;166: 30 B4 	
.KEY_10		LDI	11                         ;168: F8  A 	
		BR	.KEY_SAVE                   ;16A: 30 B4 	
.KEY_11		LDI	12                         ;16C: F8  B 	
		BR	.KEY_SAVE                   ;16E: 30 B4 	
.KEY_4		LDI	 5                         ;170: F8  4 	
		BR	.KEY_SAVE                   ;172: 30 B4 	
.KEY_5		LDI	 6                         ;174: F8  5 	
		BR	.KEY_SAVE                   ;176: 30 B4 	
.KEY_6		LDI	 7                         ;178: F8  6 	
		BR	.KEY_SAVE                   ;17A: 30 B4 	
.KEY_7		LDI	 8                         ;17C: F8  7 	
		BR	.KEY_SAVE                   ;17E: 30 B4 	
.KEY_0		LDI	 1                         ;180: F8  0 	
		BR	.KEY_SAVE                   ;182: 30 B4 	
.KEY_1		LDI	 2                         ;184: F8  1 	
		BR	.KEY_SAVE                   ;186: 30 B4 	
.KEY_2		LDI	 3                         ;188: F8  2 	
		BR	.KEY_SAVE                   ;18A: 30 B4 	
.KEY_3		LDI	 4                         ;18C: F8  3 	
		BR	.KEY_SAVE                   ;18E: 30 B4 	
.KEY_ADD	ldi	16+1
		br	.key_save
.KEY_SUB:	ldi	17+1
		br	.key_save
.KEY_MUL:	ldi	20+1
		br	.key_save
.KEY_MEM_STORE:	ldi	19+1
		br	.key_save
.KEY_REM:	ldi	18+1
		br	.key_save
.KEY_CLEAR:	req
		ldi	20+1
		br	.key_save
.KEY_INV_SIGN:	req
.KEY_CLR_ENTRY:	req
.KEY_DIV_FIS:	req
.KEY_EQU:
.KEY_DIV_WHOLE:
.KEY_MEM_RECALL:
.KEY_SAVE:	plo 15
		br .scan
;}
L1:
        sret    6
;$$function end$$ _boydinc
;$$function start$$ _disp1
_disp1:		;framesize=2
;void disp1(unsigned char d){//display a byte as two hex digits
;	asm(" glo 12\n ani 0x0f\n" //prep bottom digit
 glo 12
 ani 0x0f
 dec 2
 str 2
 out 7
 glo 12
 shr
 shr
 shr
 shr
 dec 2
 str 2
 out 7
;}
L3:
        sret    6
;$$function end$$ _disp1
;$$function start$$ _dispmemloc
_dispmemloc:		;framesize=14
        RSXD    R4
        RSXD    R5
        RSXD    R6
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((14+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((14+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
;void dispmemloc(unsigned int loc){
;	register unsigned char* m=0;
        RLDI    R7,0
;	initleds();
;	disp1(m[loc+1]);
 req
 seq
 dec 2
 out 7
 req
        glo     SP
        adi     ((14+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((14+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        inc     R11
        glo     R7
        str     sp
        glo     R11
        ADD             ;calculate the low order byte
        plo     R11
        ghi     R7
        str     sp
        ghi     R11
        ADC             ;calculate the high byte
        phi     R11
        ldn     R11
        plo     R12
        ldi     0
        phi     R12
        SCAL    6
        dw      _DISP1
;	disp1(m[loc]);
        glo     SP
        adi     ((14+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((14+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R7
        str     sp
        glo     R11
        ADD             ;calculate the low order byte
        plo     R11
        ghi     R7
        str     sp
        ghi     R11
        ADC             ;calculate the high byte
        phi     R11
        ldn     R11
        plo     R12
        ldi     0
        phi     R12
        SCAL    6
        dw      _DISP1
;	disp1(loc&0xff);
        glo     SP
        adi     ((14+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((14+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        ANI     (255)#256
        plo     R11
        ghi     R11
        ANI     (255)>>8; was/256
        phi     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        SCAL    6
        dw      _DISP1
;	disp1(loc>>8);
        glo     SP
        adi     ((14+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((14+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        SCAL    6
        dw      _DISP1
;}
L5:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        RLXA    R7
        RLXA    R6
        RLXA    R5
        lda     sp
        phi     R4
        ldn     sp
        plo     R4
        sret    6
;$$function end$$ _dispmemloc
;$$function start$$ _dispval
_dispval:		;framesize=8
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        ghi     R12
        str     memAddr
        inc     memAddr
        glo     R12
        str     memAddr
;Oct 13 (8+1) added to ldAD call
        glo     SP
        adi     ((8+1))#256
        plo     R11
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     R11
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R10
        ldn     memAddr
        plo     R10
        glo     R10
        str     R11
;void dispval(unsigned char v){
;	initleds();
;	disp1(v);
 req
 seq
 dec 2
 out 7
 req
        glo     SP
        adi     ((8+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((8+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R12
        ldi     0
        phi     R12
        SCAL    6
        dw      _DISP1
;	for (i=6;i!=0;i--) out(7,0);
        RLDI    R7,6
	lbr L12
L9:
        RLDI    R12,7
        ldi     0
        plo     R13
        phi     R13
        SCAL    6
        dw      _OUT
L10:
        dec     R7
L12:
        glo     R7
        lbnz    L9
        ghi     R7
        lbnz    L9
;}
L7:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        lda     sp
        phi     R7
        ldn     sp
        plo     R7
        sret    6
;$$function end$$ _dispval
;$$function start$$ _getsp
_getsp:		;framesize=2
;unsigned int getsp(){//return stack pointer value
;	asm(" cpy2 r15,sp\n"  	//copy stack pointer to return reg
;	return 0;				//not executed
        glo     SP
        plo     R15
        ghi     SP
        phi     R15
        sret    6
        ldi     0
        plo     R15
        phi     R15
L13:
        sret    6
;$$function end$$ _getsp
;$$function start$$ _execute
_execute:		;framesize=14
        dec sp
        dec sp
        RSXD    R5
        RSXD    R6
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
        glo     R12
        plo     R7
        ghi     R12
        phi     R7
;void execute(unsigned int loc){
;	unsigned char* mem=0;
        RLDI    R6,0
;		dispval(0x44); delay(250);
        RLDI    R12,68
        SCAL    6
        dw      _DISPVAL
        RLDI    R12,250
        SCAL    6
        dw      _DELAY
;		dispmemloc(loc); delay(3000);
        glo     R7
        plo     R12
        ghi     R7
        phi     R12
        SCAL    6
        dw      _DISPMEMLOC
        RLDI    R12,3000
        SCAL    6
        dw      _DELAY
;		op=mem[loc]; val=mem[loc+1];
;Oct 13 (11+1) added to ldAD call
        glo     SP
        adi     ((11+1))#256
        plo     R11
        ghi     SP
        adci    ((11+1))>>8; was/256
        phi     R11
        glo     R6
        str     sp
        glo     R7
        ADD             ;calculate the low order byte
        plo     R10
        ghi     R6
        str     sp
        ghi     R7
        ADC             ;calculate the high byte
        phi     R10
        ldn     R10
        plo     R10
        glo     R10
        str     R11
;Oct 13 (10+1) added to ldAD call
        glo     SP
        adi     ((10+1))#256
        plo     R11
        ghi     SP
        adci    ((10+1))>>8; was/256
        phi     R11
        glo     R7
        plo     R10
        ghi     R7
        phi     R10
        inc     R10
        glo     R6
        str     sp
        glo     R10
        ADD             ;calculate the low order byte
        plo     R10
        ghi     R6
        str     sp
        ghi     R10
        ADC             ;calculate the high byte
        phi     R10
        ldn     R10
        plo     R10
        glo     R10
        str     R11
;		switch (op){
        glo     SP
        adi     ((11+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((11+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R5
        ldi     0
        phi     R5
        glo     R5
        smi     (0)#256
        ghi     R5
        smbi    (0)>>8; was/256      ;that's a standard signed subtraction
        ghi     R5 ;
        xri     (0)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L16  ;execute 
        glo     R5
        sdi     (4)#256      ;subtract d FROM immediate value
        ghi     R5
        sdbi    (4)>>8; was/256      ;that's a standard signed subtraction (of register FROM immediate)
        ghi     R5 ;
        xri     (4)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L16  ;execute 
        glo     R5
        shl
        plo     R11
        ghi     R5
        shlc
        phi     R11
        glo     R11
        adi     ((L24))#256
        plo     MEMADDR
        ghi     R11
        adci    ((L24))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        RSXD    R6
        glo     R11
        plo     R6
        ghi     R11
        phi     R6
        sret    6
L24:
	dw L19
	dw L20
	dw L21
	dw L22
	dw L23
L19:
;				dispval(0x49); delay(250);
        RLDI    R12,73
        SCAL    6
        dw      _DISPVAL
        RLDI    R12,250
        SCAL    6
        dw      _DELAY
;				dispval(mem[val+4096]); delay(1000);
        glo     SP
        adi     ((10+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((10+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        ldi     0
        phi     R11
;Oct 13 (4096) added to ldAD call
        glo     R11
        adi     ((4096))#256
        plo     R11
        ghi     R11
        adci    ((4096))>>8; was/256
        phi     R11
        glo     R6
        str     sp
        glo     R11
        ADD             ;calculate the low order byte
        plo     R11
        ghi     R6
        str     sp
        ghi     R11
        ADC             ;calculate the high byte
        phi     R11
        ldn     R11
        plo     R12
        ldi     0
        phi     R12
        SCAL    6
        dw      _DISPVAL
        RLDI    R12,1000
        SCAL    6
        dw      _DELAY
;				dispval(0x50); delay(250);
        RLDI    R12,80
        SCAL    6
        dw      _DISPVAL
        RLDI    R12,250
        SCAL    6
        dw      _DELAY
;				break;
	lbr L17
L20:
;				mem[val+4096]+=1;
        glo     SP
        adi     ((10+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((10+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        ldi     0
        phi     R11
;Oct 13 (4096) added to ldAD call
        glo     R11
        adi     ((4096))#256
        plo     R11
        ghi     R11
        adci    ((4096))>>8; was/256
        phi     R11
        glo     R6
        str     sp
        glo     R11
        ADD             ;calculate the low order byte
        plo     R11
        ghi     R6
        str     sp
        ghi     R11
        ADC             ;calculate the high byte
        phi     R11
        ldn     R11
        plo     R10
        ldi     0
        phi     R10
        inc     R10
        glo     R10
        str     R11
;				break;
	lbr L17
L21:
;				loc=val+4096-2; //ugh
        glo     SP
        adi     ((10+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((10+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        ldi     0
        phi     R11
;Oct 13 (4096) added to ldAD call
        glo     R11
        adi     ((4096))#256
        plo     R11
        ghi     R11
        adci    ((4096))>>8; was/256
        phi     R11
        dec     R11
        dec     R11
        glo     R11
        plo     R7
        ghi     R11
        phi     R7
;				break;
	lbr L17
L22:
;				delay(val*4);
        glo     SP
        adi     ((10+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((10+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R11
        ldi     0
        phi     R11
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        plo     R12
        ghi     R11
        phi     R12
        SCAL    6
        dw      _DELAY
;				break;
	lbr L17
L23:
;				dispval(getsp());
        SCAL    6
        dw      _GETSP
        glo     R15
        plo     R11
        glo     R11
        plo     R12
        ldi     0
        phi     R12
        SCAL    6
        dw      _DISPVAL
;				delay(250);
        RLDI    R12,250
        SCAL    6
        dw      _DELAY
;				break;
	lbr L17
L16:
;				dispval(0x41); delay(250);
        RLDI    R12,65
        SCAL    6
        dw      _DISPVAL
        RLDI    R12,250
        SCAL    6
        dw      _DELAY
;				dispmemloc(loc); delay(5000);
        glo     R7
        plo     R12
        ghi     R7
        phi     R12
        SCAL    6
        dw      _DISPMEMLOC
        RLDI    R12,5000
        SCAL    6
        dw      _DELAY
;				break;
L17:
;		loc+=2;
        inc     R7
        inc     R7
;}
L15:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        RLXA    R7
        RLXA    R6
        lda     sp
        phi     R5
        ldn     sp
        plo     R5
        inc sp
        inc sp
        sret    6
;$$function end$$ _execute
;$$function start$$ _main
_main: ;copt is peeping your size 18 frame with oct 23 rules
        dec sp
        dec sp
        dec sp
        dec sp
        RSXD    R4
        RSXD    R5
        RSXD    R6
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
;{
;	unsigned int loc=0;
        ldi     0
        plo     R5
        phi     R5
;	unsigned char memtype='o'; //displaying o=eeprom,a=ram
        RLDI    R4,111
;	register unsigned char* mem=0;
        RLDI    R7,0
;	dispval(0x42);
        RLDI    R12,66
        SCAL    6
        dw      _DISPVAL
;	delay(1000);
        RLDI    R12,1000
        SCAL    6
        dw      _DELAY
	lbr L27
L26:
;	while(1){
;		dispmemloc(loc);
        glo     R5
        plo     R12
        ghi     R5
        phi     R12
        SCAL    6
        dw      _DISPMEMLOC
;		k=boydscan();
        SCAL    6
        dw      _BOYDSCAN
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R11
        plo     R6
;		switch(k){
        glo     R6
        plo     R11
        ldi     0
        phi     R11
        glo     SP
        adi     ((13+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((13+1))>>8; was/256
        phi     MEMADDR
        ghi     R11
        str     memAddr
        inc     memAddr
        glo     R11
        str     memAddr
        glo     SP
        adi     ((13+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((13+1))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        glo     R11
        smi     (16)#256
        ghi     R11
        smbi    (16)>>8; was/256      ;that's a standard signed subtraction
        ghi     R11 ;
        xri     (16)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L29  ;execute 
        glo     R11
        sdi     (20)#256      ;subtract d FROM immediate value
        ghi     R11
        sdbi    (20)>>8; was/256      ;that's a standard signed subtraction (of register FROM immediate)
        ghi     R11 ;
        xri     (20)>>8; was/256      ;sets the top bit if the signs are different
        shlc          ;the original df is now in bit 0 and df=1 if signs were different
        lsnf    ;bypass the df flip if signs were the same
        xri     01     ;invert original df if signs were different
        shrc           ;put it back in df
        LBNF    L29  ;execute 
        glo     R11
        shl
        plo     R11
        ghi     R11
        shlc
        phi     R11
        glo     R11
        adi     ((L39-32))#256
        plo     MEMADDR
        ghi     R11
        adci    ((L39-32))>>8; was/256
        phi     MEMADDR
        lda     memAddr
        phi     R11
        ldn     memAddr
        plo     R11
        RSXD    R6
        glo     R11
        plo     R6
        ghi     R11
        phi     R6
        sret    6
L39:
	dw L32
	dw L33
	dw L34
	dw L37
	dw L38
L32:
;				loc +=1;
        inc     R5
;				break;
	lbr L30
L33:
;				loc -=1;
        dec     R5
;				break;
	lbr L30
L34:
;				if (memtype=='o'){
        glo     R4
        smi     111
        lbnz    L35
;					loc=4096;
        RLDI    R5,4096
;					memtype='a';
        RLDI    R4,97
;				}else{
	lbr L30
L35:
;					loc=0;
        ldi     0
        plo     R5
        phi     R5
;					memtype='o';
        RLDI    R4,111
;				}
;				break;
	lbr L30
L37:
;				dispmemloc(loc); //makes a blink
        glo     R5
        plo     R12
        ghi     R5
        phi     R12
        SCAL    6
        dw      _DISPMEMLOC
;				k=boydscan(); dispval(k); delay(250);
        SCAL    6
        dw      _BOYDSCAN
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R11
        plo     R6
        glo     R6
        plo     R12
        ldi     0
        phi     R12
        SCAL    6
        dw      _DISPVAL
        RLDI    R12,250
        SCAL    6
        dw      _DELAY
;				k2=boydscan(); dispval(k2); delay(250);
        SCAL    6
        dw      _BOYDSCAN
;Oct 13 (15+1) added to ldAD call
        glo     SP
        adi     ((15+1))#256
        plo     R10
        ghi     SP
        adci    ((15+1))>>8; was/256
        phi     R10
        glo     R15
        plo     R11
        ghi     R15
        phi     R11
        glo     R11
        str     R10
        glo     SP
        adi     ((15+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((15+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R12
        ldi     0
        phi     R12
        SCAL    6
        dw      _DISPVAL
        RLDI    R12,250
        SCAL    6
        dw      _DELAY
;				mem[loc]=(k<<4)+k2;
        glo     R7
        str     sp
        glo     R5
        ADD             ;calculate the low order byte
        plo     R11
        ghi     R7
        str     sp
        ghi     R5
        ADC             ;calculate the high byte
        phi     R11
        glo     R6
        plo     R10
        ldi     0
        phi     R10
        glo     R10
        shl
        plo     R10
        ghi     R10
        shlc
        phi     R10
        glo     R10
        shl
        plo     R10
        ghi     R10
        shlc
        phi     R10
        glo     R10
        shl
        plo     R10
        ghi     R10
        shlc
        phi     R10
        glo     R10
        shl
        plo     R10
        ghi     R10
        shlc
        phi     R10
        glo     SP
        adi     ((15+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((15+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R9
        ldi     0
        phi     R9
        glo     R9
        str     sp
        glo     R10
        ADD             ;calculate the low order byte
        plo     R10
        ghi     R9
        str     sp
        ghi     R10
        ADC             ;calculate the high byte
        phi     R10
        glo     R10
        str     R11
;				break;
	lbr L30
L38:
;				loc=4096;
        RLDI    R5,4096
;				dispval(0x45);
        RLDI    R12,69
        SCAL    6
        dw      _DISPVAL
;				delay(250);
        RLDI    R12,250
        SCAL    6
        dw      _DELAY
;				execute(4096);
        RLDI    R12,4096
        SCAL    6
        dw      _EXECUTE
;				break;
	lbr L30
L29:
;				dispval(k);
        glo     R6
        plo     R12
        ldi     0
        phi     R12
        SCAL    6
        dw      _DISPVAL
;				delay(250);
        RLDI    R12,250
        SCAL    6
        dw      _DELAY
;		}
L30:
;	}
L27:
;	while(1){
	lbr L26
;}
L25:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        RLXA    R7
        RLXA    R6
        RLXA    R5
        lda     sp
        phi     R4
        ldn     sp
        plo     R4
        inc sp
        inc sp
        inc sp
        inc sp
        sret    6
;$$function end$$ _main
;$$function start$$ _delay
_delay:		;framesize=10
        RSXD    R6
        RSXD    R7
        dec sp
        dec sp
        dec sp
        dec sp
        glo     R12
        plo     R7
        ghi     R12
        phi     R7
;void delay(unsigned int howlong){
;	for (i=1;i!=howlong;i++){
        RLDI    R6,1
	lbr L45
L42:
;		oneMs();
        SCAL    6
        dw      _ONEMS
;	}
L43:
;	for (i=1;i!=howlong;i++){
        inc     R6
L45:
        dec     sp
        glo     R7
        str     sp
        glo     R6
        sm
        inc     sp
        lbnz    L42
        dec     sp
        ghi     R7
        str     sp
        ghi     R6
        smb
        inc     sp
        lbnz    L42
;}
L41:
        inc sp
        inc sp
        inc sp
        inc sp
        inc     sp
        RLXA    R7
        lda     sp
        phi     R6
        ldn     sp
        plo     R6
        sret    6
;$$function end$$ _delay
;$$function start$$ _olduinoincluder
_olduinoincluder:		;framesize=2
;void olduinoincluder(){
;	asm("\tinclude olduino.inc\n");
;Feb 8 2013, first version of assembler routines for olduino support	
;may 31 - incredibly, there's an error in digitalWrite.  lda2 changed to ldAD
;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
	align 64	;needed to make sure all on same page
_digitalWrite:
	glo regArg1	;get the bit number
	adi $$bvtable&255	;add the table offset
	plo memaddr
	ghi RPC		;get the top byte of the current page
	phi memaddr	
	ldn memaddr	;pick up the bit pattern
	plo rt1		;save it in a temp
        RLDI    MEMADDR,_PIN4
	sex memaddr	;prepare to change it
	glo regArg2	;get on/off switch
	bz $$setbitoff
; here we have the bit pattern in rt1 and we're ready to apply it with OR
	glo rt1		;get the bit value back
	or		;apply it
	str memaddr	;and save it
	br $$outit	;go fnish up
$$setbitoff:
	glo rt1		;get the bit pattern
	xri 0xff	;reverse it
	and		;combine it with the existing pin value
	str memaddr	;and save it
;here we gave set/reset the correct bit in PIN4 and we just have to send it out
$$outit:
	out 4		;X was already set to memaddr
	sex sp		;reset X
        sret    6
$$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
;int digitalRead(unsigned char pin){//for now this will always read ef3
	align 8	;protect jump boundary
_digitalRead:
	ldi 0		;default is false
	plo R15
	phi R15
	b3 +		;i have to reverse the sense of the external line
	inc R15		;if external line is high, supply a 1
        sret    6
;}
L46:
        sret    6
;$$function end$$ _olduinoincluder
;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
;this is the version published with the lcc1802121229 release
;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
;jan 2 removed test routines, moved code not needing short branches to before the align 256
;jan 11 going back to SCRT conventions for NG compiler
;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
;Jan 28 archived before beginning work on Birthday Compiler
;Feb 5 dubdab algorithm being brought in for ltoa itoa
;Feb 12 fixed bugs in modi2/u2
;feb 27 changed stack to start at 7fff
;mar 3, 2013 saved as epiloNO for optimization round
;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
;april 4 adding digit count argument to dubdabx
;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
;16-09-20 allow stack relocation 
;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
;17-03-07 adjusting stack offset for 1805/6 stack discipline
;17-03-13 protecting work areas in divi2,divi4 routines from 1806 SCAL
;17-03-15 onems compensates for reduced subroutine overhead in 1806
;17-04-09 don't include call/return for 1806
rwork	equ	memAddr	;work register
lcc1802init:	
        RLDI    RCALL,$$_DIE
        RLDI    RRET,$$_DIE
        RLDI    SP,LCCSTACKLOC
	sex	SP
        RLDI    RPC,$$_00000
	sep	RPC
$$_00000:
        SCAL    6
        dw      _MAIN
$$_die:	lbr	$$_die		;loop here when main returns
	db	0xde,0xad
;the following routines don't have short jumps and don't need to worry about alignment
_setqOn:
	seq
        sret    6
_setqOff:
	req
        sret    6
_out4:	
	glo	regArg1
	dec	sp
	str	sp
	out	4
        sret    6
;the following routines have short branches so all the code has to stay within the same page
	align 8
_oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
;subroutine overhead soaks up 27 instruction time.
;each loop is 2 instruction times
;so the number of loops needed is 
;CPU speed/16000 less the 27 all divide by two
LCC1802SUBOVHD  EQU 14		;1806 SCAL/SRET subroutine overhead
	ldi	(LCC1802CPUSPEED/1000/16-LCC1802SUBOVHD)/2
$$mslp:	smi	1
	bnz	$$mslp
        sret    6
;IO1802.inc contains input/output runtime routines for LCC1802
;The port is in regArg1, the output byte is in regArg2
	align 64
_putc:
_out5:	
	glo	regArg1
	dec	sp
	str	sp
	out	5
        sret    6
_inp:		;raw port input
		;stores a small tailored program on the stack and executes it
	dec	sp	;work backwards
	ldi	0xD3	;return instruction
	stxd		
	glo	regarg1	;get the port number
	ani	0x07	;clean it
	bz	+	; inp(0) isn't valid
	ori	0x68	;make it an input instruction
	stxd		;store it for execution
        glo     SP
        plo     RT1
        ghi     SP
        phi     RT1
	inc	rt1	;rt1 points to the 6x instruction
	sep	rt1	;execute it
;we will come back to here with the input byte in D
	inc	sp	;step over the work area
	plo	retVal	;save it to return
	ldi	0
	phi	retval	;clear top byte
+	inc	sp	;need to get rid of the 6x instruction
	inc	sp	;and the D3
        sret    6
_out:		;raw port output
		;stores a small tailored program on the stack and executes it
		;this could be bolder:
		;store the program as 6x cc D5 where x is the port number and cc is the char
		;then SEP sp
		;the D5 would return to the calling program and finish fixing the stack.
		;saves 6 instructions but it's a bit tricky.
	dec	sp	;work backwards
	ldi	0xD3	;return instruction
	stxd		
        glo     SP
        plo     RT1
        ghi     SP
        phi     RT1
	glo	regarg1	;get the port number
	ani	0x07	;clean it
	ori	0x60	;make it an out instruction - 60 is harmless
	stxd		;store it for execution
	glo	regarg2	;get the byte to be written
	str	sp	;store it where sp points
	sep	rt1	;execute it
;we will come back to here with sp stepped up by one
+	inc	sp	;need to get rid of the 6x instruction
	inc	sp	;and the D3
        sret    6
