 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 1 - 4/9/2017 12:24:14


       1/       0 :                     ; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Sun Apr 09 12:24:13 2017
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1) 1122/       0 :                     	listing	on
(1) 1123/       0 : C0 02 F3            	lbr	lcc1802Init
(1) 1124/       3 :                     	
(1) 1125/       3 :                     
      11/       3 :                     	listing on
      12/       3 :                     _PIN4:
      13/       3 : 00                  	db 0
      14/       4 :                     ;$$function start$$ _ef1
      15/       4 :                     _ef1:		;framesize=2
      16/       4 :                     ;unsigned char ef1(){
      17/       4 :                     ;	asm(" rldi 15,1\n"
      18/       4 :                     ;	return 0; //if the assembly doesn't return, EF1 is not active
      19/       4 : 68 CF 00 01          rldi 15,1
      20/       8 : 3C 0C                bn1 .ret0
      21/       A : (MACRO)              cretn ;will return a '1'
      22/       C :                     .ret0: ;will drop thru to return 0
      23/       C : (MACRO)             	ld2z R15
      24/      10 :                     L1:
      25/      10 : (MACRO)             	Cretn
      26/      12 :                     
      27/      12 :                     ;$$function end$$ _ef1
      28/      12 :                     ;$$function start$$ _ef2
      29/      12 :                     _ef2:		;framesize=2
      30/      12 :                     ;unsigned char ef2(){
      31/      12 :                     ;	asm(" rldi 15,1\n"
      32/      12 :                     ;	return 0; //if the assembly doesn't return, EF1 is not active
      33/      12 : 68 CF 00 01          rldi 15,1
      34/      16 : 3D 1A                bn2 .ret0
      35/      18 : (MACRO)              cretn ;will return a '1'
      36/      1A :                     .ret0: ;will drop thru to return 0
      37/      1A : (MACRO)             	ld2z R15
      38/      1E :                     L3:
      39/      1E : (MACRO)             	Cretn
      40/      20 :                     
      41/      20 :                     ;$$function end$$ _ef2
      42/      20 :                     ;$$function start$$ _disp12
      43/      20 :                     _disp12:		;framesize=6
      44/      20 : (MACRO)             	reserve 4
      45/      24 :                     ;void disp12(){
      46/      24 :                     ;	initleds();
      47/      24 :                     ;	out(7,2);
      48/      24 : 7A                   req
      49/      25 : 7B                   seq
      50/      26 : 22                   dec 2
      51/      27 : 67                   out 7
      52/      28 : 7A                   req
      53/      29 : (MACRO)             	ldaD R12,7; reg:acon
      54/      2D : (MACRO)             	ldaD R13,2; reg:acon
      55/      31 : (MACRO)             	Ccall _out; CALLI2(ar)
      56/      35 :                     ;	out(7,1);
      57/      35 : (MACRO)             	ldaD R12,7; reg:acon
      58/      39 : (MACRO)             	ldaD R13,1; reg:acon
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 2 - 4/9/2017 12:24:14


      59/      3D : (MACRO)             	Ccall _out; CALLI2(ar)
      60/      41 :                     ;	out(7,15);out(7,15);out(7,15);out(7,15);out(7,15);out(7,15);
      61/      41 : (MACRO)             	ldaD R12,7; reg:acon
      62/      45 : (MACRO)             	ldaD R13,15; reg:acon
      63/      49 : (MACRO)             	Ccall _out; CALLI2(ar)
      64/      4D : (MACRO)             	ldaD R12,7; reg:acon
      65/      51 : (MACRO)             	ldaD R13,15; reg:acon
      66/      55 : (MACRO)             	Ccall _out; CALLI2(ar)
      67/      59 : (MACRO)             	ldaD R12,7; reg:acon
      68/      5D : (MACRO)             	ldaD R13,15; reg:acon
      69/      61 : (MACRO)             	Ccall _out; CALLI2(ar)
      70/      65 : (MACRO)             	ldaD R12,7; reg:acon
      71/      69 : (MACRO)             	ldaD R13,15; reg:acon
      72/      6D : (MACRO)             	Ccall _out; CALLI2(ar)
      73/      71 : (MACRO)             	ldaD R12,7; reg:acon
      74/      75 : (MACRO)             	ldaD R13,15; reg:acon
      75/      79 : (MACRO)             	Ccall _out; CALLI2(ar)
      76/      7D : (MACRO)             	ldaD R12,7; reg:acon
      77/      81 : (MACRO)             	ldaD R13,15; reg:acon
      78/      85 : (MACRO)             	Ccall _out; CALLI2(ar)
      79/      89 :                     ;}
      80/      89 :                     L5:
      81/      89 : (MACRO)             	release 4
      82/      8D : (MACRO)             	Cretn
      83/      8F :                     
      84/      8F :                     ;$$function end$$ _disp12
      85/      8F :                     ;$$function start$$ _disp42
      86/      8F :                     _disp42:		;framesize=6
      87/      8F : (MACRO)             	reserve 4
      88/      93 :                     ;void disp42(){
      89/      93 :                     ;	initleds();
      90/      93 :                     ;	out(7,2);
      91/      93 : 7A                   req
      92/      94 : 7B                   seq
      93/      95 : 22                   dec 2
      94/      96 : 67                   out 7
      95/      97 : 7A                   req
      96/      98 : (MACRO)             	ldaD R12,7; reg:acon
      97/      9C : (MACRO)             	ldaD R13,2; reg:acon
      98/      A0 : (MACRO)             	Ccall _out; CALLI2(ar)
      99/      A4 :                     ;	out(7,4);
     100/      A4 : (MACRO)             	ldaD R12,7; reg:acon
     101/      A8 : (MACRO)             	ldaD R13,4; reg:acon
     102/      AC : (MACRO)             	Ccall _out; CALLI2(ar)
     103/      B0 :                     ;	out(7,15);out(7,15);out(7,15);out(7,15);out(7,15);out(7,15);
     104/      B0 : (MACRO)             	ldaD R12,7; reg:acon
     105/      B4 : (MACRO)             	ldaD R13,15; reg:acon
     106/      B8 : (MACRO)             	Ccall _out; CALLI2(ar)
     107/      BC : (MACRO)             	ldaD R12,7; reg:acon
     108/      C0 : (MACRO)             	ldaD R13,15; reg:acon
     109/      C4 : (MACRO)             	Ccall _out; CALLI2(ar)
     110/      C8 : (MACRO)             	ldaD R12,7; reg:acon
     111/      CC : (MACRO)             	ldaD R13,15; reg:acon
     112/      D0 : (MACRO)             	Ccall _out; CALLI2(ar)
     113/      D4 : (MACRO)             	ldaD R12,7; reg:acon
     114/      D8 : (MACRO)             	ldaD R13,15; reg:acon
     115/      DC : (MACRO)             	Ccall _out; CALLI2(ar)
     116/      E0 : (MACRO)             	ldaD R12,7; reg:acon
     117/      E4 : (MACRO)             	ldaD R13,15; reg:acon
     118/      E8 : (MACRO)             	Ccall _out; CALLI2(ar)
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 3 - 4/9/2017 12:24:14


     119/      EC : (MACRO)             	ldaD R12,7; reg:acon
     120/      F0 : (MACRO)             	ldaD R13,15; reg:acon
     121/      F4 : (MACRO)             	Ccall _out; CALLI2(ar)
     122/      F8 :                     ;}
     123/      F8 :                     L7:
     124/      F8 : (MACRO)             	release 4
     125/      FC : (MACRO)             	Cretn
     126/      FE :                     
     127/      FE :                     ;$$function end$$ _disp42
     128/      FE :                     ;$$function start$$ _dispbl
     129/      FE :                     _dispbl:		;framesize=8
     130/      FE : (MACRO)             	pushr R7
     131/     100 : (MACRO)             	reserve 4; save room for outgoing arguments
     132/     104 :                     ;void dispbl(){
     133/     104 :                     ;	initleds();
     134/     104 :                     ;	for (i=8;i>0;i--){
     135/     104 : 7A                   req
     136/     105 : 7B                   seq
     137/     106 : 22                   dec 2
     138/     107 : 67                   out 7
     139/     108 : 7A                   req
     140/     109 : (MACRO)             	ldaD R7,8; reg:acon
     141/     10D :                     L11:
     142/     10D :                     ;		out(7,15);
     143/     10D : (MACRO)             	ldaD R12,7; reg:acon
     144/     111 : (MACRO)             	ldaD R13,15; reg:acon
     145/     115 : (MACRO)             	Ccall _out; CALLI2(ar)
     146/     119 :                     ;	}
     147/     119 :                     L12:
     148/     119 :                     ;	for (i=8;i>0;i--){
     149/     119 : (MACRO)             	decm R7,1	;SUBI2(reg,consm)
     150/     11A : (MACRO)             	jnI2I R7,0,lbnf,L11; GT reverse  the subtraction
     151/     12B :                     ;}
     152/     12B :                     L9:
     153/     12B : (MACRO)             	release 4; release room for outgoing arguments
     154/     12F : (MACRO)             	popr R7
     155/     134 : (MACRO)             	Cretn
     156/     136 :                     
     157/     136 :                     ;$$function end$$ _dispbl
     158/     136 :                     ;$$function start$$ _dispmemloc
     159/     136 :                     _dispmemloc:		;framesize=14
     160/     136 : (MACRO)             	pushr R4
     161/     138 : (MACRO)             	pushr R5
     162/     13A : (MACRO)             	pushr R6
     163/     13C : (MACRO)             	pushr R7
     164/     13E : (MACRO)             	reserve 4; save room for outgoing arguments
     165/     142 : (MACRO)             	st2 R12,'O',sp,(14+1); flag1 
     166/     14F :                     ;void dispmemloc(unsigned int loc){
     167/     14F :                     ;	register unsigned char* m=0;
     168/     14F : (MACRO)             	ldaD R7,0; reg:acon
     169/     153 :                     ;	initleds();
     170/     153 :                     ;	m1=m[loc]>>4;
     171/     153 : 7A                   req
     172/     154 : 7B                   seq
     173/     155 : 22                   dec 2
     174/     156 : 67                   out 7
     175/     157 : 7A                   req
     176/     158 : (MACRO)             	ld2 R11,'O',sp,(14+1) ;reg:INDIRU2(addr)
     177/     164 : (MACRO)             	alu2 R11,R11,R7,add,adc	;ADDP2(reg,reg)
     178/     16E : (MACRO)             	ldn1 R11,R11	;opt14*
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 4 - 4/9/2017 12:24:14


     179/     170 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     180/     173 : (MACRO)             	shrI2I R11,4
     181/     193 : (MACRO)             	cpy1 R6,R11;LOADU1(reg)
     182/     195 :                     ;	m2=m[loc]&0x0f;
     183/     195 : (MACRO)             	ld2 R11,'O',sp,(14+1) ;reg:INDIRU2(addr)
     184/     1A1 : (MACRO)             	alu2 R11,R11,R7,add,adc	;ADDP2(reg,reg)
     185/     1AB : (MACRO)             	ldn1 R11,R11	;opt14*
     186/     1AD : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     187/     1B0 : (MACRO)             	alu2I R11,R11,15,ani,ani
     188/     1B8 :                     	;removed ?	cpy2 R11,R11
     189/     1B8 : (MACRO)             	cpy1 R5,R11;LOADU1(reg)
     190/     1BA :                     ;	out(7,m2); out(7,m1);
     191/     1BA : (MACRO)             	ldaD R12,7; reg:acon
     192/     1BE : (MACRO)             	cpy1 R13,R5
     193/     1C0 : (MACRO)             	zExt R13 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     194/     1C3 : (MACRO)             	Ccall _out; CALLI2(ar)
     195/     1C7 : (MACRO)             	ldaD R12,7; reg:acon
     196/     1CB : (MACRO)             	cpy1 R13,R6
     197/     1CD : (MACRO)             	zExt R13 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     198/     1D0 : (MACRO)             	Ccall _out; CALLI2(ar)
     199/     1D4 :                     ;	for (i=6;i!=0;i--) out(7,15);
     200/     1D4 : (MACRO)             	ldaD R4,6; reg:acon
     201/     1D8 : C0 01 E8            	lbr L20
     202/     1DB :                     L17:
     203/     1DB : (MACRO)             	ldaD R12,7; reg:acon
     204/     1DF : (MACRO)             	ldaD R13,15; reg:acon
     205/     1E3 : (MACRO)             	Ccall _out; CALLI2(ar)
     206/     1E7 :                     L18:
     207/     1E7 : (MACRO)             	decm R4,1	;SUBU2(reg,consm)
     208/     1E8 :                     L20:
     209/     1E8 : (MACRO)             	jnzU2 R4,L17; NE 0 
     210/     1F0 :                     ;}
     211/     1F0 :                     L15:
     212/     1F0 : (MACRO)             	release 4; release room for outgoing arguments
     213/     1F4 : (MACRO)             	popf R7	;opt11.3
     214/     1F7 : (MACRO)             	popm R6	;opt11.4
     215/     1F9 : (MACRO)             	popm R5	;opt11.4
     216/     1FB : (MACRO)             	popl R4	;opt11.4
     217/     1FF : (MACRO)             	Cretn
     218/     201 :                     
     219/     201 :                     ;$$function end$$ _dispmemloc
     220/     201 :                     ;$$function start$$ _main
     221/     201 :                     _main: ;copt is peeping your size 6 frame with oct 23 rules
     222/     201 : (MACRO)             	reserve 4
     223/     205 :                     ;{
     224/     205 :                     ;	disp42();
     225/     205 : (MACRO)             	Ccall _disp42
     226/     209 :                     ;	delay(1000);
     227/     209 : (MACRO)             	ldaD R12,1000; reg:acon
     228/     20D : (MACRO)             	Ccall _delay
     229/     211 :                     ;	dispmemloc(0);
     230/     211 : (MACRO)             	ld2z R12
     231/     215 : (MACRO)             	Ccall _dispmemloc
     232/     219 :                     ;	delay(1000);
     233/     219 : (MACRO)             	ldaD R12,1000; reg:acon
     234/     21D : (MACRO)             	Ccall _delay
     235/     221 : C0 02 74            	lbr L23
     236/     224 :                     L22:
     237/     224 :                     ;	while(1){
     238/     224 :                     ;		out(1,1); //activate top row of keys
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 5 - 4/9/2017 12:24:14


     239/     224 : (MACRO)             	ldaD R11,1; reg:acon
     240/     228 : (MACRO)             	cpy2 R12,R11 ;LOADI2(reg)
     241/     22C : (MACRO)             	cpy2 R13,R11 ;LOADI2(reg)
     242/     230 : (MACRO)             	Ccall _out; CALLI2(ar)
     243/     234 :                     ;		if(ef1()){ //key 12 pressed
     244/     234 : (MACRO)             	Ccall _ef1; CALLI2(ar)
     245/     238 : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     246/     23C : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     247/     23F : (MACRO)             	jzU2 R11,L25; EQ 0
     248/     247 :                     ;			disp12();
     249/     247 : (MACRO)             	Ccall _disp12
     250/     24B :                     ;		} else if(ef2()){//key 8
     251/     24B : C0 02 74            	lbr L26
     252/     24E :                     L25:
     253/     24E : (MACRO)             	Ccall _ef2; CALLI2(ar)
     254/     252 : (MACRO)             	cpy2 R11,R15 ;LOADU2*(reg)
     255/     256 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     256/     259 : (MACRO)             	jzU2 R11,L27; EQ 0
     257/     261 :                     ;			dispmemloc(01);
     258/     261 : (MACRO)             	ldaD R12,1; reg:acon
     259/     265 : (MACRO)             	Ccall _dispmemloc
     260/     269 :                     ;		}else{
     261/     269 : C0 02 74            	lbr L28
     262/     26C :                     L27:
     263/     26C :                     ;			dispmemloc(02);;
     264/     26C : (MACRO)             	ldaD R12,2; reg:acon
     265/     270 : (MACRO)             	Ccall _dispmemloc
     266/     274 :                     ;		}
     267/     274 :                     L28:
     268/     274 :                     L26:
     269/     274 :                     ;	}
     270/     274 :                     L23:
     271/     274 :                     ;	while(1){
     272/     274 : C0 02 24            	lbr L22
     273/     277 :                     L29:
     274/     277 :                     ;	while(1);
     275/     277 :                     L30:
     276/     277 : C0 02 77            	lbr L29
     277/     27A :                     ;}
     278/     27A :                     L21:
     279/     27A : (MACRO)             	release 4
     280/     27E : (MACRO)             	Cretn
     281/     280 :                     
     282/     280 :                     ;$$function end$$ _main
     283/     280 :                     ;$$function start$$ _delay
     284/     280 :                     _delay:		;framesize=10
     285/     280 : (MACRO)             	pushr R6
     286/     282 : (MACRO)             	pushr R7
     287/     284 : (MACRO)             	reserve 4; save room for outgoing arguments
     288/     288 : (MACRO)             	cpy2 R7,R12; function(2054) 1
     289/     28C :                     ;void delay(unsigned int howlong){
     290/     28C :                     ;	for (i=1;i!=howlong;i++){
     291/     28C : (MACRO)             	ldaD R6,1; reg:acon
     292/     290 : C0 02 98            	lbr L36
     293/     293 :                     L33:
     294/     293 :                     ;		oneMs();
     295/     293 : (MACRO)             	Ccall _oneMs; CALLI2(ar)
     296/     297 :                     ;	}
     297/     297 :                     L34:
     298/     297 :                     ;	for (i=1;i!=howlong;i++){
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 6 - 4/9/2017 12:24:14


     299/     297 : (MACRO)             	incm R6,1
     300/     298 :                     L36:
     301/     298 : (MACRO)             	jneU2 R6,R7,L33; NE
     302/     2AA :                     ;}
     303/     2AA :                     L32:
     304/     2AA : (MACRO)             	release 4; release room for outgoing arguments
     305/     2AE : (MACRO)             	popf R7	;opt11.3
     306/     2B1 : (MACRO)             	popl R6	;opt11.3
     307/     2B5 : (MACRO)             	Cretn
     308/     2B7 :                     
     309/     2B7 :                     ;$$function end$$ _delay
     310/     2B7 :                     ;$$function start$$ _olduinoincluder
     311/     2B7 :                     _olduinoincluder:		;framesize=2
     312/     2B7 :                     ;void olduinoincluder(){
     313/     2B7 :                     ;	asm("\tinclude olduino.inc\n");
     314/     2B7 :                     	include olduino.inc
(1)    1/     2B7 :                     ;Feb 8 2013, first version of assembler routines for olduino support	
(1)    2/     2B7 :                     ;may 31 - incredibly, there's an error in digitalWrite.  lda2 changed to ldAD
(1)    3/     2B7 :                     ;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
(1)    4/     2B7 :                     	align 64	;needed to make sure all on same page
(1)    5/     2C0 :                     _digitalWrite:
(1)    6/     2C0 : 8C                  	glo regArg1	;get the bit number
(1)    7/     2C1 : FC DE               	adi $$bvtable&255	;add the table offset
(1)    8/     2C3 : AE                  	plo memaddr
(1)    9/     2C4 : 93                  	ghi RPC		;get the top byte of the current page
(1)   10/     2C5 : BE                  	phi memaddr	
(1)   11/     2C6 : 0E                  	ldn memaddr	;pick up the bit pattern
(1)   12/     2C7 : A8                  	plo rt1		;save it in a temp
(1)   13/     2C8 : (MACRO)             	ldAD memaddr,_PIN4 ;address the current port value
(1)   14/     2CC : EE                  	sex memaddr	;prepare to change it
(1)   15/     2CD : 8D                  	glo regArg2	;get on/off switch
(1)   16/     2CE : 32 D5               	bz $$setbitoff
(1)   17/     2D0 :                     ; here we have the bit pattern in rt1 and we're ready to apply it with OR
(1)   18/     2D0 : 88                  	glo rt1		;get the bit value back
(1)   19/     2D1 : F1                  	or		;apply it
(1)   20/     2D2 : 5E                  	str memaddr	;and save it
(1)   21/     2D3 : 30 DA               	br $$outit	;go fnish up
(1)   22/     2D5 :                     $$setbitoff:
(1)   23/     2D5 : 88                  	glo rt1		;get the bit pattern
(1)   24/     2D6 : FB FF               	xri 0xff	;reverse it
(1)   25/     2D8 : F2                  	and		;combine it with the existing pin value
(1)   26/     2D9 : 5E                  	str memaddr	;and save it
(1)   27/     2DA :                     ;here we gave set/reset the correct bit in PIN4 and we just have to send it out
(1)   28/     2DA :                     $$outit:
(1)   29/     2DA : 64                  	out 4		;X was already set to memaddr
(1)   30/     2DB : E2                  	sex sp		;reset X
(1)   31/     2DC : (MACRO)             	cretn
(1)   32/     2DE : 01 02 04 08 10 20   $$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
                    40 80 
(1)   33/     2E6 :                     ;int digitalRead(unsigned char pin){//for now this will always read ef3
(1)   34/     2E6 :                     	align 8	;protect jump boundary
(1)   35/     2E8 :                     _digitalRead:
(1)   36/     2E8 : F8 00               	ldi 0		;default is false
(1)   37/     2EA : AF                  	plo R15
(1)   38/     2EB : BF                  	phi R15
(1)   39/     2EC : 36 EF               	b3 +		;i have to reverse the sense of the external line
(1)   40/     2EE : 1F                  	inc R15		;if external line is high, supply a 1
(1)   41/     2EF : (MACRO)             +	cretn
(1)   42/     2F1 :                     
     315/     2F1 :                     ;}
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 7 - 4/9/2017 12:24:14


     316/     2F1 :                     L37:
     317/     2F1 : (MACRO)             	Cretn
     318/     2F3 :                     
     319/     2F3 :                     ;$$function end$$ _olduinoincluder
     320/     2F3 :                     	include lcc1802epiloNW.inc
(1)    1/     2F3 :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/     2F3 :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/     2F3 :                     ;this is the version published with the lcc1802121229 release
(1)    4/     2F3 :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/     2F3 :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/     2F3 :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/     2F3 :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/     2F3 :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/     2F3 :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/     2F3 :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/     2F3 :                     ;feb 27 changed stack to start at 7fff
(1)   12/     2F3 :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/     2F3 :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/     2F3 :                     ;april 4 adding digit count argument to dubdabx
(1)   15/     2F3 :                     ;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
(1)   16/     2F3 :                     ;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
(1)   17/     2F3 :                     ;16-09-20 allow stack relocation 
(1)   18/     2F3 :                     ;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
(1)   19/     2F3 :                     ;17-03-07 adjusting stack offset for 1805/6 stack discipline
(1)   20/     2F3 :                     ;17-03-13 protecting work areas in divi2,divi4 routines from 1806 SCAL
(1)   21/     2F3 :                     ;17-03-15 onems compensates for reduced subroutine overhead in 1806
(1)   22/     2F3 : =EH                 rwork	equ	memAddr	;work register
(1)   23/     2F3 :                     lcc1802init:	
(1)   24/     2F3 : (MACRO)             	ldiReg	RCALL,$$_die; _call
(1)   25/     2F7 : (MACRO)             	ldiReg	RRET,$$_die; _return
(1)   26/     2FB : =>DEFINED             IFNDEF  LCCSTACKLOC		;wjr 16-09-20 allow stack relocation
(1)   27/     2FB :                     	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1 as default
(1)   28/     2FB : =>TRUE                ELSEIF				;wjr 16-09-20
(1)   29/     2FB : (MACRO)             	ldiReg	SP,LCCSTACKLOC	;wjr 16-09-20 start stack as specified
(1)   30/     2FF : [26]                  ENDIF				;wjr 16-09-20
(1)   31/     2FF : E2                  	sex	SP
(1)   32/     300 : (MACRO)             	ldiReg	RPC,$$_00000
(1)   33/     304 : D3                  	sep	RPC
(1)   34/     305 :                     $$_00000:
(1)   35/     305 : (MACRO)             	Ccall _main	;call the main routine
(1)   36/     309 : C0 03 09            $$_die:	lbr	$$_die		;loop here when main returns
(1)   37/     30C : DE AD               	db	0xde,0xad
(1)   38/     30E :                     
(1)   39/     30E :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   40/     30E :                     _setqOn:
(1)   41/     30E : 7B                  	seq
(1)   42/     30F : (MACRO)             	Cretn
(1)   43/     311 :                     _setqOff:
(1)   44/     311 : 7A                  	req
(1)   45/     312 : (MACRO)             	Cretn
(1)   46/     314 :                     
(1)   47/     314 :                     _modU2:	;16 bit unsigned remainder
(1)   48/     314 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   49/     314 : (MACRO)                 Ccall _divU2
(1)   50/     318 : 8C                      glo regArg1
(1)   51/     319 : AF                      plo retVal
(1)   52/     31A : 9C                      ghi regArg1
(1)   53/     31B : BF                      phi retVal
(1)   54/     31C : (MACRO)                 Cretn
(1)   55/     31E :                         
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm(lcc1802epiloNW.inc) - page 8 - 4/9/2017 12:24:14


(1)   56/     31E :                     _modI2:	;16 bit signed remainder
(1)   57/     31E :                     	; just calls the 16 bit division then puts remainder into return value
(1)   58/     31E : (MACRO)                 Ccall _divI2
(1)   59/     322 : 8C                      glo regArg1
(1)   60/     323 : AF                      plo retVal
(1)   61/     324 : 9C                      ghi regArg1
(1)   62/     325 : BF                      phi retVal
(1)   63/     326 : (MACRO)                 Cretn
(1)   64/     328 :                     
(1)   65/     328 :                     _out4:	
(1)   66/     328 : 8C                  	glo	regArg1
(1)   67/     329 : 22                  	dec	sp
(1)   68/     32A : 52                  	str	sp
(1)   69/     32B : 64                  	out	4
(1)   70/     32C : (MACRO)             	Cretn
(1)   71/     32E :                     
(1)   72/     32E :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   73/     32E :                     	align 256
(1)   74/     400 :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)   75/     400 : D3                  	sep     R3 ;go to subroutine
(1)   76/     401 : E2                  _call	sex	SP ;make sure X=SP
(1)   77/     402 : 86                  	glo	retAddr ;save previous return pointer on stack
(1)   78/     403 : 22                  	dec	sp
(1)   79/     404 : 73                  	stxd
(1)   80/     405 : 96                  	ghi	retAddr
(1)   81/     406 : 52                  	str	sp	
(1)   82/     407 : 83                  	glo	RPC ;copy old PC to retAddr
(1)   83/     408 : A6                  	plo	retAddr
(1)   84/     409 : 93                  	ghi	RPC
(1)   85/     40A : B6                  	phi	retAddr
(1)   86/     40B : 46                  	lda	retAddr ;pick up subroutine address into RPC
(1)   87/     40C : B3                  	phi	RPC
(1)   88/     40D : 46                  	lda	retAddr
(1)   89/     40E : A3                  	plo	RPC
(1)   90/     40F : 30 00               	br	_call-1
(1)   91/     411 :                     
(1)   92/     411 :                     ;Standard subroutine return 
(1)   93/     411 : D3                  	sep	RPC	;return to the original program
(1)   94/     412 : 86                  _return	glo	retAddr	;transfer the current return address to RPC
(1)   95/     413 : A3                  	plo	RPC
(1)   96/     414 : 96                  	ghi	retAddr
(1)   97/     415 : B3                  	phi	RPC
(1)   98/     416 : 42                  	lda	SP	;pick up old return address
(1)   99/     417 : B6                  	phi	retAddr
(1)  100/     418 : 42                  	lda	SP
(1)  101/     419 : A6                  	plo	retAddr
(1)  102/     41A : 30 11               	br	_return-1
(1)  103/     41C :                     
(1)  104/     41C :                     _oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
(1)  105/     41C :                     ;subroutine overhead soaks up 27 instruction time.
(1)  106/     41C :                     ;each loop is 2 instruction times
(1)  107/     41C :                     ;so the number of loops needed is 
(1)  108/     41C :                     ;CPU speed/16000 less the 27 all divide by two
(1)  109/     41C : =>DEFINED           	IFNDEF	LCC1802CPUSPEED
(1)  110/     41C :                     LCC1802CPUSPEED EQU 1600000	;1.6MHZ default
(1)  111/     41C : [109]               	ENDIF
(1)  112/     41C : =>TRUE               if MOMCPU=$1805		;for 1806 SCAL
(1)  113/     41C : =EH                 LCC1802SUBOVHD  EQU 14		;1806 SCAL/SRET subroutine overhead
(1)  114/     41C : =>FALSE              else
(1)  115/     41C :                     LCC1802SUBOVHD  EQU 27		;default SCRT subroutine overhead
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm(lcc1802epiloNW.inc) - page 9 - 4/9/2017 12:24:14


(1)  116/     41C : [112]                endif 
(1)  117/     41C : F8 02               	ldi	(LCC1802CPUSPEED/1000/16-LCC1802SUBOVHD)/2
(1)  118/     41E : FF 01               $$mslp:	smi	1
(1)  119/     420 : 3A 1E               	bnz	$$mslp
(1)  120/     422 : (MACRO)             	Cretn
(1)  121/     424 :                     
(1)  122/     424 :                     
(1)  123/     424 :                     	
(1)  124/     424 :                     ;16 bit right shifting multiply which is faster for smaller operands
(1)  125/     424 :                     ; credit to http://map.grauw.nl/articles/mult_div_shifts.php#lrmultr
(1)  126/     424 :                     _mulU2:		;retval(product)=regarg1(multiplicand)*regarg2(multiplier)
(1)  127/     424 : (MACRO)             	ld2z retval
(1)  128/     428 :                     $$mulrlp:
(1)  129/     428 : (MACRO)             	shru2 regarg2
(1)  130/     42E : 3B 3A               	bnf $$mulrnoadd
(1)  131/     430 :                     ;	bottom bit of multiplier is one so add multiplicand to product
(1)  132/     430 : (MACRO)             	alu2 retval,retval,regarg1,add,adc
(1)  133/     43A :                     $$mulrnoadd:
(1)  134/     43A : 9D                  	ghi regarg2	;check for all bits of multiplier shifted out
(1)  135/     43B : 3A 40               	bnz $$mulrshft	;nope, continue
(1)  136/     43D : 8D                  	glo regarg2	;check bottom byte
(1)  137/     43E : 32 48               	bz $$mulrdone
(1)  138/     440 :                     $$mulrshft:
(1)  139/     440 : (MACRO)             	shl2 regarg1	;shift multiplicand left 1
(1)  140/     446 : 30 28               	br $$mulrlp
(1)  141/     448 :                     $$mulrdone:		;here the product is in retval
(1)  142/     448 : (MACRO)             	cretn
(1)  143/     44A :                     
(1)  144/     44A :                     ;this is a divisor shifting algorithm which is faster for smaller operands
(1)  145/     44A :                     ;credit to http://research.microsoft.com/pubs/70645/tr-2008-141.pdf
(1)  146/     44A :                     ;changed oct 12 to save R10 & 1/2 R11 on stack
(1)  147/     44A :                     _divu2: ;retval=regarg1(x or dividend)/regarg2(y or divisor)
(1)  148/     44A :                     	;uses R14(rwork) to hold original divisor y0, 
(1)  149/     44A :                     	;regarg1 to hold develop remainder, 
(1)  150/     44A :                     	;R10 to hold working dividend R11.0 as a temp
(1)  151/     44A :                     testsub: macro reg1,reg2	;test subtraction of reg2 from reg1
(1)  152/     44A :                     				;result in D, rwork.hi, DF
(1)  153/     44A :                     	glo reg2
(1)  154/     44A :                     	str sp
(1)  155/     44A :                     	glo reg1
(1)  156/     44A :                     	sm
(1)  157/     44A :                     	plo R11
(1)  158/     44A :                     	ghi reg2
(1)  159/     44A :                     	str sp
(1)  160/     44A :                     	ghi reg1
(1)  161/     44A :                     	smb
(1)  162/     44A :                     	endm
(1)  163/     44A :                     	
(1)  164/     44A : (MACRO)             	pushf R10	;save R10 & leave stack down 1
(1)  165/     44F : 8B                  	glo R11		;and bottom
(1)  166/     450 : 73                  	stxd		;of R11 - leaves stack clear of work area
(1)  167/     451 : (MACRO)             	cpy2 R10,regarg1
(1)  168/     455 : (MACRO)             	ld2z retval	;quotient
(1)  169/     459 : (MACRO)             	cpy2 rwork,regarg2
(1)  170/     45D :                     	
(1)  171/     45D : (MACRO)             	testsub R10,regarg2
(1)  172/     466 : 3B 81               	bnf $$computequot	;DF=0 means it didn't fit
(1)  173/     468 : BA                  	phi R10	;R10=R10-regarg2
(1)  174/     469 : 8B                  	glo R11
(1)  175/     46A : AA                  	plo R10
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm(lcc1802epiloNW.inc) - page 10 - 4/9/2017 12:24:14


(1)  176/     46B :                     	
(1)  177/     46B :                     $$again:	;this is the divisor doubling phase
(1)  178/     46B : (MACRO)              	testsub R10,regarg2
(1)  179/     474 : 3B 81                	bnf $$computequot	;df=0 means it didn't fit
(1)  180/     476 : BA                  	phi R10	;R10=R10-regarg2
(1)  181/     477 : 8B                  	glo R11
(1)  182/     478 : AA                  	plo R10 	
(1)  183/     479 : (MACRO)              	shl2 regarg2	;y=y+y
(1)  184/     47F : 30 6B                	br $$again
(1)  185/     481 :                      	
(1)  186/     481 :                      $$computequot:	;here we're computing the quotient
(1)  187/     481 : (MACRO)              	testsub regarg1,regarg2
(1)  188/     48A : 3B 90                	bnf $$testexit
(1)  189/     48C : BC                   	phi regarg1		;complete the subtraction
(1)  190/     48D : 8B                   	glo R11
(1)  191/     48E : AC                   	plo regarg1
(1)  192/     48F : 1F                   	inc retval
(1)  193/     490 :                      $$testexit:
(1)  194/     490 : 9E                   	ghi rwork
(1)  195/     491 : F7                   	sm	;top of regarg2 is still on stack
(1)  196/     492 : 3A 9A                	bnz $$ney0y
(1)  197/     494 : 8D                   	glo regarg2
(1)  198/     495 : 52                   	str sp
(1)  199/     496 : 8E                   	glo rwork
(1)  200/     497 : F7                   	sm	;test low order bytes
(1)  201/     498 : 32 A8                	bz	$$out	;if = we're done
(1)  202/     49A :                      $$ney0y:
(1)  203/     49A : (MACRO)              	shl2 retval	;double quotient
(1)  204/     4A0 : (MACRO)              	shrU2 regarg2	;halve divisor
(1)  205/     4A6 : 30 81                	br $$computequot	;continue
(1)  206/     4A8 :                      $$out:
(1)  207/     4A8 :                      ;here the quotient is in retval, remainder in regarg1
(1)  208/     4A8 : 12                    	inc sp	;release work area
(1)  209/     4A9 : 42                  	lda sp	;recover
(1)  210/     4AA : AB                  	plo R11	;bottom byte of R11
(1)  211/     4AB : (MACRO)             	popr R10 ;and all of R10
(1)  212/     4B0 : (MACRO)             	cretn	;and we're done
(1)  213/     4B2 :                     
(1)  214/     4B2 :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  215/     4B2 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  216/     4B2 :                     _divI2:
(1)  217/     4B2 : 22                      dec	sp	;leave a work area available
(1)  218/     4B3 : 9C                      ghi regArg1
(1)  219/     4B4 : 52                      str sp	;save the sign of the 1st arg
(1)  220/     4B5 : FE                      shl
(1)  221/     4B6 : 3B C1                   bnf $$pos1	;if the 1st arg is -v
(1)  222/     4B8 : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
(1)  223/     4C1 :                     $$pos1: ;1st is now +v, check 2nd
(1)  224/     4C1 : 9D                      ghi regArg2
(1)  225/     4C2 : F3                      xor	
(1)  226/     4C3 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  227/     4C4 : 9D                      ghi regArg2
(1)  228/     4C5 : FE                      shl
(1)  229/     4C6 : 3B D1                   bnf $$pos2	;if the 2nd arg is -v
(1)  230/     4C8 : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  231/     4D1 :                     $$pos2: ; both args now +v
(1)  232/     4D1 : =>TRUE               if MOMCPU=$1805
(1)  233/     4D1 : 22                      dec sp	;protect workarea on the 1802
(1)  234/     4D2 : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  235/     4D6 : 12                      inc sp	;recover work area
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm(lcc1802epiloNW.inc) - page 11 - 4/9/2017 12:24:14


(1)  236/     4D7 : =>FALSE              else
(1)  237/     4D7 :                         Ccall _divU2	;call unsigned division
(1)  238/     4D7 : [232]                endif 
(1)  239/     4D7 :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  240/     4D7 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  241/     4D8 : FE                      shl
(1)  242/     4D9 : 3B E4                   bnf $$done ;if the signs were different
(1)  243/     4DB : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  244/     4E4 :                     $$done:
(1)  245/     4E4 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  246/     4E6 :                     
(1)  247/     4E6 :                     
(1)  248/     4E6 :                     	align 256    ;32 bit operations follow
(1)  249/     500 :                     _divu4:
(1)  250/     500 :                     ;This is an unsigned 32 bit restoring division
(1)  251/     500 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  252/     500 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  253/     500 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  254/     500 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  255/     500 :                     
(1)  256/     500 : F8 20               	ldi 32		;set loop count
(1)  257/     502 : AE                  	plo memaddr	;in temp register
(1)  258/     503 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  259/     50F :                     $$loop:
(1)  260/     50F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  261/     51B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  262/     527 :                     
(1)  263/     527 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  264/     53D :                     
(1)  265/     53D : FA 80               	ani 0x80	;check the top bit
(1)  266/     53F : 32 5D               	bz $$norestore	;if it's 0
(1)  267/     541 : 89                  		glo RL8
(1)  268/     542 : FA FE               		ani 0xfe	;turn off the bottom bit
(1)  269/     544 : A9                  		plo RL8
(1)  270/     545 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  271/     55B : 30 61               	br $$endlp 	;else
(1)  272/     55D :                     $$norestore:
(1)  273/     55D : 89                  		glo RL8
(1)  274/     55E : F9 01               		ori 1	;turn on the bottom bit
(1)  275/     560 : A9                  		plo RL8
(1)  276/     561 :                     	;end if
(1)  277/     561 :                     $$endlp:
(1)  278/     561 : 2E                  	dec memaddr	;check the cycle count
(1)  279/     562 : 8E                  	glo memaddr
(1)  280/     563 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  281/     565 :                     	
(1)  282/     565 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  283/     567 :                     		
(1)  284/     567 :                     
(1)  285/     567 :                     _mulu4:
(1)  286/     567 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  287/     567 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  288/     567 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  289/     567 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  290/     567 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  291/     567 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  292/     567 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  293/     567 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  294/     567 :                     	;for 10 we subtract and shift
(1)  295/     567 :                     	;for 00 and 11 we just shift
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm(lcc1802epiloNW.inc) - page 12 - 4/9/2017 12:24:14


(1)  296/     567 :                     
(1)  297/     567 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  298/     573 : F8 20                   ldi 32
(1)  299/     575 : AE                      plo memaddr		;cycle count
(1)  300/     576 : FC 00                   adi 0		;clear df
(1)  301/     578 :                     $$mloop:
(1)  302/     578 : 89                      glo RL8
(1)  303/     579 : FA 01                   ani 1		;isolate bottom bit of result
(1)  304/     57B : 3B 97                   bnf	$$check_sub	;
(1)  305/     57D : 3A AF                   bnz	$$shift		;that would be the 11 case
(1)  306/     57F :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  307/     57F : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  308/     595 : 30 AF                   br $$shift
(1)  309/     597 :                     $$check_sub:
(1)  310/     597 : 32 AF                   bz $$shift	;that would be the 00 case
(1)  311/     599 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  312/     599 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  313/     5AF :                     $$shift:
(1)  314/     5AF : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  315/     5BD : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  316/     5C9 :                     
(1)  317/     5C9 : 2E                      dec memaddr		;cycle count
(1)  318/     5CA : 8E                      glo memaddr
(1)  319/     5CB : 3A 78                   bnz $$mloop		;repeat cycle once for each bit position
(1)  320/     5CD :                         
(1)  321/     5CD : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  322/     5CF :                     
(1)  323/     5CF :                     	align 256
(1)  324/     600 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  325/     600 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  326/     600 :                     _divI4:
(1)  327/     600 : 22                      dec	sp	;leave a work area available
(1)  328/     601 : 98                      ghi RL8-1	;get the top of the dividend
(1)  329/     602 : 52                      str sp	;save the sign of the 1st arg
(1)  330/     603 : FE                      shl
(1)  331/     604 : 3B 26                   bnf $$pos1	;if the 1st arg is -v
(1)  332/     606 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  333/     626 :                     $$pos1: ;1st is now +v, check 2nd
(1)  334/     626 : 9A                      ghi RL10-1
(1)  335/     627 : F3                      xor	
(1)  336/     628 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  337/     629 : 9A                      ghi RL10-1
(1)  338/     62A : FE                      shl
(1)  339/     62B : 3B 4D                   bnf $$pos2	;if the 2nd arg is -v
(1)  340/     62D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  341/     64D :                     $$pos2: ; both args now +v
(1)  342/     64D : =>TRUE               if MOMCPU=$1805
(1)  343/     64D : 22                      dec sp	;protect workarea on the 1802
(1)  344/     64E : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  345/     652 : 12                      inc sp	;recover work area
(1)  346/     653 : =>FALSE              else
(1)  347/     653 :                         Ccall _divU4	;call unsigned division
(1)  348/     653 : [342]                endif 
(1)  349/     653 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  350/     653 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  351/     654 : FE                      shl
(1)  352/     655 : 3B 77                   bnf $$done ;if the signs were different
(1)  353/     657 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  354/     677 :                     $$done:
(1)  355/     677 : (MACRO)                 Cretn ;and we're done - I hope!
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm(lcc1802epiloNW.inc) - page 13 - 4/9/2017 12:24:14


(1)  356/     679 :                     
(1)  357/     679 :                     _dubdabx:	
(1)  358/     679 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  359/     679 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  360/     679 :                     ;long interger is passed in rp1p2
(1)  361/     679 :                     ;buffer pointer is passed at sp+2+4**+1 for 1806
(1)  362/     679 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
(1)  363/     679 :                     ;r8-11 are used as temps
(1)  364/     679 :                     ;r8 is the working pointer
(1)  365/     679 :                     ;r15.0 is bit count(32) and the return value register
(1)  366/     679 :                     ;r9.0 is digit count
(1)  367/     679 :                     ;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
(1)  368/     679 : =>TRUE               if MOMCPU=$1805
(1)  369/     679 : (MACRO)             	ld2 r8,'O',sp,(2+4+1); pick up the buffer pointer
(1)  370/     685 : (MACRO)             	ld2 r10,'O',sp,(2+4+2+1); pick up the number of digits wanted
(1)  371/     691 : =>FALSE              else
(1)  372/     691 :                     	ld2 r8,'O',sp,(2+4); pick up the buffer pointer
(1)  373/     691 :                     	ld2 r10,'O',sp,(2+4+2); pick up the number of digits wanted
(1)  374/     691 : [368]                endif
(1)  375/     691 : (MACRO)             	cpy2 r15,r8 ;save address for now
(1)  376/     695 : F8 0B               	ldi 11	;digit count+1 for trailing 0
(1)  377/     697 : A9                  	plo r9
(1)  378/     698 :                     $$clrlp:	;clear the passed buffer
(1)  379/     698 : F8 00               	ldi 0	
(1)  380/     69A : 58                  	str r8	;clear a byte
(1)  381/     69B : 18                  	inc r8
(1)  382/     69C : 29                  	dec r9
(1)  383/     69D : 89                  	glo r9	;check the count
(1)  384/     69E : 3A 98               	bnz $$clrlp ;back for more
(1)  385/     6A0 : (MACRO)             	cpy2 r8,r15 ;get the address back
(1)  386/     6A4 :                     
(1)  387/     6A4 : F8 20               	ldi 32	;bit count
(1)  388/     6A6 : AF                  	plo r15
(1)  389/     6A7 :                     ;now i'm going to spin off any leading 0's in the binary number
(1)  390/     6A7 :                     $$cktop:
(1)  391/     6A7 : 9C                  	ghi rp1p2-1	;get the top bit of the number
(1)  392/     6A8 : FE                  	shl		;check for a 1
(1)  393/     6A9 : 33 BC               	bdf $$bitloop	;move on if we have one
(1)  394/     6AB : (MACRO)             	shl4 rp1p2	;shift the input number
(1)  395/     6B7 : 2F                  	dec r15		;reduce the number of times to shift
(1)  396/     6B8 : 8F                  	glo r15
(1)  397/     6B9 : 3A A7               	bnz $$cktop	;
(1)  398/     6BB : 1F                  	inc r15		;our whole number was 0 but force at least one pass
(1)  399/     6BC :                     $$bitloop:
(1)  400/     6BC : F8 0A               	ldi 10	;digit count
(1)  401/     6BE : A9                  	plo r9
(1)  402/     6BF :                     $$dcklp:
(1)  403/     6BF : 08                  	ldn r8 	;pick up a digit
(1)  404/     6C0 : FF 05               	smi 5	;see if it's greater than 4
(1)  405/     6C2 : 3B C7               	bnf $$dnoadd ;if not, bypass add
(1)  406/     6C4 : FC 08               	adi 0x08	;add the 5 black and 3 more
(1)  407/     6C6 : 58                  	str r8	;put it back
(1)  408/     6C7 :                     $$dnoadd:
(1)  409/     6C7 : 18                  	inc r8
(1)  410/     6C8 : 29                  	dec r9	;decrement digit count
(1)  411/     6C9 : 89                  	glo r9
(1)  412/     6CA : 3A BF               	bnz $$dcklp ;and back for next digit
(1)  413/     6CC :                     	
(1)  414/     6CC : (MACRO)             	shl4 rp1p2 ;shift the input number
(1)  415/     6D8 :                     	
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm(lcc1802epiloNW.inc) - page 14 - 4/9/2017 12:24:14


(1)  416/     6D8 : F8 0A               	ldi 10	;load the digit count again
(1)  417/     6DA : A9                  	plo r9
(1)  418/     6DB :                     ;r8 is now just past the units location and ready to walk back
(1)  419/     6DB :                     $$dshlp:
(1)  420/     6DB : 28                  	dec r8	;walk back from 0's position
(1)  421/     6DC : 08                  	ldn r8	;get the digit back
(1)  422/     6DD : 7E                  	shlc	;continue the shift
(1)  423/     6DE : BF                  	phi r15 ;save it for the carry test
(1)  424/     6DF : FA 0F               	ani 0x0f ;clear the 10 bit
(1)  425/     6E1 : 58                  	str r8	;put the digit back
(1)  426/     6E2 : 9F                  	ghi r15	;now test for carry
(1)  427/     6E3 : FF 10               	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  428/     6E5 : 29                  	dec r9	;decrement the digit count
(1)  429/     6E6 : 89                  	glo r9
(1)  430/     6E7 : 3A DB               	bnz $$dshlp ;back for more if needed
(1)  431/     6E9 :                     	
(1)  432/     6E9 : 2F                  	dec r15
(1)  433/     6EA : 8F                  	glo r15
(1)  434/     6EB : 3A BC               	bnz $$bitloop
(1)  435/     6ED :                     	
(1)  436/     6ED : (MACRO)             	cpy2 r15,r8	;save the starting location of the digits
(1)  437/     6F1 : F8 0A               	ldi 10		;digit count again
(1)  438/     6F3 : A9                  	plo r9
(1)  439/     6F4 :                     $$upnxt:
(1)  440/     6F4 : 08                  	ldn r8		;get digit
(1)  441/     6F5 : F9 30               	ori 0x30	;make ascii
(1)  442/     6F7 : 58                  	str r8		;put it back
(1)  443/     6F8 : 18                  	inc r8		;next digit
(1)  444/     6F9 : 29                  	dec r9		;counter
(1)  445/     6FA : 89                  	glo r9
(1)  446/     6FB : 3A F4               	bnz $$upnxt	;upgrade all 10 spots
(1)  447/     6FD : =>TRUE               if MOMCPU=$1805	
(1)  448/     6FD : (MACRO)             	ldaX memaddr,sp,(2+4+2+1+1)	;point to lsb of desired digit count
(1)  449/     705 : =>FALSE              else
(1)  450/     705 :                      	ldaX memaddr,sp,(2+4+2+1)	;point to lsb of desired digit count
(1)  451/     705 : [447]                endif
(1)  452/     705 : EE                  	sex memaddr	;set up
(1)  453/     706 : F8 0A               	ldi 10		;max number of 0's to skip
(1)  454/     708 : F7                  	sm		;desired number of digits to skip
(1)  455/     709 : E2                  	sex sp		;reset index register
(1)  456/     70A : A9                  	plo r9		;number of leading 0's to skip
(1)  457/     70B :                     $$cknext:
(1)  458/     70B : 0F                  	ldn r15		;check digit
(1)  459/     70C : FF 30               	smi 0x30	;for '0'
(1)  460/     70E : 3A 15               	bnz $$done
(1)  461/     710 : 1F                  	inc r15		;next digit
(1)  462/     711 : 29                  	dec r9		;reduce count
(1)  463/     712 : 89                  	glo r9
(1)  464/     713 : 3A 0B               	bnz $$cknext
(1)  465/     715 :                     $$done:
(1)  466/     715 : (MACRO)             	cretn
(1)  467/     717 :                     	
(1)  468/     717 :                     	
(1)  469/     717 :                     _modU4:	;32 bit unsigned remainder
(1)  470/     717 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  471/     717 : (MACRO)                 Ccall _divU4
(1)  472/     71B : (MACRO)                 cpy4 RL8,Rp1p2
(1)  473/     723 : (MACRO)                 Cretn
(1)  474/     725 :                         
(1)  475/     725 :                     _modI4:	;32 bit signed remainder
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm(lcc1802epiloNW.inc) - page 15 - 4/9/2017 12:24:14


(1)  476/     725 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  477/     725 : (MACRO)                 Ccall _divI4
(1)  478/     729 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  479/     731 : (MACRO)                 Cretn
(1)  480/     733 :                     	
(1)  481/     733 :                     
     321/     733 :                     	include IO1802.inc
(1)    1/     733 :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/     733 :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/     733 :                     	align 64
(1)    4/     740 :                     _putc:
(1)    5/     740 :                     _out5:	
(1)    6/     740 : 8C                  	glo	regArg1
(1)    7/     741 : 22                  	dec	sp
(1)    8/     742 : 52                  	str	sp
(1)    9/     743 : 65                  	out	5
(1)   10/     744 : (MACRO)             	Cretn
(1)   11/     746 :                     _inp:		;raw port input
(1)   12/     746 :                     		;stores a small tailored program on the stack and executes it
(1)   13/     746 : 22                  	dec	sp	;work backwards
(1)   14/     747 : F8 D3               	ldi	0xD3	;return instruction
(1)   15/     749 : 73                  	stxd		
(1)   16/     74A : 8C                  	glo	regarg1	;get the port number
(1)   17/     74B : FA 07               	ani	0x07	;clean it
(1)   18/     74D : 32 5D               	bz	+	; inp(0) isn't valid
(1)   19/     74F : F9 68               	ori	0x68	;make it an input instruction
(1)   20/     751 : 73                  	stxd		;store it for execution
(1)   21/     752 : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   22/     756 : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   23/     757 : D8                  	sep	rt1	;execute it
(1)   24/     758 :                     ;we will come back to here with the input byte in D
(1)   25/     758 : 12                  	inc	sp	;step over the work area
(1)   26/     759 : AF                  	plo	retVal	;save it to return
(1)   27/     75A : F8 00               	ldi	0
(1)   28/     75C : BF                  	phi	retval	;clear top byte
(1)   29/     75D : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   30/     75E : 12                  	inc	sp	;and the D3
(1)   31/     75F : (MACRO)             	Cretn		;and we're done
(1)   32/     761 :                     	
(1)   33/     761 :                     _out:		;raw port output
(1)   34/     761 :                     		;stores a small tailored program on the stack and executes it
(1)   35/     761 :                     		;this could be bolder:
(1)   36/     761 :                     		;store the program as 6x cc D5 where x is the port number and cc is the char
(1)   37/     761 :                     		;then SEP sp
(1)   38/     761 :                     		;the D5 would return to the calling program and finish fixing the stack.
(1)   39/     761 :                     		;saves 6 instructions but it's a bit tricky.
(1)   40/     761 : 22                  	dec	sp	;work backwards
(1)   41/     762 : F8 D3               	ldi	0xD3	;return instruction
(1)   42/     764 : 73                  	stxd		
(1)   43/     765 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the OUT instruction
(1)   44/     769 : 8C                  	glo	regarg1	;get the port number
(1)   45/     76A : FA 07               	ani	0x07	;clean it
(1)   46/     76C : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   47/     76E : 73                  	stxd		;store it for execution
(1)   48/     76F : 8D                  	glo	regarg2	;get the byte to be written
(1)   49/     770 : 52                  	str	sp	;store it where sp points
(1)   50/     771 : D8                  	sep	rt1	;execute it
(1)   51/     772 :                     ;we will come back to here with sp stepped up by one
(1)   52/     772 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   53/     773 : 12                  	inc	sp	;and the D3
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm(IO1802.inc) - page 16 - 4/9/2017 12:24:14


(1)   54/     774 : (MACRO)             	Cretn		;and we're done
(1)   55/     776 :                     	
(1)   56/     776 :                     	
(1)   57/     776 :                     
     322/     776 :                     
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 17 - 4/9/2017 12:24:14


  symbol table (* = unused):
  ------------------------

 AGAIN93 :                      46B C | *ARCHITECTURE :  i386-unknown-win32 - |
*BIGENDIAN :                      0 - |  BITLOOP98 :                    6BC C |
*BRANCHEXT :                      0 - |  BVTABLE77 :                    2DE C |
*CASESENSITIVE :                  0 - |  CHECK_SUB96 :                  597 C |
 CKNEXT98 :                     70B C |  CKTOP98 :                      6A7 C |
 CLRLP98 :                      698 C |  COMPUTEQUOT93 :                481 C |
*CONSTPI :        3.141592653589793 - | *DATE :                    4/9/2017 - |
 DCKLP98 :                      6BF C |  DNOADD98 :                     6C7 C |
 DONE94 :                       4E4 C |  DONE97 :                       677 C |
 DONE98 :                       715 C |  DSHLP98 :                      6DB C |
 ENDLP95 :                      561 C | *FALSE :                          0 - |
*FULLPMMU :                       1 - | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*L1 :                            10 C |  L11 :                          10D C |
*L12 :                          119 C | *L15 :                          1F0 C |
 L17 :                          1DB C | *L18 :                          1E7 C |
 L20 :                          1E8 C | *L21 :                          27A C |
 L22 :                          224 C |  L23 :                          274 C |
 L25 :                          24E C |  L26 :                          274 C |
 L27 :                          26C C |  L28 :                          274 C |
 L29 :                          277 C | *L3 :                            1E C |
*L30 :                          277 C | *L32 :                          2AA C |
 L33 :                          293 C | *L34 :                          297 C |
 L36 :                          298 C | *L37 :                          2F1 C |
*L5 :                            89 C | *L7 :                            F8 C |
*L9 :                           12B C |  LCC1802CPUSPEED :            493E0 - |
 LCC1802INIT :                  2F3 C |  LCC1802SUBOVHD :                 E - |
 LCCCODELOC :                     0 - |  LCCSTACKLOC :                 103F - |
*LISTON :                         1 - |  LOOP95 :                       50F C |
*MACEXP :                         0 - |  MEMADDR :                        E - |
 MLOOP96 :                      578 C |  MOMCPU :                      1805 - |
*MOMCPUNAME :                  1805 - |  MSLP91 :                       41E C |
 MULRDONE92 :                   448 C |  MULRLP92 :                     428 C |
 MULRNOADD92 :                  43A C |  MULRSHFT92 :                   440 C |
*NESTMAX :                      100 - |  NEY0Y93 :                      49A C |
 NORESTORE95 :                  55D C |  OUT93 :                        4A8 C |
 OUTIT77 :                      2DA C | *PACKING :                        0 - |
*PADDING :                        1 - |  POS194 :                       4C1 C |
 POS197 :                       626 C |  POS294 :                       4D1 C |
 POS297 :                       64D C | *R0 :                             0 - |
*R1 :                             1 - |  R10 :                            A - |
 R11 :                            B - |  R12 :                            C - |
 R13 :                            D - | *R14 :                            E - |
 R15 :                            F - | *R2 :                             2 - |
 R3 :                             3 - |  R4 :                             4 - |
 R5 :                             5 - |  R6 :                             6 - |
 R7 :                             7 - |  R8 :                             8 - |
 R9 :                             9 - |  RCALL :                          4 - |
 REGARG1 :                        C - |  REGARG2 :                        D - |
*RELAXED :                        1 - |  RETADDR :                        6 - |
 RETVAL :                         F - | *RL0 :                            1 - |
 RL10 :                           B - | *RL12 :                           D - |
*RL6 :                            7 - |  RL8 :                            9 - |
 RP1P2 :                          D - |  RPC :                            3 - |
 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 18 - 4/9/2017 12:24:14


 RRET :                           5 - |  RT1 :                            8 - |
*RT2 :                            9 - |  RWORK :                          E - |
 SETBITOFF77 :                  2D5 C |  SHIFT96 :                      5AF C |
 SP :                             2 - |  TESTEXIT93 :                   490 C |
*TIME :                    12:24:14 - | *TRUE :                           1 - |
 UPNXT98 :                      6F4 C | *VERSION :                     142F - |
 _0000082 :                     305 C |  _CALL :                        401 C |
 _DELAY :                       280 C |  _DIE82 :                       309 C |
*_DIGITALREAD :                 2E8 C | *_DIGITALWRITE :                2C0 C |
 _DISP12 :                       20 C |  _DISP42 :                       8F C |
*_DISPBL :                       FE C |  _DISPMEMLOC :                  136 C |
 _DIVI2 :                       4B2 C |  _DIVI4 :                       600 C |
 _DIVU2 :                       44A C |  _DIVU4 :                       500 C |
*_DUBDABX :                     679 C |  _EF1 :                           4 C |
 _EF1.RET0 :                      C C |  _EF2 :                          12 C |
 _EF2.RET0 :                     1A C | *_INP :                         746 C |
 _MAIN :                        201 C | *_MODI2 :                       31E C |
*_MODI4 :                       725 C | *_MODU2 :                       314 C |
*_MODU4 :                       717 C | *_MULU2 :                       424 C |
*_MULU4 :                       567 C | *_OLDUINOINCLUDER :             2B7 C |
 _ONEMS :                       41C C |  _OUT :                         761 C |
*_OUT4 :                        328 C | *_OUT5 :                        740 C |
 _PIN4 :                          3 C | *_PUTC :                        740 C |
 _RETURN :                      412 C | *_SETQOFF :                     311 C |
*_SETQON :                      30E C |  __FORW2 :                      2EF C |
 __FORW3 :                      75D C | *__FORW4 :                      772 C |

    166 symbols
     66 unused symbols

 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 19 - 4/9/2017 12:24:14


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU2RRS                               | ALU4                                 
ALU4I                                 | BLKCPY                               
CCALL                                 | CPY1                                 
CPY2                                  | CPY4                                 
CRETN                                 | DECM                                 
DEMOTE                                | INC4                                 
INCM                                  | JCF4                                 
JCI2                                  | JCI2I                                
JCI4                                  | JCU2                                 
JCU2I                                 | JCU4                                 
JEQI1                                 | JEQI2                                
JEQI4                                 | JEQU1I                               
JEQU2I                                | JNEU1I                               
JNEU2                                 | JNEU2I                               
JNEU2NI                               | JNEU4                                
JNI2I                                 | JNU2I                                
JNZU1                                 | JNZU2                                
JUMPV                                 | JZU1                                 
JZU2                                  | LD1                                  
LD2                                   | LD2Z                                 
LD4                                   | LDA2                                 
LDAD                                  | LDAX                                 
LDAXS                                 | LDI4                                 
LDIREG                                | LDN1                                 
LDN2                                  | LDN2S                                
MVC1                                  | MVC2                                 
MVCN1                                 | MVCN2                                
NEGI2                                 | NEGI4                                
NOP1806                               | POPF                                 
POPL                                  | POPM                                 
POPR                                  | PUSHF                                
PUSHL                                 | PUSHM                                
PUSHR                                 | RELEASE                              
RELEASEL                              | RELEASES                             
RESERVE                               | RESERVEL                             
RESERVES                              | SEXT                                 
SEXT4                                 | SHL2                                 
SHL2I                                 | SHL2R                                
SHL4                                  | SHL4I                                
SHL4R                                 | SHLC4                                
SHLR2R                                | SHRC4                                
SHRI2                                 | SHRI2I                               
SHRI2R                                | SHRI4                                
SHRI4I                                | SHRI4R                               
SHRU2                                 | SHRU2I                               
SHRU2R                                | SHRU4                                
SHRU4I                                | SHRU4R                               
ST1                                   | ST2                                  
ST2I                                  | ST4                                  
STR1                                  | STR1I                                
STR2                                  | STR2I                                
TESTSUB                               | ZEXT                                 
ZEXT4                                 |

    107 macros

 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 20 - 4/9/2017 12:24:14


 AS V1.42 Beta [Bld 87] - source file boydmon2.oasm - page 21 - 4/9/2017 12:24:14


  codepages:
  ----------

STANDARD (0 changed characters)


0.18 seconds assembly time

   2027 lines source file
   3826 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
