; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Wed Jan 31 16:36:52 2018

SP:	equ	2 ;stack pointer
memAddr: equ	14
retAddr: equ	6
retVal:	equ	15
regArg1: equ	12
regArg2: equ	13
	listing off
	include lcc1802proloNW.inc
	listing on
_PIN4:
	db 0
_boydsegments:
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 34
	db 0
	db 0
	db 0
	db 0
	db 32
	db 0
	db 0
	db 0
	db 0
	db 17
	db 4
	db 0
	db 44
	db 123
	db 48
	db 109
	db 117
	db 54
	db 87
	db 95
	db 112
	db 127
	db 119
	db 65
	db 81
	db 0
	db 0
	db 0
	db 0
	db 111
	db 126
	db 31
	db 75
	db 61
	db 79
	db 78
	db 91
	db 62
	db 16
	db 57
	db 94
	db 11
	db 88
	db 28
	db 29
	db 110
	db 103
	db 12
	db 83
	db 15
	db 59
	db 25
	db 35
	db 92
	db 55
	db 105
	db 0
	db 22
	db 0
	db 0
	db 1
	db 6
	db 126
	db 31
	db 75
	db 61
	db 79
	db 78
	db 91
	db 62
	db 16
	db 57
	db 94
	db 11
	db 88
	db 28
	db 29
	db 110
	db 103
	db 12
	db 83
	db 15
	db 59
	db 25
	db 35
	db 92
	db 55
	db 105
	db 0
	db 0
	db 0
	db 0
	db 0
;$$function start$$ _disp1
_disp1:		;framesize=2
;void disp1(unsigned char d){//display a byte as two hex digits
;	asm(" glo 12\n ani 0x0f\n" //prep bottom digit
 glo 12
 ani 0x0f
 dec 2
 str 2
 out 7
 glo 12
 shr
 shr
 shr
 shr
 dec 2
 str 2
 out 7
;}
L1:
	Cretn

;$$function end$$ _disp1
;$$function start$$ _dispval
_dispval:		;framesize=8
	pushr R7
	reserve 4; save room for outgoing arguments
	st2 R12,'O',sp,(8+1); flag1 
	ldA2 R11,'O',sp,(8+1); reg:addr
	ld2 R10,'O',sp,(8+1) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;void dispval(unsigned char v){
;	initleds(0b11010000); //LEDs in hex decode mode
;	disp1(v);
 req
 seq
 dec 2
 ldi 0b11010000
 str 2
 out 7
 req
	ld1 R12,'O',sp,(8+1)
	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _disp1
;	for (i=6;i!=0;i--) out(7,0);
	ldaD R7,6; reg:acon
	lbr L8
L5:
	ldaD R12,7; reg:acon
	ld2z R13
	Ccall _out; CALLI2(ar)
L6:
	decm R7,1	;SUBU2(reg,consm)
L8:
	jnzU2 R7,L5; NE 0 
;}
L3:
	release 4; release room for outgoing arguments
	popr R7
	Cretn

;$$function end$$ _dispval
;$$function start$$ _strlen
_strlen:		;framesize=4
	pushr R7
;{
;	unsigned int slen = 0 ;
	ld2z R7
	lbr L11
L10:
;	while (*str != 0) {
;      slen++ ;
	incm R7,1
;      str++ ;
	incm R12,1
;   }
L11:
;	while (*str != 0) {
	ldn1 R11,R12;reg:  INDIRU1(indaddr)
	jnzU1 R11,L10; NEI2(CVUI2(reg),con0)
;   return slen;
	cpy2 R15,R7 ;LOADU2*(reg)
L9:
	popr R7
	Cretn

;$$function end$$ _strlen
;$$function start$$ _itoa
_itoa:		;framesize=16
	reserve 2; save room for local variables
	pushr R0
	pushr R1
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	st2 R12,'O',sp,(16+1)			
	inc memaddr				;opt16.1
	str2 R13,memaddr			
;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
;	unsigned int flag=0;
	ld2z R0
;	char * bptr; bptr=buffer;
	ld2 R11,'O',sp,(18+1) ;reg:INDIRP2(addr)
	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
;	if (s<0){
	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
	jcI2I R11,0,lbdf,L14; GE is flipped test from LT
;		*bptr='-';bptr++;
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	str1I 45,R11; ASGNU1(indaddr,acon)	DH
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
;		n=-s;
	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
	cpy2 R6,R11 ;LOADU2*(reg)
;	} else{
	lbr L15
L14:
;		n=s;
	ld2 R11,'O',sp,(16+1) ;reg:INDIRI2(addr)
	cpy2 R6,R11 ;LOADU2*(reg)
;	}
L15:
;	k=10000;
	ldaD R7,10000; reg:acon
	lbr L17
L16:
;	while(k>0){
;		for(r=0;k<=n;r++,n-=k); // was r=n/k
	ld2z R1
	lbr L22
L19:
L20:
	incm R1,1
	alu2 R6,R6,R7,sm,smb
L22:
	jcU2 R6,R7,lbdf,L19 ;LE is flipped test & operands
;		if (flag || r>0||k==1){
	jnzU2 R0,L26; NE 0 
	jnzU2 R1,L26; NE 0 
	jneU2I R7,1,L23; NE
L26:
;			*bptr=('0'+r);bptr++;
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	ldA2 R10,'O',R1,(48); reg:addr
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(12+1); ASGNP2(addr,reg)
;			flag='y';
	ldaD R0,121; reg:acon
;		}
L23:
;		k=k/10;
	cpy2 R12,R7 ;LOADU2*(reg)
	ldaD R13,10; reg:acon
	Ccall _divu2
	cpy2 R7,R15 ;LOADU2*(reg)
;	}
L17:
;	while(k>0){
	jnzU2 R7,L16; NE 0 
;	*bptr='\0';
	ld2 R11,'O',sp,(12+1) ;reg:INDIRP2(addr)
	str1I 0,R11; ASGNU1(indaddr,acon)	DH
;	return buffer;
	ld2 R15,'O',sp,(18+1) ;reg:INDIRP2(addr)
L13:
	release 4; release room for outgoing arguments
	popf R7	;opt11.3
	popm R6	;opt11.4
	popm R1	;opt11.4
	popl R0	;opt11.4
	release 2; release room for local variables 
	Cretn

;$$function end$$ _itoa
;$$function start$$ _dispstr
_dispstr:		;framesize=12
	pushr R1
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	st2 R12,'O',sp,(12+1); flag1 
;void dispstr(char * str){//display 8 or fewer characters on the boyd LEDs
;	L=min(strlen((char *)str),8);//length to display
	ld2 R12,'O',sp,(12+1) ;reg:INDIRP2(addr)
	Ccall _strlen;CALLU2(ar)*
	cpy2 R11,R15 ;LOADU2*(reg)
	jcI2I R11,8,lbdf,L29; GE is flipped test from LT
	ld2 R12,'O',sp,(12+1) ;reg:INDIRP2(addr)
	Ccall _strlen;CALLU2(ar)*
	cpy2 R11,R15 ;LOADU2*(reg)
	cpy2 R1,R11 ;LOADU2*(reg)
	lbr L30
L29:
	ldaD R1,8; reg:acon
L30:
	cpy2 R6,R1 ;LOADU2*(reg)
;	initleds(0b11110000); //LEDs in no-decode mode
;	if (L<8){
 req
 seq
 dec 2
 ldi 0b11110000
 str 2
 out 7
 req
	jcI2I R6,8,lbdf,L32; GE is flipped test from LT
;		for(i=(8-L); i>0;i--){ //blank trailing positions
	ldaD R11,8; reg:acon
	alu2 R7,R11,R6,sm,smb
	lbr L37
L34:
;			out(7,0);
	ldaD R12,7; reg:acon
	ld2z R13
	Ccall _out; CALLI2(ar)
;		}
L35:
;		for(i=(8-L); i>0;i--){ //blank trailing positions
	decm R7,1	;SUBU2(reg,consm)
L37:
	jnzU2 R7,L34; NE 0 
;	}
L32:
;	for (i=L;i>0;i--){
	cpy2 R7,R6 ;LOADU2*(reg)
	lbr L41
L38:
;		out(7,boydsegments[str[i-1]]);
	ldaD R12,7; reg:acon
	cpy2 R11,R7	;SUBU2(reg,consm)
	decm R11,1	;SUBU2(reg,consm)
	alu2RRS R11,R11,'O',sp,(12+1),add,adc; ADDI2(r,INDIRP2(addr))	DH3.1
	ldn1 R11,R11	;opt14*
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ld1 R13,'O',R11,(_boydsegments)
	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _out; CALLI2(ar)
;	}
L39:
;	for (i=L;i>0;i--){
	decm R7,1	;SUBU2(reg,consm)
L41:
	jnzU2 R7,L38; NE 0 
;}
L27:
	release 4; release room for outgoing arguments
	popf R7	;opt11.3
	popm R6	;opt11.4
	popl R1	;opt11.4
	Cretn

;$$function end$$ _dispstr
L43:
	db 48
	db 49
	db 50
	db 51
	db 52
	db 53
	db 54
	db 55
;$$function start$$ _main
_main: ;copt is peeping your size 20 frame with oct 23 rules
	reserve 10; save room for local variables
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
;{
;	unsigned int acc=0;
	ld2z R7
;	char buf[8]="01234567";
	ldA2 R11,'O',sp,(10+1); reg:addr
	ldaD R8,L43; reg:acon
	blkcpy R11,R8,8; ASGNB(reg,INDIRB(reg))
;	dispval(0x42);
	ldaD R12,66; reg:acon
	Ccall _dispval
;	delay(100);
	ldaD R12,100; reg:acon
	Ccall _delay
;	dispstr("BOYDPROG");
	ldaD R12,L44; reg:acon
	Ccall _dispstr
;	delay(2000);
	ldaD R12,2000; reg:acon
	Ccall _delay
	lbr L46
L45:
;	while(1){
;		dispstr("_"); acc=0;
	ldaD R12,L48; reg:acon
	Ccall _dispstr
	ld2z R7
;		k=boydscan();
	Ccall _boydscan; CALLI2(ar)
	cpy2 R11,R15 ;LOADU2*(reg)
	cpy1 R6,R11;LOADU1(reg)
	lbr L50
L49:
;		while(k<16){
;			acc=(acc<<4)+k;
	cpy2 R11,R7
	shl2I R11,4
	cpy1 R10,R6
	zExt R10 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	alu2 R7,R11,R10,add,adc; ADDU2(r,r)
;			dispstr(itoa(acc,buf));
	cpy2 R12,R7 ;LOADI2(reg)
	ldA2 R13,'O',sp,(10+1); reg:addr
	Ccall _itoa
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R11 ;LOADP2(reg)
	Ccall _dispstr
;			k=boydscan();
	Ccall _boydscan; CALLI2(ar)
	cpy2 R11,R15 ;LOADU2*(reg)
	cpy1 R6,R11;LOADU1(reg)
;		}
L50:
;		while(k<16){
	cpy1 R11,R6
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	jcI2I R11,16,lbnf,L49  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
;	}
L46:
;	while(1){
	lbr L45
;}
L42:
	release 4; release room for outgoing arguments
	popf R7	;opt11.3
	popl R6	;opt11.3
	release 10; release room for local variables 
	Cretn

;$$function end$$ _main
;$$function start$$ _delay
_delay:		;framesize=10
	pushr R6
	pushr R7
	reserve 4; save room for outgoing arguments
	cpy2 R7,R12; function(2054) 1
;void delay(unsigned int howlong){
;	for (i=1;i!=howlong;i++){
	ldaD R6,1; reg:acon
	lbr L56
L53:
;		oneMs();
	Ccall _oneMs; CALLI2(ar)
;	}
L54:
;	for (i=1;i!=howlong;i++){
	incm R6,1
L56:
	jneU2 R6,R7,L53; NE
;}
L52:
	release 4; release room for outgoing arguments
	popf R7	;opt11.3
	popl R6	;opt11.3
	Cretn

;$$function end$$ _delay
;$$function start$$ _olduinoincluder
_olduinoincluder:		;framesize=2
;void olduinoincluder(){
;	asm("\tinclude olduino.inc\n");
	include olduino.inc
;}
L57:
	Cretn

;$$function end$$ _olduinoincluder
;$$function start$$ _boydinc
_boydinc:		;framesize=2
;void boydinc(){
;	asm(" align 256\n");
;	asm(" include \"boydscan.inc\"\n");
 align 256
 include "boydscan.inc"
;}
L59:
	Cretn

;$$function end$$ _boydinc
L48:
	db 95
	db 0
L44:
	db 66
	db 79
	db 89
	db 68
	db 80
	db 82
	db 79
	db 71
	db 0
	include lcc1802epiloNW.inc
	include IO1802.inc
