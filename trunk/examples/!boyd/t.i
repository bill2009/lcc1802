; generated by lcc-xr18NW $Version: 5.0 - XR18NW $ on Wed Apr 12 17:20:09 2017
SP:	equ	2 ;stack pointer
memAddr: equ	14
retAddr: equ	6
retVal:	equ	15
regArg1: equ	12
regArg2: equ	13
	listing off
	RELAXED ON
;definitions and prolog functions needed for smc1802 programs (Hi Bill)
;dec 21 packaged version for the christmas compiler (Ho Ho Ho)
;Dec 24 fixed shift macros to use memaddr as a work register and not corrupt the shift count
;jan 6 fixed shift left macro as above
;jan 11 saving as lcc1802epiloNG.inc for the NG compiler
;jan 12 minor correction to rldmi
;jan 14 minor correction to ldi4
;jan 16 adding shri4I
;jan20 correct error in shl2r
;jan21 moved 4 byte macros to bottom and added shrc4
;Jan 28 archived before beginning work on Birthday Compiler
;Feb 7 adding nointerrupts/interrupts to control interruptability
;Feb 13 changing address mode macros
;Feb 14 removing nointerrupts, adding reserve/release for stack frame, ld2z macro
;Mar 3 changing reserve/release to use inc/dec for 8 or less bytes
;Mar 4 adding incm macro for multiple increments
;mar 5 adding jzi2 macro to speed up if processing
;mar 6 adding ldn1, str1 for register indirect addressing
;mar 17 adding decm macro
;mar 28 adding jumpv macro
;may 15 adding jnzu1, jzu1 macros
;june 21 adding demote macro
;Oct 2, 2013 DH version for dhrystone optimization 
;Oct 2, 2013 added str2 macro 2 byte store at addr pointed to by register
;oct 4,	added st2i 2 byte immediate sore, pushf,pushm,pushl sequences, 
;oct 24, added ldaXs for stack pointed addresses, added mvcn1, mvc1 for 1 byte storage to storage moves, jneu1i for single byte immediate compare
;Feb 17 2014 added "inc sp" to restore stack pointer in jeqI1, affected strncmp.
;Feb 18 2017 added org to LCCCODELOC to allow for non-zero origin
;Feb 19 2017 beginning to adapt for 1806
;17-03-06 remove inc/dec from ccall, cretn6, add inc to popr
;17-03-07 add popf,popm,popl for optimization
;17-03-14 removed savemi, rldmi,cretn6
;17-03-27 added jequ1i
	org	LCCCODELOC	;wjr 17-02-18 allow code relocation
R0:	equ	0
R1:	equ	1
R2:	equ	2
R3:	equ	3
R4:	equ	4
R5:	equ	5
R6:	equ	6
R7:	equ	7
R8:	equ	8
R9:	equ	9
R10:	equ	10
R11:	equ	11
R12:	equ	12
R13:	equ	13
R14:	equ	14
R15:	equ	15
RL0:	equ	1 ;long register pairs are identified by their odd numbered register
RL6:	equ	7 
RL8:	equ	9 ;temp 1
RL10:	equ	11;temp 2
RL12:	equ	13 ;return value register for longs
Rp1p2:	equ	13 ;argument register for longs
Rt1:	equ	8  ;1st temp register
Rt2:	equ	9  ;2nd temp register
RCALL:	equ 	4 ;standard call routine
RRET:	equ 	5 ;standard return register
RPC:	equ 	3 ; standard program counter
;	listing	off
	macexp off	;this seems to have to go before the definitions
;macro definitions
;more natural 1802 macros
	listing	on
	lbr	lcc1802Init
	listing on
;$$function start$$ _main
_main: ;copt is peeping your size 6 frame with oct 23 rules
        dec sp
        dec sp
        RSXD    R7
;void main(){
;	register unsigned char* mem=0;
        RLDI    R7,0
;	unsigned char k=0;
;Oct 13 (3+1) added to ldAD call
        glo     SP
        adi     ((3+1))#256
        plo     R11
        ghi     SP
        adci    ((3+1))>>8; was/256
        phi     R11
        ldi     0
        str     R11
;	mem[3]=42;
        glo     R7
        plo     R11
        ghi     R7
        phi     R11
        inc     R11
        inc     R11
        inc     R11
        ldi     42
        str     R11
;	mem[3]=k<<4;
        glo     R7
        plo     R11
        ghi     R7
        phi     R11
        inc     R11
        inc     R11
        inc     R11
        glo     SP
        adi     ((3+1))#256
        plo     MEMADDR
        ghi     SP
        adci    ((3+1))>>8; was/256
        phi     MEMADDR
        ldn     memAddr
        plo     R10
        ldi     0
        phi     R10
        glo     R10
        shl
        plo     R10
        ghi     R10
        shlc
        phi     R10
        glo     R10
        shl
        plo     R10
        ghi     R10
        shlc
        phi     R10
        glo     R10
        shl
        plo     R10
        ghi     R10
        shlc
        phi     R10
        glo     R10
        shl
        plo     R10
        ghi     R10
        shlc
        phi     R10
        glo     R10
        str     R11
;}
L1:
        inc     sp
        lda     sp
        phi     R7
        ldn     sp
        plo     R7
        inc sp
        inc sp
        sret    6
;$$function end$$ _main
;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
;this is the version published with the lcc1802121229 release
;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
;jan 2 removed test routines, moved code not needing short branches to before the align 256
;jan 11 going back to SCRT conventions for NG compiler
;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
;Jan 28 archived before beginning work on Birthday Compiler
;Feb 5 dubdab algorithm being brought in for ltoa itoa
;Feb 12 fixed bugs in modi2/u2
;feb 27 changed stack to start at 7fff
;mar 3, 2013 saved as epiloNO for optimization round
;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
;april 4 adding digit count argument to dubdabx
;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
;16-09-20 allow stack relocation 
;16-11-26 calculate onems delay from cpu speed in LCC1802CPUSPEED
;17-03-07 adjusting stack offset for 1805/6 stack discipline
;17-03-13 protecting work areas in divi2,divi4 routines from 1806 SCAL
;17-03-15 onems compensates for reduced subroutine overhead in 1806
;17-04-09 don't include call/return for 1806
rwork	equ	memAddr	;work register
lcc1802init:	
        RLDI    RCALL,$$_DIE
        RLDI    RRET,$$_DIE
        RLDI    SP,LCCSTACKLOC
	sex	SP
        RLDI    RPC,$$_00000
	sep	RPC
$$_00000:
        SCAL    6
        dw      _MAIN
$$_die:	lbr	$$_die		;loop here when main returns
	db	0xde,0xad
;the following routines don't have short jumps and don't need to worry about alignment
_setqOn:
	seq
        sret    6
_setqOff:
	req
        sret    6
_out4:	
	glo	regArg1
	dec	sp
	str	sp
	out	4
        sret    6
;the following routines have short branches so all the code has to stay within the same page
	align 256
_oneMs:		;execute 1ms worth of instructions including call(15)/return(10) sequence. takes about 1 ms
;subroutine overhead soaks up 27 instruction time.
;each loop is 2 instruction times
;so the number of loops needed is 
;CPU speed/16000 less the 27 all divide by two
LCC1802SUBOVHD  EQU 14		;1806 SCAL/SRET subroutine overhead
	ldi	(LCC1802CPUSPEED/1000/16-LCC1802SUBOVHD)/2
$$mslp:	smi	1
	bnz	$$mslp
        sret    6
;IO1802.inc contains input/output runtime routines for LCC1802
;The port is in regArg1, the output byte is in regArg2
	align 64
_putc:
_out5:	
	glo	regArg1
	dec	sp
	str	sp
	out	5
        sret    6
_inp:		;raw port input
		;stores a small tailored program on the stack and executes it
	dec	sp	;work backwards
	ldi	0xD3	;return instruction
	stxd		
	glo	regarg1	;get the port number
	ani	0x07	;clean it
	bz	+	; inp(0) isn't valid
	ori	0x68	;make it an input instruction
	stxd		;store it for execution
        glo     SP
        plo     RT1
        ghi     SP
        phi     RT1
	inc	rt1	;rt1 points to the 6x instruction
	sep	rt1	;execute it
;we will come back to here with the input byte in D
	inc	sp	;step over the work area
	plo	retVal	;save it to return
	ldi	0
	phi	retval	;clear top byte
+	inc	sp	;need to get rid of the 6x instruction
	inc	sp	;and the D3
        sret    6
_out:		;raw port output
		;stores a small tailored program on the stack and executes it
		;this could be bolder:
		;store the program as 6x cc D5 where x is the port number and cc is the char
		;then SEP sp
		;the D5 would return to the calling program and finish fixing the stack.
		;saves 6 instructions but it's a bit tricky.
	dec	sp	;work backwards
	ldi	0xD3	;return instruction
	stxd		
        glo     SP
        plo     RT1
        ghi     SP
        phi     RT1
	glo	regarg1	;get the port number
	ani	0x07	;clean it
	ori	0x60	;make it an out instruction - 60 is harmless
	stxd		;store it for execution
	glo	regarg2	;get the byte to be written
	str	sp	;store it where sp points
	sep	rt1	;execute it
;we will come back to here with sp stepped up by one
+	inc	sp	;need to get rid of the 6x instruction
	inc	sp	;and the D3
        sret    6
