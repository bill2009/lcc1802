; generated by lcc-xr18DH $Version: 5.0 - XR18DH $ on Wed Aug 27 11:16:27 2014

SP:	equ	2 ;stack pointer
memAddr: equ	14
retAddr: equ	6
retVal:	equ	15
regArg1: equ	12
regArg2: equ	13
	listing off
	include lcc1802ProloDH.inc
	listing on
_PIN4:
	db 0
_send:		;framesize=2
;void send(unsigned char data){ //shift out a byte -lsb first
;	asm("	ldi 8	; loop count\n"
	ldi 8	; loop count
	plo rt1	; in temp register
	lda2 rt2,'D',_PIN4,0	;point rt2 to PIN4 which holds current output data
	ldn	 rt2	;pick up PIN4 value
	ani	 0x7f!(1<<4) ;turn off data and strobe bits
	str  rt2
	;and put it back
$$slp: ; we will do this 8 times
	sex  rt2		;temporarily use rt2 as X
	glo regArg1	; get the data byte
	ani	0x01 ;isolate the bottom bit
   lsz     ;need to have it in the top position though
   ldi 0x80 ;there it is
	or		 ; combine PIN4 with the current data bit
	sex sp	;return to normal index reg
	dec sp	; work space
	str sp	;prep for output
	out 4 	;put it out
	ori 1<<4 ;blip the spi clock
	dec sp	; work space
	str sp	;prep for output
	out 4 	;put it out
	glo	regArg1	; get the data back
	shr		; rotate the next bit into position
	plo regArg1	;prepare to repeat
	dec rt1 ;decrement loop count
	glo rt1	;get the loop count
	lbnz $$slp ; back for more
;}
L1:
	Cretn

_sendCommand:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6); flag1 
	ldA2 R11,'O',sp,(6); reg:addr
	ld2 R10,'O',sp,(6) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;void sendCommand(uchar cmd){
;  digitalWrite(strobePin, LOW);
	ldaD R12,5; reg:acon
	ld2z R13
	Ccall _digitalWrite
;  send(cmd);
	ld1 R12,'O',sp,(6)
	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _send
;  digitalWrite(strobePin, HIGH);
	ldaD R12,5; reg:acon
	ldaD R13,1; reg:acon
	Ccall _digitalWrite
;}
L3:
	release 4
	Cretn

_sendData:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6)			
	inc memaddr				;opt16.1
	str2 R13,memaddr			
	ldA2 R11,'O',sp,(6); reg:addr
	ld2 R10,'O',sp,(6) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
	ldA2 R11,'O',sp,(8); reg:addr
	ld2 R10,'O',sp,(8) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;void sendData(uchar address, uchar data){
;  sendCommand(0x44);
	ldaD R12,68; reg:acon
	Ccall _sendCommand
;  digitalWrite(strobePin, LOW);
	ldaD R12,5; reg:acon
	ld2z R13
	Ccall _digitalWrite
;  send(0xC0 | address);
	ld1 R11,'O',sp,(6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	alu2I R11,R11,192,ori,ori ;removed copy
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _send
;  send(data);
	ld1 R12,'O',sp,(8)
	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _send
;  digitalWrite(strobePin, HIGH);
	ldaD R12,5; reg:acon
	ldaD R13,1; reg:acon
	Ccall _digitalWrite
;}
L4:
	release 4
	Cretn

_setLED:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6)			
	inc memaddr				;opt16.1
	str2 R13,memaddr			
	ldA2 R11,'O',sp,(6); reg:addr
	ld2 R10,'O',sp,(6) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
	ldA2 R11,'O',sp,(8); reg:addr
	ld2 R10,'O',sp,(8) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;{
;    sendData((pos << 1) + 1, color);
	ld1 R11,'O',sp,(8)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	shl2I R11,1
	incm R11,1
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	ld1 R13,'O',sp,(6)
	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _sendData
;}
L5:
	release 4
	Cretn

_setDisplay:		;framesize=12
	pushf R1	;opt11
	pushm R6	;opt11.1
	pushl R7	;opt11.1
	reserve 4; save room for outgoing arguments
	cpy2 R7,R12; function(2055) 1
	cpy2 R6,R13; function(1030) 1
;void setDisplay(const unsigned char values[], unsigned char size){
;  for (i = 0; i<size; i++) {
	ldaD R1,0; reg:acon
	lbr L10
L7:
;    sendData(i<<1, values[i]);
	cpy1 R11,R1
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	shlR2R	R10,R11	;opt6
	cpy1 R12,R10
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	alu2 R11,R11,R7,add,adc	;ADDP2(reg,reg)
	ldn1 R13,R11	;opt14*
	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _sendData
;  }
L8:
;  for (i = 0; i<size; i++) {
	incm R1,1	;opt13
L10:
	cpy1 R11,R1
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	cpy1 R10,R6
	zExt R10 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	jcI2 R11,R10,lbnf,L7; LT=lbnf i.e. subtract B from A and jump if borrow 
;}
L6:
	release 4; release room for outgoing arguments
	popr R7
	popr R6
	popr R1
	Cretn

_tms1638init:		;framesize=8
	pushr R7
	reserve 4; save room for outgoing arguments
;void tms1638init(){
;  digitalWrite(strobePin, HIGH);
	ldaD R12,5; reg:acon
	ldaD R13,1; reg:acon
	Ccall _digitalWrite
;  digitalWrite(tmclockpin, HIGH);
	ldaD R12,4; reg:acon
	ldaD R13,1; reg:acon
	Ccall _digitalWrite
;  sendCommand(0x40);
	ldaD R12,64; reg:acon
	Ccall _sendCommand
;  sendCommand(0x80 | (8) | min(7, 3));
	ldaD R12,139; reg:acon
	Ccall _sendCommand
;  digitalWrite(strobePin, LOW);
	ldaD R12,5; reg:acon
	ld2z R13
	Ccall _digitalWrite
;  send(0xC0);
	ldaD R12,192; reg:acon
	Ccall _send
;  for (i = 0; i < 16; i++) {
	ldaD R7,0; reg:acon
	lbr L15
L12:
;    send(0x00);
	ld2z R12
	Ccall _send
;  }
L13:
;  for (i = 0; i < 16; i++) {
	incm R7,1	;opt13
L15:
	cpy1 R11,R7
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	jcI2I R11,16,lbnf,L12  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
;  digitalWrite(strobePin, HIGH);
	ldaD R12,5; reg:acon
	ldaD R13,1; reg:acon
	Ccall _digitalWrite
;}
L11:
	release 4; release room for outgoing arguments
	popr R7
	Cretn

L17:
	db 0
	db 0
	db 0
	db 0
	db 6
	db 127
	db 63
	db 91
	db 0
	db 0
	db 0
	db 0
_setDisplayTo1802:		;framesize=18
	reserve 16
	st2 R12,'O',sp,(18); flag1 
	ldA2 R11,'O',sp,(18); reg:addr
	ld2 R10,'O',sp,(18) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;{
;const unsigned char RCA_DATA[] = {
	ldA2 R11,'O',sp,(4); reg:addr
	ldaD R8,L17; reg:acon
	blkcpy R11,R8,12; ASGNB(reg,INDIRB(reg))
;  setDisplay(RCA_DATA+offset, 8);
	ld1 R11,'O',sp,(18)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldA2 R10,'O',sp,(4); reg:addr
	alu2 R12,R11,R10,add,adc	;ADDP2(reg,reg)
	ldaD R13,8; reg:acon
	Ccall _setDisplay
;}
L16:
	release 16
	Cretn

L19:
	db 3
L20:
	db 1
_sparkle:		;framesize=6
	reserve 4
;	static unsigned char pos=3,color=tmsred;
;  		delay(150);
	ldaD R12,2; reg:acon
	ld1 R13,'D',(L19),0
	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _setLED
;  		setLED(0,pos);
	ldaD R12,150; reg:acon
	Ccall _delay
;  		delay(150);
	ld2z R12
	ld1 R13,'D',(L19),0
	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _setLED
;  		pos=(pos+1)%8;
	ldaD R12,150; reg:acon
	Ccall _delay
;  		setLED(tmsgreen,pos);
	ldaD R11,L19; reg:acon
	ld1 R10,'D',(L19),0
	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
	cpy2 R12,R10 ;reg:ADDI2(consm,reg)
	incm R12,1
	ldaD R13,8; reg:acon
	Ccall _modi2
	cpy2 R10,R15 ;LOADU2(reg)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;  		delay(150);
	ldaD R12,2; reg:acon
	ld1 R13,'D',(L19),0
	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _setLED
;  		setLED(0,pos);
	ldaD R12,150; reg:acon
	Ccall _delay
;  		pos=(pos+1)%8;
	ld2z R12
	ld1 R13,'D',(L19),0
	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _setLED
;}
	ldaD R11,L19; reg:acon
	ld1 R10,'D',(L19),0
	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
	cpy2 R12,R10 ;reg:ADDI2(consm,reg)
	incm R12,1
	ldaD R13,8; reg:acon
	Ccall _modi2
	cpy2 R10,R15 ;LOADU2(reg)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;
L18:
	release 4
	Cretn

_main: ;copt is peeping your size 6 frame with oct 23 rules
	reserve 4
;  tms1638init();
;  delay(10);
	Ccall _tms1638init
;  while(1){
	ldaD R12,10; reg:acon
	Ccall _delay
	lbr L23
L22:
;    setDisplayTo1802(4);
;    sparkle();
	ldaD R12,4; reg:acon
	Ccall _setDisplayTo1802
;    setDisplayTo1802(0);
	Ccall _sparkle
;    sparkle();
	ld2z R12
	Ccall _setDisplayTo1802
;  }
	Ccall _sparkle
;}
L23:
;    setDisplayTo1802(4);
	lbr L22
;#include "olduino.c"
L21:
	release 4
	Cretn

_delay:		;framesize=10
	pushf R6	;opt11
	pushl R7	;opt11
	reserve 4; save room for outgoing arguments
	cpy2 R7,R12; function(2054) 1
;void delay(unsigned int howlong){
;	for (i=1;i!=howlong;i++){
	ldaD R6,1; reg:acon
	lbr L29
L26:
;		oneMs();
	Ccall _oneMs; CALLI2(ar)
;	}
L27:
;	for (i=1;i!=howlong;i++){
	incm R6,1
L29:
	jneU2 R6,R7,L26; NE
;}
L25:
	release 4; release room for outgoing arguments
	popr R7
	popr R6
	Cretn

_olduinoincluder:		;framesize=2
;void olduinoincluder(){
;	asm("\tinclude olduino.inc\n");
	include olduino.inc
;}
L30:
	Cretn

_strncmp:		;framesize=6
	pushf R6	;opt11
	pushl R7	;opt11
	ld2 R7,'O',sp,(10) ;reg:INDIRU2(addr)
;{
;    for ( ; n > 0; s1++, s2++, --n)
	lbr L36
L33:
;	if (*s1 != *s2)
	ldn1 R11,R12	;opt14*
	ldn1 R10,R13	;opt14*
	jeqI1 R11,R10,L37	;opt21
;	    return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1);
	ldn1 R11,R12	;opt14*
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldn1 R10,R13	;opt14*
	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
	jcI2 R11,R10,lbdf,L40; GE is flipped test from LT
	ldaD R6,-1; reg:acon
	lbr L41
L40:
	ldaD R6,1; reg:acon
L41:
	cpy2 R15,R6 ;LOADI2(reg)
	lbr L32
L37:
;	else if (*s1 == '\0')
	ldn1 R11,R12;reg:  INDIRU1(indaddr)
	jnzU1 R11,L42; NEI2(CVUI2(reg),con0)
;	    return 0;
	ld2z R15
	lbr L32
L42:
L34:
;    for ( ; n > 0; s1++, s2++, --n)
	incm R12,1
	incm R13,1
	decm R7,1
L36:
	jnzU2 R7,L33; NE 0
;    return 0;
	ld2z R15
L32:
	popr R7
	popr R6
	Cretn

_strlen:		;framesize=4
	pushr R7
;{
;	unsigned int slen = 0 ;
	ld2z R7
	lbr L46
L45:
;	while (*str != 0) {
;      slen++ ;
	incm R7,1
;      str++ ;
	incm R12,1
;   }
L46:
;	while (*str != 0) {
	ldn1 R11,R12;reg:  INDIRU1(indaddr)
	jnzU1 R11,L45; NEI2(CVUI2(reg),con0)
;   return slen;
	cpy2 R15,R7 ;LOADU2(reg)
L44:
	popr R7
	Cretn

_printstr:		;framesize=8
	pushr R7
	reserve 4; save room for outgoing arguments
	cpy2 R7,R12; function(2055) 1
;void printstr(char *ptr){
	lbr L50
L49:
;    while(*ptr) putc(*ptr++); //jan 29
	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
	incm R7,1
	ldn1 R12,R11	;opt14*
	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
	Ccall _putc
L50:
	ldn1 R11,R7;reg:  INDIRU1(indaddr)
	jnzU1 R11,L49; NEI2(CVUI2(reg),con0)
;}
L48:
	release 4; release room for outgoing arguments
	popr R7
	Cretn

	align 4
_round_nums:
	dd 0x3f000000
	dd 0x3d4ccccd
	dd 0x3ba3d70a
	dd 0x3a03126f
	dd 0x3851b717
	dd 0x36a7c5ac
	dd 0x350637bd
	dd 0x3356bf95
	align 4
_mult_nums:
	dd 0x3f800000
	dd 0x41200000
	dd 0x42c80000
	dd 0x447a0000
	dd 0x461c4000
	dd 0x47c35000
	dd 0x49742400
	dd 0x4b189680
_ftoa:		;framesize=80
	reserve 62; save room for local variables
	pushf R0	;opt11
	pushm R1	;opt11.1
	pushm R6	;opt11.1
	pushl R7	;opt11.1
	reserve 8; save room for outgoing arguments
	cpy4 RL6,RL12; halfbaked&floaty
	ld2 R1,'O',sp,(86) ;reg:INDIRU2(addr)
;{
;   char *output = outbfr ;
	ld2 R0,'O',sp,(84) ;reg:INDIRP2(addr)
;   if (flt < 0.0) {
	ld4 RL10,'D',(L55),0;INDIRF4(addr)
	jcF4 RL6,RL10,lbdf,L53;GEF4(reg,reg) - reverse test
;      *output++ = '-' ;
	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
	incm R0,1
	str1I 45,R11; ASGNU1(indaddr,acon)	DH
;      flt *= -1.0 ;
	ld4 RL8,'D',(L56),0;INDIRF4(addr)
	cpy4 RL10,RL6; LOADU4(reg)
	Ccall fp_mul ;MULF4(reg,reg)
	cpy4 RL6,RL8; LOADU4(reg)
;   } else {
	lbr L54
L53:
;      if (use_leading_plus) {
	lbr L57
;         *output++ = '+' ;
	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
	incm R0,1
	str1I 43,R11; ASGNU1(indaddr,acon)	DH
;      }
L57:
;   }
L54:
;   if (dec_digits < 8) {
	jcI2I R1,8,lbdf,L59; GE is flipped test from LT
;      flt += round_nums[dec_digits] ;
	cpy4 RL8,RL6; LOADU4(reg)
	shlR2R	R11,R1	;opt6.1
	shl2I 	R11,1	;opt6.1
	ld4 RL10,'O',R11,(_round_nums);INDIRF4(addr)
	Ccall fp_add ;ADDF4(reg,reg)
	cpy4 RL6,RL8; LOADU4(reg)
;   }
L59:
;	mult=mult_nums[dec_digits];
	shlR2R	R11,R1	;opt6.1
	shl2I 	R11,1	;opt6.1
	ld4 RL10,'O',R11,(_mult_nums);INDIRF4(addr)
	st4 RL10,'O',sp,(68); ASGNF4(addr,reg)
;   wholeNum = flt;
	cpy4 RL8,RL6; LOADU4(reg)
	ccall cvfi4; CVFI4(reg) convert float to long
	st4 RL8,'O',sp,(72)
;   decimalNum = ((flt - wholeNum) * mult);
	cpy4 RL8,RL6; LOADU4(reg)
	st4 RL8,'O',sp,(16); ASGNF4(addr,reg)
	ld4 RL8,'O',sp,(72);reg:  INDIRI4(addr)
	Ccall cvif4; emit2
	cpy4 RL10,RL8; LOADU4(reg)
	ld4 RL8,'O',sp,(16);INDIRF4(addr)
	Ccall fp_sub ;SUBF4(reg,reg)
	ld4 RL10,'O',sp,(68);INDIRF4(addr)
	Ccall fp_mul ;MULF4(reg,reg)
	ccall cvfi4; CVFI4(reg) convert float to long
	st4 RL8,'O',sp,(64)
;   strcpy(output,dubdabx(wholeNum,output,1));
	ld4 Rp1p2,'O',sp,(72);reg:  INDIRI4(addr)
	st2 R0,'O',sp,(4); arg+f**
	ldaD R11,1; reg:acon
	st2 R11,'O',sp,(6); arg+f**
	Ccall _dubdabx
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R0 ;LOADP2(reg)
	cpy2 R13,R11 ;LOADP2(reg)
	Ccall _strcpy
;   output+=strlen(output);
	cpy2 R12,R0 ;LOADP2(reg)
	Ccall _strlen;CALLU2(ar)*
	alu2 R0,R15,R0,add,adc	;ADDP2(reg,reg)
;   if (dec_digits > 0) {
	jzU2 R1,L61; EQ 0
;		*output++ = '.' ;
	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
	incm R0,1
	str1I 46,R11; ASGNU1(indaddr,acon)	DH
;		strcpy(output,dubdabx(decimalNum,output,dec_digits));
	ld4 Rp1p2,'O',sp,(64);reg:  INDIRI4(addr)
	st2 R0,'O',sp,(4); arg+f**
	cpy2 R11,R1 ;LOADI2(reg)
	st2 R11,'O',sp,(6); arg+f**
	Ccall _dubdabx
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R0 ;LOADP2(reg)
	cpy2 R13,R11 ;LOADP2(reg)
	Ccall _strcpy
;	}
L61:
;   return outbfr;
	ld2 R15,'O',sp,(84) ;reg:INDIRP2(addr)
L52:
	release 8; release room for outgoing arguments
	popr R7
	popr R6
	popr R1
	popr R0
	release 62; release room for local variables 
	Cretn

_itoa:		;framesize=16
	reserve 2; save room for local variables
	pushf R0	;opt11
	pushm R1	;opt11.1
	pushm R6	;opt11.1
	pushl R7	;opt11.1
	reserve 4; save room for outgoing arguments
	st2 R12,'O',sp,(16)			
	inc memaddr				;opt16.1
	str2 R13,memaddr			
;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
;	unsigned int flag=0;
	ld2z R0
;	char * bptr; bptr=buffer;
	ld2 R11,'O',sp,(18) ;reg:INDIRP2(addr)
	st2 R11,'O',sp,(12); ASGNP2(addr,reg)
;	if (s<0){
	ld2 R11,'O',sp,(16) ;reg:INDIRI2(addr)
	jcI2I R11,0,lbdf,L64; GE is flipped test from LT
;		*bptr='-';bptr++;
	ld2 R11,'O',sp,(12) ;reg:INDIRP2(addr)
	str1I 45,R11; ASGNU1(indaddr,acon)	DH
	ld2 R11,'O',sp,(12) ;reg:INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(12); ASGNP2(addr,reg)
;		n=-s;
	ld2 R11,'O',sp,(16) ;reg:INDIRI2(addr)
	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
	cpy2 R6,R11 ;LOADU2(reg)
;	} else{
	lbr L65
L64:
;		n=s;
	ld2 R11,'O',sp,(16) ;reg:INDIRI2(addr)
	cpy2 R6,R11 ;LOADU2(reg)
;	}
L65:
;	k=10000;
	ldaD R7,10000; reg:acon
	lbr L67
L66:
;	while(k>0){
;		for(r=0;k<=n;r++,n-=k); // was r=n/k
	ld2z R1
	lbr L72
L69:
L70:
	incm R1,1
	alu2 R6,R6,R7,sm,smb
L72:
	jcU2 R6,R7,lbdf,L69 ;LE is flipped test & operands
;		if (flag || r>0||k==1){
	jnzU2 R0,L76; NE 0
	jnzU2 R1,L76; NE 0
	jneU2I R7,1,L73; NE
L76:
;			*bptr=('0'+r);bptr++;
	ld2 R11,'O',sp,(12) ;reg:INDIRP2(addr)
	ldA2 R10,'O',R1,(48); reg:addr
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
	ld2 R11,'O',sp,(12) ;reg:INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(12); ASGNP2(addr,reg)
;			flag='y';
	ldaD R0,121; reg:acon
;		}
L73:
;		k=k/10;
	cpy2 R12,R7 ;LOADU2(reg)
	ldaD R13,10; reg:acon
	Ccall _divu2
	cpy2 R7,R15 ;LOADU2(reg)
;	}
L67:
;	while(k>0){
	jnzU2 R7,L66; NE 0
;	*bptr='\0';
	ld2 R11,'O',sp,(12) ;reg:INDIRP2(addr)
	str1I 0,R11; ASGNU1(indaddr,acon)	DH
;	return buffer;
	ld2 R15,'O',sp,(18) ;reg:INDIRP2(addr)
L63:
	release 4; release room for outgoing arguments
	popr R7
	popr R6
	popr R1
	popr R0
	release 2; release room for local variables 
	Cretn

_ltoa:		;framesize=16
	pushf R1	;opt11
	pushm R6	;opt11.1
	pushl R7	;opt11.1
	reserve 8; save room for outgoing arguments
	cpy4 RL6,RL12; halfbaked
;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
;	char* bptr=buffer;
	ld2 R1,'O',sp,(20) ;reg:INDIRP2(addr)
;	if (s<0){
	ldI4 RL10,0 ;loading a long integer constant
	jcI4 RL6,RL10,lbdf,L78; GE is flipped test from LT
;		*bptr++='-';
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,1
	str1I 45,R11; ASGNU1(indaddr,acon)	DH
;		s=-s;
	negI4 RL6,RL6 ;was alu4I RL6,RL6,0,sdi,sdbi
;	}
L78:
;	strcpy(bptr,dubdabx(s,bptr,1)); //uses assembler double-dabble routine
	cpy4 Rp1p2,RL6; LOADI4*
	st2 R1,'O',sp,(4); arg+f**
	ldaD R11,1; reg:acon
	st2 R11,'O',sp,(6); arg+f**
	Ccall _dubdabx
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R1 ;LOADP2(reg)
	cpy2 R13,R11 ;LOADP2(reg)
	Ccall _strcpy
;	return buffer;
	ld2 R15,'O',sp,(20) ;reg:INDIRP2(addr)
L77:
	release 8; release room for outgoing arguments
	popr R7
	popr R6
	popr R1
	Cretn

_printint:		;framesize=14
	reserve 12
	st2 R12,'O',sp,(14); flag1 
;void printint(int s){ //print an integer
;	itoa(s,buffer);
	ld2 R12,'O',sp,(14) ;reg:INDIRI2(addr)
	ldA2 R13,'O',sp,(4); reg:addr
	Ccall _itoa
;	printstr(buffer);
	ldA2 R12,'O',sp,(4); reg:addr
	Ccall _printstr
;}
L80:
	release 12
	Cretn

_printlint:		;framesize=20
	reserve 18
	st2 R12,'O',sp,(20)			
	inc memaddr				;opt16.1
	str2 R13,memaddr			
;void printlint(long s){ //print a long integer
;	printstr(ltoa(s,buffer));
	ld4 Rp1p2,'O',sp,(20);reg:  INDIRI4(addr)
	ldA2 R11,'O',sp,(6); reg:addr
	st2 R11,'O',sp,(4); arg+f**
	Ccall _ltoa
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R11 ;LOADP2(reg)
	Ccall _printstr
;}
L81:
	release 18
	Cretn

_printflt:		;framesize=30
	reserve 28
	st2 R12,'O',sp,(30)			
	inc memaddr				;opt16.1
	str2 R13,memaddr			
;void printflt(float s){ //print a float
;	printstr(ftoa(s,buffer,3));
	ld4 Rp1p2,'O',sp,(30);INDIRF4(addr)
	ldA2 R11,'O',sp,(8); reg:addr
	st2 R11,'O',sp,(4); arg+f**
	ldaD R11,3; reg:acon
	st2 R11,'O',sp,(6); arg+f**
	Ccall _ftoa
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R11 ;LOADP2(reg)
	Ccall _printstr
;}
L82:
	release 28
	Cretn

_putxn:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6); flag1 
	ldA2 R11,'O',sp,(6); reg:addr
	ld2 R10,'O',sp,(6) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;void putxn(unsigned char x){ //print a nibble as ascii hex
;	if (x<10){
	ld1 R11,'O',sp,(6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jcI2I R11,10,lbdf,L84; GE is flipped test from LT
;		putc(x+'0');
	ld1 R11,'O',sp,(6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldA2 R11,'O',R11,(48); reg:addr
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putc
;	} else {
	lbr L85
L84:
;		putc(x+'A'-10);
	ld1 R11,'O',sp,(6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldA2 R11,'O',R11,(65); reg:addr
	alu2I R11,R11,10,smi,smbi
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putc
;	}
L85:
;}
L83:
	release 4
	Cretn

_putx:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6); flag1 
	ldA2 R11,'O',sp,(6); reg:addr
	ld2 R10,'O',sp,(6) ;reg:INDIRI2(addr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;void putx(unsigned char x){ //print a unsigned char as ascii hex
;	putxn(x>>4);
	ld1 R11,'O',sp,(6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	shrI2I R11,4
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putxn
;	putxn(x & 0x0F);
	ld1 R11,'O',sp,(6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	alu2I R11,R11,15,ani,ani
	;removed ?	cpy2 R11,R11
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putxn
;}
L86:
	release 4
	Cretn

_printf:		;framesize=16
	reserve 2; save room for local variables
	pushf R0	;opt11
	pushm R1	;opt11.1
	pushm R6	;opt11.1
	pushl R7	;opt11.1
	reserve 4; save room for outgoing arguments
	st2 R12,'O',sp,(16)			
	inc memaddr				;opt16
	str2 R13,memaddr			
;void printf(char *ptr,...){ //limited implementation of printf
;	int argslot=0;	//used to align longs
	ld2z R1
;	int * this=(int *)&ptr;
	ldA2 R6,'O',sp,(16); reg:addr
;	this++; argslot++; //advance argument pointer and slot #
	incm R6,2
	incm R1,1
	lbr L89
L88:
;    while(*ptr) {
;		c=*ptr++;
	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(16); ASGNP2(addr,reg)
	ldn1 R7,R11;reg:  INDIRU1(indaddr)
;		if (c!='%'){
	cpy1 R11,R7
	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	jeqU2I R11,37,L91;EQI2(reg,con)
;			putc(c);
	cpy1 R12,R7
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putc
;		} else{
	lbr L92
L91:
;			c=*ptr++;
	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(16); ASGNP2(addr,reg)
	ldn1 R7,R11;reg:  INDIRU1(indaddr)
;			switch (c){
	cpy1 R0,R7
	zExt R0 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	jcI2I R0,99,lbnf,L114  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
	jnI2I R0,108,lbnf,L115; GT reverse  the subtraction
	shlR2R	R11,R0	;opt6
	ld2 R11,'O',R11,(L116-198) ;reg:INDIRP2(addr)
	jumpv R11; JUMPV(reg)
L116:
	dw L98
	dw L96
	dw L93
	dw L109
	dw L93
	dw L93
	dw L96
	dw L93
	dw L93
	dw L102
L114:
	jeqU2I R0,88,L101;EQI2(reg,con)
	lbr L93
L115:
	ldaD R11,115; reg:acon
	jeqI2 R0,R11,L97; EQI2(reg,reg)
	jcI2 R0,R11,lbnf,L93; LT=lbnf i.e. subtract B from A and jump if borrow 
L118:
	jeqU2I R0,120,L101;EQI2(reg,con)
	lbr L93
L96:
;					printint(*this++);
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,2
	ldn2 R12,R11	;opt9x
	Ccall _printint
;					argslot+=1; //next argument slot
	incm R1,1
;					break;
	lbr L94
L97:
;					printstr((char*) *this++);
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,2
	ldn2s R11,R11	;opt9xs
	cpy2 R12,R11 ;LOADP2(reg)
	Ccall _printstr
;					argslot+=1; //next argument slot
	incm R1,1
;					break;
	lbr L94
L98:
;					if (*ptr=='x'){ //if there's an x
	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
	ldn1 R11,R11;reg:  INDIRU1(indaddr)
	jneU1I R11,120,L99	; DH 4
;						ptr++; //skip over the x
	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(16); ASGNP2(addr,reg)
;						putx(((unsigned int) *this++)&255); //print 1 byte as hex
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,2
	ldn2s R11,R11	;opt9xs
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;					} else{
	lbr L100
L99:
;						putc((unsigned int) *this++);		//print as char
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,2
	ldn2s R11,R11	;opt9xs
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putc
;					}
L100:
;					argslot+=1; //next argument slot
	incm R1,1
;					break;
	lbr L94
L101:
;					putx(((unsigned int) *this)>>8);
	ldn2 R11,R6	;opt9x
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;					putx(((unsigned int) *this++)&255);
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,2
	ldn2s R11,R11	;opt9xs
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;					argslot+=1; //next argument slot
	incm R1,1
;					break;
	lbr L94
L102:
;					if (*ptr){ //as long as there's something there
	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
	ldn1 R11,R11	;opt14*
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jzU2 R11,L103; EQ 0
;						xord=*ptr++;
	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(16); ASGNP2(addr,reg)
	ldA2 R10,'O',sp,(13); reg:addr
	ldn1 R11,R11;reg:  INDIRU1(indaddr)
	str1 R11,R10; ASGNU1(indaddr,reg)		DH
;						if (argslot&1) {
	alu2I R11,R1,1,ani,ani
	;removed ?	cpy2 R11,R1
	jzU2 R11,L105; EQ 0
;							this++;
	incm R6,2
;							argslot++;
	incm R1,1
;						}
L105:
;						if(xord=='d'){
	ld1 R11,'O',sp,(13)
	jneU1I R11,100,L107	; DH 4
;							printlint(*(long *)this);//treats "this" as a pointer to long
	ld4 Rp1p2,'O',R6,0;reg:  INDIRI4(addr)
	Ccall _printlint
;							this+=2;				// and advances it 4 bytes
	incm R6,4
;						} else{
	lbr L108
L107:
;							putx(((unsigned int) *this)>>8);
	ldn2 R11,R6	;opt9x
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;							putx(((unsigned int) *this++)&255);
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,2
	ldn2s R11,R11	;opt9xs
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;							putx(((unsigned int) *this)>>8);
	ldn2 R11,R6	;opt9x
	ghi	R11	;opt2
	plo	R11
	ldi	0
	phi	R11	
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;							putx(((unsigned int) *this++)&255);
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,2
	ldn2s R11,R11	;opt9xs
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putx
;						}
L108:
;						argslot+=2;
	incm R1,2
;						break;
	lbr L94
L103:
L109:
;					if (*ptr){ //as long as there's something there
	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
	ldn1 R11,R11	;opt14*
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jzU2 R11,L110; EQ 0
;						if (argslot&1) { //adjust alignment
	alu2I R11,R1,1,ani,ani
	;removed ?	cpy2 R11,R1
	jzU2 R11,L112; EQ 0
;							this++;
	incm R6,2
;							argslot++;
	incm R1,1
;						}
L112:
;						printflt(*(float *)this);//treats "this" as a pointer to float
	ld4 Rp1p2,'O',R6,0;INDIRF4(addr)
	Ccall _printflt
;						this+=2;				// and advances it 4 bytes
	incm R6,4
;						argslot+=2;
	incm R1,2
;						break;
	lbr L94
L110:
L93:
;					putc('%');putc(c);
	ldaD R12,37; reg:acon
	Ccall _putc
	cpy1 R12,R7
	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
	Ccall _putc
;			} //switch
L94:
;		} //%
L92:
;	} //while
L89:
;    while(*ptr) {
	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
	ldn1 R11,R11;reg:  INDIRU1(indaddr)
	jnzU1 R11,L88; NEI2(CVUI2(reg),con0)
;} //prtf
L87:
	release 4; release room for outgoing arguments
	popr R7
	popr R6
	popr R1
	popr R0
	release 2; release room for local variables 
	Cretn

_exit:		;framesize=6
	reserve 4
	st2 R12,'O',sp,(6); flag1 
;void exit(int code){
;	printf("exit %d\n",code);
	ldaD R12,L120; reg:acon
	ld2 R13,'O',sp,(6) ;reg:INDIRI2(addr)
	Ccall _printf
L121:
;	while(1);
L122:
	lbr L121
;}
L119:
	release 4
	Cretn

_memcmp:		;framesize=10
	pushf R0	;opt11
	pushm R1	;opt11.1
	pushm R6	;opt11.1
	pushl R7	;opt11.1
	ld2 R7,'O',sp,(14) ;reg:INDIRU2(addr)
;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
;    int v = 0;
	ld2z R6
;    p1 = (unsigned char *)Ptr1;
	cpy2 R1,R12 ;LOADP2(reg)
;    p2 = (unsigned char *)Ptr2;
	cpy2 R0,R13 ;LOADP2(reg)
	lbr L126
L125:
;    while(Count-- > 0 && v == 0) {
;        v = *(p1++) - *(p2++);
	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
	incm R1,1
	cpy2 R10,R0 ;LOADP2(reg) ;opt1.1
	incm R0,1
	ldn1 R11,R11	;opt14*
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldn1 R10,R10	;opt14*
	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
	alu2 R6,R11,R10,sm,smb
;    }
L126:
;    while(Count-- > 0 && v == 0) {
	cpy2 R11,R7 ;LOADU2(reg) ;opt1.1
	decm R7,1
	jzU2 R11,L128; EQ 0
	jzU2 R6,L125; EQ 0
L128:
;    return v;
	cpy2 R15,R6 ;LOADI2(reg)
L124:
	popr R7
	popr R6
	popr R1
	popr R0
	Cretn

_memcpy:		;framesize=8
	pushf R1	;opt11
	pushm R6	;opt11.1
	pushl R7	;opt11.1
	ld2 R7,'O',sp,(12) ;reg:INDIRU2(addr)
;void* memcpy(void* dest, const void* src, unsigned int count) {
;        char* dst8 = (char*)dest;
	cpy2 R6,R12 ;LOADP2(reg)
;        char* src8 = (char*)src;
	cpy2 R1,R13 ;LOADP2(reg)
	lbr L131
L130:
;        while (count--) {
;            *dst8++ = *src8++;
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,1
	cpy2 R10,R1 ;LOADP2(reg) ;opt1.1
	incm R1,1
	ldn1 R10,R10;reg:  INDIRU1(indaddr)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
;        }
L131:
;        while (count--) {
	cpy2 R11,R7 ;LOADU2(reg) ;opt1.1
	decm R7,1
	jnzU2 R11,L130; NE 0
;        return dest;
	cpy2 R15,R12 ;LOADP2(reg)
L129:
	popr R7
	popr R6
	popr R1
	Cretn

_memset:		;framesize=6
	pushf R6	;opt11
	pushl R7	;opt11
	ld2 R7,'O',sp,(10) ;reg:INDIRU2(addr)
;{
;    unsigned char* p=s;
	cpy2 R6,R12 ;LOADP2(reg)
	lbr L135
L134:
;        *p++ = (unsigned char)c;
	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
	incm R6,1
	cpy2 R10,R13 ;LOADU2(reg)
	str1 R10,R11; ASGNU1(indaddr,reg)		DH
L135:
;    while(n--)
	cpy2 R11,R7 ;LOADU2(reg) ;opt1.1
	decm R7,1
	jnzU2 R11,L134; NE 0
;    return s;
	cpy2 R15,R12 ;LOADP2(reg)
L133:
	popr R7
	popr R6
	Cretn

_nstdlibincluder:		;framesize=2
;void nstdlibincluder(){
;	asm("\tinclude nstdlib.inc\n"); //strcpy, strcmp
	include nstdlib.inc
;}
L137:
	Cretn

L120:
	db 101
	db 120
	db 105
	db 116
	db 32
	db 37
	db 100
	db 10
	db 0
	align 4
L56:
	dd 0xbf800000
	align 4
L55:
	dd 0x0
	include lcc1802EpiloDH.inc
	include LCC1802fp.inc
	include IO1802.inc
