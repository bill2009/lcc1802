 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 1 - 8/27/2014 11:16:27


       1/       0 :                     ; generated by lcc-xr18DH $Version: 5.0 - XR18DH $ on Wed Aug 27 11:16:27 2014
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1) 1008/       0 :                     	listing	on
(1) 1009/       0 : C0 11 B4            	lbr	lcc1802Init
(1) 1010/       3 :                     	
(1) 1011/       3 :                     
      11/       3 :                     	listing on
      12/       3 :                     _PIN4:
      13/       3 : 00                  	db 0
      14/       4 :                     _send:		;framesize=2
      15/       4 :                     ;void send(unsigned char data){ //shift out a byte -lsb first
      16/       4 :                     ;	asm("	ldi 8	; loop count\n"
      17/       4 : F8 08               	ldi 8	; loop count
      18/       6 : A8                  	plo rt1	; in temp register
      19/       7 : (MACRO)             	lda2 rt2,'D',_PIN4,0	;point rt2 to PIN4 which holds current output data
      20/       D : 09                  	ldn	 rt2	;pick up PIN4 value
      21/       E : FA 6F               	ani	 0x7f!(1<<4) ;turn off data and strobe bits
      22/      10 : 59                  	str  rt2
      23/      11 :                     	;and put it back
      24/      11 :                     $$slp: ; we will do this 8 times
      25/      11 : E9                  	sex  rt2		;temporarily use rt2 as X
      26/      12 : 8C                  	glo regArg1	; get the data byte
      27/      13 : FA 01               	ani	0x01 ;isolate the bottom bit
      28/      15 : CE                     lsz     ;need to have it in the top position though
      29/      16 : F8 80                  ldi 0x80 ;there it is
      30/      18 : F1                  	or		 ; combine PIN4 with the current data bit
      31/      19 : E2                  	sex sp	;return to normal index reg
      32/      1A : 22                  	dec sp	; work space
      33/      1B : 52                  	str sp	;prep for output
      34/      1C : 64                  	out 4 	;put it out
      35/      1D : F9 10               	ori 1<<4 ;blip the spi clock
      36/      1F : 22                  	dec sp	; work space
      37/      20 : 52                  	str sp	;prep for output
      38/      21 : 64                  	out 4 	;put it out
      39/      22 : 8C                  	glo	regArg1	; get the data back
      40/      23 : F6                  	shr		; rotate the next bit into position
      41/      24 : AC                  	plo regArg1	;prepare to repeat
      42/      25 : 28                  	dec rt1 ;decrement loop count
      43/      26 : 88                  	glo rt1	;get the loop count
      44/      27 : CA 00 11            	lbnz $$slp ; back for more
      45/      2A :                     ;}
      46/      2A :                     L1:
      47/      2A : (MACRO)             	Cretn
      48/      2B :                     
      49/      2B :                     _sendCommand:		;framesize=6
      50/      2B : (MACRO)             	reserve 4
      51/      2F : (MACRO)             	st2 R12,'O',sp,(6); flag1 
      52/      3C : (MACRO)             	ldA2 R11,'O',sp,(6); reg:addr
      53/      44 : (MACRO)             	ld2 R10,'O',sp,(6) ;reg:INDIRI2(addr)
      54/      50 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
      55/      52 :                     ;void sendCommand(uchar cmd){
      56/      52 :                     ;  digitalWrite(strobePin, LOW);
      57/      52 : (MACRO)             	ldaD R12,5; reg:acon
      58/      58 : (MACRO)             	ld2z R13
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 2 - 8/27/2014 11:16:27


      59/      5C : (MACRO)             	Ccall _digitalWrite
      60/      5F :                     ;  send(cmd);
      61/      5F : (MACRO)             	ld1 R12,'O',sp,(6)
      62/      69 : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
      63/      6C : (MACRO)             	Ccall _send
      64/      6F :                     ;  digitalWrite(strobePin, HIGH);
      65/      6F : (MACRO)             	ldaD R12,5; reg:acon
      66/      75 : (MACRO)             	ldaD R13,1; reg:acon
      67/      7B : (MACRO)             	Ccall _digitalWrite
      68/      7E :                     ;}
      69/      7E :                     L3:
      70/      7E : (MACRO)             	release 4
      71/      82 : (MACRO)             	Cretn
      72/      83 :                     
      73/      83 :                     _sendData:		;framesize=6
      74/      83 : (MACRO)             	reserve 4
      75/      87 : (MACRO)             	st2 R12,'O',sp,(6)			
      76/      94 : 1E                  	inc memaddr				;opt16.1
      77/      95 : (MACRO)             	str2 R13,memaddr			
      78/      9B : (MACRO)             	ldA2 R11,'O',sp,(6); reg:addr
      79/      A3 : (MACRO)             	ld2 R10,'O',sp,(6) ;reg:INDIRI2(addr)
      80/      AF : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
      81/      B1 : (MACRO)             	ldA2 R11,'O',sp,(8); reg:addr
      82/      B9 : (MACRO)             	ld2 R10,'O',sp,(8) ;reg:INDIRI2(addr)
      83/      C5 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
      84/      C7 :                     ;void sendData(uchar address, uchar data){
      85/      C7 :                     ;  sendCommand(0x44);
      86/      C7 : (MACRO)             	ldaD R12,68; reg:acon
      87/      CD : (MACRO)             	Ccall _sendCommand
      88/      D0 :                     ;  digitalWrite(strobePin, LOW);
      89/      D0 : (MACRO)             	ldaD R12,5; reg:acon
      90/      D6 : (MACRO)             	ld2z R13
      91/      DA : (MACRO)             	Ccall _digitalWrite
      92/      DD :                     ;  send(0xC0 | address);
      93/      DD : (MACRO)             	ld1 R11,'O',sp,(6)
      94/      E7 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
      95/      EA : (MACRO)             	alu2I R11,R11,192,ori,ori ;removed copy
      96/      F2 : (MACRO)             	cpy1 R12,R11
      97/      F4 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
      98/      F7 : (MACRO)             	Ccall _send
      99/      FA :                     ;  send(data);
     100/      FA : (MACRO)             	ld1 R12,'O',sp,(8)
     101/     104 : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     102/     107 : (MACRO)             	Ccall _send
     103/     10A :                     ;  digitalWrite(strobePin, HIGH);
     104/     10A : (MACRO)             	ldaD R12,5; reg:acon
     105/     110 : (MACRO)             	ldaD R13,1; reg:acon
     106/     116 : (MACRO)             	Ccall _digitalWrite
     107/     119 :                     ;}
     108/     119 :                     L4:
     109/     119 : (MACRO)             	release 4
     110/     11D : (MACRO)             	Cretn
     111/     11E :                     
     112/     11E :                     _setLED:		;framesize=6
     113/     11E : (MACRO)             	reserve 4
     114/     122 : (MACRO)             	st2 R12,'O',sp,(6)			
     115/     12F : 1E                  	inc memaddr				;opt16.1
     116/     130 : (MACRO)             	str2 R13,memaddr			
     117/     136 : (MACRO)             	ldA2 R11,'O',sp,(6); reg:addr
     118/     13E : (MACRO)             	ld2 R10,'O',sp,(6) ;reg:INDIRI2(addr)
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 3 - 8/27/2014 11:16:27


     119/     14A : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     120/     14C : (MACRO)             	ldA2 R11,'O',sp,(8); reg:addr
     121/     154 : (MACRO)             	ld2 R10,'O',sp,(8) ;reg:INDIRI2(addr)
     122/     160 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     123/     162 :                     ;{
     124/     162 :                     ;    sendData((pos << 1) + 1, color);
     125/     162 : (MACRO)             	ld1 R11,'O',sp,(8)
     126/     16C : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     127/     16F : (MACRO)             	shl2I R11,1
     128/     175 : (MACRO)             	incm R11,1
     129/     176 : (MACRO)             	cpy1 R12,R11
     130/     178 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     131/     17B : (MACRO)             	ld1 R13,'O',sp,(6)
     132/     185 : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     133/     188 : (MACRO)             	Ccall _sendData
     134/     18B :                     ;}
     135/     18B :                     L5:
     136/     18B : (MACRO)             	release 4
     137/     18F : (MACRO)             	Cretn
     138/     190 :                     
     139/     190 :                     _setDisplay:		;framesize=12
     140/     190 : (MACRO)             	pushf R1	;opt11
     141/     195 : (MACRO)             	pushm R6	;opt11.1
     142/     199 : (MACRO)             	pushl R7	;opt11.1
     143/     19D : (MACRO)             	reserve 4; save room for outgoing arguments
     144/     1A1 : (MACRO)             	cpy2 R7,R12; function(2055) 1
     145/     1A5 : (MACRO)             	cpy2 R6,R13; function(1030) 1
     146/     1A9 :                     ;void setDisplay(const unsigned char values[], unsigned char size){
     147/     1A9 :                     ;  for (i = 0; i<size; i++) {
     148/     1A9 : (MACRO)             	ldaD R1,0; reg:acon
     149/     1AF : C0 01 D7            	lbr L10
     150/     1B2 :                     L7:
     151/     1B2 :                     ;    sendData(i<<1, values[i]);
     152/     1B2 : (MACRO)             	cpy1 R11,R1
     153/     1B4 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     154/     1B7 : (MACRO)             	shlR2R	R10,R11	;opt6
     155/     1BD : (MACRO)             	cpy1 R12,R10
     156/     1BF : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     157/     1C2 : (MACRO)             	alu2 R11,R11,R7,add,adc	;ADDP2(reg,reg)
     158/     1CE : (MACRO)             	ldn1 R13,R11	;opt14*
     159/     1D0 : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     160/     1D3 : (MACRO)             	Ccall _sendData
     161/     1D6 :                     ;  }
     162/     1D6 :                     L8:
     163/     1D6 :                     ;  for (i = 0; i<size; i++) {
     164/     1D6 : (MACRO)             	incm R1,1	;opt13
     165/     1D7 :                     L10:
     166/     1D7 : (MACRO)             	cpy1 R11,R1
     167/     1D9 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     168/     1DC : (MACRO)             	cpy1 R10,R6
     169/     1DE : (MACRO)             	zExt R10 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     170/     1E1 : (MACRO)             	jcI2 R11,R10,lbnf,L7; LT=lbnf i.e. subtract B from A and jump if borrow 
     171/     1F5 :                     ;}
     172/     1F5 :                     L6:
     173/     1F5 : (MACRO)             	release 4; release room for outgoing arguments
     174/     1F9 : (MACRO)             	popr R7
     175/     1FD : (MACRO)             	popr R6
     176/     201 : (MACRO)             	popr R1
     177/     205 : (MACRO)             	Cretn
     178/     206 :                     
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 4 - 8/27/2014 11:16:27


     179/     206 :                     _tms1638init:		;framesize=8
     180/     206 : (MACRO)             	pushr R7
     181/     20B : (MACRO)             	reserve 4; save room for outgoing arguments
     182/     20F :                     ;void tms1638init(){
     183/     20F :                     ;  digitalWrite(strobePin, HIGH);
     184/     20F : (MACRO)             	ldaD R12,5; reg:acon
     185/     215 : (MACRO)             	ldaD R13,1; reg:acon
     186/     21B : (MACRO)             	Ccall _digitalWrite
     187/     21E :                     ;  digitalWrite(tmclockpin, HIGH);
     188/     21E : (MACRO)             	ldaD R12,4; reg:acon
     189/     224 : (MACRO)             	ldaD R13,1; reg:acon
     190/     22A : (MACRO)             	Ccall _digitalWrite
     191/     22D :                     ;  sendCommand(0x40);
     192/     22D : (MACRO)             	ldaD R12,64; reg:acon
     193/     233 : (MACRO)             	Ccall _sendCommand
     194/     236 :                     ;  sendCommand(0x80 | (8) | min(7, 3));
     195/     236 : (MACRO)             	ldaD R12,139; reg:acon
     196/     23C : (MACRO)             	Ccall _sendCommand
     197/     23F :                     ;  digitalWrite(strobePin, LOW);
     198/     23F : (MACRO)             	ldaD R12,5; reg:acon
     199/     245 : (MACRO)             	ld2z R13
     200/     249 : (MACRO)             	Ccall _digitalWrite
     201/     24C :                     ;  send(0xC0);
     202/     24C : (MACRO)             	ldaD R12,192; reg:acon
     203/     252 : (MACRO)             	Ccall _send
     204/     255 :                     ;  for (i = 0; i < 16; i++) {
     205/     255 : (MACRO)             	ldaD R7,0; reg:acon
     206/     25B : C0 02 66            	lbr L15
     207/     25E :                     L12:
     208/     25E :                     ;    send(0x00);
     209/     25E : (MACRO)             	ld2z R12
     210/     262 : (MACRO)             	Ccall _send
     211/     265 :                     ;  }
     212/     265 :                     L13:
     213/     265 :                     ;  for (i = 0; i < 16; i++) {
     214/     265 : (MACRO)             	incm R7,1	;opt13
     215/     266 :                     L15:
     216/     266 : (MACRO)             	cpy1 R11,R7
     217/     268 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     218/     26B : (MACRO)             	jcI2I R11,16,lbnf,L12  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     219/     27C :                     ;  digitalWrite(strobePin, HIGH);
     220/     27C : (MACRO)             	ldaD R12,5; reg:acon
     221/     282 : (MACRO)             	ldaD R13,1; reg:acon
     222/     288 : (MACRO)             	Ccall _digitalWrite
     223/     28B :                     ;}
     224/     28B :                     L11:
     225/     28B : (MACRO)             	release 4; release room for outgoing arguments
     226/     28F : (MACRO)             	popr R7
     227/     293 : (MACRO)             	Cretn
     228/     294 :                     
     229/     294 :                     L17:
     230/     294 : 00                  	db 0
     231/     295 : 00                  	db 0
     232/     296 : 00                  	db 0
     233/     297 : 00                  	db 0
     234/     298 : 06                  	db 6
     235/     299 : 7F                  	db 127
     236/     29A : 3F                  	db 63
     237/     29B : 5B                  	db 91
     238/     29C : 00                  	db 0
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 5 - 8/27/2014 11:16:27


     239/     29D : 00                  	db 0
     240/     29E : 00                  	db 0
     241/     29F : 00                  	db 0
     242/     2A0 :                     _setDisplayTo1802:		;framesize=18
     243/     2A0 : (MACRO)             	reserve 16
     244/     2AA : (MACRO)             	st2 R12,'O',sp,(18); flag1 
     245/     2B7 : (MACRO)             	ldA2 R11,'O',sp,(18); reg:addr
     246/     2BF : (MACRO)             	ld2 R10,'O',sp,(18) ;reg:INDIRI2(addr)
     247/     2CB : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     248/     2CD :                     ;{
     249/     2CD :                     ;const unsigned char RCA_DATA[] = {
     250/     2CD : (MACRO)             	ldA2 R11,'O',sp,(4); reg:addr
     251/     2D5 : (MACRO)             	ldaD R8,L17; reg:acon
     252/     2DB : (MACRO)             	blkcpy R11,R8,12; ASGNB(reg,INDIRB(reg))
     253/     2F0 :                     ;  setDisplay(RCA_DATA+offset, 8);
     254/     2F0 : (MACRO)             	ld1 R11,'O',sp,(18)
     255/     2FA : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     256/     2FD : (MACRO)             	ldA2 R10,'O',sp,(4); reg:addr
     257/     305 : (MACRO)             	alu2 R12,R11,R10,add,adc	;ADDP2(reg,reg)
     258/     311 : (MACRO)             	ldaD R13,8; reg:acon
     259/     317 : (MACRO)             	Ccall _setDisplay
     260/     31A :                     ;}
     261/     31A :                     L16:
     262/     31A : (MACRO)             	release 16
     263/     322 : (MACRO)             	Cretn
     264/     323 :                     
     265/     323 :                     L19:
     266/     323 : 03                  	db 3
     267/     324 :                     L20:
     268/     324 : 01                  	db 1
     269/     325 :                     _sparkle:		;framesize=6
     270/     325 : (MACRO)             	reserve 4
     271/     329 :                     ;	static unsigned char pos=3,color=tmsred;
     272/     329 :                     ;  		delay(150);
     273/     329 : (MACRO)             	ldaD R12,2; reg:acon
     274/     32F : (MACRO)             	ld1 R13,'D',(L19),0
     275/     337 : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     276/     33A : (MACRO)             	Ccall _setLED
     277/     33D :                     ;  		setLED(0,pos);
     278/     33D : (MACRO)             	ldaD R12,150; reg:acon
     279/     343 : (MACRO)             	Ccall _delay
     280/     346 :                     ;  		delay(150);
     281/     346 : (MACRO)             	ld2z R12
     282/     34A : (MACRO)             	ld1 R13,'D',(L19),0
     283/     352 : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     284/     355 : (MACRO)             	Ccall _setLED
     285/     358 :                     ;  		pos=(pos+1)%8;
     286/     358 : (MACRO)             	ldaD R12,150; reg:acon
     287/     35E : (MACRO)             	Ccall _delay
     288/     361 :                     ;  		setLED(tmsgreen,pos);
     289/     361 : (MACRO)             	ldaD R11,L19; reg:acon
     290/     367 : (MACRO)             	ld1 R10,'D',(L19),0
     291/     36F : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     292/     372 : (MACRO)             	cpy2 R12,R10 ;reg:ADDI2(consm,reg)
     293/     376 : (MACRO)             	incm R12,1
     294/     377 : (MACRO)             	ldaD R13,8; reg:acon
     295/     37D : (MACRO)             	Ccall _modi2
     296/     380 : (MACRO)             	cpy2 R10,R15 ;LOADU2(reg)
     297/     384 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     298/     386 :                     ;  		delay(150);
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 6 - 8/27/2014 11:16:27


     299/     386 : (MACRO)             	ldaD R12,2; reg:acon
     300/     38C : (MACRO)             	ld1 R13,'D',(L19),0
     301/     394 : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     302/     397 : (MACRO)             	Ccall _setLED
     303/     39A :                     ;  		setLED(0,pos);
     304/     39A : (MACRO)             	ldaD R12,150; reg:acon
     305/     3A0 : (MACRO)             	Ccall _delay
     306/     3A3 :                     ;  		pos=(pos+1)%8;
     307/     3A3 : (MACRO)             	ld2z R12
     308/     3A7 : (MACRO)             	ld1 R13,'D',(L19),0
     309/     3AF : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     310/     3B2 : (MACRO)             	Ccall _setLED
     311/     3B5 :                     ;}
     312/     3B5 : (MACRO)             	ldaD R11,L19; reg:acon
     313/     3BB : (MACRO)             	ld1 R10,'D',(L19),0
     314/     3C3 : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     315/     3C6 : (MACRO)             	cpy2 R12,R10 ;reg:ADDI2(consm,reg)
     316/     3CA : (MACRO)             	incm R12,1
     317/     3CB : (MACRO)             	ldaD R13,8; reg:acon
     318/     3D1 : (MACRO)             	Ccall _modi2
     319/     3D4 : (MACRO)             	cpy2 R10,R15 ;LOADU2(reg)
     320/     3D8 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     321/     3DA :                     ;
     322/     3DA :                     L18:
     323/     3DA : (MACRO)             	release 4
     324/     3DE : (MACRO)             	Cretn
     325/     3DF :                     
     326/     3DF :                     _main: ;copt is peeping your size 6 frame with oct 23 rules
     327/     3DF : (MACRO)             	reserve 4
     328/     3E3 :                     ;  tms1638init();
     329/     3E3 :                     ;  delay(10);
     330/     3E3 : (MACRO)             	Ccall _tms1638init
     331/     3E6 :                     ;  while(1){
     332/     3E6 : (MACRO)             	ldaD R12,10; reg:acon
     333/     3EC : (MACRO)             	Ccall _delay
     334/     3EF : C0 04 08            	lbr L23
     335/     3F2 :                     L22:
     336/     3F2 :                     ;    setDisplayTo1802(4);
     337/     3F2 :                     ;    sparkle();
     338/     3F2 : (MACRO)             	ldaD R12,4; reg:acon
     339/     3F8 : (MACRO)             	Ccall _setDisplayTo1802
     340/     3FB :                     ;    setDisplayTo1802(0);
     341/     3FB : (MACRO)             	Ccall _sparkle
     342/     3FE :                     ;    sparkle();
     343/     3FE : (MACRO)             	ld2z R12
     344/     402 : (MACRO)             	Ccall _setDisplayTo1802
     345/     405 :                     ;  }
     346/     405 : (MACRO)             	Ccall _sparkle
     347/     408 :                     ;}
     348/     408 :                     L23:
     349/     408 :                     ;    setDisplayTo1802(4);
     350/     408 : C0 03 F2            	lbr L22
     351/     40B :                     ;#include "olduino.c"
     352/     40B :                     L21:
     353/     40B : (MACRO)             	release 4
     354/     40F : (MACRO)             	Cretn
     355/     410 :                     
     356/     410 :                     _delay:		;framesize=10
     357/     410 : (MACRO)             	pushf R6	;opt11
     358/     415 : (MACRO)             	pushl R7	;opt11
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 7 - 8/27/2014 11:16:27


     359/     419 : (MACRO)             	reserve 4; save room for outgoing arguments
     360/     41D : (MACRO)             	cpy2 R7,R12; function(2054) 1
     361/     421 :                     ;void delay(unsigned int howlong){
     362/     421 :                     ;	for (i=1;i!=howlong;i++){
     363/     421 : (MACRO)             	ldaD R6,1; reg:acon
     364/     427 : C0 04 2E            	lbr L29
     365/     42A :                     L26:
     366/     42A :                     ;		oneMs();
     367/     42A : (MACRO)             	Ccall _oneMs; CALLI2(ar)
     368/     42D :                     ;	}
     369/     42D :                     L27:
     370/     42D :                     ;	for (i=1;i!=howlong;i++){
     371/     42D : (MACRO)             	incm R6,1
     372/     42E :                     L29:
     373/     42E : (MACRO)             	jneU2 R6,R7,L26; NE
     374/     440 :                     ;}
     375/     440 :                     L25:
     376/     440 : (MACRO)             	release 4; release room for outgoing arguments
     377/     444 : (MACRO)             	popr R7
     378/     448 : (MACRO)             	popr R6
     379/     44C : (MACRO)             	Cretn
     380/     44D :                     
     381/     44D :                     _olduinoincluder:		;framesize=2
     382/     44D :                     ;void olduinoincluder(){
     383/     44D :                     ;	asm("\tinclude olduino.inc\n");
     384/     44D :                     	include olduino.inc
(1)    1/     44D :                     ;Feb 8 2013, first version of assembler routines for olduino support	
(1)    2/     44D :                     ;may 31 - incredibly, there's an error in digitalWrite.  lda2 changed to ldAD
(1)    3/     44D :                     ;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
(1)    4/     44D :                     	align 64	;needed to make sure all on same page
(1)    5/     480 :                     _digitalWrite:
(1)    6/     480 : 8C                  	glo regArg1	;get the bit number
(1)    7/     481 : FC 9F               	adi $$bvtable&255	;add the table offset
(1)    8/     483 : AE                  	plo memaddr
(1)    9/     484 : 93                  	ghi RPC		;get the top byte of the current page
(1)   10/     485 : BE                  	phi memaddr	
(1)   11/     486 : 0E                  	ldn memaddr	;pick up the bit pattern
(1)   12/     487 : A8                  	plo rt1		;save it in a temp
(1)   13/     488 : (MACRO)             	ldAD memaddr,_PIN4 ;address the current port value
(1)   14/     48E : EE                  	sex memaddr	;prepare to change it
(1)   15/     48F : 8D                  	glo regArg2	;get on/off switch
(1)   16/     490 : 32 97               	bz $$setbitoff
(1)   17/     492 :                     ; here we have the bit pattern in rt1 and we're ready to apply it with OR
(1)   18/     492 : 88                  	glo rt1		;get the bit value back
(1)   19/     493 : F1                  	or		;apply it
(1)   20/     494 : 5E                  	str memaddr	;and save it
(1)   21/     495 : 30 9C               	br $$outit	;go fnish up
(1)   22/     497 :                     $$setbitoff:
(1)   23/     497 : 88                  	glo rt1		;get the bit pattern
(1)   24/     498 : FB FF               	xri 0xff	;reverse it
(1)   25/     49A : F2                  	and		;combine it with the existing pin value
(1)   26/     49B : 5E                  	str memaddr	;and save it
(1)   27/     49C :                     ;here we gave set/reset the correct bit in PIN4 and we just have to send it out
(1)   28/     49C :                     $$outit:
(1)   29/     49C : 64                  	out 4		;X was already set to memaddr
(1)   30/     49D : E2                  	sex sp		;reset X
(1)   31/     49E : (MACRO)             	cretn
(1)   32/     49F : 01 02 04 08 10 20   $$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
                    40 80 
(1)   33/     4A7 :                     ;int digitalRead(unsigned char pin){//for now this will always read ef3
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(olduino.inc) - page 8 - 8/27/2014 11:16:27


(1)   34/     4A7 :                     	align 8	;protect jump boundary
(1)   35/     4A8 :                     _digitalRead:
(1)   36/     4A8 : F8 00               	ldi 0		;default is false
(1)   37/     4AA : AF                  	plo R15
(1)   38/     4AB : BF                  	phi R15
(1)   39/     4AC : 36 AF               	b3 +		;i have to reverse the sense of the external line
(1)   40/     4AE : 1F                  	inc R15		;if external line is high, supply a 1
(1)   41/     4AF : (MACRO)             +	cretn
(1)   42/     4B0 :                     
     385/     4B0 :                     ;}
     386/     4B0 :                     L30:
     387/     4B0 : (MACRO)             	Cretn
     388/     4B1 :                     
     389/     4B1 :                     _strncmp:		;framesize=6
     390/     4B1 : (MACRO)             	pushf R6	;opt11
     391/     4B6 : (MACRO)             	pushl R7	;opt11
     392/     4BA : (MACRO)             	ld2 R7,'O',sp,(10) ;reg:INDIRU2(addr)
     393/     4C6 :                     ;{
     394/     4C6 :                     ;    for ( ; n > 0; s1++, s2++, --n)
     395/     4C6 : C0 05 1A            	lbr L36
     396/     4C9 :                     L33:
     397/     4C9 :                     ;	if (*s1 != *s2)
     398/     4C9 : (MACRO)             	ldn1 R11,R12	;opt14*
     399/     4CB : (MACRO)             	ldn1 R10,R13	;opt14*
     400/     4CD : (MACRO)             	jeqI1 R11,R10,L37	;opt21
     401/     4D6 :                     ;	    return ((*(unsigned char *)s1 < *(unsigned char *)s2) ? -1 : +1);
     402/     4D6 : (MACRO)             	ldn1 R11,R12	;opt14*
     403/     4D8 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     404/     4DB : (MACRO)             	ldn1 R10,R13	;opt14*
     405/     4DD : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     406/     4E0 : (MACRO)             	jcI2 R11,R10,lbdf,L40; GE is flipped test from LT
     407/     4F4 : (MACRO)             	ldaD R6,-1; reg:acon
     408/     4FA : C0 05 03            	lbr L41
     409/     4FD :                     L40:
     410/     4FD : (MACRO)             	ldaD R6,1; reg:acon
     411/     503 :                     L41:
     412/     503 : (MACRO)             	cpy2 R15,R6 ;LOADI2(reg)
     413/     507 : C0 05 26            	lbr L32
     414/     50A :                     L37:
     415/     50A :                     ;	else if (*s1 == '\0')
     416/     50A : (MACRO)             	ldn1 R11,R12;reg:  INDIRU1(indaddr)
     417/     50C : (MACRO)             	jnzU1 R11,L42; NEI2(CVUI2(reg),con0)
     418/     510 :                     ;	    return 0;
     419/     510 : (MACRO)             	ld2z R15
     420/     514 : C0 05 26            	lbr L32
     421/     517 :                     L42:
     422/     517 :                     L34:
     423/     517 :                     ;    for ( ; n > 0; s1++, s2++, --n)
     424/     517 : (MACRO)             	incm R12,1
     425/     518 : (MACRO)             	incm R13,1
     426/     519 : (MACRO)             	decm R7,1
     427/     51A :                     L36:
     428/     51A : (MACRO)             	jnzU2 R7,L33; NE 0
     429/     522 :                     ;    return 0;
     430/     522 : (MACRO)             	ld2z R15
     431/     526 :                     L32:
     432/     526 : (MACRO)             	popr R7
     433/     52A : (MACRO)             	popr R6
     434/     52E : (MACRO)             	Cretn
     435/     52F :                     
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 9 - 8/27/2014 11:16:27


     436/     52F :                     _strlen:		;framesize=4
     437/     52F : (MACRO)             	pushr R7
     438/     534 :                     ;{
     439/     534 :                     ;	unsigned int slen = 0 ;
     440/     534 : (MACRO)             	ld2z R7
     441/     538 : C0 05 3D            	lbr L46
     442/     53B :                     L45:
     443/     53B :                     ;	while (*str != 0) {
     444/     53B :                     ;      slen++ ;
     445/     53B : (MACRO)             	incm R7,1
     446/     53C :                     ;      str++ ;
     447/     53C : (MACRO)             	incm R12,1
     448/     53D :                     ;   }
     449/     53D :                     L46:
     450/     53D :                     ;	while (*str != 0) {
     451/     53D : (MACRO)             	ldn1 R11,R12;reg:  INDIRU1(indaddr)
     452/     53F : (MACRO)             	jnzU1 R11,L45; NEI2(CVUI2(reg),con0)
     453/     543 :                     ;   return slen;
     454/     543 : (MACRO)             	cpy2 R15,R7 ;LOADU2(reg)
     455/     547 :                     L44:
     456/     547 : (MACRO)             	popr R7
     457/     54B : (MACRO)             	Cretn
     458/     54C :                     
     459/     54C :                     _printstr:		;framesize=8
     460/     54C : (MACRO)             	pushr R7
     461/     551 : (MACRO)             	reserve 4; save room for outgoing arguments
     462/     555 : (MACRO)             	cpy2 R7,R12; function(2055) 1
     463/     559 :                     ;void printstr(char *ptr){
     464/     559 : C0 05 69            	lbr L50
     465/     55C :                     L49:
     466/     55C :                     ;    while(*ptr) putc(*ptr++); //jan 29
     467/     55C : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg) ;opt1.1
     468/     560 : (MACRO)             	incm R7,1
     469/     561 : (MACRO)             	ldn1 R12,R11	;opt14*
     470/     563 : (MACRO)             	zExt R12 ;CVUI2: widen unsigned char to signed int (zero extend)
     471/     566 : (MACRO)             	Ccall _putc
     472/     569 :                     L50:
     473/     569 : (MACRO)             	ldn1 R11,R7;reg:  INDIRU1(indaddr)
     474/     56B : (MACRO)             	jnzU1 R11,L49; NEI2(CVUI2(reg),con0)
     475/     56F :                     ;}
     476/     56F :                     L48:
     477/     56F : (MACRO)             	release 4; release room for outgoing arguments
     478/     573 : (MACRO)             	popr R7
     479/     577 : (MACRO)             	Cretn
     480/     578 :                     
     481/     578 :                     	align 4
     482/     578 :                     _round_nums:
     483/     578 : 3F 00 00 00         	dd 0x3f000000
     484/     57C : 3D 4C CC CD         	dd 0x3d4ccccd
     485/     580 : 3B A3 D7 0A         	dd 0x3ba3d70a
     486/     584 : 3A 03 12 6F         	dd 0x3a03126f
     487/     588 : 38 51 B7 17         	dd 0x3851b717
     488/     58C : 36 A7 C5 AC         	dd 0x36a7c5ac
     489/     590 : 35 06 37 BD         	dd 0x350637bd
     490/     594 : 33 56 BF 95         	dd 0x3356bf95
     491/     598 :                     	align 4
     492/     598 :                     _mult_nums:
     493/     598 : 3F 80 00 00         	dd 0x3f800000
     494/     59C : 41 20 00 00         	dd 0x41200000
     495/     5A0 : 42 C8 00 00         	dd 0x42c80000
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 10 - 8/27/2014 11:16:27


     496/     5A4 : 44 7A 00 00         	dd 0x447a0000
     497/     5A8 : 46 1C 40 00         	dd 0x461c4000
     498/     5AC : 47 C3 50 00         	dd 0x47c35000
     499/     5B0 : 49 74 24 00         	dd 0x49742400
     500/     5B4 : 4B 18 96 80         	dd 0x4b189680
     501/     5B8 :                     _ftoa:		;framesize=80
     502/     5B8 : (MACRO)             	reserve 62; save room for local variables
     503/     5C2 : (MACRO)             	pushf R0	;opt11
     504/     5C7 : (MACRO)             	pushm R1	;opt11.1
     505/     5CB : (MACRO)             	pushm R6	;opt11.1
     506/     5CF : (MACRO)             	pushl R7	;opt11.1
     507/     5D3 : (MACRO)             	reserve 8; save room for outgoing arguments
     508/     5DB : (MACRO)             	cpy4 RL6,RL12; halfbaked&floaty
     509/     5E3 : (MACRO)             	ld2 R1,'O',sp,(86) ;reg:INDIRU2(addr)
     510/     5EF :                     ;{
     511/     5EF :                     ;   char *output = outbfr ;
     512/     5EF : (MACRO)             	ld2 R0,'O',sp,(84) ;reg:INDIRP2(addr)
     513/     5FB :                     ;   if (flt < 0.0) {
     514/     5FB : (MACRO)             	ld4 RL10,'D',(L55),0;INDIRF4(addr)
     515/     609 : (MACRO)             	jcF4 RL6,RL10,lbdf,L53;GEF4(reg,reg) - reverse test
     516/     64E :                     ;      *output++ = '-' ;
     517/     64E : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
     518/     652 : (MACRO)             	incm R0,1
     519/     653 : (MACRO)             	str1I 45,R11; ASGNU1(indaddr,acon)	DH
     520/     656 :                     ;      flt *= -1.0 ;
     521/     656 : (MACRO)             	ld4 RL8,'D',(L56),0;INDIRF4(addr)
     522/     664 : (MACRO)             	cpy4 RL10,RL6; LOADU4(reg)
     523/     66C : (MACRO)             	Ccall fp_mul ;MULF4(reg,reg)
     524/     66F : (MACRO)             	cpy4 RL6,RL8; LOADU4(reg)
     525/     677 :                     ;   } else {
     526/     677 : C0 06 85            	lbr L54
     527/     67A :                     L53:
     528/     67A :                     ;      if (use_leading_plus) {
     529/     67A : C0 06 85            	lbr L57
     530/     67D :                     ;         *output++ = '+' ;
     531/     67D : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
     532/     681 : (MACRO)             	incm R0,1
     533/     682 : (MACRO)             	str1I 43,R11; ASGNU1(indaddr,acon)	DH
     534/     685 :                     ;      }
     535/     685 :                     L57:
     536/     685 :                     ;   }
     537/     685 :                     L54:
     538/     685 :                     ;   if (dec_digits < 8) {
     539/     685 : (MACRO)             	jcI2I R1,8,lbdf,L59; GE is flipped test from LT
     540/     696 :                     ;      flt += round_nums[dec_digits] ;
     541/     696 : (MACRO)             	cpy4 RL8,RL6; LOADU4(reg)
     542/     69E : (MACRO)             	shlR2R	R11,R1	;opt6.1
     543/     6A4 : (MACRO)             	shl2I 	R11,1	;opt6.1
     544/     6AA : (MACRO)             	ld4 RL10,'O',R11,(_round_nums);INDIRF4(addr)
     545/     6BA : (MACRO)             	Ccall fp_add ;ADDF4(reg,reg)
     546/     6BD : (MACRO)             	cpy4 RL6,RL8; LOADU4(reg)
     547/     6C5 :                     ;   }
     548/     6C5 :                     L59:
     549/     6C5 :                     ;	mult=mult_nums[dec_digits];
     550/     6C5 : (MACRO)             	shlR2R	R11,R1	;opt6.1
     551/     6CB : (MACRO)             	shl2I 	R11,1	;opt6.1
     552/     6D1 : (MACRO)             	ld4 RL10,'O',R11,(_mult_nums);INDIRF4(addr)
     553/     6E1 : (MACRO)             	st4 RL10,'O',sp,(68); ASGNF4(addr,reg)
     554/     6F4 :                     ;   wholeNum = flt;
     555/     6F4 : (MACRO)             	cpy4 RL8,RL6; LOADU4(reg)
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 11 - 8/27/2014 11:16:27


     556/     6FC : (MACRO)             	ccall cvfi4; CVFI4(reg) convert float to long
     557/     6FF : (MACRO)             	st4 RL8,'O',sp,(72)
     558/     712 :                     ;   decimalNum = ((flt - wholeNum) * mult);
     559/     712 : (MACRO)             	cpy4 RL8,RL6; LOADU4(reg)
     560/     71A : (MACRO)             	st4 RL8,'O',sp,(16); ASGNF4(addr,reg)
     561/     72D : (MACRO)             	ld4 RL8,'O',sp,(72);reg:  INDIRI4(addr)
     562/     73D : (MACRO)             	Ccall cvif4; emit2
     563/     740 : (MACRO)             	cpy4 RL10,RL8; LOADU4(reg)
     564/     748 : (MACRO)             	ld4 RL8,'O',sp,(16);INDIRF4(addr)
     565/     758 : (MACRO)             	Ccall fp_sub ;SUBF4(reg,reg)
     566/     75B : (MACRO)             	ld4 RL10,'O',sp,(68);INDIRF4(addr)
     567/     76B : (MACRO)             	Ccall fp_mul ;MULF4(reg,reg)
     568/     76E : (MACRO)             	ccall cvfi4; CVFI4(reg) convert float to long
     569/     771 : (MACRO)             	st4 RL8,'O',sp,(64)
     570/     784 :                     ;   strcpy(output,dubdabx(wholeNum,output,1));
     571/     784 : (MACRO)             	ld4 Rp1p2,'O',sp,(72);reg:  INDIRI4(addr)
     572/     794 : (MACRO)             	st2 R0,'O',sp,(4); arg+f**
     573/     7A1 : (MACRO)             	ldaD R11,1; reg:acon
     574/     7A7 : (MACRO)             	st2 R11,'O',sp,(6); arg+f**
     575/     7B4 : (MACRO)             	Ccall _dubdabx
     576/     7B7 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     577/     7BB : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     578/     7BF : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     579/     7C3 : (MACRO)             	Ccall _strcpy
     580/     7C6 :                     ;   output+=strlen(output);
     581/     7C6 : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     582/     7CA : (MACRO)             	Ccall _strlen;CALLU2(ar)*
     583/     7CD : (MACRO)             	alu2 R0,R15,R0,add,adc	;ADDP2(reg,reg)
     584/     7D9 :                     ;   if (dec_digits > 0) {
     585/     7D9 : (MACRO)             	jzU2 R1,L61; EQ 0
     586/     7E1 :                     ;		*output++ = '.' ;
     587/     7E1 : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg) ;opt1.1
     588/     7E5 : (MACRO)             	incm R0,1
     589/     7E6 : (MACRO)             	str1I 46,R11; ASGNU1(indaddr,acon)	DH
     590/     7E9 :                     ;		strcpy(output,dubdabx(decimalNum,output,dec_digits));
     591/     7E9 : (MACRO)             	ld4 Rp1p2,'O',sp,(64);reg:  INDIRI4(addr)
     592/     7F9 : (MACRO)             	st2 R0,'O',sp,(4); arg+f**
     593/     806 : (MACRO)             	cpy2 R11,R1 ;LOADI2(reg)
     594/     80A : (MACRO)             	st2 R11,'O',sp,(6); arg+f**
     595/     817 : (MACRO)             	Ccall _dubdabx
     596/     81A : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     597/     81E : (MACRO)             	cpy2 R12,R0 ;LOADP2(reg)
     598/     822 : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     599/     826 : (MACRO)             	Ccall _strcpy
     600/     829 :                     ;	}
     601/     829 :                     L61:
     602/     829 :                     ;   return outbfr;
     603/     829 : (MACRO)             	ld2 R15,'O',sp,(84) ;reg:INDIRP2(addr)
     604/     835 :                     L52:
     605/     835 : (MACRO)             	release 8; release room for outgoing arguments
     606/     83D : (MACRO)             	popr R7
     607/     841 : (MACRO)             	popr R6
     608/     845 : (MACRO)             	popr R1
     609/     849 : (MACRO)             	popr R0
     610/     84D : (MACRO)             	release 62; release room for local variables 
     611/     855 : (MACRO)             	Cretn
     612/     856 :                     
     613/     856 :                     _itoa:		;framesize=16
     614/     856 : (MACRO)             	reserve 2; save room for local variables
     615/     858 : (MACRO)             	pushf R0	;opt11
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 12 - 8/27/2014 11:16:27


     616/     85D : (MACRO)             	pushm R1	;opt11.1
     617/     861 : (MACRO)             	pushm R6	;opt11.1
     618/     865 : (MACRO)             	pushl R7	;opt11.1
     619/     869 : (MACRO)             	reserve 4; save room for outgoing arguments
     620/     86D : (MACRO)             	st2 R12,'O',sp,(16)			
     621/     87A : 1E                  	inc memaddr				;opt16.1
     622/     87B : (MACRO)             	str2 R13,memaddr			
     623/     881 :                     ;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
     624/     881 :                     ;	unsigned int flag=0;
     625/     881 : (MACRO)             	ld2z R0
     626/     885 :                     ;	char * bptr; bptr=buffer;
     627/     885 : (MACRO)             	ld2 R11,'O',sp,(18) ;reg:INDIRP2(addr)
     628/     891 : (MACRO)             	st2 R11,'O',sp,(12); ASGNP2(addr,reg)
     629/     89E :                     ;	if (s<0){
     630/     89E : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRI2(addr)
     631/     8AA : (MACRO)             	jcI2I R11,0,lbdf,L64; GE is flipped test from LT
     632/     8BB :                     ;		*bptr='-';bptr++;
     633/     8BB : (MACRO)             	ld2 R11,'O',sp,(12) ;reg:INDIRP2(addr)
     634/     8C7 : (MACRO)             	str1I 45,R11; ASGNU1(indaddr,acon)	DH
     635/     8CA : (MACRO)             	ld2 R11,'O',sp,(12) ;reg:INDIRP2(addr)
     636/     8D6 : (MACRO)             	incm R11,1
     637/     8D7 : (MACRO)             	st2 R11,'O',sp,(12); ASGNP2(addr,reg)
     638/     8E4 :                     ;		n=-s;
     639/     8E4 : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRI2(addr)
     640/     8F0 : (MACRO)             	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
     641/     8F9 : (MACRO)             	cpy2 R6,R11 ;LOADU2(reg)
     642/     8FD :                     ;	} else{
     643/     8FD : C0 09 10            	lbr L65
     644/     900 :                     L64:
     645/     900 :                     ;		n=s;
     646/     900 : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRI2(addr)
     647/     90C : (MACRO)             	cpy2 R6,R11 ;LOADU2(reg)
     648/     910 :                     ;	}
     649/     910 :                     L65:
     650/     910 :                     ;	k=10000;
     651/     910 : (MACRO)             	ldaD R7,10000; reg:acon
     652/     916 : C0 09 9D            	lbr L67
     653/     919 :                     L66:
     654/     919 :                     ;	while(k>0){
     655/     919 :                     ;		for(r=0;k<=n;r++,n-=k); // was r=n/k
     656/     919 : (MACRO)             	ld2z R1
     657/     91D : C0 09 2D            	lbr L72
     658/     920 :                     L69:
     659/     920 :                     L70:
     660/     920 : (MACRO)             	incm R1,1
     661/     921 : (MACRO)             	alu2 R6,R6,R7,sm,smb
     662/     92D :                     L72:
     663/     92D : (MACRO)             	jcU2 R6,R7,lbdf,L69 ;LE is flipped test & operands
     664/     93A :                     ;		if (flag || r>0||k==1){
     665/     93A : (MACRO)             	jnzU2 R0,L76; NE 0
     666/     942 : (MACRO)             	jnzU2 R1,L76; NE 0
     667/     94A : (MACRO)             	jneU2I R7,1,L73; NE
     668/     956 :                     L76:
     669/     956 :                     ;			*bptr=('0'+r);bptr++;
     670/     956 : (MACRO)             	ld2 R11,'O',sp,(12) ;reg:INDIRP2(addr)
     671/     962 : (MACRO)             	ldA2 R10,'O',R1,(48); reg:addr
     672/     96A : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     673/     96C : (MACRO)             	ld2 R11,'O',sp,(12) ;reg:INDIRP2(addr)
     674/     978 : (MACRO)             	incm R11,1
     675/     979 : (MACRO)             	st2 R11,'O',sp,(12); ASGNP2(addr,reg)
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 13 - 8/27/2014 11:16:27


     676/     986 :                     ;			flag='y';
     677/     986 : (MACRO)             	ldaD R0,121; reg:acon
     678/     98C :                     ;		}
     679/     98C :                     L73:
     680/     98C :                     ;		k=k/10;
     681/     98C : (MACRO)             	cpy2 R12,R7 ;LOADU2(reg)
     682/     990 : (MACRO)             	ldaD R13,10; reg:acon
     683/     996 : (MACRO)             	Ccall _divu2
     684/     999 : (MACRO)             	cpy2 R7,R15 ;LOADU2(reg)
     685/     99D :                     ;	}
     686/     99D :                     L67:
     687/     99D :                     ;	while(k>0){
     688/     99D : (MACRO)             	jnzU2 R7,L66; NE 0
     689/     9A5 :                     ;	*bptr='\0';
     690/     9A5 : (MACRO)             	ld2 R11,'O',sp,(12) ;reg:INDIRP2(addr)
     691/     9B1 : (MACRO)             	str1I 0,R11; ASGNU1(indaddr,acon)	DH
     692/     9B4 :                     ;	return buffer;
     693/     9B4 : (MACRO)             	ld2 R15,'O',sp,(18) ;reg:INDIRP2(addr)
     694/     9C0 :                     L63:
     695/     9C0 : (MACRO)             	release 4; release room for outgoing arguments
     696/     9C4 : (MACRO)             	popr R7
     697/     9C8 : (MACRO)             	popr R6
     698/     9CC : (MACRO)             	popr R1
     699/     9D0 : (MACRO)             	popr R0
     700/     9D4 : (MACRO)             	release 2; release room for local variables 
     701/     9D6 : (MACRO)             	Cretn
     702/     9D7 :                     
     703/     9D7 :                     _ltoa:		;framesize=16
     704/     9D7 : (MACRO)             	pushf R1	;opt11
     705/     9DC : (MACRO)             	pushm R6	;opt11.1
     706/     9E0 : (MACRO)             	pushl R7	;opt11.1
     707/     9E4 : (MACRO)             	reserve 8; save room for outgoing arguments
     708/     9EC : (MACRO)             	cpy4 RL6,RL12; halfbaked
     709/     9F4 :                     ;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
     710/     9F4 :                     ;	char* bptr=buffer;
     711/     9F4 : (MACRO)             	ld2 R1,'O',sp,(20) ;reg:INDIRP2(addr)
     712/     A00 :                     ;	if (s<0){
     713/     A00 : (MACRO)             	ldI4 RL10,0 ;loading a long integer constant
     714/     A0C : (MACRO)             	jcI4 RL6,RL10,lbdf,L78; GE is flipped test from LT
     715/     A28 :                     ;		*bptr++='-';
     716/     A28 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
     717/     A2C : (MACRO)             	incm R1,1
     718/     A2D : (MACRO)             	str1I 45,R11; ASGNU1(indaddr,acon)	DH
     719/     A30 :                     ;		s=-s;
     720/     A30 : (MACRO)             	negI4 RL6,RL6 ;was alu4I RL6,RL6,0,sdi,sdbi
     721/     A50 :                     ;	}
     722/     A50 :                     L78:
     723/     A50 :                     ;	strcpy(bptr,dubdabx(s,bptr,1)); //uses assembler double-dabble routine
     724/     A50 : (MACRO)             	cpy4 Rp1p2,RL6; LOADI4*
     725/     A58 : (MACRO)             	st2 R1,'O',sp,(4); arg+f**
     726/     A65 : (MACRO)             	ldaD R11,1; reg:acon
     727/     A6B : (MACRO)             	st2 R11,'O',sp,(6); arg+f**
     728/     A78 : (MACRO)             	Ccall _dubdabx
     729/     A7B : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     730/     A7F : (MACRO)             	cpy2 R12,R1 ;LOADP2(reg)
     731/     A83 : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     732/     A87 : (MACRO)             	Ccall _strcpy
     733/     A8A :                     ;	return buffer;
     734/     A8A : (MACRO)             	ld2 R15,'O',sp,(20) ;reg:INDIRP2(addr)
     735/     A96 :                     L77:
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 14 - 8/27/2014 11:16:27


     736/     A96 : (MACRO)             	release 8; release room for outgoing arguments
     737/     A9E : (MACRO)             	popr R7
     738/     AA2 : (MACRO)             	popr R6
     739/     AA6 : (MACRO)             	popr R1
     740/     AAA : (MACRO)             	Cretn
     741/     AAB :                     
     742/     AAB :                     _printint:		;framesize=14
     743/     AAB : (MACRO)             	reserve 12
     744/     AB5 : (MACRO)             	st2 R12,'O',sp,(14); flag1 
     745/     AC2 :                     ;void printint(int s){ //print an integer
     746/     AC2 :                     ;	itoa(s,buffer);
     747/     AC2 : (MACRO)             	ld2 R12,'O',sp,(14) ;reg:INDIRI2(addr)
     748/     ACE : (MACRO)             	ldA2 R13,'O',sp,(4); reg:addr
     749/     AD6 : (MACRO)             	Ccall _itoa
     750/     AD9 :                     ;	printstr(buffer);
     751/     AD9 : (MACRO)             	ldA2 R12,'O',sp,(4); reg:addr
     752/     AE1 : (MACRO)             	Ccall _printstr
     753/     AE4 :                     ;}
     754/     AE4 :                     L80:
     755/     AE4 : (MACRO)             	release 12
     756/     AEC : (MACRO)             	Cretn
     757/     AED :                     
     758/     AED :                     _printlint:		;framesize=20
     759/     AED : (MACRO)             	reserve 18
     760/     AF7 : (MACRO)             	st2 R12,'O',sp,(20)			
     761/     B04 : 1E                  	inc memaddr				;opt16.1
     762/     B05 : (MACRO)             	str2 R13,memaddr			
     763/     B0B :                     ;void printlint(long s){ //print a long integer
     764/     B0B :                     ;	printstr(ltoa(s,buffer));
     765/     B0B : (MACRO)             	ld4 Rp1p2,'O',sp,(20);reg:  INDIRI4(addr)
     766/     B1B : (MACRO)             	ldA2 R11,'O',sp,(6); reg:addr
     767/     B23 : (MACRO)             	st2 R11,'O',sp,(4); arg+f**
     768/     B30 : (MACRO)             	Ccall _ltoa
     769/     B33 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     770/     B37 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     771/     B3B : (MACRO)             	Ccall _printstr
     772/     B3E :                     ;}
     773/     B3E :                     L81:
     774/     B3E : (MACRO)             	release 18
     775/     B46 : (MACRO)             	Cretn
     776/     B47 :                     
     777/     B47 :                     _printflt:		;framesize=30
     778/     B47 : (MACRO)             	reserve 28
     779/     B51 : (MACRO)             	st2 R12,'O',sp,(30)			
     780/     B5E : 1E                  	inc memaddr				;opt16.1
     781/     B5F : (MACRO)             	str2 R13,memaddr			
     782/     B65 :                     ;void printflt(float s){ //print a float
     783/     B65 :                     ;	printstr(ftoa(s,buffer,3));
     784/     B65 : (MACRO)             	ld4 Rp1p2,'O',sp,(30);INDIRF4(addr)
     785/     B75 : (MACRO)             	ldA2 R11,'O',sp,(8); reg:addr
     786/     B7D : (MACRO)             	st2 R11,'O',sp,(4); arg+f**
     787/     B8A : (MACRO)             	ldaD R11,3; reg:acon
     788/     B90 : (MACRO)             	st2 R11,'O',sp,(6); arg+f**
     789/     B9D : (MACRO)             	Ccall _ftoa
     790/     BA0 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     791/     BA4 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     792/     BA8 : (MACRO)             	Ccall _printstr
     793/     BAB :                     ;}
     794/     BAB :                     L82:
     795/     BAB : (MACRO)             	release 28
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 15 - 8/27/2014 11:16:27


     796/     BB3 : (MACRO)             	Cretn
     797/     BB4 :                     
     798/     BB4 :                     _putxn:		;framesize=6
     799/     BB4 : (MACRO)             	reserve 4
     800/     BB8 : (MACRO)             	st2 R12,'O',sp,(6); flag1 
     801/     BC5 : (MACRO)             	ldA2 R11,'O',sp,(6); reg:addr
     802/     BCD : (MACRO)             	ld2 R10,'O',sp,(6) ;reg:INDIRI2(addr)
     803/     BD9 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     804/     BDB :                     ;void putxn(unsigned char x){ //print a nibble as ascii hex
     805/     BDB :                     ;	if (x<10){
     806/     BDB : (MACRO)             	ld1 R11,'O',sp,(6)
     807/     BE5 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     808/     BE8 : (MACRO)             	jcI2I R11,10,lbdf,L84; GE is flipped test from LT
     809/     BF9 :                     ;		putc(x+'0');
     810/     BF9 : (MACRO)             	ld1 R11,'O',sp,(6)
     811/     C03 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     812/     C06 : (MACRO)             	ldA2 R11,'O',R11,(48); reg:addr
     813/     C0E : (MACRO)             	cpy1 R12,R11
     814/     C10 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     815/     C13 : (MACRO)             	Ccall _putc
     816/     C16 :                     ;	} else {
     817/     C16 : C0 0C 3E            	lbr L85
     818/     C19 :                     L84:
     819/     C19 :                     ;		putc(x+'A'-10);
     820/     C19 : (MACRO)             	ld1 R11,'O',sp,(6)
     821/     C23 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     822/     C26 : (MACRO)             	ldA2 R11,'O',R11,(65); reg:addr
     823/     C2E : (MACRO)             	alu2I R11,R11,10,smi,smbi
     824/     C36 : (MACRO)             	cpy1 R12,R11
     825/     C38 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     826/     C3B : (MACRO)             	Ccall _putc
     827/     C3E :                     ;	}
     828/     C3E :                     L85:
     829/     C3E :                     ;}
     830/     C3E :                     L83:
     831/     C3E : (MACRO)             	release 4
     832/     C42 : (MACRO)             	Cretn
     833/     C43 :                     
     834/     C43 :                     _putx:		;framesize=6
     835/     C43 : (MACRO)             	reserve 4
     836/     C47 : (MACRO)             	st2 R12,'O',sp,(6); flag1 
     837/     C54 : (MACRO)             	ldA2 R11,'O',sp,(6); reg:addr
     838/     C5C : (MACRO)             	ld2 R10,'O',sp,(6) ;reg:INDIRI2(addr)
     839/     C68 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
     840/     C6A :                     ;void putx(unsigned char x){ //print a unsigned char as ascii hex
     841/     C6A :                     ;	putxn(x>>4);
     842/     C6A : (MACRO)             	ld1 R11,'O',sp,(6)
     843/     C74 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     844/     C77 : (MACRO)             	shrI2I R11,4
     845/     C97 : (MACRO)             	cpy1 R12,R11
     846/     C99 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     847/     C9C : (MACRO)             	Ccall _putxn
     848/     C9F :                     ;	putxn(x & 0x0F);
     849/     C9F : (MACRO)             	ld1 R11,'O',sp,(6)
     850/     CA9 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     851/     CAC : (MACRO)             	alu2I R11,R11,15,ani,ani
     852/     CB4 :                     	;removed ?	cpy2 R11,R11
     853/     CB4 : (MACRO)             	cpy1 R12,R11
     854/     CB6 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     855/     CB9 : (MACRO)             	Ccall _putxn
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 16 - 8/27/2014 11:16:27


     856/     CBC :                     ;}
     857/     CBC :                     L86:
     858/     CBC : (MACRO)             	release 4
     859/     CC0 : (MACRO)             	Cretn
     860/     CC1 :                     
     861/     CC1 :                     _printf:		;framesize=16
     862/     CC1 : (MACRO)             	reserve 2; save room for local variables
     863/     CC3 : (MACRO)             	pushf R0	;opt11
     864/     CC8 : (MACRO)             	pushm R1	;opt11.1
     865/     CCC : (MACRO)             	pushm R6	;opt11.1
     866/     CD0 : (MACRO)             	pushl R7	;opt11.1
     867/     CD4 : (MACRO)             	reserve 4; save room for outgoing arguments
     868/     CD8 : (MACRO)             	st2 R12,'O',sp,(16)			
     869/     CE5 : 1E                  	inc memaddr				;opt16
     870/     CE6 : (MACRO)             	str2 R13,memaddr			
     871/     CEC :                     ;void printf(char *ptr,...){ //limited implementation of printf
     872/     CEC :                     ;	int argslot=0;	//used to align longs
     873/     CEC : (MACRO)             	ld2z R1
     874/     CF0 :                     ;	int * this=(int *)&ptr;
     875/     CF0 : (MACRO)             	ldA2 R6,'O',sp,(16); reg:addr
     876/     CF8 :                     ;	this++; argslot++; //advance argument pointer and slot #
     877/     CF8 : (MACRO)             	incm R6,2
     878/     CFA : (MACRO)             	incm R1,1
     879/     CFB : C0 0F FB            	lbr L89
     880/     CFE :                     L88:
     881/     CFE :                     ;    while(*ptr) {
     882/     CFE :                     ;		c=*ptr++;
     883/     CFE : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
     884/     D0A : (MACRO)             	cpy2 R10,R11
     885/     D0E : (MACRO)             	incm R10,1
     886/     D0F : (MACRO)             	st2 R10,'O',sp,(16); ASGNP2(addr,reg)
     887/     D1C : (MACRO)             	ldn1 R7,R11;reg:  INDIRU1(indaddr)
     888/     D1E :                     ;		if (c!='%'){
     889/     D1E : (MACRO)             	cpy1 R11,R7
     890/     D20 : (MACRO)             	zExt R11 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     891/     D23 : (MACRO)             	jeqU2I R11,37,L91;EQI2(reg,con)
     892/     D2F :                     ;			putc(c);
     893/     D2F : (MACRO)             	cpy1 R12,R7
     894/     D31 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     895/     D34 : (MACRO)             	Ccall _putc
     896/     D37 :                     ;		} else{
     897/     D37 : C0 0F FB            	lbr L92
     898/     D3A :                     L91:
     899/     D3A :                     ;			c=*ptr++;
     900/     D3A : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
     901/     D46 : (MACRO)             	cpy2 R10,R11
     902/     D4A : (MACRO)             	incm R10,1
     903/     D4B : (MACRO)             	st2 R10,'O',sp,(16); ASGNP2(addr,reg)
     904/     D58 : (MACRO)             	ldn1 R7,R11;reg:  INDIRU1(indaddr)
     905/     D5A :                     ;			switch (c){
     906/     D5A : (MACRO)             	cpy1 R0,R7
     907/     D5C : (MACRO)             	zExt R0 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     908/     D5F : (MACRO)             	jcI2I R0,99,lbnf,L114  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     909/     D70 : (MACRO)             	jnI2I R0,108,lbnf,L115; GT reverse  the subtraction
     910/     D81 : (MACRO)             	shlR2R	R11,R0	;opt6
     911/     D87 : (MACRO)             	ld2 R11,'O',R11,(L116-198) ;reg:INDIRP2(addr)
     912/     D93 : (MACRO)             	jumpv R11; JUMPV(reg)
     913/     D9D :                     L116:
     914/     D9D : 0E 25               	dw L98
     915/     D9F : 0D FB               	dw L96
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 17 - 8/27/2014 11:16:27


     916/     DA1 : 0F EA               	dw L93
     917/     DA3 : 0F A2               	dw L109
     918/     DA5 : 0F EA               	dw L93
     919/     DA7 : 0F EA               	dw L93
     920/     DA9 : 0D FB               	dw L96
     921/     DAB : 0F EA               	dw L93
     922/     DAD : 0F EA               	dw L93
     923/     DAF : 0E BF               	dw L102
     924/     DB1 :                     L114:
     925/     DB1 : (MACRO)             	jeqU2I R0,88,L101;EQI2(reg,con)
     926/     DBD : C0 0F EA            	lbr L93
     927/     DC0 :                     L115:
     928/     DC0 : (MACRO)             	ldaD R11,115; reg:acon
     929/     DC6 : (MACRO)             	jeqI2 R0,R11,L97; EQI2(reg,reg)
     930/     DD8 : (MACRO)             	jcI2 R0,R11,lbnf,L93; LT=lbnf i.e. subtract B from A and jump if borrow 
     931/     DEC :                     L118:
     932/     DEC : (MACRO)             	jeqU2I R0,120,L101;EQI2(reg,con)
     933/     DF8 : C0 0F EA            	lbr L93
     934/     DFB :                     L96:
     935/     DFB :                     ;					printint(*this++);
     936/     DFB : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
     937/     DFF : (MACRO)             	incm R6,2
     938/     E01 : (MACRO)             	ldn2 R12,R11	;opt9x
     939/     E06 : (MACRO)             	Ccall _printint
     940/     E09 :                     ;					argslot+=1; //next argument slot
     941/     E09 : (MACRO)             	incm R1,1
     942/     E0A :                     ;					break;
     943/     E0A : C0 0F FB            	lbr L94
     944/     E0D :                     L97:
     945/     E0D :                     ;					printstr((char*) *this++);
     946/     E0D : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
     947/     E11 : (MACRO)             	incm R6,2
     948/     E13 : (MACRO)             	ldn2s R11,R11	;opt9xs
     949/     E1A : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     950/     E1E : (MACRO)             	Ccall _printstr
     951/     E21 :                     ;					argslot+=1; //next argument slot
     952/     E21 : (MACRO)             	incm R1,1
     953/     E22 :                     ;					break;
     954/     E22 : C0 0F FB            	lbr L94
     955/     E25 :                     L98:
     956/     E25 :                     ;					if (*ptr=='x'){ //if there's an x
     957/     E25 : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
     958/     E31 : (MACRO)             	ldn1 R11,R11;reg:  INDIRU1(indaddr)
     959/     E33 : (MACRO)             	jneU1I R11,120,L99	; DH 4
     960/     E39 :                     ;						ptr++; //skip over the x
     961/     E39 : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
     962/     E45 : (MACRO)             	incm R11,1
     963/     E46 : (MACRO)             	st2 R11,'O',sp,(16); ASGNP2(addr,reg)
     964/     E53 :                     ;						putx(((unsigned int) *this++)&255); //print 1 byte as hex
     965/     E53 : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
     966/     E57 : (MACRO)             	incm R6,2
     967/     E59 : (MACRO)             	ldn2s R11,R11	;opt9xs
     968/     E60 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     969/     E68 : (MACRO)             	cpy1 R12,R11
     970/     E6A : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     971/     E6D : (MACRO)             	Ccall _putx
     972/     E70 :                     ;					} else{
     973/     E70 : C0 0E 88            	lbr L100
     974/     E73 :                     L99:
     975/     E73 :                     ;						putc((unsigned int) *this++);		//print as char
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 18 - 8/27/2014 11:16:27


     976/     E73 : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
     977/     E77 : (MACRO)             	incm R6,2
     978/     E79 : (MACRO)             	ldn2s R11,R11	;opt9xs
     979/     E80 : (MACRO)             	cpy1 R12,R11
     980/     E82 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     981/     E85 : (MACRO)             	Ccall _putc
     982/     E88 :                     ;					}
     983/     E88 :                     L100:
     984/     E88 :                     ;					argslot+=1; //next argument slot
     985/     E88 : (MACRO)             	incm R1,1
     986/     E89 :                     ;					break;
     987/     E89 : C0 0F FB            	lbr L94
     988/     E8C :                     L101:
     989/     E8C :                     ;					putx(((unsigned int) *this)>>8);
     990/     E8C : (MACRO)             	ldn2 R11,R6	;opt9x
     991/     E91 : 9B                  	ghi	R11	;opt2
     992/     E92 : AB                  	plo	R11
     993/     E93 : F8 00               	ldi	0
     994/     E95 : BB                  	phi	R11	
     995/     E96 : (MACRO)             	cpy1 R12,R11
     996/     E98 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
     997/     E9B : (MACRO)             	Ccall _putx
     998/     E9E :                     ;					putx(((unsigned int) *this++)&255);
     999/     E9E : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
    1000/     EA2 : (MACRO)             	incm R6,2
    1001/     EA4 : (MACRO)             	ldn2s R11,R11	;opt9xs
    1002/     EAB : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
    1003/     EB3 : (MACRO)             	cpy1 R12,R11
    1004/     EB5 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1005/     EB8 : (MACRO)             	Ccall _putx
    1006/     EBB :                     ;					argslot+=1; //next argument slot
    1007/     EBB : (MACRO)             	incm R1,1
    1008/     EBC :                     ;					break;
    1009/     EBC : C0 0F FB            	lbr L94
    1010/     EBF :                     L102:
    1011/     EBF :                     ;					if (*ptr){ //as long as there's something there
    1012/     EBF : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
    1013/     ECB : (MACRO)             	ldn1 R11,R11	;opt14*
    1014/     ECD : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
    1015/     ED0 : (MACRO)             	jzU2 R11,L103; EQ 0
    1016/     ED8 :                     ;						xord=*ptr++;
    1017/     ED8 : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
    1018/     EE4 : (MACRO)             	cpy2 R10,R11
    1019/     EE8 : (MACRO)             	incm R10,1
    1020/     EE9 : (MACRO)             	st2 R10,'O',sp,(16); ASGNP2(addr,reg)
    1021/     EF6 : (MACRO)             	ldA2 R10,'O',sp,(13); reg:addr
    1022/     EFE : (MACRO)             	ldn1 R11,R11;reg:  INDIRU1(indaddr)
    1023/     F00 : (MACRO)             	str1 R11,R10; ASGNU1(indaddr,reg)		DH
    1024/     F02 :                     ;						if (argslot&1) {
    1025/     F02 : (MACRO)             	alu2I R11,R1,1,ani,ani
    1026/     F0A :                     	;removed ?	cpy2 R11,R1
    1027/     F0A : (MACRO)             	jzU2 R11,L105; EQ 0
    1028/     F12 :                     ;							this++;
    1029/     F12 : (MACRO)             	incm R6,2
    1030/     F14 :                     ;							argslot++;
    1031/     F14 : (MACRO)             	incm R1,1
    1032/     F15 :                     ;						}
    1033/     F15 :                     L105:
    1034/     F15 :                     ;						if(xord=='d'){
    1035/     F15 : (MACRO)             	ld1 R11,'O',sp,(13)
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 19 - 8/27/2014 11:16:27


    1036/     F1F : (MACRO)             	jneU1I R11,100,L107	; DH 4
    1037/     F25 :                     ;							printlint(*(long *)this);//treats "this" as a pointer to long
    1038/     F25 : (MACRO)             	ld4 Rp1p2,'O',R6,0;reg:  INDIRI4(addr)
    1039/     F35 : (MACRO)             	Ccall _printlint
    1040/     F38 :                     ;							this+=2;				// and advances it 4 bytes
    1041/     F38 : (MACRO)             	incm R6,4
    1042/     F3C :                     ;						} else{
    1043/     F3C : C0 0F 9D            	lbr L108
    1044/     F3F :                     L107:
    1045/     F3F :                     ;							putx(((unsigned int) *this)>>8);
    1046/     F3F : (MACRO)             	ldn2 R11,R6	;opt9x
    1047/     F44 : 9B                  	ghi	R11	;opt2
    1048/     F45 : AB                  	plo	R11
    1049/     F46 : F8 00               	ldi	0
    1050/     F48 : BB                  	phi	R11	
    1051/     F49 : (MACRO)             	cpy1 R12,R11
    1052/     F4B : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1053/     F4E : (MACRO)             	Ccall _putx
    1054/     F51 :                     ;							putx(((unsigned int) *this++)&255);
    1055/     F51 : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
    1056/     F55 : (MACRO)             	incm R6,2
    1057/     F57 : (MACRO)             	ldn2s R11,R11	;opt9xs
    1058/     F5E : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
    1059/     F66 : (MACRO)             	cpy1 R12,R11
    1060/     F68 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1061/     F6B : (MACRO)             	Ccall _putx
    1062/     F6E :                     ;							putx(((unsigned int) *this)>>8);
    1063/     F6E : (MACRO)             	ldn2 R11,R6	;opt9x
    1064/     F73 : 9B                  	ghi	R11	;opt2
    1065/     F74 : AB                  	plo	R11
    1066/     F75 : F8 00               	ldi	0
    1067/     F77 : BB                  	phi	R11	
    1068/     F78 : (MACRO)             	cpy1 R12,R11
    1069/     F7A : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1070/     F7D : (MACRO)             	Ccall _putx
    1071/     F80 :                     ;							putx(((unsigned int) *this++)&255);
    1072/     F80 : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
    1073/     F84 : (MACRO)             	incm R6,2
    1074/     F86 : (MACRO)             	ldn2s R11,R11	;opt9xs
    1075/     F8D : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
    1076/     F95 : (MACRO)             	cpy1 R12,R11
    1077/     F97 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1078/     F9A : (MACRO)             	Ccall _putx
    1079/     F9D :                     ;						}
    1080/     F9D :                     L108:
    1081/     F9D :                     ;						argslot+=2;
    1082/     F9D : (MACRO)             	incm R1,2
    1083/     F9F :                     ;						break;
    1084/     F9F : C0 0F FB            	lbr L94
    1085/     FA2 :                     L103:
    1086/     FA2 :                     L109:
    1087/     FA2 :                     ;					if (*ptr){ //as long as there's something there
    1088/     FA2 : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
    1089/     FAE : (MACRO)             	ldn1 R11,R11	;opt14*
    1090/     FB0 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
    1091/     FB3 : (MACRO)             	jzU2 R11,L110; EQ 0
    1092/     FBB :                     ;						if (argslot&1) { //adjust alignment
    1093/     FBB : (MACRO)             	alu2I R11,R1,1,ani,ani
    1094/     FC3 :                     	;removed ?	cpy2 R11,R1
    1095/     FC3 : (MACRO)             	jzU2 R11,L112; EQ 0
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 20 - 8/27/2014 11:16:27


    1096/     FCB :                     ;							this++;
    1097/     FCB : (MACRO)             	incm R6,2
    1098/     FCD :                     ;							argslot++;
    1099/     FCD : (MACRO)             	incm R1,1
    1100/     FCE :                     ;						}
    1101/     FCE :                     L112:
    1102/     FCE :                     ;						printflt(*(float *)this);//treats "this" as a pointer to float
    1103/     FCE : (MACRO)             	ld4 Rp1p2,'O',R6,0;INDIRF4(addr)
    1104/     FDE : (MACRO)             	Ccall _printflt
    1105/     FE1 :                     ;						this+=2;				// and advances it 4 bytes
    1106/     FE1 : (MACRO)             	incm R6,4
    1107/     FE5 :                     ;						argslot+=2;
    1108/     FE5 : (MACRO)             	incm R1,2
    1109/     FE7 :                     ;						break;
    1110/     FE7 : C0 0F FB            	lbr L94
    1111/     FEA :                     L110:
    1112/     FEA :                     L93:
    1113/     FEA :                     ;					putc('%');putc(c);
    1114/     FEA : (MACRO)             	ldaD R12,37; reg:acon
    1115/     FF0 : (MACRO)             	Ccall _putc
    1116/     FF3 : (MACRO)             	cpy1 R12,R7
    1117/     FF5 : (MACRO)             	zExt R12 ;CVUI2(reg)*: widen unsigned char to signed int (zero extend)*
    1118/     FF8 : (MACRO)             	Ccall _putc
    1119/     FFB :                     ;			} //switch
    1120/     FFB :                     L94:
    1121/     FFB :                     ;		} //%
    1122/     FFB :                     L92:
    1123/     FFB :                     ;	} //while
    1124/     FFB :                     L89:
    1125/     FFB :                     ;    while(*ptr) {
    1126/     FFB : (MACRO)             	ld2 R11,'O',sp,(16) ;reg:INDIRP2(addr)
    1127/    1007 : (MACRO)             	ldn1 R11,R11;reg:  INDIRU1(indaddr)
    1128/    1009 : (MACRO)             	jnzU1 R11,L88; NEI2(CVUI2(reg),con0)
    1129/    100D :                     ;} //prtf
    1130/    100D :                     L87:
    1131/    100D : (MACRO)             	release 4; release room for outgoing arguments
    1132/    1011 : (MACRO)             	popr R7
    1133/    1015 : (MACRO)             	popr R6
    1134/    1019 : (MACRO)             	popr R1
    1135/    101D : (MACRO)             	popr R0
    1136/    1021 : (MACRO)             	release 2; release room for local variables 
    1137/    1023 : (MACRO)             	Cretn
    1138/    1024 :                     
    1139/    1024 :                     _exit:		;framesize=6
    1140/    1024 : (MACRO)             	reserve 4
    1141/    1028 : (MACRO)             	st2 R12,'O',sp,(6); flag1 
    1142/    1035 :                     ;void exit(int code){
    1143/    1035 :                     ;	printf("exit %d\n",code);
    1144/    1035 : (MACRO)             	ldaD R12,L120; reg:acon
    1145/    103B : (MACRO)             	ld2 R13,'O',sp,(6) ;reg:INDIRI2(addr)
    1146/    1047 : (MACRO)             	Ccall _printf
    1147/    104A :                     L121:
    1148/    104A :                     ;	while(1);
    1149/    104A :                     L122:
    1150/    104A : C0 10 4A            	lbr L121
    1151/    104D :                     ;}
    1152/    104D :                     L119:
    1153/    104D : (MACRO)             	release 4
    1154/    1051 : (MACRO)             	Cretn
    1155/    1052 :                     
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 21 - 8/27/2014 11:16:27


    1156/    1052 :                     _memcmp:		;framesize=10
    1157/    1052 : (MACRO)             	pushf R0	;opt11
    1158/    1057 : (MACRO)             	pushm R1	;opt11.1
    1159/    105B : (MACRO)             	pushm R6	;opt11.1
    1160/    105F : (MACRO)             	pushl R7	;opt11.1
    1161/    1063 : (MACRO)             	ld2 R7,'O',sp,(14) ;reg:INDIRU2(addr)
    1162/    106F :                     ;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
    1163/    106F :                     ;    int v = 0;
    1164/    106F : (MACRO)             	ld2z R6
    1165/    1073 :                     ;    p1 = (unsigned char *)Ptr1;
    1166/    1073 : (MACRO)             	cpy2 R1,R12 ;LOADP2(reg)
    1167/    1077 :                     ;    p2 = (unsigned char *)Ptr2;
    1168/    1077 : (MACRO)             	cpy2 R0,R13 ;LOADP2(reg)
    1169/    107B : C0 10 9E            	lbr L126
    1170/    107E :                     L125:
    1171/    107E :                     ;    while(Count-- > 0 && v == 0) {
    1172/    107E :                     ;        v = *(p1++) - *(p2++);
    1173/    107E : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg) ;opt1.1
    1174/    1082 : (MACRO)             	incm R1,1
    1175/    1083 : (MACRO)             	cpy2 R10,R0 ;LOADP2(reg) ;opt1.1
    1176/    1087 : (MACRO)             	incm R0,1
    1177/    1088 : (MACRO)             	ldn1 R11,R11	;opt14*
    1178/    108A : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
    1179/    108D : (MACRO)             	ldn1 R10,R10	;opt14*
    1180/    108F : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
    1181/    1092 : (MACRO)             	alu2 R6,R11,R10,sm,smb
    1182/    109E :                     ;    }
    1183/    109E :                     L126:
    1184/    109E :                     ;    while(Count-- > 0 && v == 0) {
    1185/    109E : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg) ;opt1.1
    1186/    10A2 : (MACRO)             	decm R7,1
    1187/    10A3 : (MACRO)             	jzU2 R11,L128; EQ 0
    1188/    10AB : (MACRO)             	jzU2 R6,L125; EQ 0
    1189/    10B3 :                     L128:
    1190/    10B3 :                     ;    return v;
    1191/    10B3 : (MACRO)             	cpy2 R15,R6 ;LOADI2(reg)
    1192/    10B7 :                     L124:
    1193/    10B7 : (MACRO)             	popr R7
    1194/    10BB : (MACRO)             	popr R6
    1195/    10BF : (MACRO)             	popr R1
    1196/    10C3 : (MACRO)             	popr R0
    1197/    10C7 : (MACRO)             	Cretn
    1198/    10C8 :                     
    1199/    10C8 :                     _memcpy:		;framesize=8
    1200/    10C8 : (MACRO)             	pushf R1	;opt11
    1201/    10CD : (MACRO)             	pushm R6	;opt11.1
    1202/    10D1 : (MACRO)             	pushl R7	;opt11.1
    1203/    10D5 : (MACRO)             	ld2 R7,'O',sp,(12) ;reg:INDIRU2(addr)
    1204/    10E1 :                     ;void* memcpy(void* dest, const void* src, unsigned int count) {
    1205/    10E1 :                     ;        char* dst8 = (char*)dest;
    1206/    10E1 : (MACRO)             	cpy2 R6,R12 ;LOADP2(reg)
    1207/    10E5 :                     ;        char* src8 = (char*)src;
    1208/    10E5 : (MACRO)             	cpy2 R1,R13 ;LOADP2(reg)
    1209/    10E9 : C0 10 FA            	lbr L131
    1210/    10EC :                     L130:
    1211/    10EC :                     ;        while (count--) {
    1212/    10EC :                     ;            *dst8++ = *src8++;
    1213/    10EC : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
    1214/    10F0 : (MACRO)             	incm R6,1
    1215/    10F1 : (MACRO)             	cpy2 R10,R1 ;LOADP2(reg) ;opt1.1
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 22 - 8/27/2014 11:16:27


    1216/    10F5 : (MACRO)             	incm R1,1
    1217/    10F6 : (MACRO)             	ldn1 R10,R10;reg:  INDIRU1(indaddr)
    1218/    10F8 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
    1219/    10FA :                     ;        }
    1220/    10FA :                     L131:
    1221/    10FA :                     ;        while (count--) {
    1222/    10FA : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg) ;opt1.1
    1223/    10FE : (MACRO)             	decm R7,1
    1224/    10FF : (MACRO)             	jnzU2 R11,L130; NE 0
    1225/    1107 :                     ;        return dest;
    1226/    1107 : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
    1227/    110B :                     L129:
    1228/    110B : (MACRO)             	popr R7
    1229/    110F : (MACRO)             	popr R6
    1230/    1113 : (MACRO)             	popr R1
    1231/    1117 : (MACRO)             	Cretn
    1232/    1118 :                     
    1233/    1118 :                     _memset:		;framesize=6
    1234/    1118 : (MACRO)             	pushf R6	;opt11
    1235/    111D : (MACRO)             	pushl R7	;opt11
    1236/    1121 : (MACRO)             	ld2 R7,'O',sp,(10) ;reg:INDIRU2(addr)
    1237/    112D :                     ;{
    1238/    112D :                     ;    unsigned char* p=s;
    1239/    112D : (MACRO)             	cpy2 R6,R12 ;LOADP2(reg)
    1240/    1131 : C0 11 3F            	lbr L135
    1241/    1134 :                     L134:
    1242/    1134 :                     ;        *p++ = (unsigned char)c;
    1243/    1134 : (MACRO)             	cpy2 R11,R6 ;LOADP2(reg) ;opt1.1
    1244/    1138 : (MACRO)             	incm R6,1
    1245/    1139 : (MACRO)             	cpy2 R10,R13 ;LOADU2(reg)
    1246/    113D : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)		DH
    1247/    113F :                     L135:
    1248/    113F :                     ;    while(n--)
    1249/    113F : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg) ;opt1.1
    1250/    1143 : (MACRO)             	decm R7,1
    1251/    1144 : (MACRO)             	jnzU2 R11,L134; NE 0
    1252/    114C :                     ;    return s;
    1253/    114C : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
    1254/    1150 :                     L133:
    1255/    1150 : (MACRO)             	popr R7
    1256/    1154 : (MACRO)             	popr R6
    1257/    1158 : (MACRO)             	Cretn
    1258/    1159 :                     
    1259/    1159 :                     _nstdlibincluder:		;framesize=2
    1260/    1159 :                     ;void nstdlibincluder(){
    1261/    1159 :                     ;	asm("\tinclude nstdlib.inc\n"); //strcpy, strcmp
    1262/    1159 :                     	include nstdlib.inc
(1)    1/    1159 :                     ;nstdlib.inc includes assembly versions of nstdlib routines strcpy, strcmp
(1)    2/    1159 :                     ;Oct 1 first test seems ok
(1)    3/    1159 :                     ;char * strcpy(char * to, const char *from)
(1)    4/    1159 :                     	align 64
(1)    5/    1180 :                     _strcpy:
(1)    6/    1180 :                     ;char *save = to; (to is R12, from is R13)
(1)    7/    1180 : 8C                  	glo R12	
(1)    8/    1181 : AF                  	plo R15
(1)    9/    1182 : 9C                  	ghi R12
(1)   10/    1183 : BF                  	phi R15
(1)   11/    1184 :                     ;for (; (*to = *from) != 0; ++from, ++to);
(1)   12/    1184 : 4D                  __strcpy: lda R13
(1)   13/    1185 : 5C                  	str R12
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(nstdlib.inc) - page 23 - 8/27/2014 11:16:27


(1)   14/    1186 : 1C                  	inc R12
(1)   15/    1187 : 3A 84               	bnz __strcpy
(1)   16/    1189 :                     ;return(save);
(1)   17/    1189 : (MACRO)             	cretn
(1)   18/    118A :                     ;}
(1)   19/    118A :                     
(1)   20/    118A :                     
(1)   21/    118A :                     ;int strcmp(const char *s1, const char *s2){  s1 will be R12, s2 R13
(1)   22/    118A :                     _strcmp:	;entry point from C program
(1)   23/    118A :                     ;  int ret = 0;
(1)   24/    118A : (MACRO)             	ld2z	R15	;ret is R15
(1)   25/    118E :                     ;  while (!(ret = *(unsigned char *) s1 - *(unsigned char *) s2) && *s2) ++s1, ++s2;
(1)   26/    118E : 22                  	dec	sp	;make a work area
(1)   27/    118F :                     __strcmplp:
(1)   28/    118F : 4D                  	lda	R13	;get string 2 character
(1)   29/    1190 : 52                  	str	sp	;prep for compare
(1)   30/    1191 : 4C                  	lda	R12	;get string 1 character
(1)   31/    1192 : F7                  	sm		;subtract string 2 char from string 1
(1)   32/    1193 : 3A 9A               	bnz	__strcmpne ;strings not equal quit
(1)   33/    1195 :                     	
(1)   34/    1195 : 02                  	ldn	sp	;check string 2 character
(1)   35/    1196 : 3A 8F               	bnz	__strcmplp ;back for more if not done
(1)   36/    1198 : 12                  	inc	sp	;release the work area
(1)   37/    1199 : (MACRO)             	cretn		;back to caler with 0 in R15
(1)   38/    119A :                     	
(1)   39/    119A :                     __strcmpne:	;here I know they're not equal
(1)   40/    119A : 12                  	inc	sp		;release the work area
(1)   41/    119B : 33 9F               	bdf	__strcmpgt	;string1>string2
(1)   42/    119D : 2F                  	dec	R15		;string 1<string 2, return -1
(1)   43/    119E : (MACRO)             	cretn
(1)   44/    119F :                     __strcmpgt:
(1)   45/    119F : 1F                  	inc	R15		;string1>string2, return 1
(1)   46/    11A0 : (MACRO)             	cretn
(1)   47/    11A1 :                     
    1263/    11A1 :                     ;}
    1264/    11A1 :                     L137:
    1265/    11A1 : (MACRO)             	Cretn
    1266/    11A2 :                     
    1267/    11A2 :                     L120:
    1268/    11A2 : 65                  	db 101
    1269/    11A3 : 78                  	db 120
    1270/    11A4 : 69                  	db 105
    1271/    11A5 : 74                  	db 116
    1272/    11A6 : 20                  	db 32
    1273/    11A7 : 25                  	db 37
    1274/    11A8 : 64                  	db 100
    1275/    11A9 : 0A                  	db 10
    1276/    11AA : 00                  	db 0
    1277/    11AB :                     	align 4
    1278/    11AC :                     L56:
    1279/    11AC : BF 80 00 00         	dd 0xbf800000
    1280/    11B0 :                     	align 4
    1281/    11B0 :                     L55:
    1282/    11B0 : 00 00 00 00         	dd 0x0
    1283/    11B4 :                     	include lcc1802EpiloDH.inc
(1)    1/    11B4 :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/    11B4 :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/    11B4 :                     ;this is the version published with the lcc1802121229 release
(1)    4/    11B4 :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/    11B4 :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(lcc1802EpiloDH.inc) - page 24 - 8/27/2014 11:16:27


(1)    6/    11B4 :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/    11B4 :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/    11B4 :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/    11B4 :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/    11B4 :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/    11B4 :                     ;feb 27 changed stack to start at 7fff
(1)   12/    11B4 :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/    11B4 :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/    11B4 :                     ;april 4 adding digit count argument to dubdabx
(1)   15/    11B4 :                     ;Oct 2, 2013 redoing mulu2 for faster results with small arg1 - dhrystone
(1)   16/    11B4 :                     ;oct 12 divu2 redone for faster perf on small numbers, remainder now in regarg1 - modu2/modi2 changed to match
(1)   17/    11B4 : =EH                 rwork	equ	memAddr	;work register
(1)   18/    11B4 :                     lcc1802init:	
(1)   19/    11B4 : (MACRO)             	ldiReg	RCALL,_call
(1)   20/    11BA : (MACRO)             	ldiReg	RRET,_return
(1)   21/    11C0 : (MACRO)             	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1
(1)   22/    11C6 : E2                  	sex	SP
(1)   23/    11C7 : (MACRO)             	ldiReg	RPC,$$_00000
(1)   24/    11CD : D3                  	sep	RPC
(1)   25/    11CE :                     $$_00000:
(1)   26/    11CE : (MACRO)             	Ccall _main	;call the main routine
(1)   27/    11D1 : C0 11 D1            $$_die:	lbr	$$_die		;loop here when main returns
(1)   28/    11D4 : DE AD               	db	0xde,0xad
(1)   29/    11D6 :                     
(1)   30/    11D6 :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   31/    11D6 :                     _setqOn:
(1)   32/    11D6 : 7B                  	seq
(1)   33/    11D7 : (MACRO)             	Cretn
(1)   34/    11D8 :                     _setqOff:
(1)   35/    11D8 : 7A                  	req
(1)   36/    11D9 : (MACRO)             	Cretn
(1)   37/    11DA :                     
(1)   38/    11DA :                     _modU2:	;16 bit unsigned remainder
(1)   39/    11DA :                     	; just calls the 16 bit division then puts remainder into return value
(1)   40/    11DA : (MACRO)                 Ccall _divU2
(1)   41/    11DD : 8C                      glo regArg1
(1)   42/    11DE : AF                      plo retVal
(1)   43/    11DF : 9C                      ghi regArg1
(1)   44/    11E0 : BF                      phi retVal
(1)   45/    11E1 : (MACRO)                 Cretn
(1)   46/    11E2 :                         
(1)   47/    11E2 :                     _modI2:	;16 bit signed remainder
(1)   48/    11E2 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   49/    11E2 : (MACRO)                 Ccall _divI2
(1)   50/    11E5 : 8C                      glo regArg1
(1)   51/    11E6 : AF                      plo retVal
(1)   52/    11E7 : 9C                      ghi regArg1
(1)   53/    11E8 : BF                      phi retVal
(1)   54/    11E9 : (MACRO)                 Cretn
(1)   55/    11EA :                     
(1)   56/    11EA :                     _out4:	
(1)   57/    11EA : 8C                  	glo	regArg1
(1)   58/    11EB : 22                  	dec	sp
(1)   59/    11EC : 52                  	str	sp
(1)   60/    11ED : 64                  	out	4
(1)   61/    11EE : (MACRO)             	Cretn
(1)   62/    11EF :                     
(1)   63/    11EF :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   64/    11EF :                     	align 256
(1)   65/    1200 :                     ;non-standard Call routine invoked as D4xxxx - using z80 stack convention
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(lcc1802EpiloDH.inc) - page 25 - 8/27/2014 11:16:27


(1)   66/    1200 :                     ;requires programs to save the return address if they destroy it (by using call for example)
(1)   67/    1200 :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)   68/    1200 : D3                  	sep     R3 ;go to subroutine
(1)   69/    1201 : E2                  _call	sex	SP ;make sure X=SP
(1)   70/    1202 : 86                  	glo	retAddr ;save previous return pointer on stack
(1)   71/    1203 : 22                  	dec	sp
(1)   72/    1204 : 73                  	stxd
(1)   73/    1205 : 96                  	ghi	retAddr
(1)   74/    1206 : 52                  	str	sp	
(1)   75/    1207 : 83                  	glo	RPC ;copy old PC to retAddr
(1)   76/    1208 : A6                  	plo	retAddr
(1)   77/    1209 : 93                  	ghi	RPC
(1)   78/    120A : B6                  	phi	retAddr
(1)   79/    120B : 46                  	lda	retAddr ;pick up subroutine address into RPC
(1)   80/    120C : B3                  	phi	RPC
(1)   81/    120D : 46                  	lda	retAddr
(1)   82/    120E : A3                  	plo	RPC
(1)   83/    120F : 30 00               	br	_call-1
(1)   84/    1211 :                     
(1)   85/    1211 :                     ;Standard subroutine return 
(1)   86/    1211 : D3                  	sep	RPC	;return to the original program
(1)   87/    1212 : 86                  _return	glo	retAddr	;transfer the current return address to RPC
(1)   88/    1213 : A3                  	plo	RPC
(1)   89/    1214 : 96                  	ghi	retAddr
(1)   90/    1215 : B3                  	phi	RPC
(1)   91/    1216 : 42                  	lda	SP	;pick up old return address
(1)   92/    1217 : B6                  	phi	retAddr
(1)   93/    1218 : 42                  	lda	SP
(1)   94/    1219 : A6                  	plo	retAddr
(1)   95/    121A : 30 11               	br	_return-1
(1)   96/    121C :                     
(1)   97/    121C :                     _oneMs:		;execute 100 instructions including call(15)/return(10) sequence. takes about 1 ms
(1)   98/    121C : F8 24               	ldi	(100-15-10-2)/2
(1)   99/    121E : FF 01               $$mslp:	smi	1
(1)  100/    1220 : 3A 1E               	bnz	$$mslp
(1)  101/    1222 : (MACRO)             	Cretn
(1)  102/    1223 :                     
(1)  103/    1223 :                     
(1)  104/    1223 :                     	
(1)  105/    1223 :                     ;16 bit right shifting multiply which is faster for smaller operands
(1)  106/    1223 :                     ; credit to http://map.grauw.nl/articles/mult_div_shifts.php#lrmultr
(1)  107/    1223 :                     _mulU2:		;retval(product)=regarg1(multiplicand)*regarg2(multiplier)
(1)  108/    1223 : (MACRO)             	ld2z retval
(1)  109/    1227 :                     $$mulrlp:
(1)  110/    1227 : (MACRO)             	shru2 regarg2
(1)  111/    122D : 3B 3B               	bnf $$mulrnoadd
(1)  112/    122F :                     ;	bottom bit of multiplier is one so add multiplicand to product
(1)  113/    122F : (MACRO)             	alu2 retval,retval,regarg1,add,adc
(1)  114/    123B :                     $$mulrnoadd:
(1)  115/    123B : 9D                  	ghi regarg2	;check for all bits of multiplier shifted out
(1)  116/    123C : 3A 41               	bnz $$mulrshft	;nope, continue
(1)  117/    123E : 8D                  	glo regarg2	;check bottom byte
(1)  118/    123F : 32 49               	bz $$mulrdone
(1)  119/    1241 :                     $$mulrshft:
(1)  120/    1241 : (MACRO)             	shl2 regarg1	;shift multiplicand left 1
(1)  121/    1247 : 30 27               	br $$mulrlp
(1)  122/    1249 :                     $$mulrdone:		;here the product is in retval
(1)  123/    1249 : (MACRO)             	cretn
(1)  124/    124A :                     
(1)  125/    124A :                     ;this is a divisor shifting algorithm which is faster for smaller operands
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(lcc1802EpiloDH.inc) - page 26 - 8/27/2014 11:16:27


(1)  126/    124A :                     ;credit to http://research.microsoft.com/pubs/70645/tr-2008-141.pdf
(1)  127/    124A :                     ;changed oct 12 to save R10 & 1/2 R11 on stack
(1)  128/    124A :                     _divu2: ;retval=regarg1(x or dividend)/regarg2(y or divisor)
(1)  129/    124A :                     	;uses R14(rwork) to hold original divisor y0, 
(1)  130/    124A :                     	;regarg1 to hold develop remainder, 
(1)  131/    124A :                     	;R10 to hold working dividend R11.0 as a temp
(1)  132/    124A :                     testsub: macro reg1,reg2	;test subtraction of reg2 from reg1
(1)  133/    124A :                     				;result in D, rwork.hi, DF
(1)  134/    124A :                     	glo reg2
(1)  135/    124A :                     	str sp
(1)  136/    124A :                     	glo reg1
(1)  137/    124A :                     	sm
(1)  138/    124A :                     	plo R11
(1)  139/    124A :                     	ghi reg2
(1)  140/    124A :                     	str sp
(1)  141/    124A :                     	ghi reg1
(1)  142/    124A :                     	smb
(1)  143/    124A :                     	endm
(1)  144/    124A :                     	
(1)  145/    124A : (MACRO)             	pushf R10	;save R10 & leave stack down 1
(1)  146/    124F : 8B                  	glo R11		;and bottom
(1)  147/    1250 : 73                  	stxd		;of R11 - leaves stack clear of work area
(1)  148/    1251 : (MACRO)             	cpy2 R10,regarg1
(1)  149/    1255 : (MACRO)             	ld2z retval	;quotient
(1)  150/    1259 : (MACRO)             	cpy2 rwork,regarg2
(1)  151/    125D :                     	
(1)  152/    125D : (MACRO)             	testsub R10,regarg2
(1)  153/    1266 : 3B 81               	bnf $$computequot	;DF=0 means it didn't fit
(1)  154/    1268 : BA                  	phi R10	;R10=R10-regarg2
(1)  155/    1269 : 8B                  	glo R11
(1)  156/    126A : AA                  	plo R10
(1)  157/    126B :                     	
(1)  158/    126B :                     $$again:	;this is the divisor doubling phase
(1)  159/    126B : (MACRO)              	testsub R10,regarg2
(1)  160/    1274 : 3B 81                	bnf $$computequot	;df=0 means it didn't fit
(1)  161/    1276 : BA                  	phi R10	;R10=R10-regarg2
(1)  162/    1277 : 8B                  	glo R11
(1)  163/    1278 : AA                  	plo R10 	
(1)  164/    1279 : (MACRO)              	shl2 regarg2	;y=y+y
(1)  165/    127F : 30 6B                	br $$again
(1)  166/    1281 :                      	
(1)  167/    1281 :                      $$computequot:	;here we're computing the quotient
(1)  168/    1281 : (MACRO)              	testsub regarg1,regarg2
(1)  169/    128A : 3B 90                	bnf $$testexit
(1)  170/    128C : BC                   	phi regarg1		;complete the subtraction
(1)  171/    128D : 8B                   	glo R11
(1)  172/    128E : AC                   	plo regarg1
(1)  173/    128F : 1F                   	inc retval
(1)  174/    1290 :                      $$testexit:
(1)  175/    1290 : 9E                   	ghi rwork
(1)  176/    1291 : F7                   	sm	;top of regarg2 is still on stack
(1)  177/    1292 : 3A 9A                	bnz $$ney0y
(1)  178/    1294 : 8D                   	glo regarg2
(1)  179/    1295 : 52                   	str sp
(1)  180/    1296 : 8E                   	glo rwork
(1)  181/    1297 : F7                   	sm	;test low order bytes
(1)  182/    1298 : 32 A8                	bz	$$out	;if = we're done
(1)  183/    129A :                      $$ney0y:
(1)  184/    129A : (MACRO)              	shl2 retval	;double quotient
(1)  185/    12A0 : (MACRO)              	shrU2 regarg2	;halve divisor
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(lcc1802EpiloDH.inc) - page 27 - 8/27/2014 11:16:27


(1)  186/    12A6 : 30 81                	br $$computequot	;continue
(1)  187/    12A8 :                      $$out:
(1)  188/    12A8 :                      ;here the quotient is in retval, remainder in regarg1
(1)  189/    12A8 : 12                    	inc sp	;release work area
(1)  190/    12A9 : 42                  	lda sp	;recover
(1)  191/    12AA : AB                  	plo R11	;bottom byte of R11
(1)  192/    12AB : (MACRO)             	popr R10 ;and all of R10
(1)  193/    12AF : (MACRO)             	cretn	;and we're done
(1)  194/    12B0 :                     
(1)  195/    12B0 :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  196/    12B0 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  197/    12B0 :                     _divI2:
(1)  198/    12B0 :                         ;pushr retAddr	;save the return address NG doesnot need
(1)  199/    12B0 : 22                      dec	sp	;leave a work area available
(1)  200/    12B1 : 9C                      ghi regArg1
(1)  201/    12B2 : 52                      str sp	;save the sign of the 1st arg
(1)  202/    12B3 : FE                      shl
(1)  203/    12B4 : 3B BF                   bnf $$pos1	;if the 1st arg is -v
(1)  204/    12B6 : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
(1)  205/    12BF :                     $$pos1: ;1st is now +v, check 2nd
(1)  206/    12BF : 9D                      ghi regArg2
(1)  207/    12C0 : F3                      xor	
(1)  208/    12C1 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  209/    12C2 : 9D                      ghi regArg2
(1)  210/    12C3 : FE                      shl
(1)  211/    12C4 : 3B CF                   bnf $$pos2	;if the 2nd arg is -v
(1)  212/    12C6 : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  213/    12CF :                     $$pos2: ; both args now +v
(1)  214/    12CF : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  215/    12D2 :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  216/    12D2 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  217/    12D3 : FE                      shl
(1)  218/    12D4 : 3B DF                   bnf $$done ;if the signs were different
(1)  219/    12D6 : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  220/    12DF :                     $$done:
(1)  221/    12DF :                         ;popr RetAddr ;restore the return address NG doesnot need
(1)  222/    12DF : (MACRO)                 Cretn ;and we're done - I hope!
(1)  223/    12E0 :                     
(1)  224/    12E0 :                     
(1)  225/    12E0 :                     	align 256    ;32 bit operations follow
(1)  226/    1300 :                     _divu4:
(1)  227/    1300 :                     ;This is an unsigned 32 bit restoring division
(1)  228/    1300 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  229/    1300 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  230/    1300 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  231/    1300 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  232/    1300 :                     
(1)  233/    1300 : F8 20               	ldi 32		;set loop count
(1)  234/    1302 : AE                  	plo memaddr	;in temp register
(1)  235/    1303 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  236/    130F :                     $$loop:
(1)  237/    130F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  238/    131B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  239/    1327 :                     
(1)  240/    1327 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  241/    133D :                     
(1)  242/    133D : FA 80               	ani 0x80	;check the top bit
(1)  243/    133F : 32 5D               	bz $$norestore	;if it's 0
(1)  244/    1341 : 89                  		glo RL8
(1)  245/    1342 : FA FE               		ani 0xfe	;turn off the bottom bit
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(lcc1802EpiloDH.inc) - page 28 - 8/27/2014 11:16:27


(1)  246/    1344 : A9                  		plo RL8
(1)  247/    1345 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  248/    135B : 30 61               	br $$endlp 	;else
(1)  249/    135D :                     $$norestore:
(1)  250/    135D : 89                  		glo RL8
(1)  251/    135E : F9 01               		ori 1	;turn on the bottom bit
(1)  252/    1360 : A9                  		plo RL8
(1)  253/    1361 :                     	;end if
(1)  254/    1361 :                     $$endlp:
(1)  255/    1361 : 2E                  	dec memaddr	;check the cycle count
(1)  256/    1362 : 8E                  	glo memaddr
(1)  257/    1363 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  258/    1365 :                     	
(1)  259/    1365 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  260/    1366 :                     		
(1)  261/    1366 :                     
(1)  262/    1366 :                     _mulu4:
(1)  263/    1366 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  264/    1366 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  265/    1366 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  266/    1366 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  267/    1366 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  268/    1366 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  269/    1366 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  270/    1366 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  271/    1366 :                     	;for 10 we subtract and shift
(1)  272/    1366 :                     	;for 00 and 11 we just shift
(1)  273/    1366 :                     
(1)  274/    1366 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  275/    1372 : F8 20                   ldi 32
(1)  276/    1374 : AE                      plo memaddr		;cycle count
(1)  277/    1375 : FC 00                   adi 0		;clear df
(1)  278/    1377 :                     $$mloop:
(1)  279/    1377 : 89                      glo RL8
(1)  280/    1378 : FA 01                   ani 1		;isolate bottom bit of result
(1)  281/    137A : 3B 96                   bnf	$$check_sub	;
(1)  282/    137C : 3A AE                   bnz	$$shift		;that would be the 11 case
(1)  283/    137E :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  284/    137E : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  285/    1394 : 30 AE                   br $$shift
(1)  286/    1396 :                     $$check_sub:
(1)  287/    1396 : 32 AE                   bz $$shift	;that would be the 00 case
(1)  288/    1398 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  289/    1398 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  290/    13AE :                     $$shift:
(1)  291/    13AE : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  292/    13BC : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  293/    13C8 :                     
(1)  294/    13C8 : 2E                      dec memaddr		;cycle count
(1)  295/    13C9 : 8E                      glo memaddr
(1)  296/    13CA : 3A 77                   bnz $$mloop		;repeat cycle once for each bit position
(1)  297/    13CC :                         
(1)  298/    13CC : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  299/    13CD :                     
(1)  300/    13CD :                     	align 256
(1)  301/    1400 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  302/    1400 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  303/    1400 :                     _divI4:
(1)  304/    1400 : 22                      dec	sp	;leave a work area available
(1)  305/    1401 : 98                      ghi RL8-1	;get the top of the dividend
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(lcc1802EpiloDH.inc) - page 29 - 8/27/2014 11:16:27


(1)  306/    1402 : 52                      str sp	;save the sign of the 1st arg
(1)  307/    1403 : FE                      shl
(1)  308/    1404 : 3B 26                   bnf $$pos1	;if the 1st arg is -v
(1)  309/    1406 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  310/    1426 :                     $$pos1: ;1st is now +v, check 2nd
(1)  311/    1426 : 9A                      ghi RL10-1
(1)  312/    1427 : F3                      xor	
(1)  313/    1428 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  314/    1429 : 9A                      ghi RL10-1
(1)  315/    142A : FE                      shl
(1)  316/    142B : 3B 4D                   bnf $$pos2	;if the 2nd arg is -v
(1)  317/    142D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  318/    144D :                     $$pos2: ; both args now +v
(1)  319/    144D : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  320/    1450 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  321/    1450 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  322/    1451 : FE                      shl
(1)  323/    1452 : 3B 74                   bnf $$done ;if the signs were different
(1)  324/    1454 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  325/    1474 :                     $$done:
(1)  326/    1474 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  327/    1475 :                     
(1)  328/    1475 :                     _dubdabx:	
(1)  329/    1475 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  330/    1475 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  331/    1475 :                     ;long interger is passed in rp1p2
(1)  332/    1475 :                     ;buffer pointer is passed at sp+2+4
(1)  333/    1475 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
(1)  334/    1475 :                     ;r8-11 are used as temps
(1)  335/    1475 :                     ;r8 is the working pointer
(1)  336/    1475 :                     ;r15.0 is bit count(32) and the return value register
(1)  337/    1475 :                     ;r9.0 is digit count
(1)  338/    1475 :                     ;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
(1)  339/    1475 : (MACRO)             	ld2 r8,'O',sp,(2+4); pick up the buffer pointer
(1)  340/    1481 : (MACRO)             	ld2 r10,'O',sp,(2+4+2); pick up the number of digits wanted
(1)  341/    148D : (MACRO)             	cpy2 r15,r8 ;save address for now
(1)  342/    1491 : F8 0B               	ldi 11	;digit count+1 for trailing 0
(1)  343/    1493 : A9                  	plo r9
(1)  344/    1494 :                     $$clrlp:	;clear the passed buffer
(1)  345/    1494 : F8 00               	ldi 0	
(1)  346/    1496 : 58                  	str r8	;clear a byte
(1)  347/    1497 : 18                  	inc r8
(1)  348/    1498 : 29                  	dec r9
(1)  349/    1499 : 89                  	glo r9	;check the count
(1)  350/    149A : 3A 94               	bnz $$clrlp ;back for more
(1)  351/    149C : (MACRO)             	cpy2 r8,r15 ;get the address back
(1)  352/    14A0 :                     
(1)  353/    14A0 : F8 20               	ldi 32	;bit count
(1)  354/    14A2 : AF                  	plo r15
(1)  355/    14A3 :                     ;now i'm going to spin off any leading 0's in the binary number
(1)  356/    14A3 :                     $$cktop:
(1)  357/    14A3 : 9C                  	ghi rp1p2-1	;get the top bit of the number
(1)  358/    14A4 : FE                  	shl		;check for a 1
(1)  359/    14A5 : 33 B8               	bdf $$bitloop	;move on if we have one
(1)  360/    14A7 : (MACRO)             	shl4 rp1p2	;shift the input number
(1)  361/    14B3 : 2F                  	dec r15		;reduce the number of times to shift
(1)  362/    14B4 : 8F                  	glo r15
(1)  363/    14B5 : 3A A3               	bnz $$cktop	;
(1)  364/    14B7 : 1F                  	inc r15		;our whole number was 0 but force at least one pass
(1)  365/    14B8 :                     $$bitloop:
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(lcc1802EpiloDH.inc) - page 30 - 8/27/2014 11:16:27


(1)  366/    14B8 : F8 0A               	ldi 10	;digit count
(1)  367/    14BA : A9                  	plo r9
(1)  368/    14BB :                     $$dcklp:
(1)  369/    14BB : 08                  	ldn r8 	;pick up a digit
(1)  370/    14BC : FF 05               	smi 5	;see if it's greater than 4
(1)  371/    14BE : 3B C3               	bnf $$dnoadd ;if not, bypass add
(1)  372/    14C0 : FC 08               	adi 0x08	;add the 5 black and 3 more
(1)  373/    14C2 : 58                  	str r8	;put it back
(1)  374/    14C3 :                     $$dnoadd:
(1)  375/    14C3 : 18                  	inc r8
(1)  376/    14C4 : 29                  	dec r9	;decrement digit count
(1)  377/    14C5 : 89                  	glo r9
(1)  378/    14C6 : 3A BB               	bnz $$dcklp ;and back for next digit
(1)  379/    14C8 :                     	
(1)  380/    14C8 : (MACRO)             	shl4 rp1p2 ;shift the input number
(1)  381/    14D4 :                     	
(1)  382/    14D4 : F8 0A               	ldi 10	;load the digit count again
(1)  383/    14D6 : A9                  	plo r9
(1)  384/    14D7 :                     ;r8 is now just past the units location and ready to walk back
(1)  385/    14D7 :                     $$dshlp:
(1)  386/    14D7 : 28                  	dec r8	;walk back from 0's position
(1)  387/    14D8 : 08                  	ldn r8	;get the digit back
(1)  388/    14D9 : 7E                  	shlc	;continue the shift
(1)  389/    14DA : BF                  	phi r15 ;save it for the carry test
(1)  390/    14DB : FA 0F               	ani 0x0f ;clear the 10 bit
(1)  391/    14DD : 58                  	str r8	;put the digit back
(1)  392/    14DE : 9F                  	ghi r15	;now test for carry
(1)  393/    14DF : FF 10               	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  394/    14E1 : 29                  	dec r9	;decrement the digit count
(1)  395/    14E2 : 89                  	glo r9
(1)  396/    14E3 : 3A D7               	bnz $$dshlp ;back for more if needed
(1)  397/    14E5 :                     	
(1)  398/    14E5 : 2F                  	dec r15
(1)  399/    14E6 : 8F                  	glo r15
(1)  400/    14E7 : 3A B8               	bnz $$bitloop
(1)  401/    14E9 :                     	
(1)  402/    14E9 : (MACRO)             	cpy2 r15,r8	;save the starting location of the digits
(1)  403/    14ED : F8 0A               	ldi 10		;digit count again
(1)  404/    14EF : A9                  	plo r9
(1)  405/    14F0 :                     $$upnxt:
(1)  406/    14F0 : 08                  	ldn r8		;get digit
(1)  407/    14F1 : F9 30               	ori 0x30	;make ascii
(1)  408/    14F3 : 58                  	str r8		;put it back
(1)  409/    14F4 : 18                  	inc r8		;next digit
(1)  410/    14F5 : 29                  	dec r9		;counter
(1)  411/    14F6 : 89                  	glo r9
(1)  412/    14F7 : 3A F0               	bnz $$upnxt	;upgrade all 10 spots
(1)  413/    14F9 :                     	
(1)  414/    14F9 : (MACRO)             	ldaX memaddr,sp,(2+4+2+1)	;point to lsb of desired digit count
(1)  415/    1501 : EE                  	sex memaddr	;set up
(1)  416/    1502 : F8 0A               	ldi 10		;max number of 0's to skip
(1)  417/    1504 : F7                  	sm		;desired number of digits to skip
(1)  418/    1505 : E2                  	sex sp		;reset index register
(1)  419/    1506 : A9                  	plo r9		;number of leading 0's to skip
(1)  420/    1507 :                     $$cknext:
(1)  421/    1507 : 0F                  	ldn r15		;check digit
(1)  422/    1508 : FF 30               	smi 0x30	;for '0'
(1)  423/    150A : 3A 11               	bnz $$done
(1)  424/    150C : 1F                  	inc r15		;next digit
(1)  425/    150D : 29                  	dec r9		;reduce count
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(lcc1802EpiloDH.inc) - page 31 - 8/27/2014 11:16:27


(1)  426/    150E : 89                  	glo r9
(1)  427/    150F : 3A 07               	bnz $$cknext
(1)  428/    1511 :                     $$done:
(1)  429/    1511 : (MACRO)             	cretn
(1)  430/    1512 :                     	
(1)  431/    1512 :                     	
(1)  432/    1512 :                     _modU4:	;32 bit unsigned remainder
(1)  433/    1512 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  434/    1512 : (MACRO)                 Ccall _divU4
(1)  435/    1515 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  436/    151D : (MACRO)                 Cretn
(1)  437/    151E :                         
(1)  438/    151E :                     _modI4:	;32 bit signed remainder
(1)  439/    151E :                     	; just calls the 32 bit division then puts remainder into return value
(1)  440/    151E : (MACRO)                 Ccall _divI4
(1)  441/    1521 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  442/    1529 : (MACRO)                 Cretn
(1)  443/    152A :                     	
(1)  444/    152A :                     
    1284/    152A :                     	include LCC1802fp.inc
(1)    1/    152A :                     ;from http://www.elf-emulation.com/software/fp.asm - thanks to mike Reilley
(1)    2/    152A :                     ;maybe originally from RCA
(1)    3/    152A :                     ;these routines use ALL the registers from 6-15!
(1)    4/    152A :                     ;8-15 were more or less available to start with
(1)    5/    152A :                     ;it saves 6 when it uses it
(1)    6/    152A :                     ;I save 7 on entry and restore on exit
(1)    7/    152A :                     ;to keep my sanity I renamed some register equates where I was changing them e.g. F7 used to be RB
(1)    8/    152A : =BH                 FB	equ	11	;was R9
(1)    9/    152A : =9H                 F9	equ	9	;was R7
(1)   10/    152A : =7H                 F7	equ	7	;was RB
(1)   11/    152A :                     ;April 1 added code to fp_add to restore resgisters when returning a 0 - around add_nz:
(1)   12/    152A :                     ; *** Convert signed long to float
(1)   13/    152A :                     ; *** RL8-1:RL8 is the number to convert(8:9)
(1)   14/    152A :                     ; *** result in same register
(1)   15/    152A :                     ; *** uses memaddr.1 for sign, .0 for shift count/exponent
(1)   16/    152A :                     	align 256
(1)   17/    1600 : F8 00               cvif4:	ldi	0
(1)   18/    1602 : BE                  	phi	memaddr	;sign
(1)   19/    1603 : F8 96               	ldi	150	;150 is  the 127 exponent bias plus the 23 required to shift a long 1 to bit 23
(1)   20/    1605 : AE                  	plo	memaddr	;
(1)   21/    1606 : 98                  	ghi	RL8-1	;get sign and bits 7-1 of exponent
(1)   22/    1607 : 32 30               	bz	$$nxt	;keep testing for 0
(1)   23/    1609 : FE                  	shl		;sign bit to df
(1)   24/    160A : 3B 39               	bnf	$$sgnpos ;number is >0
(1)   25/    160C : 76                  	shrc		;shift it back so we know byte is non-zerro
(1)   26/    160D : BE                  	phi	memaddr	;save it
(1)   27/    160E : (MACRO)             	negi4	RL8,RL8	;flip the number
(1)   28/    162E : 30 39               	br	$$sgnpos ;go handle positive long
(1)   29/    1630 : 88                  $$nxt:	glo	RL8-1	;next byte
(1)   30/    1631 : 3A 39               	bnz	$$sgnpos ;sign is positive, number is not 0
(1)   31/    1633 : 99                  	ghi	RL8	;next byte
(1)   32/    1634 : 3A 39               	bnz	$$sgnpos ;sign is positive, number is not 0
(1)   33/    1636 : 89                  	glo	RL8	;last byte
(1)   34/    1637 : 32 6F               	bz	$$done	;the whole thing is zero so we're done
(1)   35/    1639 : 98                  $$sgnpos: ghi	RL8-1	;top byte - begin shifting right to clear it
(1)   36/    163A : 32 4B               	bz	$$shl	;if it's zero we're done right shifting
(1)   37/    163C : 1E                  	inc	memaddr	;increase exponent 1 for each right shift
(1)   38/    163D : (MACRO)             	shru4	RL8
(1)   39/    1649 : 30 39               	br	$$sgnpos
(1)   40/    164B : 88                  $$shl:	glo	RL8-1	;check bit 23
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 32 - 8/27/2014 11:16:27


(1)   41/    164C : FA 80               	ani	0x80	;isolate it
(1)   42/    164E : 3A 5F               	bnz	$$shdn	;if it's on we're done here
(1)   43/    1650 : 2E                  	dec	memaddr	;decrease exponent 1 for each left shift
(1)   44/    1651 : (MACRO)             	shl4	RL8	;shift mantissa left one
(1)   45/    165D : 30 4B               	br	$$shl
(1)   46/    165F : 8E                  $$shdn:	glo	memaddr	;get the exponent
(1)   47/    1660 : F6                  	shr		;shift right so it can go into bits 31-24
(1)   48/    1661 : B8                  	phi	RL8-1	;put top bits of exponent into place
(1)   49/    1662 : 33 68               	bdf	$$setsgn ;if the bit 0 is on we're done
(1)   50/    1664 : 88                  	glo	RL8-1	;get the byte
(1)   51/    1665 : FA 7F               	ani	0x7f	;clear bit 23
(1)   52/    1667 : A8                  	plo	RL8-1	;put it back
(1)   53/    1668 : 9E                  $$setsgn: ghi	memaddr	;get the original sign byte
(1)   54/    1669 : 32 6F               	bz	$$done	;sign bit is already zero so we're done
(1)   55/    166B : 98                  	ghi	RL8-1	;get the sign byte
(1)   56/    166C : F9 80               	ori	0x80	;set the sign bit
(1)   57/    166E : B8                  	phi	RL8-1	;place it
(1)   58/    166F : (MACRO)             $$done:	Cretn		;and we're done
(1)   59/    1670 :                     	
(1)   60/    1670 :                     
(1)   61/    1670 :                     
(1)   62/    1670 :                     ; *** Convert float to signed long
(1)   63/    1670 :                     ; *** RL8-1:RL8 is the number to convert(8:9)
(1)   64/    1670 :                     ; *** result in same register
(1)   65/    1670 :                     	align 256
(1)   66/    1700 :                     cvfi4:
(1)   67/    1700 : 98                  	ghi	RL8-1	;get sign and bits 7-1 of exponent
(1)   68/    1701 : BE                  	phi	memaddr ;save for later
(1)   69/    1702 : 88                  	glo	RL8-1	;get bit 0 of exponent
(1)   70/    1703 : FE                  	shl		;shift to df
(1)   71/    1704 : 9E                  	ghi	memaddr	;get exponent 7-1
(1)   72/    1705 : 7E                  	shlc		;combine with 0
(1)   73/    1706 :                     ;the following sequence is equivalent to sdi 150; I did it this way to coddle my emulator which doesn't do this properly.
(1)   74/    1706 : 22                  	dec	sp
(1)   75/    1707 : 52                  	str	sp
(1)   76/    1708 : F8 96               	ldi	150
(1)   77/    170A : F7                  	sm		;calculate shift count needed
(1)   78/    170B :                     ;*******note - the df flag set here is tested later
(1)   79/    170B : AE                  	plo	memaddr
(1)   80/    170C : 12                  	inc	sp	;release work area
(1)   81/    170D :                     ;end of sdi 150 sequence - now convert the mantissa to unsigned long
(1)   82/    170D : F8 00               	ldi	0
(1)   83/    170F : B8                  	phi	RL8-1	;clear the top byte of the float
(1)   84/    1710 : 88                  	glo	RL8-1	;get the next byte
(1)   85/    1711 : F9 80               	ori	0x80	;add in the implied 1 bit
(1)   86/    1713 : A8                  	plo	RL8-1	;put it back
(1)   87/    1714 : 8E                  	glo	memaddr	;make sure there's at least 1 shift
(1)   88/    1715 : 32 3B               	bz	$$sign
(1)   89/    1717 :                     ;**********note df is set from subtraction before setting mantissa
(1)   90/    1717 : 3B 2B               	bnf	$$lsh ; if the shift count is negative
(1)   91/    1719 :                     
(1)   92/    1719 : (MACRO)             $$shr:	shru4	RL8
(1)   93/    1725 : 2E                  	dec	memaddr	;check shift count
(1)   94/    1726 : 8E                  	glo	memaddr
(1)   95/    1727 : 3A 19               	bnz	$$shr	;complete the shift
(1)   96/    1729 : 30 3B               	br	$$sign
(1)   97/    172B :                     
(1)   98/    172B :                     ;handle negative shift as best I can - gigo
(1)   99/    172B : (MACRO)             $$lsh: 	shl4	RL8	;shift once
(1)  100/    1737 : 1E                  	inc	memaddr
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 33 - 8/27/2014 11:16:27


(1)  101/    1738 : 8E                  	glo	memaddr
(1)  102/    1739 : 3A 2B               	bnz	$$lsh	
(1)  103/    173B :                     	
(1)  104/    173B : 9E                  $$sign:	ghi	memaddr	;now the sign
(1)  105/    173C : FE                  	shl		;shift sign bit into df
(1)  106/    173D : 3B 61               	bnf	$$done
(1)  107/    173F : (MACRO)             	negi4	RL8,RL8	;negate the number if needed
(1)  108/    175F : 30 61               	br	$$done	; and return
(1)  109/    1761 :                     
(1)  110/    1761 : (MACRO)             $$done:	Cretn		;and we're done
(1)  111/    1762 :                     
(1)  112/    1762 :                     ; *** Check if character is numeric
(1)  113/    1762 :                     ; *** D - char to check
(1)  114/    1762 :                     ; *** Returns DF=1 if numeric
(1)  115/    1762 :                     ; ***         DF=0 if not
(1)  116/    1762 : AE                  f_isnum:   plo     r14                 ; save a copy
(1)  117/    1763 : FF 30                          smi     '0'                 ; check for below zero
(1)  118/    1765 : 3B 6E                          bnf     fails               ; jump if below
(1)  119/    1767 : FF 0A                          smi     10                  ; see if above
(1)  120/    1769 : 33 6E                          bdf     fails               ; fails if so
(1)  121/    176B : FF 00               passes:    smi     0                   ; signal success
(1)  122/    176D : C8                             lskp
(1)  123/    176E : FC 00               fails:     adi     0                   ; signal failure
(1)  124/    1770 : 8E                             glo     r14                 ; recover character
(1)  125/    1771 : D5                             sep     RRET                ; and return; *******************************
(1)  126/    1772 :                     ; *** Shift R8:F9 right 1 bit ***
(1)  127/    1772 :                     ; *******************************
(1)  128/    1772 : 98                  fp_shr_1:  ghi   r8                    ; shift high word right
(1)  129/    1773 : F6                             shr
(1)  130/    1774 : B8                             phi   r8
(1)  131/    1775 : 88                             glo   r8
(1)  132/    1776 : 76                             shrc
(1)  133/    1777 : A8                             plo   r8
(1)  134/    1778 : 99                             ghi   F9                    ; shift low word right
(1)  135/    1779 : 76                             shrc
(1)  136/    177A : B9                             phi   F9
(1)  137/    177B : 89                             glo   F9
(1)  138/    177C : 76                             shrc
(1)  139/    177D : A9                             plo   F9
(1)  140/    177E : (MACRO)                        Cretn
(1)  141/    177F :                     
(1)  142/    177F :                     ; ******************************
(1)  143/    177F :                     ; *** Shift R8:F9 left 1 bit ***
(1)  144/    177F :                     ; ******************************
(1)  145/    177F : 89                  fp_shl_1:  glo   F9
(1)  146/    1780 : FE                             shl
(1)  147/    1781 : A9                             plo   F9
(1)  148/    1782 : 99                             ghi   F9
(1)  149/    1783 : 7E                             shlc
(1)  150/    1784 : B9                             phi   F9
(1)  151/    1785 : 88                             glo   r8
(1)  152/    1786 : 7E                             shlc
(1)  153/    1787 : A8                             plo   r8
(1)  154/    1788 : 98                             ghi   r8
(1)  155/    1789 : 7E                             shlc
(1)  156/    178A : B8                             phi   r8
(1)  157/    178B : D5                             sep   RRET
(1)  158/    178C :                     
(1)  159/    178C :                     ; **********************
(1)  160/    178C :                     ; *** R8:F9 += RA:FB ***
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 34 - 8/27/2014 11:16:27


(1)  161/    178C :                     ; **********************
(1)  162/    178C : 8B                  fp_add_12: glo   FB
(1)  163/    178D : 22                  	   dec r2	;wjr - make a work area
(1)  164/    178E : 52                             str   r2
(1)  165/    178F : 89                             glo   F9
(1)  166/    1790 : F4                             add
(1)  167/    1791 : A9                             plo   F9
(1)  168/    1792 : 9B                             ghi   FB
(1)  169/    1793 : 52                             str   r2
(1)  170/    1794 : 99                             ghi   F9
(1)  171/    1795 : 74                             adc
(1)  172/    1796 : B9                             phi   F9
(1)  173/    1797 : 8A                             glo   R10
(1)  174/    1798 : 52                             str   r2
(1)  175/    1799 : 88                             glo   r8
(1)  176/    179A : 74                             adc
(1)  177/    179B : A8                             plo   r8
(1)  178/    179C : 9A                             ghi   R10
(1)  179/    179D : 52                             str   r2
(1)  180/    179E : 98                             ghi   r8
(1)  181/    179F : 74                             adc
(1)  182/    17A0 : B8                             phi   r8
(1)  183/    17A1 : 12                             inc	r2	;wjr - release work area
(1)  184/    17A2 : (MACRO)                        Cretn
(1)  185/    17A3 :                     
(1)  186/    17A3 :                     ; *******************************
(1)  187/    17A3 :                     ; *** Shift RF:RD right 1 bit ***
(1)  188/    17A3 :                     ; *******************************
(1)  189/    17A3 : 9F                  fp_shr_fd: ghi   R15                    ; shift high word right
(1)  190/    17A4 : F6                             shr
(1)  191/    17A5 : BF                             phi   R15
(1)  192/    17A6 : 8F                             glo   R15
(1)  193/    17A7 : 76                             shrc
(1)  194/    17A8 : AF                             plo   R15
(1)  195/    17A9 : 9D                             ghi   R13                    ; shift low word right
(1)  196/    17AA : 76                             shrc
(1)  197/    17AB : BD                             phi   R13
(1)  198/    17AC : 8D                             glo   R13
(1)  199/    17AD : 76                             shrc
(1)  200/    17AE : AD                             plo   R13
(1)  201/    17AF : (MACRO)                        Cretn
(1)  202/    17B0 :                     
(1)  203/    17B0 :                     ; *************************************
(1)  204/    17B0 :                     ; *** Scale number to high bit is 1 ***
(1)  205/    17B0 :                     ; *** R8:F9 - Number to scale       ***
(1)  206/    17B0 :                     ; *** RF.1  - Exponent for number   ***
(1)  207/    17B0 :                     ; *** F7.0  - Sign bit (bit 0) ***
(1)  208/    17B0 :                     ; *** Returns: R8:F9 - final sp num ***
(1)  209/    17B0 :                     ; *************************************
(1)  210/    17B0 : 88                  fp_sc_up:  glo   r8                    ; need high bit to be a 1
(1)  211/    17B1 : FA 80                          ani   080h                  ; check it
(1)  212/    17B3 : CA 17 C0                       lbnz  fp_sc_cln             ; jump if good
(1)  213/    17B6 : (MACRO)                        Ccall fp_shl_1              ; shift answer left
(1)  214/    17B9 : 9F                             ghi   R15                    ; get exp1
(1)  215/    17BA : FF 01                          smi   1                     ; minus 1
(1)  216/    17BC : BF                             phi   R15                    ; and put it back
(1)  217/    17BD : C0 17 B0                       lbr   fp_sc_up              ; loop back intil msbit is 1
(1)  218/    17C0 : 88                  fp_sc_cln: glo   r8                    ; get high byte
(1)  219/    17C1 : FE                             shl                         ; shift out high 1 bit
(1)  220/    17C2 : A8                             plo   r8                    ; set aside
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 35 - 8/27/2014 11:16:27


(1)  221/    17C3 : 9F                             ghi   R15                    ; get exponent byte
(1)  222/    17C4 : B8                             phi   r8                    ; write other 7 bits to r8.1
(1)  223/    17C5 : F6                             shr                         ; shift bit 0 into DF
(1)  224/    17C6 : 88                             glo   r8                    ; get high byte of mantissa
(1)  225/    17C7 : 76                             shrc                        ; shift bit 0 of expnent in
(1)  226/    17C8 : A8                             plo   r8                    ; and put it back
(1)  227/    17C9 : 87                             glo   F7                   ; get signs
(1)  228/    17CA : F6                             shr                         ; get sign 1
(1)  229/    17CB : 98                             ghi   r8                    ; recover exponent
(1)  230/    17CC : 76                             shrc                        ; shift in sign
(1)  231/    17CD : B8                             phi   r8                    ; put it back
(1)  232/    17CE : 12                             inc	r2	;wjr release work area
(1)  233/    17CF : (MACRO)             	   popr R13	;wjr restore param regs
(1)  234/    17D3 : (MACRO)             	   popr R12	;wjr
(1)  235/    17D7 : (MACRO)                        popr	F7	;wjr restore c variable register
(1)  236/    17DB : (MACRO)                        Cretn                       ; return to caller
(1)  237/    17DC :                     
(1)  238/    17DC :                     ; ************************************
(1)  239/    17DC :                     ; *** Get exponenst from arguments ***
(1)  240/    17DC :                     ; *** R8:F9 - Arg 1                ***
(1)  241/    17DC :                     ; *** RA:FB - Arg 2                ***
(1)  242/    17DC :                     ; *** Returns: RF.1 - exp1         ***
(1)  243/    17DC :                     ; ***          RF.0 - exp2         ***
(1)  244/    17DC :                     ; ************************************
(1)  245/    17DC : 88                  fp_getexp: glo   r8                    ; get exponent of arg1 (bit 0)
(1)  246/    17DD : FE                             shl                         ; shift it into DF
(1)  247/    17DE : 98                             ghi   r8                    ; get top 7 bits
(1)  248/    17DF : 7E                             shlc                        ; shift in first bit
(1)  249/    17E0 : BF                             phi   R15                    ; put exp1 into RF.1
(1)  250/    17E1 :                                ;str   r2    wjr - this is never used; place into memory as well
(1)  251/    17E1 : 8A                             glo   R10                    ; get exponent of arg2 (bit 0)
(1)  252/    17E2 : FE                             shl                         ; shift it into DF
(1)  253/    17E3 : 9A                             ghi   R10                    ; get top 7 bits
(1)  254/    17E4 : 7E                             shlc                        ; shift in first bit
(1)  255/    17E5 : AF                             plo   R15                    ; put into RF
(1)  256/    17E6 : D5                             sep   RRET                  ; return to caller
(1)  257/    17E7 :                     
(1)  258/    17E7 :                     ; ************************************
(1)  259/    17E7 :                     ; *** Get signs from arguments     ***
(1)  260/    17E7 :                     ; *** R8:F9 - Arg 1                ***
(1)  261/    17E7 :                     ; *** RA:FB - Arg 2                ***
(1)  262/    17E7 :                     ; *** Returns: F7.0 - signs        ***
(1)  263/    17E7 :                     ; ************************************
(1)  264/    17E7 : 98                  fp_getsgn: ghi   r8                    ; get sign of arg1
(1)  265/    17E8 : FE                             shl                         ; shift into DF
(1)  266/    17E9 : 9A                             ghi   R10                    ; get sign of arg2
(1)  267/    17EA : 7E                             shlc                        ; shift into DF, sign of arg1 to bit 0
(1)  268/    17EB : 7E                             shlc                        ; now shift in sign of arg2
(1)  269/    17EC : A7                             plo   F7                    ; save them
(1)  270/    17ED : (MACRO)                        Cretn                       ; return to caller
(1)  271/    17EE :                     
(1)  272/    17EE :                     ; ***************************************
(1)  273/    17EE :                     ; *** Add 2 SP floating point numbers ***
(1)  274/    17EE :                     ; *** R8:F9 - Arg 1                   ***
(1)  275/    17EE :                     ; *** RA:FB - Arg 2                   ***
(1)  276/    17EE :                     ; *** Returns: R8:F9 - Answer         ***
(1)  277/    17EE :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  278/    17EE :                     ; ***        RF.1 - exponent of arg2  ***
(1)  279/    17EE :                     ; ***        F7.0 - signs        ***
(1)  280/    17EE :                     ; ***************************************
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 36 - 8/27/2014 11:16:27


(1)  281/    17EE : 98                  fp_add:   ghi   r8                    ; check arg1 for zero
(1)  282/    17EF : CA 18 07                       lbnz  add_a1nz
(1)  283/    17F2 : 88                             glo   r8
(1)  284/    17F3 : CA 18 07                       lbnz  add_a1nz
(1)  285/    17F6 : 99                             ghi   F9
(1)  286/    17F7 : CA 18 07                       lbnz  add_a1nz
(1)  287/    17FA : 89                             glo   F9
(1)  288/    17FB : CA 18 07                       lbnz  add_a1nz
(1)  289/    17FE : 9A                             ghi   R10                    ; transfer arg2 to answer
(1)  290/    17FF : B8                             phi   r8
(1)  291/    1800 : 8A                             glo   R10
(1)  292/    1801 : A8                             plo   r8
(1)  293/    1802 : 9B                             ghi   FB
(1)  294/    1803 : B9                             phi   F9
(1)  295/    1804 : 8B                             glo   FB
(1)  296/    1805 : A9                             plo   F9
(1)  297/    1806 : (MACRO)                        Cretn                        ; return to caller
(1)  298/    1807 :                     
(1)  299/    1807 : 9A                  add_a1nz:  ghi   R10                    ; check arg2 for zero
(1)  300/    1808 : CA 18 18                       lbnz  add_a2nz
(1)  301/    180B : 8A                             glo   R10
(1)  302/    180C : CA 18 18                       lbnz  add_a2nz
(1)  303/    180F : 9B                             ghi   FB
(1)  304/    1810 : CA 18 18                       lbnz  add_a2nz
(1)  305/    1813 : 8B                             glo   FB
(1)  306/    1814 : CA 18 18                       lbnz  add_a2nz
(1)  307/    1817 : (MACRO)                        Cretn                       ; return arg1 as answer
(1)  308/    1818 :                                
(1)  309/    1818 : (MACRO)             add_a2nz:  pushr F7	;wjr save c variable register
(1)  310/    181D : (MACRO)             	   pushr R12	;wjr save param regs
(1)  311/    1822 : (MACRO)             	   pushr R13	;wjr
(1)  312/    1827 : 22                  	   dec	r2	;wjr - make a work area
(1)  313/    1828 : (MACRO)             	   Ccall fp_getexp             ; get exponents
(1)  314/    182B : 9F                             ghi   R15
(1)  315/    182C : 52                             str   r2
(1)  316/    182D : 8F                             glo   R15
(1)  317/    182E : F7                             sm                          ; perfrom exp2 - exp1
(1)  318/    182F : CB 18 50                       lbnf  add_ns                ; jump if no swap needed
(1)  319/    1832 :                     
(1)  320/    1832 : 98                             ghi   r8                    ; swap arg1 with arg2
(1)  321/    1833 : AE                             plo   R14
(1)  322/    1834 : 9A                             ghi   R10
(1)  323/    1835 : B8                             phi   r8
(1)  324/    1836 : 8E                             glo   R14
(1)  325/    1837 : BA                             phi   R10
(1)  326/    1838 : 88                             glo   r8
(1)  327/    1839 : AE                             plo   R14
(1)  328/    183A : 8A                             glo   R10
(1)  329/    183B : A8                             plo   r8
(1)  330/    183C : 8E                             glo   R14
(1)  331/    183D : AA                             plo   R10
(1)  332/    183E : 99                             ghi   F9                    ; swap arg1 with arg2
(1)  333/    183F : AE                             plo   R14
(1)  334/    1840 : 9B                             ghi   FB
(1)  335/    1841 : B9                             phi   F9
(1)  336/    1842 : 8E                             glo   R14
(1)  337/    1843 : BB                             phi   FB
(1)  338/    1844 : 89                             glo   F9
(1)  339/    1845 : AE                             plo   R14
(1)  340/    1846 : 8B                             glo   FB
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 37 - 8/27/2014 11:16:27


(1)  341/    1847 : A9                             plo   F9
(1)  342/    1848 : 8E                             glo   R14
(1)  343/    1849 : AB                             plo   FB
(1)  344/    184A : 9F                             ghi   R15                    ; swap exponents
(1)  345/    184B : AE                             plo   R14
(1)  346/    184C : 8F                             glo   R15
(1)  347/    184D : BF                             phi   R15
(1)  348/    184E : 8E                             glo   R14
(1)  349/    184F : AF                             plo   R15
(1)  350/    1850 : (MACRO)             add_ns:    ccall fp_getsgn              ; get signs of arguments
(1)  351/    1853 : F8 00                          ldi   0                     ; setup mantissas
(1)  352/    1855 : B8                             phi   r8
(1)  353/    1856 : BA                             phi   R10
(1)  354/    1857 : F8 80                          ldi   128                   ; need to set high bit in mantissa
(1)  355/    1859 : 52                             str   r2
(1)  356/    185A : 88                             glo   r8
(1)  357/    185B : F1                             or
(1)  358/    185C : A8                             plo   r8
(1)  359/    185D : 8A                             glo   R10
(1)  360/    185E : F1                             or
(1)  361/    185F : AA                             plo   R10
(1)  362/    1860 : 9F                             ghi   R15                    ; get exp1
(1)  363/    1861 : 52                             str   r2                    ; place into memory
(1)  364/    1862 : 8F                  add_lp1:   glo   R15                    ; get exp2
(1)  365/    1863 : F7                             sm                          ; see if match to exp1
(1)  366/    1864 : C2 18 77                       lbz   add_lp1dn             ; jump if match
(1)  367/    1867 : 8F                             glo   R15                    ; need to increase it
(1)  368/    1868 : FC 01                          adi   1
(1)  369/    186A : AF                             plo   R15
(1)  370/    186B : 8A                             glo   R10                    ; now shift arg2 over 1 bit
(1)  371/    186C : F6                             shr
(1)  372/    186D : AA                             plo   R10
(1)  373/    186E : 9B                             ghi   FB
(1)  374/    186F : 76                             shrc
(1)  375/    1870 : BB                             phi   FB
(1)  376/    1871 : 8B                             glo   FB
(1)  377/    1872 : 76                             shrc
(1)  378/    1873 : AB                             plo   FB
(1)  379/    1874 : C0 18 62                       lbr   add_lp1               ; keep shifting until exponents match
(1)  380/    1877 : 87                  add_lp1dn: glo   F7                    ; see if signs match
(1)  381/    1878 : 52                             str   r2
(1)  382/    1879 : F6                             shr
(1)  383/    187A : F3                             xor
(1)  384/    187B : FA 01                          ani   1                     ; keep only bottom bit
(1)  385/    187D : CA 18 86                       lbnz  add_nm                ; jump if signs do not match
(1)  386/    1880 : (MACRO)                        Ccall fp_add_12             ; perform arg1 += arg2
(1)  387/    1883 : C0 18 BF                       lbr   add_fnl               ; jump to clean up
(1)  388/    1886 : 8B                  add_nm:    glo   FB                    ; perform arg1 - arg2
(1)  389/    1887 : 52                             str   r2
(1)  390/    1888 : 89                             glo   F9
(1)  391/    1889 : F7                             sm
(1)  392/    188A : AC                             plo   R12                    ; place into RD:RC
(1)  393/    188B : 9B                             ghi   FB
(1)  394/    188C : 52                             str   r2
(1)  395/    188D : 99                             ghi   F9
(1)  396/    188E : 77                             smb
(1)  397/    188F : BC                             phi   R12
(1)  398/    1890 : 8A                             glo   R10
(1)  399/    1891 : 52                             str   r2
(1)  400/    1892 : 88                             glo   r8
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 38 - 8/27/2014 11:16:27


(1)  401/    1893 : 77                             smb
(1)  402/    1894 : AD                             plo   R13
(1)  403/    1895 : 9A                             ghi   R10
(1)  404/    1896 : 52                             str   r2
(1)  405/    1897 : 98                             ghi   r8
(1)  406/    1898 : 77                             smb
(1)  407/    1899 : BD                             phi   R13
(1)  408/    189A : CB 18 A8                       lbnf  add_no                ; jump if arg2 was larger than arg1
(1)  409/    189D : 9D                             ghi   R13                    ; transfer result to arg1
(1)  410/    189E : B8                             phi   r8
(1)  411/    189F : 8D                             glo   R13
(1)  412/    18A0 : A8                             plo   r8
(1)  413/    18A1 : 9C                             ghi   R12
(1)  414/    18A2 : B9                             phi   F9
(1)  415/    18A3 : 8C                             glo   R12
(1)  416/    18A4 : A9                             plo   F9
(1)  417/    18A5 : C0 18 BF                       lbr   add_fnl               ; finalize
(1)  418/    18A8 : 89                  add_no:    glo   F9                    ; perform arg1 = arg2 - arg1
(1)  419/    18A9 : 52                             str   r2
(1)  420/    18AA : 8B                             glo   FB
(1)  421/    18AB : F7                             sm
(1)  422/    18AC : A9                             plo   F9
(1)  423/    18AD : 99                             ghi   F9
(1)  424/    18AE : 52                             str   r2
(1)  425/    18AF : 9B                             ghi   FB
(1)  426/    18B0 : 77                             smb
(1)  427/    18B1 : B9                             phi   F9
(1)  428/    18B2 : 88                             glo   r8
(1)  429/    18B3 : 52                             str   r2
(1)  430/    18B4 : 8A                             glo   R10
(1)  431/    18B5 : 77                             smb
(1)  432/    18B6 : A8                             plo   r8
(1)  433/    18B7 : 98                             ghi   r8
(1)  434/    18B8 : 52                             str   r2
(1)  435/    18B9 : 9A                             ghi   R10
(1)  436/    18BA : 77                             smb
(1)  437/    18BB : B8                             phi   r8
(1)  438/    18BC : 87                             glo   F7                    ; move sign 2 to sign1
(1)  439/    18BD : FE                             shl
(1)  440/    18BE : A7                             plo   F7
(1)  441/    18BF : 98                  add_fnl:   ghi   r8                    ; check for zero result
(1)  442/    18C0 : CA 18 DD                       lbnz  add_nz                ; jump if not
(1)  443/    18C3 : 88                             glo   r8
(1)  444/    18C4 : CA 18 DD                       lbnz  add_nz
(1)  445/    18C7 : 99                             ghi   F9
(1)  446/    18C8 : CA 18 DD                       lbnz  add_nz
(1)  447/    18CB : 89                             glo   F9
(1)  448/    18CC : CA 18 DD                       lbnz  add_nz
(1)  449/    18CF : 12                             inc	r2	;wjr release work area
(1)  450/    18D0 : (MACRO)             	   popr R13	;wjr restore param regs
(1)  451/    18D4 : (MACRO)             	   popr R12	;wjr
(1)  452/    18D8 : (MACRO)                        popr	F7	;wjr restore c variable register
(1)  453/    18DC : (MACRO)                        Cretn                       ; return the zero
(1)  454/    18DD : 98                  add_nz:    ghi   r8                    ; see if answer is beyond 24 bits
(1)  455/    18DE : C2 18 EB                       lbz   add_nx                ; jump if not
(1)  456/    18E1 : (MACRO)                        Ccall fp_shr_1              ; shift answer to the right
(1)  457/    18E4 : 9F                             ghi   R15                    ; get exp1
(1)  458/    18E5 : FC 01                          adi   1                     ; increment it
(1)  459/    18E7 : BF                             phi   R15                    ; and put it back
(1)  460/    18E8 : C0 18 DD                       lbr   add_nz                ; keep going until not > 24 bits
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 39 - 8/27/2014 11:16:27


(1)  461/    18EB :                     
(1)  462/    18EB : 87                  add_nx:    glo   F7                    ; move sign 1 to low bit
(1)  463/    18EC : F6                             shr
(1)  464/    18ED : A7                             plo   F7
(1)  465/    18EE : C0 17 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  466/    18F1 :                     
(1)  467/    18F1 :                     ; ***************************************
(1)  468/    18F1 :                     ; *** sub 2 SP floating point numbers ***
(1)  469/    18F1 :                     ; *** R8:F9 - Arg 1                   ***
(1)  470/    18F1 :                     ; *** RA:FB - Arg 2                   ***
(1)  471/    18F1 :                     ; *** Returns: R8:F9 - Answer         ***
(1)  472/    18F1 :                     ; ***************************************
(1)  473/    18F1 : 9A                  fp_sub:    ghi   R10                    ; change sign of arg2
(1)  474/    18F2 : FB 80                          xri   080h
(1)  475/    18F4 : BA                             phi   R10                    ; and put it back
(1)  476/    18F5 : C0 17 EE                       lbr   fp_add                ; now just add
(1)  477/    18F8 :                     
(1)  478/    18F8 :                     ; ***************************************
(1)  479/    18F8 :                     ; *** Div 2 SP floating point numbers ***
(1)  480/    18F8 :                     ; *** R8:F9 - Arg 1                   ***
(1)  481/    18F8 :                     ; *** RA:FB - Arg 2                   ***
(1)  482/    18F8 :                     ; *** Returns: R8:F9 - Answer         ***
(1)  483/    18F8 :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  484/    18F8 :                     ; ***        RF.1 - exponent of arg2  ***
(1)  485/    18F8 :                     ; ***        F7.0 - signs        ***
(1)  486/    18F8 :                     ; ***************************************
(1)  487/    18F8 : 98                  fp_div:    ghi   r8                    ; check arg1 for zero
(1)  488/    18F9 : CA 19 09                       lbnz  div_a1nz
(1)  489/    18FC : 88                             glo   r8
(1)  490/    18FD : CA 19 09                       lbnz  div_a1nz
(1)  491/    1900 : 99                             ghi   F9
(1)  492/    1901 : CA 19 09                       lbnz  div_a1nz
(1)  493/    1904 : 89                             glo   F9
(1)  494/    1905 : CA 19 09                       lbnz  div_a1nz
(1)  495/    1908 : (MACRO)                        Cretn	                ; just return the zero
(1)  496/    1909 : 9A                  div_a1nz:  ghi   R10                    ; check arg2 for zero
(1)  497/    190A : CA 19 27                       lbnz  div_a2nz
(1)  498/    190D : 8A                             glo   R10
(1)  499/    190E : CA 19 27                       lbnz  div_a2nz
(1)  500/    1911 : 9B                             ghi   FB
(1)  501/    1912 : CA 19 27                       lbnz  div_a2nz
(1)  502/    1915 : 8B                             glo   FB
(1)  503/    1916 : CA 19 27                       lbnz  div_a2nz
(1)  504/    1919 : 98                             ghi   r8                    ; need sign of arg1
(1)  505/    191A : FA 80                          ani   080h                  ; want only sign
(1)  506/    191C : F9 7F                          ori   07fh                  ; exponent will be all ones
(1)  507/    191E : B8                             phi   r8                    ; put into answer
(1)  508/    191F : F8 80                          ldi   080h                  ; build rest of answer
(1)  509/    1921 : A8                             plo   r8 
(1)  510/    1922 : F8 00                          ldi   0
(1)  511/    1924 : B9                             phi   F9
(1)  512/    1925 : A9                             plo   F9
(1)  513/    1926 : (MACRO)                        Cretn                  	; and return to caller
(1)  514/    1927 :                     
(1)  515/    1927 : (MACRO)             div_a2nz:  pushr F7	;wjr save the C variable
(1)  516/    192C : (MACRO)             	   pushr R12	;wjr save param regs
(1)  517/    1931 : (MACRO)             	   pushr R13	;wjr
(1)  518/    1936 : 22                  	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
(1)  519/    1937 :                     
(1)  520/    1937 : (MACRO)             	   Ccall fp_getexp              ; get exponents
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 40 - 8/27/2014 11:16:27


(1)  521/    193A : (MACRO)                        Ccall fp_getsgn		; get signs
(1)  522/    193D : 8F                             glo   R15                    ; get exp2
(1)  523/    193E : FF 7F                          smi   127                   ; remove bias
(1)  524/    1940 : 52                             str   r2                    ; place into memory
(1)  525/    1941 : 9F                             ghi   R15                    ; get exp1
(1)  526/    1942 : FF 7F                          smi   127                   ; remove bias
(1)  527/    1944 : F7                             sm                          ; perform exp1 - exp2
(1)  528/    1945 : FC 7F                          adi   127                   ; put bias back in
(1)  529/    1947 : 73                             stxd                        ; save onto stack
(1)  530/    1948 : 87                             glo   F7                    ; determine sign for answer
(1)  531/    1949 : 52                             str   r2
(1)  532/    194A : F6                             shr
(1)  533/    194B : F3                             xor
(1)  534/    194C : 73                             stxd                        ; place onto stack
(1)  535/    194D : F8 00                          ldi   0                     ; setup man
(1)  536/    194F : BA                             phi   R10
(1)  537/    1950 : 8A                             glo   R10
(1)  538/    1951 : F9 80                          ori   080h
(1)  539/    1953 : AA                             plo   R10
(1)  540/    1954 : F8 00                          ldi   0                     ; setup div
(1)  541/    1956 : B8                             phi   r8
(1)  542/    1957 : 88                             glo   r8
(1)  543/    1958 : F9 80                          ori   080h
(1)  544/    195A : A8                             plo   r8
(1)  545/    195B : F8 00                          ldi   0                     ; setup result
(1)  546/    195D : BC                             phi   R12
(1)  547/    195E : AC                             plo   R12
(1)  548/    195F : B7                             phi   F7
(1)  549/    1960 : A7                             plo   F7
(1)  550/    1961 : AF                             plo   R15                    ; setup quotient
(1)  551/    1962 : BF                             phi   R15
(1)  552/    1963 : BD                             phi   R13
(1)  553/    1964 : AD                             plo   R13
(1)  554/    1965 : F8 80                          ldi   080h
(1)  555/    1967 : AF                             plo   R15
(1)  556/    1968 : 98                  div_lp:    ghi   r8                    ; check div for nonzero
(1)  557/    1969 : CA 19 7B                       lbnz  div_go1
(1)  558/    196C : 88                             glo   r8
(1)  559/    196D : CA 19 7B                       lbnz  div_go1
(1)  560/    1970 : 99                             ghi   F9
(1)  561/    1971 : CA 19 7B                       lbnz  div_go1
(1)  562/    1974 : 89                             glo   F9
(1)  563/    1975 : CA 19 7B                       lbnz  div_go1
(1)  564/    1978 : C0 19 DB                       lbr   div_z
(1)  565/    197B : 9A                  div_go1:   ghi   R10
(1)  566/    197C : CA 19 8E                       lbnz  div_go
(1)  567/    197F : 8A                             glo   R10
(1)  568/    1980 : CA 19 8E                       lbnz  div_go
(1)  569/    1983 : 9B                             ghi   FB
(1)  570/    1984 : CA 19 8E                       lbnz  div_go
(1)  571/    1987 : 8B                             glo   FB
(1)  572/    1988 : CA 19 8E                       lbnz  div_go
(1)  573/    198B : C0 19 DB                       lbr   div_z                 ; nothing more to do
(1)  574/    198E : 8B                  div_go:    glo   FB                    ; see if div > man
(1)  575/    198F : 52                             str   r2
(1)  576/    1990 : 89                             glo   F9
(1)  577/    1991 : F7                             sm
(1)  578/    1992 : 9B                             ghi   FB
(1)  579/    1993 : 52                             str   r2
(1)  580/    1994 : 99                             ghi   F9
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 41 - 8/27/2014 11:16:27


(1)  581/    1995 : 77                             smb
(1)  582/    1996 : 8A                             glo   R10
(1)  583/    1997 : 52                             str   r2
(1)  584/    1998 : 88                             glo   r8
(1)  585/    1999 : 77                             smb
(1)  586/    199A : 9A                             ghi   R10
(1)  587/    199B : 52                             str   r2
(1)  588/    199C : 98                             ghi   r8
(1)  589/    199D : 77                             smb
(1)  590/    199E : CB 19 C9                       lbnf  div_nope              ; jump if div was smaller
(1)  591/    19A1 : 8B                             glo   FB                    ; div -= man
(1)  592/    19A2 : 52                             str   r2
(1)  593/    19A3 : 89                             glo   F9
(1)  594/    19A4 : F7                             sm
(1)  595/    19A5 : A9                             plo   F9
(1)  596/    19A6 : 9B                             ghi   FB
(1)  597/    19A7 : 52                             str   r2
(1)  598/    19A8 : 99                             ghi   F9
(1)  599/    19A9 : 77                             smb
(1)  600/    19AA : B9                             phi   F9
(1)  601/    19AB : 8A                             glo   R10
(1)  602/    19AC : 52                             str   r2
(1)  603/    19AD : 88                             glo   r8
(1)  604/    19AE : 77                             smb
(1)  605/    19AF : A8                             plo   r8
(1)  606/    19B0 : 9A                             ghi   R10
(1)  607/    19B1 : 52                             str   r2
(1)  608/    19B2 : 98                             ghi   r8
(1)  609/    19B3 : 77                             smb
(1)  610/    19B4 : B8                             phi   r8
(1)  611/    19B5 : 9F                             ghi   R15                    ; merge quotient into result
(1)  612/    19B6 : 52                             str   r2
(1)  613/    19B7 : 9C                             ghi   R12
(1)  614/    19B8 : F1                             or
(1)  615/    19B9 : BC                             phi   R12
(1)  616/    19BA : 8F                             glo   R15
(1)  617/    19BB : 52                             str   r2
(1)  618/    19BC : 8C                             glo   R12
(1)  619/    19BD : F1                             or
(1)  620/    19BE : AC                             plo   R12
(1)  621/    19BF : 9D                             ghi   R13
(1)  622/    19C0 : 52                             str   r2
(1)  623/    19C1 : 97                             ghi   F7
(1)  624/    19C2 : F1                             or
(1)  625/    19C3 : B7                             phi   F7
(1)  626/    19C4 : 8D                             glo   R13
(1)  627/    19C5 : 52                             str   r2
(1)  628/    19C6 : 87                             glo   F7
(1)  629/    19C7 : F1                             or
(1)  630/    19C8 : A7                             plo   F7
(1)  631/    19C9 : D4                  div_nope:  sep   RCALL                 ; shift quotient right
(1)  632/    19CA : 17 A3                          dw    fp_shr_fd
(1)  633/    19CC : 9A                             ghi   R10                    ; shift divisor right
(1)  634/    19CD : F6                             shr
(1)  635/    19CE : BA                             phi   R10
(1)  636/    19CF : 8A                             glo   R10
(1)  637/    19D0 : 76                             shrc
(1)  638/    19D1 : AA                             plo   R10
(1)  639/    19D2 : 9B                             ghi   FB
(1)  640/    19D3 : 76                             shrc
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 42 - 8/27/2014 11:16:27


(1)  641/    19D4 : BB                             phi   FB
(1)  642/    19D5 : 8B                             glo   FB
(1)  643/    19D6 : 76                             shrc
(1)  644/    19D7 : AB                             plo   FB
(1)  645/    19D8 : C0 19 68                       lbr   div_lp                ; loop back until done
(1)  646/    19DB : 9C                  div_z:     ghi   R12                    ; move result to arg1
(1)  647/    19DC : B8                             phi   r8
(1)  648/    19DD : 8C                             glo   R12
(1)  649/    19DE : A8                             plo   r8
(1)  650/    19DF : 97                             ghi   F7
(1)  651/    19E0 : B9                             phi   F9
(1)  652/    19E1 : 87                             glo   F7
(1)  653/    19E2 : A9                             plo   F9
(1)  654/    19E3 : 60                             irx                         ; recover sign
(1)  655/    19E4 : 72                             ldxa
(1)  656/    19E5 : A7                             plo   F7
(1)  657/    19E6 : F0                             ldx                         ; recover answer exponent
(1)  658/    19E7 : BF                             phi   R15
(1)  659/    19E8 : C0 17 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  660/    19EB :                     
(1)  661/    19EB :                     ; ***************************************
(1)  662/    19EB :                     ; *** Mul 2 SP floating point numbers ***
(1)  663/    19EB :                     ; *** R8:F9 - Arg 1                   ***
(1)  664/    19EB :                     ; *** RA:FB - Arg 2                   ***
(1)  665/    19EB :                     ; *** Returns: R8:F9 - Answer         ***
(1)  666/    19EB :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  667/    19EB :                     ; ***        RF.1 - exponent of arg2  ***
(1)  668/    19EB :                     ; ***        F7.0 - signs             ***
(1)  669/    19EB :                     ; ***************************************
(1)  670/    19EB : (MACRO)             fp_mul:    pushr F7	;wjr save the C variable
(1)  671/    19F0 : (MACRO)             	   pushr R12	;wjr save param regs
(1)  672/    19F5 : (MACRO)             	   pushr R13	;wjr
(1)  673/    19FA : 22                  	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
(1)  674/    19FB :                     
(1)  675/    19FB : (MACRO)                        Ccall    fp_getexp	       ; get exponents
(1)  676/    19FE : (MACRO)                        Ccall    fp_getsgn            ; get signs
(1)  677/    1A01 : 8F                             glo   R15                    ; get exp2
(1)  678/    1A02 : FF 7F                          smi   127                   ; remove bias
(1)  679/    1A04 : 52                             str   r2                    ; place into memory
(1)  680/    1A05 : 9F                             ghi   R15                    ; get exp1
(1)  681/    1A06 : FF 7F                          smi   127                   ; remove bias
(1)  682/    1A08 : F4                             add                         ; add in exponent 2
(1)  683/    1A09 : FC 7F                          adi   127                   ; put bias back in
(1)  684/    1A0B : 73                             stxd                        ; place onto stack
(1)  685/    1A0C : 87                             glo   F7                    ; determine sign for answer
(1)  686/    1A0D : 52                             str   r2
(1)  687/    1A0E : F6                             shr
(1)  688/    1A0F : F3                             xor
(1)  689/    1A10 : 73                             stxd                        ; place onto stack
(1)  690/    1A11 : 9E                             ghi   R14                    ; get baud constant
(1)  691/    1A12 : 73                             stxd                        ; save on stack
(1)  692/    1A13 : 96                             ghi   r6                    ; save return position on stack
(1)  693/    1A14 : 73                             stxd
(1)  694/    1A15 : 86                             glo   r6
(1)  695/    1A16 : 73                             stxd
(1)  696/    1A17 : F8 00                          ldi   0                     ; initial value of ct
(1)  697/    1A19 : 73                             stxd
(1)  698/    1A1A : BE                             phi   R14                    ; set mulH to 0
(1)  699/    1A1B : AE                             plo   R14
(1)  700/    1A1C : B6                             phi   r6
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 43 - 8/27/2014 11:16:27


(1)  701/    1A1D : A6                             plo   r6
(1)  702/    1A1E : B8                             phi   r8                    ; mulL = arg1 & 0xffffff
(1)  703/    1A1F : 88                             glo   r8                    ; be sure high bit is set
(1)  704/    1A20 : F9 80                          ori   080h
(1)  705/    1A22 : A8                             plo   r8
(1)  706/    1A23 : F8 00                          ldi   0
(1)  707/    1A25 : BC                             phi   R12                    ; set result to 0
(1)  708/    1A26 : AC                             plo   R12
(1)  709/    1A27 : B7                             phi   F7
(1)  710/    1A28 : A7                             plo   F7
(1)  711/    1A29 : BF                             phi   R15
(1)  712/    1A2A : AF                             plo   R15
(1)  713/    1A2B : BD                             phi   R13
(1)  714/    1A2C : AD                             plo   R13
(1)  715/    1A2D : BA                             phi   R10                    ; arg2 &= 0ffffff
(1)  716/    1A2E : 8A                             glo   R10                    ; be sure high bit is set
(1)  717/    1A2F : F9 80                          ori   080h
(1)  718/    1A31 : AA                             plo   R10
(1)  719/    1A32 : 8B                  mul_lp1:   glo   FB                    ; check for zero multiplier
(1)  720/    1A33 : CA 1A 42                       lbnz  mul_go1               ; jump if not zero
(1)  721/    1A36 : 9B                             ghi   FB
(1)  722/    1A37 : CA 1A 42                       lbnz  mul_go1
(1)  723/    1A3A : 8A                             glo   R10
(1)  724/    1A3B : CA 1A 42                       lbnz  mul_go1
(1)  725/    1A3E : 9A                             ghi   R10
(1)  726/    1A3F : C2 1A BA                       lbz   mul_dn                ; jump if muliplier is zero
(1)  727/    1A42 : 9A                  mul_go1:   ghi   R10                    ; shift multiplier right
(1)  728/    1A43 : F6                             shr
(1)  729/    1A44 : BA                             phi   R10
(1)  730/    1A45 : 8A                             glo   R10
(1)  731/    1A46 : 76                             shrc
(1)  732/    1A47 : AA                             plo   R10
(1)  733/    1A48 : 9B                             ghi   FB
(1)  734/    1A49 : 76                             shrc
(1)  735/    1A4A : BB                             phi   FB
(1)  736/    1A4B : 8B                             glo   FB
(1)  737/    1A4C : 76                             shrc
(1)  738/    1A4D : AB                             plo   FB
(1)  739/    1A4E : CB 1A 8F                       lbnf  mul_no                ; jump if low bit was zero
(1)  740/    1A51 : 89                             glo   F9                    ; res += mul
(1)  741/    1A52 : 52                             str   r2
(1)  742/    1A53 : 87                             glo   F7
(1)  743/    1A54 : F4                             add
(1)  744/    1A55 : A7                             plo   F7
(1)  745/    1A56 : 99                             ghi   F9
(1)  746/    1A57 : 52                             str   r2
(1)  747/    1A58 : 97                             ghi   F7
(1)  748/    1A59 : 74                             adc
(1)  749/    1A5A : B7                             phi   F7
(1)  750/    1A5B : 88                             glo   r8
(1)  751/    1A5C : 52                             str   r2
(1)  752/    1A5D : 8C                             glo   R12
(1)  753/    1A5E : 74                             adc
(1)  754/    1A5F : AC                             plo   R12
(1)  755/    1A60 : 98                             ghi   r8
(1)  756/    1A61 : 52                             str   r2
(1)  757/    1A62 : 9C                             ghi   R12
(1)  758/    1A63 : 74                             adc
(1)  759/    1A64 : BC                             phi   R12
(1)  760/    1A65 : 86                             glo   r6                    ; now high 32 bits
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 44 - 8/27/2014 11:16:27


(1)  761/    1A66 : 52                             str   r2
(1)  762/    1A67 : 8D                             glo   R13
(1)  763/    1A68 : F4                             add
(1)  764/    1A69 : AD                             plo   R13
(1)  765/    1A6A : 96                             ghi   r6
(1)  766/    1A6B : 52                             str   r2
(1)  767/    1A6C : 96                             ghi   r6
(1)  768/    1A6D : 52                             str   r2
(1)  769/    1A6E : 9D                             ghi   R13
(1)  770/    1A6F : 74                             adc
(1)  771/    1A70 : BD                             phi   R13
(1)  772/    1A71 : 8E                             glo   R14
(1)  773/    1A72 : 52                             str   r2
(1)  774/    1A73 : 8F                             glo   R15
(1)  775/    1A74 : 74                             adc
(1)  776/    1A75 : AF                             plo   R15
(1)  777/    1A76 : 9E                             ghi   R14
(1)  778/    1A77 : 52                             str   r2
(1)  779/    1A78 : 9F                             ghi   R15
(1)  780/    1A79 : 74                             adc
(1)  781/    1A7A : BF                             phi   R15
(1)  782/    1A7B : 9C                             ghi   R12                    ; see if need carry from low to high
(1)  783/    1A7C : C2 1A 8F                       lbz   mul_no                ; jump if no carry is needed
(1)  784/    1A7F : 8D                             glo   R13                    ; move the carry on over
(1)  785/    1A80 : FC 01                          adi   1
(1)  786/    1A82 : AD                             plo   R13
(1)  787/    1A83 : 9D                             ghi   R13
(1)  788/    1A84 : 7C 00                          adci  0
(1)  789/    1A86 : BD                             phi   R13
(1)  790/    1A87 : 8F                             glo   R15
(1)  791/    1A88 : 7C 00                          adci  0
(1)  792/    1A8A : AF                             plo   R15
(1)  793/    1A8B : 9F                             ghi   R15
(1)  794/    1A8C : 7C 00                          adci  0
(1)  795/    1A8E : BF                             phi   R15
(1)  796/    1A8F : 60                  mul_no:    irx                         ; recover ct
(1)  797/    1A90 : F0                             ldx
(1)  798/    1A91 : FC 01                          adi   1                     ; increment by 1
(1)  799/    1A93 : 73                             stxd                        ; and put it back
(1)  800/    1A94 : 89                             glo   F9                    ; shift mulL left
(1)  801/    1A95 : FE                             shl
(1)  802/    1A96 : A9                             plo   F9
(1)  803/    1A97 : 99                             ghi   F9
(1)  804/    1A98 : 7E                             shlc
(1)  805/    1A99 : B9                             phi   F9
(1)  806/    1A9A : 88                             glo   r8
(1)  807/    1A9B : 7E                             shlc
(1)  808/    1A9C : A8                             plo   r8
(1)  809/    1A9D : 98                             ghi   r8
(1)  810/    1A9E : 7E                             shlc
(1)  811/    1A9F : B8                             phi   r8
(1)  812/    1AA0 : 86                             glo   r6                    ; shift mulH left
(1)  813/    1AA1 : FE                             shl
(1)  814/    1AA2 : A6                             plo   r6
(1)  815/    1AA3 : 96                             ghi   r6
(1)  816/    1AA4 : 7E                             shlc
(1)  817/    1AA5 : B6                             phi   r6
(1)  818/    1AA6 : 8E                             glo   R14
(1)  819/    1AA7 : 7E                             shlc
(1)  820/    1AA8 : AE                             plo   R14
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 45 - 8/27/2014 11:16:27


(1)  821/    1AA9 : 9E                             ghi   R14
(1)  822/    1AAA : 7E                             shlc
(1)  823/    1AAB : BE                             phi   R14
(1)  824/    1AAC : 98                             ghi   r8                    ; see if a carry is needed
(1)  825/    1AAD : C2 1A 32                       lbz   mul_lp1               ; jump if not
(1)  826/    1AB0 : F8 00                          ldi   0                     ; zero the high byte
(1)  827/    1AB2 : B8                             phi   r8
(1)  828/    1AB3 : 86                             glo   r6                    ; add in the carry
(1)  829/    1AB4 : F9 01                          ori   1
(1)  830/    1AB6 : A6                             plo   r6
(1)  831/    1AB7 : C0 1A 32                       lbr   mul_lp1               ; loop back for more
(1)  832/    1ABA : 60                  mul_dn:    irx                         ; recover ct
(1)  833/    1ABB : 72                             ldxa
(1)  834/    1ABC : AE                             plo   R14                    ; set aside
(1)  835/    1ABD : 72                             ldxa
(1)  836/    1ABE : A6                             plo   r6
(1)  837/    1ABF : 72                             ldxa
(1)  838/    1AC0 : B6                             phi   r6
(1)  839/    1AC1 : F0                             ldx
(1)  840/    1AC2 : BE                             phi   R14
(1)  841/    1AC3 : 9C                             ghi   R12                    ; transfer resL to arg1
(1)  842/    1AC4 : B8                             phi   r8
(1)  843/    1AC5 : 8C                             glo   R12
(1)  844/    1AC6 : A8                             plo   r8
(1)  845/    1AC7 : 97                             ghi   F7
(1)  846/    1AC8 : B9                             phi   F9
(1)  847/    1AC9 : 87                             glo   F7
(1)  848/    1ACA : A9                             plo   F9
(1)  849/    1ACB : 8E                             glo   R14
(1)  850/    1ACC : AC                             plo   R12                    ; put ct into RC.0
(1)  851/    1ACD : 8C                  mul_lp2:   glo   R12                    ; get ct
(1)  852/    1ACE : FF 02                          smi   2                     ; see if <2
(1)  853/    1AD0 : CB 1A E4                       lbnf  mul_nxt1              ; jump if so
(1)  854/    1AD3 : D4                             sep   RCALL                 ; shift answer to the right
(1)  855/    1AD4 : 17 72                          dw    fp_shr_1
(1)  856/    1AD6 : D4                             sep   RCALL                 ; shift resH right
(1)  857/    1AD7 : 17 A3                          dw    fp_shr_fd
(1)  858/    1AD9 : CB 1A E0                       lbnf  mul_lp2a              ; jump if no carry into low word
(1)  859/    1ADC : 88                             glo   r8                    ; set high bit
(1)  860/    1ADD : F9 80                          ori   080h
(1)  861/    1ADF : A8                             plo   r8
(1)  862/    1AE0 : 2C                  mul_lp2a:  dec   R12                    ; decrement count
(1)  863/    1AE1 : C0 1A CD                       lbr   mul_lp2               ; loop back to keep checking
(1)  864/    1AE4 : 60                  mul_nxt1:  irx                         ; recover sign
(1)  865/    1AE5 : 72                             ldxa
(1)  866/    1AE6 : A7                             plo   F7
(1)  867/    1AE7 : F0                             ldx                         ; recover answer exponent
(1)  868/    1AE8 : AC                             plo   R12
(1)  869/    1AE9 : 9F                  mul_lp3:   ghi   R15                    ; check resH for nonzero
(1)  870/    1AEA : CA 1A FC                       lbnz  mul_lp3a
(1)  871/    1AED : 8F                             glo   R15
(1)  872/    1AEE : CA 1A FC                       lbnz  mul_lp3a
(1)  873/    1AF1 : 9D                             ghi   R13
(1)  874/    1AF2 : CA 1A FC                       lbnz  mul_lp3a
(1)  875/    1AF5 : 8D                             glo   R13
(1)  876/    1AF6 : CA 1A FC                       lbnz  mul_lp3a
(1)  877/    1AF9 : C0 1B 0D                       lbr   mul_lp4               ; jump if no bits set in resH
(1)  878/    1AFC : 1C                  mul_lp3a:  inc   R12                    ; increment exponent
(1)  879/    1AFD : (MACRO)                        Ccall fp_shr_1                ; shift answer to the right
(1)  880/    1B00 : (MACRO)                        Ccall fp_shr_fd               ; shift resH right
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 46 - 8/27/2014 11:16:27


(1)  881/    1B03 : CB 1A E9                       lbnf  mul_lp3               ; jump if no carry into low word
(1)  882/    1B06 : 88                             glo   r8                    ; set high bit
(1)  883/    1B07 : F9 80                          ori   080h
(1)  884/    1B09 : A8                             plo   r8
(1)  885/    1B0A : C0 1A E9                       lbr   mul_lp3
(1)  886/    1B0D : 8C                  mul_lp4:   glo   R12                    ; transfer exponent
(1)  887/    1B0E : BF                             phi   R15                    ; to high R15
(1)  888/    1B0F : C0 17 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  889/    1B12 :                     
(1)  890/    1B12 :                     ; ***************************************
(1)  891/    1B12 :                     ; *** Convert ascii to floating point ***
(1)  892/    1B12 :                     ; *** RF - buffer to ascii text       ***
(1)  893/    1B12 :                     ; *** Returns: R8:F9 - number         ***
(1)  894/    1B12 :                     ; ***************************************
(1)  895/    1B12 : 4F                  fp_atof:   lda   R15                    ; get byte from buffer
(1)  896/    1B13 : FF 20                          smi   ' '                   ; check for space
(1)  897/    1B15 : C2 1B 12                       lbz   fp_atof               ; move past any spaces
(1)  898/    1B18 : 2F                             dec   R15                    ; point back to nonspace chara
(1)  899/    1B19 : 0F                             ldn   R15                    ; check for possible sign
(1)  900/    1B1A : FF 2D                          smi   '-'                   ; first check for minus
(1)  901/    1B1C : CA 1B 26                       lbnz   atof_nm              ; jump if not minus
(1)  902/    1B1F : F8 80                          ldi   080h                  ; high bit set for minus
(1)  903/    1B21 : 73                             stxd                        ; place onto stack
(1)  904/    1B22 : 1F                             inc   R15                    ; move past sign
(1)  905/    1B23 : C0 1B 30                       lbr   atof_go1              ; and continue
(1)  906/    1B26 : F8 00               atof_nm:   ldi   0                     ; indicate positive number
(1)  907/    1B28 : 73                             stxd                        ; place onto stack
(1)  908/    1B29 : 0F                             ldn   R15                    ; now check for + sign
(1)  909/    1B2A : FF 2B                          smi   '+'
(1)  910/    1B2C : CA 1B 30                       lbnz  atof_go1              ; jump if not plus
(1)  911/    1B2F : 1F                             inc   R15                    ; move past plus sign
(1)  912/    1B30 : F8 00               atof_go1:  ldi   0                     ; setup result
(1)  913/    1B32 : B8                             phi   r8
(1)  914/    1B33 : A8                             plo   r8
(1)  915/    1B34 : B9                             phi   F9
(1)  916/    1B35 : A9                             plo   F9
(1)  917/    1B36 : 0F                  atof_lp1:  ldn   R15                    ; get next byte from buffer
(1)  918/    1B37 : (MACRO)                        Ccall f_isnum                ; is it numeric
(1)  919/    1B3A : CB 1B 67                       lbnf  atof_no1              ; jump if not
(1)  920/    1B3D : 98                             ghi   r8                    ; copy arg1 to arg2
(1)  921/    1B3E : BA                             phi   R10
(1)  922/    1B3F : 88                             glo   r8
(1)  923/    1B40 : AA                             plo   R10
(1)  924/    1B41 : 99                             ghi   F9
(1)  925/    1B42 : BB                             phi   FB
(1)  926/    1B43 : 89                             glo   F9
(1)  927/    1B44 : AB                             plo   FB
(1)  928/    1B45 : (MACRO)                        Ccall fp_shl_1                ; multiply arg1 by 2
(1)  929/    1B48 : (MACRO)                        Ccall fp_shl_1                 ; multiply arg1 by 4
(1)  930/    1B4B : (MACRO)                        Ccall fp_add_12                ; multiply arg1 by 5
(1)  931/    1B4E : (MACRO)                        Ccall fp_shl_1                ; multiply arg1 by 10
(1)  932/    1B51 : 4F                             lda   R15                    ; get number
(1)  933/    1B52 : FF 30                          smi   '0'                   ; convert to binary
(1)  934/    1B54 : 52                             str   r2                    ; setup for add
(1)  935/    1B55 : 89                             glo   F9                    ; add in next digit
(1)  936/    1B56 : F4                             add
(1)  937/    1B57 : A9                             plo   F9
(1)  938/    1B58 : 99                             ghi   F9                    ; propagate carry
(1)  939/    1B59 : 7C 00                          adci  0
(1)  940/    1B5B : B9                             phi   F9
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 47 - 8/27/2014 11:16:27


(1)  941/    1B5C : 88                             glo   r8
(1)  942/    1B5D : 7C 00                          adci  0
(1)  943/    1B5F : A8                             plo   r8
(1)  944/    1B60 : 98                             ghi   r8
(1)  945/    1B61 : 7C 00                          adci  0
(1)  946/    1B63 : B8                             phi   r8
(1)  947/    1B64 : C0 1B 36                       lbr   atof_lp1              ; loop until no more digits
(1)  948/    1B67 : 0F                  atof_no1:  ldn   R15                    ; check for decimal point
(1)  949/    1B68 : FF 2E                          smi   '.'
(1)  950/    1B6A : CA 1B 6E                       lbnz  atof_ndp              ; jump if none
(1)  951/    1B6D : 1F                             inc   R15                    ; move past decimal
(1)  952/    1B6E : F8 1C               atof_ndp:  ldi   scratch>>8          ; point to scratch area
(1)  953/    1B70 : BA                             phi   R10
(1)  954/    1B71 : F8 A3                          ldi   scratch&255
(1)  955/    1B73 : AA                             plo   R10
(1)  956/    1B74 : F8 10                          ldi   16                    ; 16 bytes to clear
(1)  957/    1B76 : AC                             plo   R12
(1)  958/    1B77 : F8 00               atof_lpx:  ldi   0
(1)  959/    1B79 : 5A                             str   R10
(1)  960/    1B7A : 1A                             inc   R10
(1)  961/    1B7B : 2C                             dec   R12
(1)  962/    1B7C : 8C                             glo   R12
(1)  963/    1B7D : CA 1B 77                       lbnz  atof_lpx
(1)  964/    1B80 : F8 1C                          ldi   (scratch+1)>>8      ; point to scratch area
(1)  965/    1B82 : BA                             phi   R10
(1)  966/    1B83 : F8 A4                          ldi   (scratch+1)&255
(1)  967/    1B85 : AA                             plo   R10
(1)  968/    1B86 : F8 01                          ldi   1                     ; setup count
(1)  969/    1B88 : AC                             plo   R12
(1)  970/    1B89 : F8 00                          ldi   0                     ; setup exp flag
(1)  971/    1B8B : BC                             phi   R12
(1)  972/    1B8C : 8C                  atof_lp2:  glo   R12                    ; see if done making bcd
(1)  973/    1B8D : FF 11                          smi   17
(1)  974/    1B8F : C2 1B A8                       lbz   atof_dn3              ; jump if so
(1)  975/    1B92 : 0F                             ldn   R15                    ; get character
(1)  976/    1B93 : D4                             sep   RCALL                 ; is it numeric
(1)  977/    1B94 : 17 62                          dw    f_isnum
(1)  978/    1B96 : CB 1B A8                       lbnf  atof_dn3              ; jump if not
(1)  979/    1B99 : 4F                             lda   R15                    ; get character
(1)  980/    1B9A : FF 30                          smi   '0'                   ; converto to binary
(1)  981/    1B9C : 5A                             str   R10                    ; write into bcd area
(1)  982/    1B9D : 1A                             inc   R10
(1)  983/    1B9E : 1C                             inc   R12                    ; increment count
(1)  984/    1B9F : CA 1B 8C                       lbnz  atof_lp2              ; loop back until done
(1)  985/    1BA2 : F8 01                          ldi   1                     ; set non zero flag
(1)  986/    1BA4 : BC                             phi   R12
(1)  987/    1BA5 : C0 1B 8C                       lbr   atof_lp2
(1)  988/    1BA8 : 9C                  atof_dn3:  ghi   R12                    ; check for non-zero digits
(1)  989/    1BA9 : CA 1B C2                       lbnz  atof_nz
(1)  990/    1BAC : 98                             ghi   r8                    ; check for non-zero integer
(1)  991/    1BAD : CA 1B C2                       lbnz  atof_nz
(1)  992/    1BB0 : 88                             glo   r8
(1)  993/    1BB1 : CA 1B C2                       lbnz  atof_nz
(1)  994/    1BB4 : 99                             ghi   F9
(1)  995/    1BB5 : CA 1B C2                       lbnz  atof_nz
(1)  996/    1BB8 : 89                             glo   F9
(1)  997/    1BB9 : CA 1B C2                       lbnz  atof_nz
(1)  998/    1BBC : 60                             irx                         ; recover sign
(1)  999/    1BBD : F0                             ldx
(1) 1000/    1BBE : B8                             phi   r8                    ; put in high of zero
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 48 - 8/27/2014 11:16:27


(1) 1001/    1BBF : C0 1C 95                       lbr	atof_end               ; and return
(1) 1002/    1BC2 : F8 00               atof_nz:   ldi   0                     ; setup dp
(1) 1003/    1BC4 : BC                             phi   R12
(1) 1004/    1BC5 : 98                  atof_lp3:  ghi   r8                    ; check for high bit set
(1) 1005/    1BC6 : FA 80                          ani   080h
(1) 1006/    1BC8 : CA 1C 12                       lbnz  atof_dn4              ; jump if so
(1) 1007/    1BCB : (MACRO)                        Ccall fp_shl_1                ; shift answer left
(1) 1008/    1BCE : F8 1C                          ldi   scratch>>8          ; point to bcd number
(1) 1009/    1BD0 : BA                             phi   R10
(1) 1010/    1BD1 : F8 A3                          ldi   255&scratch
(1) 1011/    1BD3 : AA                             plo   R10
(1) 1012/    1BD4 : F8 00                          ldi   0                     ; set high byte to zero
(1) 1013/    1BD6 : 5A                             str   R10
(1) 1014/    1BD7 : F8 1C                          ldi   (scratch+15)>>8     ; point to last cell
(1) 1015/    1BD9 : BA                             phi   R10
(1) 1016/    1BDA : F8 B2                          ldi   255&(scratch+15)
(1) 1017/    1BDC : AA                             plo   R10
(1) 1018/    1BDD : F8 00                          ldi   0                     ; set carry forward
(1) 1019/    1BDF : AE                             plo   R14
(1) 1020/    1BE0 : F8 10                          ldi   16                    ; setup count
(1) 1021/    1BE2 : AC                             plo   R12
(1) 1022/    1BE3 : 8E                  atof_lp4:  glo   R14                    ; get carry
(1) 1023/    1BE4 : 52                             str   r2                    ; in memory for add
(1) 1024/    1BE5 : 0A                             ldn   R10                    ; get bcd digit
(1) 1025/    1BE6 : F4                             add                         ; add in carry
(1) 1026/    1BE7 : 52                             str   r2                    ; place into memory
(1) 1027/    1BE8 : 0A                             ldn   R10                    ; recover bcd digit
(1) 1028/    1BE9 : F4                             add                         ; digit now doubled with carry
(1) 1029/    1BEA : 5A                             str   R10                    ; put it back
(1) 1030/    1BEB : FF 0A                          smi   10
(1) 1031/    1BED : CB 1B F4                       lbnf  atof_no4              ; jump if below 10
(1) 1032/    1BF0 : 5A                             str   R10                    ; store value - 10
(1) 1033/    1BF1 : F8 01                          ldi   1                     ; carry set to 1
(1) 1034/    1BF3 : C8                             lskp                        ; skip next instruction
(1) 1035/    1BF4 : F8 00               atof_no4:  ldi   0                     ; reset carry
(1) 1036/    1BF6 : AE                             plo   R14
(1) 1037/    1BF7 : 2A                             dec   R10                    ; move to previous digit
(1) 1038/    1BF8 : 2C                             dec   R12                    ; decrement digit count
(1) 1039/    1BF9 : 8C                             glo   R12                    ; see if done
(1) 1040/    1BFA : CA 1B E3                       lbnz  atof_lp4              ; jump if not
(1) 1041/    1BFD : F8 1C                          ldi   scratch>>8	       ; point to first digit
(1) 1042/    1BFF : BA                             phi   R10
(1) 1043/    1C00 : F8 A3                          ldi   255&scratch
(1) 1044/    1C02 : AA                             plo   R10
(1) 1045/    1C03 : 0A                             ldn   R10                    ; retrieve it
(1) 1046/    1C04 : C2 1C 0B                       lbz   atof_nc4              ; jump if no carry
(1) 1047/    1C07 : 89                             glo   F9                    ; add in the carry
(1) 1048/    1C08 : F9 01                          ori   1
(1) 1049/    1C0A : A9                             plo   F9
(1) 1050/    1C0B : 9C                  atof_nc4:  ghi   R12                    ; increment dp
(1) 1051/    1C0C : FC 01                          adi   1
(1) 1052/    1C0E : BC                             phi   R12
(1) 1053/    1C0F : C0 1B C5                       lbr   atof_lp3              ; loop until full
(1) 1054/    1C12 : 9C                  atof_dn4:  ghi   R12                    ; get dp
(1) 1055/    1C13 : 52                             str   r2                    ; into memory
(1) 1056/    1C14 : F8 1F                          ldi   31                    ; need to subtract from 31
(1) 1057/    1C16 : F7                             sm
(1) 1058/    1C17 : FC 7F                          adi   127                   ; add in bias
(1) 1059/    1C19 : BD                             phi   R13                    ; set aside
(1) 1060/    1C1A : 99                             ghi   F9                    ; shift result down 8 bits
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 49 - 8/27/2014 11:16:27


(1) 1061/    1C1B : A9                             plo   F9
(1) 1062/    1C1C : 88                             glo   r8
(1) 1063/    1C1D : B9                             phi   F9
(1) 1064/    1C1E : 98                             ghi   r8
(1) 1065/    1C1F : FE                             shl                         ; shift out high bit
(1) 1066/    1C20 : A8                             plo   r8
(1) 1067/    1C21 : 9D                             ghi   R13                    ; get bit 0 of exponent
(1) 1068/    1C22 : F6                             shr
(1) 1069/    1C23 : B8                             phi   r8                    ; bits 1-7 into high byte
(1) 1070/    1C24 : 88                             glo   r8                    ; get mantissa
(1) 1071/    1C25 : 76                             shrc                        ; shift in bit 0 of exponent
(1) 1072/    1C26 : A8                             plo   r8                    ; and write it
(1) 1073/    1C27 : 60                             irx                         ; point to sign
(1) 1074/    1C28 : 98                             ghi   r8                    ; high byte
(1) 1075/    1C29 : F1                             or                          ; set sign
(1) 1076/    1C2A : B8                             phi   r8                    ; done with base conversion
(1) 1077/    1C2B : 0F                             ldn   R15                    ; get next byte
(1) 1078/    1C2C : FF 65                          smi   'e'                   ; check for exponents
(1) 1079/    1C2E : C2 1C 37                       lbz   atof_exp
(1) 1080/    1C31 : 0F                             ldn   R15
(1) 1081/    1C32 : FF 45                          smi   'E'
(1) 1082/    1C34 : CA 1C 95                       lbnz  atof_end
(1) 1083/    1C37 : 1F                  atof_exp:  inc   R15                    ; move past E
(1) 1084/    1C38 : 0F                             ldn   R15                    ; check for sign
(1) 1085/    1C39 : FF 2D                          smi   '-'
(1) 1086/    1C3B : C2 1C 48                       lbz   atof_n
(1) 1087/    1C3E : 0F                             ldn   R15
(1) 1088/    1C3F : FF 2B                          smi   '+'
(1) 1089/    1C41 : C2 1C 45                       lbz   atof_p
(1) 1090/    1C44 : 2F                             dec   R15                    ; positive if no sign
(1) 1091/    1C45 : F8 01               atof_p:    ldi   1                     ; indicate positive exponent
(1) 1092/    1C47 : C8                             lskp
(1) 1093/    1C48 : F8 00               atof_n:    ldi   0                     ; indicate negative exponent
(1) 1094/    1C4A : BC                             phi   R12                    ; place into sign variable
(1) 1095/    1C4B : 1F                             inc   R15                    ; move past sign
(1) 1096/    1C4C : F8 00                          ldi   0                     ; setup intial count
(1) 1097/    1C4E : AC                             plo   R12
(1) 1098/    1C4F : 0F                  atof_lp5:  ldn   R15                    ; get next byte
(1) 1099/    1C50 : (MACRO)                        Ccall f_isnum                ; see if numeric
(1) 1100/    1C53 : CB 1C 65                       lbnf  atof_dn5              ; jump if not
(1) 1101/    1C56 : 8C                             glo   R12                    ; make copy of exponent
(1) 1102/    1C57 : 52                             str   r2
(1) 1103/    1C58 : F6                             shr                         ; multiply by 2
(1) 1104/    1C59 : F6                             shr                         ; by 4
(1) 1105/    1C5A : F4                             add                         ; by 5
(1) 1106/    1C5B : F6                             shr                         ; by 10
(1) 1107/    1C5C : 52                             str   r2                    ; put here for add
(1) 1108/    1C5D : 4F                             lda   R15                    ; recover number
(1) 1109/    1C5E : FF 30                          smi   '0'                   ; convert to binary
(1) 1110/    1C60 : F4                             add                         ; add with total
(1) 1111/    1C61 : AC                             plo   R12                    ; copy back to R12
(1) 1112/    1C62 : C0 1C 4F                       lbr   atof_lp5              ; loop back until done reading exponent
(1) 1113/    1C65 : 8C                  atof_dn5:  glo   R12                    ; see if done
(1) 1114/    1C66 : C2 1C 95                       lbz   atof_end              ; jump if so
(1) 1115/    1C69 : 2C                             dec   R12                    ; otherwise decrement count
(1) 1116/    1C6A : 8C                             glo   R12                    ; save count
(1) 1117/    1C6B : 73                             stxd
(1) 1118/    1C6C : 9C                             ghi   R12                    ; save sign
(1) 1119/    1C6D : 73                             stxd
(1) 1120/    1C6E : 8F                             glo   R15
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(LCC1802fp.inc) - page 50 - 8/27/2014 11:16:27


(1) 1121/    1C6F : 73                             stxd
(1) 1122/    1C70 : 9F                             ghi   R15
(1) 1123/    1C71 : 73                             stxd
(1) 1124/    1C72 : F8 41                          ldi   041h                  ; setup 10.0
(1) 1125/    1C74 : BA                             phi   R10
(1) 1126/    1C75 : F8 20                          ldi   020h
(1) 1127/    1C77 : AA                             plo   R10
(1) 1128/    1C78 : F8 00                          ldi   0
(1) 1129/    1C7A : BB                             phi   FB
(1) 1130/    1C7B : AB                             plo   FB
(1) 1131/    1C7C : 9C                             ghi   R12
(1) 1132/    1C7D : C2 1C 86                       lbz   atof_div              ; jump if negative
(1) 1133/    1C80 : (MACRO)                        Ccall fp_mul                 ; multiply by 10
(1) 1134/    1C83 : C0 1C 89                       lbr   atof_go5              ; clean up call
(1) 1135/    1C86 : (MACRO)             atof_div:  Ccall fp_div                 ; divice by 10
(1) 1136/    1C89 : 60                  atof_go5:  irx                         ; recover variables
(1) 1137/    1C8A : 72                             ldxa
(1) 1138/    1C8B : BF                             phi   R15
(1) 1139/    1C8C : 72                             ldxa
(1) 1140/    1C8D : AF                             plo   R15
(1) 1141/    1C8E : 72                             ldxa
(1) 1142/    1C8F : BC                             phi   R12
(1) 1143/    1C90 : F0                             ldx
(1) 1144/    1C91 : AC                             plo   R12
(1) 1145/    1C92 : C0 1C 65                       lbr   atof_dn5              ; loop until exponent is zero
(1) 1146/    1C95 :                     atof_end:
(1) 1147/    1C95 : 12                  	   inc	r2	;wjr release work area
(1) 1148/    1C96 : (MACRO)             	   popr R13	;wjr restore param regs
(1) 1149/    1C9A : (MACRO)             	   popr R12	;wjr
(1) 1150/    1C9E : (MACRO)             	   popr	F7	;wjr restore c variable
(1) 1151/    1CA2 : (MACRO)             	   Cretn
(1) 1152/    1CA3 : 00 00               scratch:   db	00,00
    1285/    1CA5 :                     	include IO1802.inc
(1)    1/    1CA5 :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/    1CA5 :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/    1CA5 :                     	align 64
(1)    4/    1CC0 :                     _putc:
(1)    5/    1CC0 :                     _out5:	
(1)    6/    1CC0 : 8C                  	glo	regArg1
(1)    7/    1CC1 : 22                  	dec	sp
(1)    8/    1CC2 : 52                  	str	sp
(1)    9/    1CC3 : 65                  	out	5
(1)   10/    1CC4 : (MACRO)             	Cretn
(1)   11/    1CC5 :                     _inp:		;raw port input
(1)   12/    1CC5 :                     		;stores a small tailored program on the stack and executes it
(1)   13/    1CC5 : 22                  	dec	sp	;work backwards
(1)   14/    1CC6 : F8 D3               	ldi	0xD3	;return instruction
(1)   15/    1CC8 : 73                  	stxd		
(1)   16/    1CC9 : 8C                  	glo	regarg1	;get the port number
(1)   17/    1CCA : FA 07               	ani	0x07	;clean it
(1)   18/    1CCC : 32 DC               	bz	+	; inp(0) isn't valid
(1)   19/    1CCE : F9 68               	ori	0x68	;make it an input instruction
(1)   20/    1CD0 : 73                  	stxd		;store it for execution
(1)   21/    1CD1 : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   22/    1CD5 : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   23/    1CD6 : D8                  	sep	rt1	;execute it
(1)   24/    1CD7 :                     ;we will come back to here with the input byte in D
(1)   25/    1CD7 : 12                  	inc	sp	;step over the work area
(1)   26/    1CD8 : AF                  	plo	retVal	;save it to return
(1)   27/    1CD9 : F8 00               	ldi	0
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm(IO1802.inc) - page 51 - 8/27/2014 11:16:27


(1)   28/    1CDB : BF                  	phi	retval	;clear top byte
(1)   29/    1CDC : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   30/    1CDD : 12                  	inc	sp	;and the D3
(1)   31/    1CDE : (MACRO)             	Cretn		;and we're done
(1)   32/    1CDF :                     	
(1)   33/    1CDF :                     _out:		;raw port output
(1)   34/    1CDF :                     		;stores a small tailored program on the stack and executes it
(1)   35/    1CDF :                     		;this could be bolder:
(1)   36/    1CDF :                     		;store the program as 6x cc D5 where x is the port number and cc is the char
(1)   37/    1CDF :                     		;then SEP sp
(1)   38/    1CDF :                     		;the D5 would return to the calling program and finish fixing the stack.
(1)   39/    1CDF :                     		;saves 6 instrucrions but it's a bit tricky.
(1)   40/    1CDF : 22                  	dec	sp	;work backwards
(1)   41/    1CE0 : F8 D3               	ldi	0xD3	;return instruction
(1)   42/    1CE2 : 73                  	stxd		
(1)   43/    1CE3 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the OUT instruction
(1)   44/    1CE7 : 8C                  	glo	regarg1	;get the port number
(1)   45/    1CE8 : FA 07               	ani	0x07	;clean it
(1)   46/    1CEA : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   47/    1CEC : 73                  	stxd		;store it for execution
(1)   48/    1CED : 8D                  	glo	regarg2	;get the byte to be written
(1)   49/    1CEE : 52                  	str	sp	;store it where sp points
(1)   50/    1CEF : D8                  	sep	rt1	;execute it
(1)   51/    1CF0 :                     ;we will come back to here with sp stepped up by one
(1)   52/    1CF0 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   53/    1CF1 : 12                  	inc	sp	;and the D3
(1)   54/    1CF2 : (MACRO)             	Cretn		;and we're done
(1)   55/    1CF3 :                     	
(1)   56/    1CF3 :                     	
    1286/    1CF3 :                     
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 52 - 8/27/2014 11:16:27


  symbol table (* = unused):
  ------------------------

 ADD_A1NZ :                    1807 C |  ADD_A2NZ :                    1818 C |
 ADD_FNL :                     18BF C |  ADD_LP1 :                     1862 C |
 ADD_LP1DN :                   1877 C |  ADD_NM :                      1886 C |
 ADD_NO :                      18A8 C |  ADD_NS :                      1850 C |
 ADD_NX :                      18EB C |  ADD_NZ :                      18DD C |
 AGAIN204 :                    126B C | *ARCHITECTURE :  i386-unknown-win32 - |
 ATOF_DIV :                    1C86 C |  ATOF_DN3 :                    1BA8 C |
 ATOF_DN4 :                    1C12 C |  ATOF_DN5 :                    1C65 C |
 ATOF_END :                    1C95 C |  ATOF_EXP :                    1C37 C |
 ATOF_GO1 :                    1B30 C |  ATOF_GO5 :                    1C89 C |
 ATOF_LP1 :                    1B36 C |  ATOF_LP2 :                    1B8C C |
 ATOF_LP3 :                    1BC5 C |  ATOF_LP4 :                    1BE3 C |
 ATOF_LP5 :                    1C4F C |  ATOF_LPX :                    1B77 C |
 ATOF_N :                      1C48 C |  ATOF_NC4 :                    1C0B C |
 ATOF_NDP :                    1B6E C |  ATOF_NM :                     1B26 C |
 ATOF_NO1 :                    1B67 C |  ATOF_NO4 :                    1BF4 C |
 ATOF_NZ :                     1BC2 C |  ATOF_P :                      1C45 C |
*BIGENDIAN :                      0 - |  BITLOOP209 :                  14B8 C |
*BRANCHEXT :                      0 - |  BVTABLE76 :                    49F C |
*CASESENSITIVE :                  0 - |  CHECK_SUB207 :                1396 C |
 CKNEXT209 :                   1507 C |  CKTOP209 :                    14A3 C |
 CLRLP209 :                    1494 C |  COMPUTEQUOT204 :              1281 C |
*CONSTPI :        3.141592653589793 - |  CVFI4 :                       1700 C |
 CVIF4 :                       1600 C | *DATE :                   8/27/2014 - |
 DCKLP209 :                    14BB C |  DIV_A1NZ :                    1909 C |
 DIV_A2NZ :                    1927 C |  DIV_GO :                      198E C |
 DIV_GO1 :                     197B C |  DIV_LP :                      1968 C |
 DIV_NOPE :                    19C9 C |  DIV_Z :                       19DB C |
 DNOADD209 :                   14C3 C |  DONE205 :                     12DF C |
 DONE208 :                     1474 C |  DONE209 :                     1511 C |
 DONE215 :                     166F C |  DONE216 :                     1761 C |
 DSHLP209 :                    14D7 C |  ENDLP206 :                    1361 C |
 F7 :                             7 - |  F9 :                             9 - |
 FAILS :                       176E C | *FALSE :                          0 - |
 FB :                             B - |  FP_ADD :                      17EE C |
 FP_ADD_12 :                   178C C |  FP_ATOF :                     1B12 C |
 FP_DIV :                      18F8 C |  FP_GETEXP :                   17DC C |
 FP_GETSGN :                   17E7 C |  FP_MUL :                      19EB C |
 FP_SC_CLN :                   17C0 C |  FP_SC_UP :                    17B0 C |
 FP_SHL_1 :                    177F C |  FP_SHR_1 :                    1772 C |
 FP_SHR_FD :                   17A3 C |  FP_SUB :                      18F1 C |
*FULLPMMU :                       1 - |  F_ISNUM :                     1762 C |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - | *INSRCMODE :                      0 - |
*INSUPMODE :                      0 - | *L1 :                            2A C |
 L10 :                          1D7 C |  L100 :                         E88 C |
 L101 :                         E8C C |  L102 :                         EBF C |
 L103 :                         FA2 C |  L105 :                         F15 C |
 L107 :                         F3F C |  L108 :                         F9D C |
 L109 :                         FA2 C | *L11 :                          28B C |
 L110 :                         FEA C |  L112 :                         FCE C |
 L114 :                         DB1 C |  L115 :                         DC0 C |
 L116 :                         D9D C | *L118 :                         DEC C |
*L119 :                        104D C |  L12 :                          25E C |
 L120 :                        11A2 C |  L121 :                        104A C |
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 53 - 8/27/2014 11:16:27


*L122 :                        104A C | *L124 :                        10B7 C |
 L125 :                        107E C |  L126 :                        109E C |
 L128 :                        10B3 C | *L129 :                        110B C |
*L13 :                          265 C |  L130 :                        10EC C |
 L131 :                        10FA C | *L133 :                        1150 C |
 L134 :                        1134 C |  L135 :                        113F C |
*L137 :                        11A1 C |  L15 :                          266 C |
*L16 :                          31A C |  L17 :                          294 C |
*L18 :                          3DA C |  L19 :                          323 C |
*L20 :                          324 C | *L21 :                          40B C |
 L22 :                          3F2 C |  L23 :                          408 C |
*L25 :                          440 C |  L26 :                          42A C |
*L27 :                          42D C |  L29 :                          42E C |
*L3 :                            7E C | *L30 :                          4B0 C |
 L32 :                          526 C |  L33 :                          4C9 C |
*L34 :                          517 C |  L36 :                          51A C |
 L37 :                          50A C | *L4 :                           119 C |
 L40 :                          4FD C |  L41 :                          503 C |
 L42 :                          517 C | *L44 :                          547 C |
 L45 :                          53B C |  L46 :                          53D C |
*L48 :                          56F C |  L49 :                          55C C |
*L5 :                           18B C |  L50 :                          569 C |
*L52 :                          835 C |  L53 :                          67A C |
 L54 :                          685 C |  L55 :                         11B0 C |
 L56 :                         11AC C |  L57 :                          685 C |
 L59 :                          6C5 C | *L6 :                           1F5 C |
 L61 :                          829 C | *L63 :                          9C0 C |
 L64 :                          900 C |  L65 :                          910 C |
 L66 :                          919 C |  L67 :                          99D C |
 L69 :                          920 C |  L7 :                           1B2 C |
*L70 :                          920 C |  L72 :                          92D C |
 L73 :                          98C C |  L76 :                          956 C |
*L77 :                          A96 C |  L78 :                          A50 C |
*L8 :                           1D6 C | *L80 :                          AE4 C |
*L81 :                          B3E C | *L82 :                          BAB C |
*L83 :                          C3E C |  L84 :                          C19 C |
 L85 :                          C3E C | *L86 :                          CBC C |
*L87 :                         100D C |  L88 :                          CFE C |
 L89 :                          FFB C |  L91 :                          D3A C |
 L92 :                          FFB C |  L93 :                          FEA C |
 L94 :                          FFB C |  L96 :                          DFB C |
 L97 :                          E0D C |  L98 :                          E25 C |
 L99 :                          E73 C |  LCC1802INIT :                 11B4 C |
*LISTON :                         1 - |  LOOP206 :                     130F C |
 LSH216 :                      172B C | *MACEXP :                         0 - |
 MEMADDR :                        E - |  MLOOP207 :                    1377 C |
*MOMCPU :                      1802 - | *MOMCPUNAME :                  1802 - |
 MSLP202 :                     121E C |  MULRDONE203 :                 1249 C |
 MULRLP203 :                   1227 C |  MULRNOADD203 :                123B C |
 MULRSHFT203 :                 1241 C |  MUL_DN :                      1ABA C |
 MUL_GO1 :                     1A42 C |  MUL_LP1 :                     1A32 C |
 MUL_LP2 :                     1ACD C |  MUL_LP2A :                    1AE0 C |
 MUL_LP3 :                     1AE9 C |  MUL_LP3A :                    1AFC C |
 MUL_LP4 :                     1B0D C |  MUL_NO :                      1A8F C |
 MUL_NXT1 :                    1AE4 C | *NESTMAX :                      100 - |
 NEY0Y204 :                    129A C |  NORESTORE206 :                135D C |
 NXT215 :                      1630 C |  OUT204 :                      12A8 C |
 OUTIT76 :                      49C C | *PACKING :                        0 - |
*PADDING :                        1 - | *PASSES :                      176B C |
 POS1205 :                     12BF C |  POS1208 :                     1426 C |
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 54 - 8/27/2014 11:16:27


 POS2205 :                     12CF C |  POS2208 :                     144D C |
 R0 :                             0 - |  R1 :                             1 - |
 R10 :                            A - |  R11 :                            B - |
 R12 :                            C - |  R13 :                            D - |
 R14 :                            E - |  R15 :                            F - |
 R2 :                             2 - |  R3 :                             3 - |
*R4 :                             4 - | *R5 :                             5 - |
 R6 :                             6 - |  R7 :                             7 - |
 R8 :                             8 - |  R9 :                             9 - |
 RCALL :                          4 - |  REGARG1 :                        C - |
 REGARG2 :                        D - | *RELAXED :                        1 - |
 RETADDR :                        6 - |  RETVAL :                         F - |
*RL0 :                            1 - |  RL10 :                           B - |
 RL12 :                           D - |  RL6 :                            7 - |
 RL8 :                            9 - |  RP1P2 :                          D - |
 RPC :                            3 - |  RRET :                           5 - |
 RT1 :                            8 - |  RT2 :                            9 - |
 RWORK :                          E - |  SCRATCH :                     1CA3 C |
 SETBITOFF76 :                  497 C |  SETSGN215 :                   1668 C |
 SGNPOS215 :                   1639 C |  SHDN215 :                     165F C |
 SHIFT207 :                    13AE C |  SHL215 :                      164B C |
 SHR216 :                      1719 C |  SIGN216 :                     173B C |
 SLP41 :                         11 C |  SP :                             2 - |
 TESTEXIT204 :                 1290 C | *TIME :                    11:16:27 - |
*TRUE :                           1 - |  UPNXT209 :                    14F0 C |
*VERSION :                     142F - |  _00000194 :                   11CE C |
 _CALL :                       1201 C |  _DELAY :                       410 C |
 _DIE194 :                     11D1 C | *_DIGITALREAD :                 4A8 C |
 _DIGITALWRITE :                480 C |  _DIVI2 :                      12B0 C |
 _DIVI4 :                      1400 C |  _DIVU2 :                      124A C |
 _DIVU4 :                      1300 C |  _DUBDABX :                    1475 C |
*_EXIT :                       1024 C |  _FTOA :                        5B8 C |
*_INP :                        1CC5 C |  _ITOA :                        856 C |
 _LTOA :                        9D7 C |  _MAIN :                        3DF C |
*_MEMCMP :                     1052 C | *_MEMCPY :                     10C8 C |
*_MEMSET :                     1118 C |  _MODI2 :                      11E2 C |
*_MODI4 :                      151E C | *_MODU2 :                      11DA C |
*_MODU4 :                      1512 C |  _MULT_NUMS :                   598 C |
*_MULU2 :                      1223 C | *_MULU4 :                      1366 C |
*_NSTDLIBINCLUDER :            1159 C | *_OLDUINOINCLUDER :             44D C |
 _ONEMS :                      121C C | *_OUT :                        1CDF C |
*_OUT4 :                       11EA C | *_OUT5 :                       1CC0 C |
 _PIN4 :                          3 C |  _PRINTF :                      CC1 C |
 _PRINTFLT :                    B47 C |  _PRINTINT :                    AAB C |
 _PRINTLINT :                   AED C |  _PRINTSTR :                    54C C |
 _PUTC :                       1CC0 C |  _PUTX :                        C43 C |
 _PUTXN :                       BB4 C |  _RETURN :                     1212 C |
 _ROUND_NUMS :                  578 C |  _SEND :                          4 C |
 _SENDCOMMAND :                  2B C |  _SENDDATA :                     83 C |
 _SETDISPLAY :                  190 C |  _SETDISPLAYTO1802 :            2A0 C |
 _SETLED :                      11E C | *_SETQOFF :                    11D8 C |
*_SETQON :                     11D6 C |  _SPARKLE :                     325 C |
*_STRCMP :                     118A C |  _STRCPY :                     1180 C |
 _STRLEN :                      52F C | *_STRNCMP :                     4B1 C |
 _TMS1638INIT :                 206 C |  __FORW0 :                      4AF C |
 __FORW8 :                     1CDC C | *__FORW9 :                     1CF0 C |
 __STRCMPGT :                  119F C |  __STRCMPLP :                  118F C |
 __STRCMPNE :                  119A C |  __STRCPY :                    1184 C |

    350 symbols
 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 55 - 8/27/2014 11:16:27


     88 unused symbols

 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 56 - 8/27/2014 11:16:27


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU2RRS                               | ALU4                                 
ALU4I                                 | BLKCPY                               
CCALL                                 | CPY1                                 
CPY2                                  | CPY4                                 
CRETN                                 | DECM                                 
DEMOTE                                | INC4                                 
INCM                                  | JCF4                                 
JCI2                                  | JCI2I                                
JCI4                                  | JCU2                                 
JCU2I                                 | JCU4                                 
JEQI1                                 | JEQI2                                
JEQI4                                 | JEQU2I                               
JNEU1I                                | JNEU2                                
JNEU2I                                | JNEU2NI                              
JNEU4                                 | JNI2I                                
JNU2I                                 | JNZU1                                
JNZU2                                 | JUMPV                                
JZU1                                  | JZU2                                 
LD1                                   | LD2                                  
LD2Z                                  | LD4                                  
LDA2                                  | LDAD                                 
LDAX                                  | LDAXS                                
LDI4                                  | LDIREG                               
LDN1                                  | LDN2                                 
LDN2S                                 | MVC1                                 
MVC2                                  | MVCN1                                
MVCN2                                 | NEGI2                                
NEGI4                                 | POPR                                 
PUSHF                                 | PUSHL                                
PUSHM                                 | PUSHR                                
RELEASE                               | RELEASEL                             
RELEASES                              | RESERVE                              
RESERVEL                              | RESERVES                             
RLDMI                                 | SAVMI                                
SEXT                                  | SEXT4                                
SHL2                                  | SHL2I                                
SHL2R                                 | SHL4                                 
SHL4I                                 | SHL4R                                
SHLC4                                 | SHLR2R                               
SHRC4                                 | SHRI2                                
SHRI2I                                | SHRI2R                               
SHRI4                                 | SHRI4I                               
SHRI4R                                | SHRU2                                
SHRU2I                                | SHRU2R                               
SHRU4                                 | SHRU4I                               
SHRU4R                                | ST1                                  
ST2                                   | ST2I                                 
ST4                                   | STR1                                 
STR1I                                 | STR2                                 
STR2I                                 | TESTSUB                              
ZEXT                                  | ZEXT4                                

    104 macros

 AS V1.42 Beta [Bld 87] - source file tms1638demo.asm - page 57 - 8/27/2014 11:16:27


  codepages:
  ----------

STANDARD (0 changed characters)


0.10 seconds assembly time

   4038 lines source file
   9387 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
