 AS V1.42 Beta [Bld 87] - source file failertoo.asm - page 1 - 4/25/2013 10:39:31


       1/       0 :                     ; generated by lcc-xr182b $Version: 4.0 - XR182b $ on Thu Apr 25 10:18:29 2013
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1)  830/       0 :                     	listing	on
(1)  831/       0 : C0 01 50            	lbr	lcc1802Init
(1)  832/       3 :                     	
      11/       3 :                     	listing on
      12/       3 :                     _fill_checksum:
      13/       3 : (MACRO)             	reserve 6; save room for local variables
      14/       9 : (MACRO)             	pushr r0
      15/       E : (MACRO)             	pushr r1
      16/      13 : (MACRO)             	pushr r14
      17/      18 : (MACRO)             	reserve 0; save room for outgoing arguments
      18/      18 :                     ; void fill_checksum() {
      19/      18 : C0 00 EB            	lbr L3
      20/      1B :                     L2:
      21/      1B :                     ;  while(2 >1) {
      22/      1B :                     ;    sum += (unsigned int) (((unsigned long)*ptr<<8)|*(ptr+1));
      23/      1B : (MACRO)             	ld1 R11,'O',R14,0
      24/      25 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
      25/      28 : (MACRO)             	cpy2 RL10,R11
      26/      2C : (MACRO)             	sext4 RL10; CVIU4
      27/      37 : (MACRO)             	shl4I RL10,8; LSHU4(reg,con)
      28/      97 : (MACRO)             	ld1 R9,'O',R14,(1)
      29/      A1 : (MACRO)             	zExt R9 ;CVUI2: widen unsigned char to signed int (zero extend)
      30/      A4 : (MACRO)             	cpy2 RL8,R9
      31/      A8 : (MACRO)             	sext4 RL8; CVIU4
      32/      B3 : (MACRO)             	alu4 RL10,RL10,RL8,or,or
      33/      C9 : (MACRO)             	cpy2 R11,RL10 ;LOADU2(reg)*
      34/      CD : (MACRO)             	cpy2 RL10,R11
      35/      D1 : (MACRO)             	zext4 RL10; CVUI4 jan 16
      36/      D5 : (MACRO)             	alu4 RL0,RL0,RL10,add,adc
      37/      EB :                     ;  }
      38/      EB :                     L3:
      39/      EB :                     ;  while(2 >1) {
      40/      EB : C0 00 1B            	lbr L2
      41/      EE : C0 01 3A            	lbr L6
      42/      F1 :                     L5:
      43/      F1 :                     ;  while(2 >1) {
      44/      F1 :                     ;    sum2 += *(unsigned int*)ptr;
      45/      F1 : (MACRO)             	ld4 RL10,'O',sp,(-8+14);reg:  INDIRI4(addr)
      46/     101 : (MACRO)             	ld2 RL8,'O',R14,0
      47/     10D : (MACRO)             	zext4 RL8 ;CVUI4: widen unsigned int to signed long (zero extend)
      48/     111 : (MACRO)             	alu4 RL10,RL10,RL8,add,adc
      49/     127 : (MACRO)             	st4 RL10,'O',sp,(-8+14)
      50/     13A :                     ;  }
      51/     13A :                     L6:
      52/     13A :                     ;  while(2 >1) {
      53/     13A : C0 00 F1            	lbr L5
      54/     13D :                     ;}
      55/     13D :                     L1:
      56/     13D : (MACRO)             	release 0; release room for outgoing arguments
      57/     13D : (MACRO)             	popr r14
      58/     141 : (MACRO)             	popr r1
      59/     145 : (MACRO)             	popr r0
 AS V1.42 Beta [Bld 87] - source file failertoo.asm - page 2 - 4/25/2013 10:39:31


      60/     149 : (MACRO)             	release 6; release room for local variables 
      61/     14F : (MACRO)             	Cretn
      62/     150 :                     
      63/     150 :                     	include lcc1802Epilofl.inc
(1)    1/     150 :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/     150 :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/     150 :                     ;this is the version published with the lcc1802121229 release
(1)    4/     150 :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/     150 :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/     150 :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/     150 :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/     150 :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/     150 :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/     150 :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/     150 :                     ;feb 27 changed stack to start at 7fff
(1)   12/     150 :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/     150 :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/     150 :                     ;april 4 adding digit count argument to dubdabx
(1)   15/     150 :                     
(1)   16/     150 : =EH                 rwork	equ	memAddr	;work register
(1)   17/     150 :                     lcc1802init:	
(1)   18/     150 : (MACRO)             	ldiReg	RCALL,_call
(1)   19/     156 : (MACRO)             	ldiReg	RRET,_return
(1)   20/     15C : (MACRO)             	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1
(1)   21/     162 : E2                  	sex	SP
(1)   22/     163 : (MACRO)             	ldiReg	RPC,$$_00000
(1)   23/     169 : D3                  	sep	RPC
(1)   24/     16A :                     $$_00000:
(1)   25/     16A : (MACRO)             	Ccall _main	;call the main routine
> > >lcc1802Epilofl.inc(25) CCALL(2): error: symbol undefined
(1)   26/     16B : C0 01 6B            $$_die:	lbr	$$_die		;loop here when main returns
(1)   27/     16E : DE AD               	db	0xde,0xad
(1)   28/     170 :                     
(1)   29/     170 :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   30/     170 :                     _setqOn:
(1)   31/     170 : 7B                  	seq
(1)   32/     171 : (MACRO)             	Cretn
(1)   33/     172 :                     _setqOff:
(1)   34/     172 : 7A                  	req
(1)   35/     173 : (MACRO)             	Cretn
(1)   36/     174 :                     
(1)   37/     174 :                     _modU2:	;16 bit unsigned remainder
(1)   38/     174 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   39/     174 : (MACRO)                 Ccall _divU2
(1)   40/     177 : 8D                      glo regArg2
(1)   41/     178 : AF                      plo retVal
(1)   42/     179 : 9D                      ghi regArg2
(1)   43/     17A : BF                      phi retVal
(1)   44/     17B : (MACRO)                 Cretn
(1)   45/     17C :                         
(1)   46/     17C :                     _modI2:	;16 bit signed remainder
(1)   47/     17C :                     	; just calls the 16 bit division then puts remainder into return value
(1)   48/     17C : (MACRO)                 Ccall _divI2
(1)   49/     17F : 8D                      glo regArg2
(1)   50/     180 : AF                      plo retVal
(1)   51/     181 : 9D                      ghi regArg2
(1)   52/     182 : BF                      phi retVal
(1)   53/     183 : (MACRO)                 Cretn
(1)   54/     184 :                     
(1)   55/     184 :                     _out4:	
 AS V1.42 Beta [Bld 87] - source file failertoo.asm(lcc1802Epilofl.inc) - page 3 - 4/25/2013 10:39:31


(1)   56/     184 : 8C                  	glo	regArg1
(1)   57/     185 : 22                  	dec	sp
(1)   58/     186 : 52                  	str	sp
(1)   59/     187 : 64                  	out	4
(1)   60/     188 : (MACRO)             	Cretn
(1)   61/     189 :                     
(1)   62/     189 :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   63/     189 :                     	align 256
(1)   64/     200 :                     ;non-standard Call routine invoked as D4xxxx - using z80 stack convention
(1)   65/     200 :                     ;requires programs to save the return address if they destroy it (by using call for example)
(1)   66/     200 :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)   67/     200 : D3                  	sep     R3 ;go to subroutine
(1)   68/     201 : E2                  _call	sex	SP ;make sure X=SP
(1)   69/     202 : 86                  	glo	retAddr ;save previous return pointer on stack
(1)   70/     203 : 22                  	dec	sp
(1)   71/     204 : 73                  	stxd
(1)   72/     205 : 96                  	ghi	retAddr
(1)   73/     206 : 52                  	str	sp	
(1)   74/     207 : 83                  	glo	RPC ;copy old PC to retAddr
(1)   75/     208 : A6                  	plo	retAddr
(1)   76/     209 : 93                  	ghi	RPC
(1)   77/     20A : B6                  	phi	retAddr
(1)   78/     20B : 46                  	lda	retAddr ;pick up subroutine address into RPC
(1)   79/     20C : B3                  	phi	RPC
(1)   80/     20D : 46                  	lda	retAddr
(1)   81/     20E : A3                  	plo	RPC
(1)   82/     20F : 30 00               	br	_call-1
(1)   83/     211 :                     
(1)   84/     211 :                     ;Standard subroutine return 
(1)   85/     211 : D3                  	sep	RPC	;return to the original program
(1)   86/     212 : 86                  _return	glo	retAddr	;transfer the current return address to RPC
(1)   87/     213 : A3                  	plo	RPC
(1)   88/     214 : 96                  	ghi	retAddr
(1)   89/     215 : B3                  	phi	RPC
(1)   90/     216 : 42                  	lda	SP	;pick up old return address
(1)   91/     217 : B6                  	phi	retAddr
(1)   92/     218 : 42                  	lda	SP
(1)   93/     219 : A6                  	plo	retAddr
(1)   94/     21A : 30 11               	br	_return-1
(1)   95/     21C :                     
(1)   96/     21C :                     _oneMs:		;execute 100 instructions including call(15)/return(10) sequence. takes about 1 ms
(1)   97/     21C : F8 24               	ldi	(100-15-10-2)/2
(1)   98/     21E : FF 01               $$mslp:	smi	1
(1)   99/     220 : 3A 1E               	bnz	$$mslp
(1)  100/     222 : (MACRO)             	Cretn
(1)  101/     223 :                     
(1)  102/     223 :                     
(1)  103/     223 :                     	
(1)  104/     223 :                     ;16 bit unsigned multiply thanks to Ted Rossin!
(1)  105/     223 :                     ;retVal=regArg1*regArg2. uses register rwork as a work regitsr
(1)  106/     223 :                     _mulu2:		
(1)  107/     223 : 22                      dec sp
(1)  108/     224 : F8 10                   ldi 16
(1)  109/     226 : AE                      plo	rwork	;bit count
(1)  110/     227 : F8 00                   ldi 0
(1)  111/     229 : BF                      phi	retVal	;quotient
(1)  112/     22A : AF                      plo retVal
(1)  113/     22B :                     $$MultLoop16_16:
(1)  114/     22B : 9C                      ghi regArg1
(1)  115/     22C : F6                      shr
 AS V1.42 Beta [Bld 87] - source file failertoo.asm(lcc1802Epilofl.inc) - page 4 - 4/25/2013 10:39:31


(1)  116/     22D : BC                      phi regArg1
(1)  117/     22E : 8C                      glo regArg1
(1)  118/     22F : 76                      shrc
(1)  119/     230 : AC                      plo regArg1
(1)  120/     231 : 3B 3D                   bnf $$MultSkip16_16
(1)  121/     233 : 8D                      glo regArg2
(1)  122/     234 : 52                      str sp
(1)  123/     235 : 8F                      glo retVal
(1)  124/     236 : F4                      add 
(1)  125/     237 : AF                      plo retVal
(1)  126/     238 : 9D                      ghi regArg2
(1)  127/     239 : 52                      str sp
(1)  128/     23A : 9F                      ghi retVal
(1)  129/     23B : 74                      adc
(1)  130/     23C : BF                      phi retVal
(1)  131/     23D :                     $$MultSkip16_16:
(1)  132/     23D : 8D                      glo regArg2
(1)  133/     23E : FE                      shl
(1)  134/     23F : AD                      plo regArg2
(1)  135/     240 : 9D                      ghi regArg2
(1)  136/     241 : 7E                      shlc
(1)  137/     242 : BD                      phi regArg2
(1)  138/     243 : 2E                      dec rwork
(1)  139/     244 : 8E                      glo rwork
(1)  140/     245 : 3A 2B                   bnz $$MultLoop16_16
(1)  141/     247 : 12                      inc sp
(1)  142/     248 : D5                      sep 5
(1)  143/     249 :                     
(1)  144/     249 :                     
(1)  145/     249 :                     _divU2:
(1)  146/     249 :                     	; retVal = regArg1/regArg2  (remainder in regArg1)
(1)  147/     249 :                     	; This is really an unsigned 23 bit divide
(1)  148/     249 :                     	;thanks to Ted Rossin
(1)  149/     249 :                     	;bodged Dec 12 to shuffle registers at the end.
(1)  150/     249 : 22                      dec sp
(1)  151/     24A : F8 10                   ldi 16
(1)  152/     24C : AE                      plo rwork
(1)  153/     24D : F8 00                   ldi 0
(1)  154/     24F : BF                      phi retVal
(1)  155/     250 : AF                      plo retVal
(1)  156/     251 : BE                      phi rwork
(1)  157/     252 :                     $$DivLoop16_16:
(1)  158/     252 : 8C                      glo regArg1
(1)  159/     253 : FE                      shl
(1)  160/     254 : AC                      plo regArg1
(1)  161/     255 : 9C                      ghi regArg1
(1)  162/     256 : 7E                      shlc
(1)  163/     257 : BC                      phi regArg1
(1)  164/     258 : 8F                      glo retVal
(1)  165/     259 : 7E                      shlc
(1)  166/     25A : AF                      plo retVal
(1)  167/     25B : 9F                      ghi retVal
(1)  168/     25C : 7E                      shlc
(1)  169/     25D : BF                      phi retVal
(1)  170/     25E : 9E                      ghi rwork
(1)  171/     25F : 7E                      shlc
(1)  172/     260 : BE                      phi rwork
(1)  173/     261 : 3B 73                   bnf $$DivSub16_16
(1)  174/     263 : 8D                      glo regArg2
(1)  175/     264 : 52                      str sp
 AS V1.42 Beta [Bld 87] - source file failertoo.asm(lcc1802Epilofl.inc) - page 5 - 4/25/2013 10:39:31


(1)  176/     265 : 8F                      glo retVal
(1)  177/     266 : F4                      add 
(1)  178/     267 : AF                      plo retVal
(1)  179/     268 : 9D                      ghi regArg2
(1)  180/     269 : 52                      str sp
(1)  181/     26A : 9F                      ghi retVal
(1)  182/     26B : 74                      adc 
(1)  183/     26C : BF                      phi retVal
(1)  184/     26D : 9E                      ghi rwork
(1)  185/     26E : 7C 00                   adci 0
(1)  186/     270 : BE                      phi rwork
(1)  187/     271 : 30 81                   br $$DivSkip16_16
(1)  188/     273 :                     $$DivSub16_16:
(1)  189/     273 : 8D                      glo regArg2
(1)  190/     274 : 52                      str sp
(1)  191/     275 : 8F                      glo retVal
(1)  192/     276 : F7                      sm
(1)  193/     277 : AF                      plo retVal
(1)  194/     278 : 9D                      ghi regArg2
(1)  195/     279 : 52                      str sp
(1)  196/     27A : 9F                      ghi retVal
(1)  197/     27B : 77                      smb 
(1)  198/     27C : BF                      phi retVal
(1)  199/     27D : 9E                      ghi rwork
(1)  200/     27E : 7F 00                   smbi 0
(1)  201/     280 : BE                      phi rwork 
(1)  202/     281 :                     $$DivSkip16_16:
(1)  203/     281 : FE                      shl
(1)  204/     282 : 33 88                   bdf $$DivSkipClear16_16
(1)  205/     284 :                     $$DivSetBit16_16:
(1)  206/     284 : 8C                      glo regArg1
(1)  207/     285 : F9 01                   ori  0x01
(1)  208/     287 : AC                      plo regArg1
(1)  209/     288 :                     $$DivSkipClear16_16:
(1)  210/     288 : 2E                      dec rwork
(1)  211/     289 : 8E                      glo rwork
(1)  212/     28A : 3A 52                   bnz $$DivLoop16_16
(1)  213/     28C : 9E                      ghi rwork
(1)  214/     28D : FE                      shl
(1)  215/     28E : 3B 9A                   bnf $$DivSkipFinalAdd16_16
(1)  216/     290 : 8D                      glo regArg2
(1)  217/     291 : 52                      str sp
(1)  218/     292 : 8F                      glo retVal
(1)  219/     293 : F4                      add
(1)  220/     294 : AF                      plo retVal
(1)  221/     295 : 9D                      ghi regArg2
(1)  222/     296 : 52                      str sp
(1)  223/     297 : 9F                      ghi retVal
(1)  224/     298 : 74                      adc
(1)  225/     299 : BF                      phi retVal
(1)  226/     29A :                     $$DivSkipFinalAdd16_16:
(1)  227/     29A : 12                      inc sp
(1)  228/     29B :                     ;here I have the quotient in regArg1 and remainder in retVal
(1)  229/     29B : 8F                      glo retVal
(1)  230/     29C : AD                      plo regArg2
(1)  231/     29D : 9F                      ghi retVal
(1)  232/     29E : BD                      phi regArg2
(1)  233/     29F : 8C                      glo regArg1
(1)  234/     2A0 : AF                      plo retVal
(1)  235/     2A1 : 9C                      ghi regArg1
 AS V1.42 Beta [Bld 87] - source file failertoo.asm(lcc1802Epilofl.inc) - page 6 - 4/25/2013 10:39:31


(1)  236/     2A2 : BF                      phi retVal
(1)  237/     2A3 :                         ;return with quotient in retVal and remainder in regArg2
(1)  238/     2A3 : D5                      sep 5
(1)  239/     2A4 :                     
(1)  240/     2A4 :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  241/     2A4 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  242/     2A4 :                     _divI2:
(1)  243/     2A4 :                         ;pushr retAddr	;save the return address NG doesnot need
(1)  244/     2A4 : 22                      dec	sp	;leave a work area available
(1)  245/     2A5 : 9C                      ghi regArg1
(1)  246/     2A6 : 52                      str sp	;save the sign of the 1st arg
(1)  247/     2A7 : FE                      shl
(1)  248/     2A8 : 3B B3                   bnf $$pos1	;if the 1st arg is -v
(1)  249/     2AA : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
(1)  250/     2B3 :                     $$pos1: ;1st is now +v, check 2nd
(1)  251/     2B3 : 9D                      ghi regArg2
(1)  252/     2B4 : F3                      xor	
(1)  253/     2B5 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  254/     2B6 : 9D                      ghi regArg2
(1)  255/     2B7 : FE                      shl
(1)  256/     2B8 : 3B C3                   bnf $$pos2	;if the 2nd arg is -v
(1)  257/     2BA : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  258/     2C3 :                     $$pos2: ; both args now +v
(1)  259/     2C3 : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  260/     2C6 :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  261/     2C6 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  262/     2C7 : FE                      shl
(1)  263/     2C8 : 3B D3                   bnf $$done ;if the signs were different
(1)  264/     2CA : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  265/     2D3 :                     $$done:
(1)  266/     2D3 :                         ;popr RetAddr ;restore the return address NG doesnot need
(1)  267/     2D3 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  268/     2D4 :                     
(1)  269/     2D4 :                     
(1)  270/     2D4 :                     	align 256    ;32 bit operations follow
(1)  271/     300 :                     _divu4:
(1)  272/     300 :                     ;This is an unsigned 32 bit restoring division
(1)  273/     300 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  274/     300 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  275/     300 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  276/     300 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  277/     300 :                     
(1)  278/     300 : F8 20               	ldi 32		;set loop count
(1)  279/     302 : AE                  	plo memaddr	;in temp register
(1)  280/     303 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  281/     30F :                     $$loop:
(1)  282/     30F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  283/     31B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  284/     327 :                     
(1)  285/     327 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  286/     33D :                     
(1)  287/     33D : FA 80               	ani 0x80	;check the top bit
(1)  288/     33F : 32 5D               	bz $$norestore	;if it's 0
(1)  289/     341 : 89                  		glo RL8
(1)  290/     342 : FA FE               		ani 0xfe	;turn off the bottom bit
(1)  291/     344 : A9                  		plo RL8
(1)  292/     345 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  293/     35B : 30 61               	br $$endlp 	;else
(1)  294/     35D :                     $$norestore:
(1)  295/     35D : 89                  		glo RL8
 AS V1.42 Beta [Bld 87] - source file failertoo.asm(lcc1802Epilofl.inc) - page 7 - 4/25/2013 10:39:31


(1)  296/     35E : F9 01               		ori 1	;turn on the bottom bit
(1)  297/     360 : A9                  		plo RL8
(1)  298/     361 :                     	;end if
(1)  299/     361 :                     $$endlp:
(1)  300/     361 : 2E                  	dec memaddr	;check the cycle count
(1)  301/     362 : 8E                  	glo memaddr
(1)  302/     363 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  303/     365 :                     	
(1)  304/     365 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  305/     366 :                     		
(1)  306/     366 :                     
(1)  307/     366 :                     _mulu4:
(1)  308/     366 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  309/     366 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  310/     366 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  311/     366 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  312/     366 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  313/     366 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  314/     366 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  315/     366 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  316/     366 :                     	;for 10 we subtract and shift
(1)  317/     366 :                     	;for 00 and 11 we just shift
(1)  318/     366 :                     
(1)  319/     366 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  320/     372 : F8 20                   ldi 32
(1)  321/     374 : AE                      plo memaddr		;cycle count
(1)  322/     375 : FC 00                   adi 0		;clear df
(1)  323/     377 :                     $$mloop:
(1)  324/     377 : 89                      glo RL8
(1)  325/     378 : FA 01                   ani 1		;isolate bottom bit of result
(1)  326/     37A : 3B 96                   bnf	$$check_sub	;
(1)  327/     37C : 3A AE                   bnz	$$shift		;that would be the 11 case
(1)  328/     37E :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  329/     37E : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  330/     394 : 30 AE                   br $$shift
(1)  331/     396 :                     $$check_sub:
(1)  332/     396 : 32 AE                   bz $$shift	;that would be the 00 case
(1)  333/     398 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  334/     398 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  335/     3AE :                     $$shift:
(1)  336/     3AE : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  337/     3BC : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  338/     3C8 :                     
(1)  339/     3C8 : 2E                      dec memaddr		;cycle count
(1)  340/     3C9 : 8E                      glo memaddr
(1)  341/     3CA : 3A 77                   bnz $$mloop		;repeat cycle once for each bit position
(1)  342/     3CC :                         
(1)  343/     3CC : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  344/     3CD :                     
(1)  345/     3CD :                     	align 256
(1)  346/     400 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  347/     400 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  348/     400 :                     _divI4:
(1)  349/     400 : 22                      dec	sp	;leave a work area available
(1)  350/     401 : 98                      ghi RL8-1	;get the top of the dividend
(1)  351/     402 : 52                      str sp	;save the sign of the 1st arg
(1)  352/     403 : FE                      shl
(1)  353/     404 : 3B 26                   bnf $$pos1	;if the 1st arg is -v
(1)  354/     406 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  355/     426 :                     $$pos1: ;1st is now +v, check 2nd
 AS V1.42 Beta [Bld 87] - source file failertoo.asm(lcc1802Epilofl.inc) - page 8 - 4/25/2013 10:39:31


(1)  356/     426 : 9A                      ghi RL10-1
(1)  357/     427 : F3                      xor	
(1)  358/     428 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  359/     429 : 9A                      ghi RL10-1
(1)  360/     42A : FE                      shl
(1)  361/     42B : 3B 4D                   bnf $$pos2	;if the 2nd arg is -v
(1)  362/     42D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  363/     44D :                     $$pos2: ; both args now +v
(1)  364/     44D : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  365/     450 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  366/     450 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  367/     451 : FE                      shl
(1)  368/     452 : 3B 74                   bnf $$done ;if the signs were different
(1)  369/     454 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  370/     474 :                     $$done:
(1)  371/     474 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  372/     475 :                     
(1)  373/     475 :                     _dubdabx:	
(1)  374/     475 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  375/     475 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  376/     475 :                     ;long interger is passed in rp1p2
(1)  377/     475 :                     ;buffer pointer is passed at sp+2+4
(1)  378/     475 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
(1)  379/     475 :                     ;r8-11 are used as temps
(1)  380/     475 :                     ;r8 is the working pointer
(1)  381/     475 :                     ;r15.0 is bit count(32) and the return value register
(1)  382/     475 :                     ;r9.0 is digit count
(1)  383/     475 :                     ;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
(1)  384/     475 : (MACRO)             	ld2 r8,'O',sp,(2+4); pick up the buffer pointer
(1)  385/     481 : (MACRO)             	ld2 r10,'O',sp,(2+4+2); pick up the number of digits wanted
(1)  386/     48D : (MACRO)             	cpy2 r15,r8 ;save address for now
(1)  387/     491 : F8 0B               	ldi 11	;digit count+1 for trailing 0
(1)  388/     493 : A9                  	plo r9
(1)  389/     494 :                     $$clrlp:	;clear the passed buffer
(1)  390/     494 : F8 00               	ldi 0	
(1)  391/     496 : 58                  	str r8	;clear a byte
(1)  392/     497 : 18                  	inc r8
(1)  393/     498 : 29                  	dec r9
(1)  394/     499 : 89                  	glo r9	;check the count
(1)  395/     49A : 3A 94               	bnz $$clrlp ;back for more
(1)  396/     49C : (MACRO)             	cpy2 r8,r15 ;get the address back
(1)  397/     4A0 :                     
(1)  398/     4A0 : F8 20               	ldi 32	;bit count
(1)  399/     4A2 : AF                  	plo r15
(1)  400/     4A3 :                     ;now i'm going to spin off any leading 0's in the binary number
(1)  401/     4A3 :                     $$cktop:
(1)  402/     4A3 : 9C                  	ghi rp1p2-1	;get the top bit of the number
(1)  403/     4A4 : FE                  	shl		;check for a 1
(1)  404/     4A5 : 33 B8               	bdf $$bitloop	;move on if we have one
(1)  405/     4A7 : (MACRO)             	shl4 rp1p2	;shift the input number
(1)  406/     4B3 : 2F                  	dec r15		;reduce the number of times to shift
(1)  407/     4B4 : 8F                  	glo r15
(1)  408/     4B5 : 3A A3               	bnz $$cktop	;
(1)  409/     4B7 : 1F                  	inc r15		;our whole number was 0 but force at least one pass
(1)  410/     4B8 :                     $$bitloop:
(1)  411/     4B8 : F8 0A               	ldi 10	;digit count
(1)  412/     4BA : A9                  	plo r9
(1)  413/     4BB :                     $$dcklp:
(1)  414/     4BB : 08                  	ldn r8 	;pick up a digit
(1)  415/     4BC : FF 05               	smi 5	;see if it's greater than 4
 AS V1.42 Beta [Bld 87] - source file failertoo.asm(lcc1802Epilofl.inc) - page 9 - 4/25/2013 10:39:31


(1)  416/     4BE : 3B C3               	bnf $$dnoadd ;if not, bypass add
(1)  417/     4C0 : FC 08               	adi 0x08	;add the 5 black and 3 more
(1)  418/     4C2 : 58                  	str r8	;put it back
(1)  419/     4C3 :                     $$dnoadd:
(1)  420/     4C3 : 18                  	inc r8
(1)  421/     4C4 : 29                  	dec r9	;decrement digit count
(1)  422/     4C5 : 89                  	glo r9
(1)  423/     4C6 : 3A BB               	bnz $$dcklp ;and back for next digit
(1)  424/     4C8 :                     	
(1)  425/     4C8 : (MACRO)             	shl4 rp1p2 ;shift the input number
(1)  426/     4D4 :                     	
(1)  427/     4D4 : F8 0A               	ldi 10	;load the digit count again
(1)  428/     4D6 : A9                  	plo r9
(1)  429/     4D7 :                     ;r8 is now just past the units location and ready to walk back
(1)  430/     4D7 :                     $$dshlp:
(1)  431/     4D7 : 28                  	dec r8	;walk back from 0's position
(1)  432/     4D8 : 08                  	ldn r8	;get the digit back
(1)  433/     4D9 : 7E                  	shlc	;continue the shift
(1)  434/     4DA : BF                  	phi r15 ;save it for the carry test
(1)  435/     4DB : FA 0F               	ani 0x0f ;clear the 10 bit
(1)  436/     4DD : 58                  	str r8	;put the digit back
(1)  437/     4DE : 9F                  	ghi r15	;now test for carry
(1)  438/     4DF : FF 10               	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  439/     4E1 : 29                  	dec r9	;decrement the digit count
(1)  440/     4E2 : 89                  	glo r9
(1)  441/     4E3 : 3A D7               	bnz $$dshlp ;back for more if needed
(1)  442/     4E5 :                     	
(1)  443/     4E5 : 2F                  	dec r15
(1)  444/     4E6 : 8F                  	glo r15
(1)  445/     4E7 : 3A B8               	bnz $$bitloop
(1)  446/     4E9 :                     	
(1)  447/     4E9 : (MACRO)             	cpy2 r15,r8	;save the starting location of the digits
(1)  448/     4ED : F8 0A               	ldi 10		;digit count again
(1)  449/     4EF : A9                  	plo r9
(1)  450/     4F0 :                     $$upnxt:
(1)  451/     4F0 : 08                  	ldn r8		;get digit
(1)  452/     4F1 : F9 30               	ori 0x30	;make ascii
(1)  453/     4F3 : 58                  	str r8		;put it back
(1)  454/     4F4 : 18                  	inc r8		;next digit
(1)  455/     4F5 : 29                  	dec r9		;counter
(1)  456/     4F6 : 89                  	glo r9
(1)  457/     4F7 : 3A F0               	bnz $$upnxt	;upgrade all 10 spots
(1)  458/     4F9 :                     	
(1)  459/     4F9 : (MACRO)             	ldaX memaddr,sp,(2+4+2+1)	;point to lsb of desired digit count
(1)  460/     501 : EE                  	sex memaddr	;set up
(1)  461/     502 : F8 0A               	ldi 10		;max number of 0's to skip
(1)  462/     504 : F7                  	sm		;desired number of digits to skip
(1)  463/     505 : E2                  	sex sp		;reset index register
(1)  464/     506 : A9                  	plo r9		;number of leading 0's to skip
(1)  465/     507 :                     $$cknext:
(1)  466/     507 : 0F                  	ldn r15		;check digit
(1)  467/     508 : FF 30               	smi 0x30	;for '0'
(1)  468/     50A : 3A 11               	bnz $$done
(1)  469/     50C : 1F                  	inc r15		;next digit
(1)  470/     50D : 29                  	dec r9		;reduce count
(1)  471/     50E : 89                  	glo r9
(1)  472/     50F : 3A 07               	bnz $$cknext
(1)  473/     511 :                     $$done:
(1)  474/     511 : (MACRO)             	cretn
(1)  475/     512 :                     	
 AS V1.42 Beta [Bld 87] - source file failertoo.asm(lcc1802Epilofl.inc) - page 10 - 4/25/2013 10:39:31


(1)  476/     512 :                     	
(1)  477/     512 :                     _modU4:	;32 bit unsigned remainder
(1)  478/     512 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  479/     512 : (MACRO)                 Ccall _divU4
(1)  480/     515 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  481/     51D : (MACRO)                 Cretn
(1)  482/     51E :                         
(1)  483/     51E :                     _modI4:	;32 bit signed remainder
(1)  484/     51E :                     	; just calls the 32 bit division then puts remainder into return value
(1)  485/     51E : (MACRO)                 Ccall _divI4
(1)  486/     521 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  487/     529 : (MACRO)                 Cretn
(1)  488/     52A :                         
(1)  489/     52A :                     	
(1)  490/     52A :                      
      64/     52A :                     	include IO1802.inc
(1)    1/     52A :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/     52A :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/     52A :                     	align 64
(1)    4/     540 :                     _putc:
(1)    5/     540 :                     _out5:	
(1)    6/     540 : 8C                  	glo	regArg1
(1)    7/     541 : 22                  	dec	sp
(1)    8/     542 : 52                  	str	sp
(1)    9/     543 : 65                  	out	5
(1)   10/     544 : (MACRO)             	Cretn
(1)   11/     545 :                     _inp:		;raw port input
(1)   12/     545 :                     		;stores a small tailored program on the stack and executes it
(1)   13/     545 : 22                  	dec	sp	;work backwards
(1)   14/     546 : F8 D3               	ldi	0xD3	;return instruction
(1)   15/     548 : 73                  	stxd		
(1)   16/     549 : 8C                  	glo	regarg1	;get the port number
(1)   17/     54A : FA 07               	ani	0x07	;clean it
(1)   18/     54C : 32 5C               	bz	+	; inp(0) isn't valid
(1)   19/     54E : F9 68               	ori	0x68	;make it an input instruction
(1)   20/     550 : 73                  	stxd		;store it for execution
(1)   21/     551 : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   22/     555 : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   23/     556 : D8                  	sep	rt1	;execute it
(1)   24/     557 :                     ;we will come back to here with the input byte in D
(1)   25/     557 : 12                  	inc	sp	;step over the work area
(1)   26/     558 : AF                  	plo	retVal	;save it to return
(1)   27/     559 : F8 00               	ldi	0
(1)   28/     55B : BF                  	phi	retval	;clear top byte
(1)   29/     55C : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   30/     55D : 12                  	inc	sp	;and the D3
(1)   31/     55E : (MACRO)             	Cretn		;and we're done
(1)   32/     55F :                     	
(1)   33/     55F :                     _out:		;raw port output
(1)   34/     55F :                     		;stores a small tailored program on the stack and executes it
(1)   35/     55F : 22                  	dec	sp	;work backwards
(1)   36/     560 : F8 D3               	ldi	0xD3	;return instruction
(1)   37/     562 : 73                  	stxd		
(1)   38/     563 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the inp instruction
(1)   39/     567 : 8C                  	glo	regarg1	;get the port number
(1)   40/     568 : FA 07               	ani	0x07	;clean it
(1)   41/     56A : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   42/     56C : 73                  	stxd		;store it for execution
(1)   43/     56D : 8D                  	glo	regarg2	;get the byte to be written
(1)   44/     56E : 52                  	str	sp	;store it where sp points
 AS V1.42 Beta [Bld 87] - source file failertoo.asm(IO1802.inc) - page 11 - 4/25/2013 10:39:31


(1)   45/     56F : D8                  	sep	rt1	;execute it
(1)   46/     570 :                     ;we will come back to here with sp stepped up by one
(1)   47/     570 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   48/     571 : 12                  	inc	sp	;and the D3
(1)   49/     572 : (MACRO)             	Cretn		;and we're done
(1)   50/     573 :                     	
(1)   51/     573 :                     	
      65/     573 :                     
 AS V1.42 Beta [Bld 87] - source file failertoo.asm - page 12 - 4/25/2013 10:39:31


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :  i386-unknown-win32 - | *BIGENDIAN :                      0 - |
 BITLOOP61 :                    4B8 C | *BRANCHEXT :                      0 - |
*CASESENSITIVE :                  0 - |  CHECK_SUB59 :                  396 C |
 CKNEXT61 :                     507 C |  CKTOP61 :                      4A3 C |
 CLRLP61 :                      494 C | *CONSTPI :        3.141592653589793 - |
*DATE :                   4/25/2013 - |  DCKLP61 :                      4BB C |
 DIVLOOP16_1656 :               252 C | *DIVSETBIT16_1656 :             284 C |
 DIVSKIP16_1656 :               281 C |  DIVSKIPCLEAR16_1656 :          288 C |
 DIVSKIPFINALADD16_1656 :       29A C |  DIVSUB16_1656 :                273 C |
 DNOADD61 :                     4C3 C |  DONE57 :                       2D3 C |
 DONE60 :                       474 C |  DONE61 :                       511 C |
 DSHLP61 :                      4D7 C |  ENDLP58 :                      361 C |
*FALSE :                          0 - | *FULLPMMU :                       1 - |
*HAS64 :                          1 - | *HASDSP :                         0 - |
*HASFPU :                         0 - | *HASPMMU :                        0 - |
*INEXTMODE :                      0 - | *INLWORDMODE :                    0 - |
*INMAXMODE :                      0 - | *INSRCMODE :                      0 - |
*INSUPMODE :                      0 - | *L1 :                           13D C |
 L2 :                            1B C |  L3 :                            EB C |
 L5 :                            F1 C |  L6 :                           13A C |
 LCC1802INIT :                  150 C | *LISTON :                         1 - |
 LOOP58 :                       30F C | *MACEXP :                         0 - |
 MEMADDR :                        E - |  MLOOP59 :                      377 C |
*MOMCPU :                      1802 - | *MOMCPUNAME :                  1802 - |
 MSLP54 :                       21E C |  MULTLOOP16_1655 :              22B C |
 MULTSKIP16_1655 :              23D C | *NESTMAX :                      100 - |
 NORESTORE58 :                  35D C | *PACKING :                        0 - |
*PADDING :                        1 - |  POS157 :                       2B3 C |
 POS160 :                       426 C |  POS257 :                       2C3 C |
 POS260 :                       44D C |  R0 :                             0 - |
 R1 :                             1 - |  R10 :                            A - |
 R11 :                            B - | *R12 :                            C - |
*R13 :                            D - |  R14 :                            E - |
 R15 :                            F - | *R2 :                             2 - |
 R3 :                             3 - | *R4 :                             4 - |
*R5 :                             5 - | *R6 :                             6 - |
*R7 :                             7 - |  R8 :                             8 - |
 R9 :                             9 - |  RCALL :                          4 - |
 REGARG1 :                        C - |  REGARG2 :                        D - |
*RELAXED :                        1 - |  RETADDR :                        6 - |
 RETVAL :                         F - |  RL0 :                            1 - |
 RL10 :                           B - | *RL12 :                           D - |
 RL8 :                            9 - |  RP1P2 :                          D - |
 RPC :                            3 - |  RRET :                           5 - |
 RT1 :                            8 - | *RT2 :                            9 - |
 RWORK :                          E - |  SHIFT59 :                      3AE C |
 SP :                             2 - | *TIME :                    10:39:30 - |
*TRUE :                           1 - |  UPNXT61 :                      4F0 C |
*VERSION :                     142F - |  _0000046 :                     16A C |
 _CALL :                        201 C |  _DIE46 :                       16B C |
 _DIVI2 :                       2A4 C |  _DIVI4 :                       400 C |
 _DIVU2 :                       249 C |  _DIVU4 :                       300 C |
*_DUBDABX :                     475 C | *_FILL_CHECKSUM :                 3 C |
*_INP :                         545 C | *_MODI2 :                       17C C |
*_MODI4 :                       51E C | *_MODU2 :                       174 C |
*_MODU4 :                       512 C | *_MULU2 :                       223 C |
*_MULU4 :                       366 C | *_ONEMS :                       21C C |
 AS V1.42 Beta [Bld 87] - source file failertoo.asm - page 13 - 4/25/2013 10:39:31


*_OUT :                         55F C | *_OUT4 :                        184 C |
*_OUT5 :                        540 C | *_PUTC :                        540 C |
 _RETURN :                      212 C | *_SETQOFF :                     172 C |
*_SETQON :                      170 C |  __FORW0 :                      55C C |
*__FORW1 :                      570 C |

    123 symbols
     56 unused symbols

 AS V1.42 Beta [Bld 87] - source file failertoo.asm - page 14 - 4/25/2013 10:39:31


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU4                                  | ALU4I                                
BLKCPY                                | CCALL                                
CPY1                                  | CPY2                                 
CPY4                                  | CRETN                                
DECM                                  | INC4                                 
INCM                                  | JCF4                                 
JCI2                                  | JCI2I                                
JCI4                                  | JCU2                                 
JCU2I                                 | JCU4                                 
JEQI2                                 | JEQI4                                
JEQU2I                                | JNEU2                                
JNEU2I                                | JNEU4                                
JNI2I                                 | JNU2I                                
JNZU2                                 | JUMPV                                
JZU2                                  | LD1                                  
LD2                                   | LD2Z                                 
LD4                                   | LDA2                                 
LDAD                                  | LDAX                                 
LDI4                                  | LDIREG                               
LDN1                                  | NEGI2                                
NEGI4                                 | POPR                                 
PUSHR                                 | RELEASE                              
RELEASEL                              | RELEASES                             
RESERVE                               | RESERVEL                             
RESERVES                              | RLDMI                                
SAVMI                                 | SEXT                                 
SEXT4                                 | SHL2                                 
SHL2I                                 | SHL2R                                
SHL4                                  | SHL4I                                
SHL4R                                 | SHLC4                                
SHRC4                                 | SHRI2                                
SHRI2I                                | SHRI2R                               
SHRI4                                 | SHRI4I                               
SHRI4R                                | SHRU2                                
SHRU2I                                | SHRU2R                               
SHRU4                                 | SHRU4I                               
SHRU4R                                | ST1                                  
ST2                                   | ST4                                  
STR1                                  | ZEXT                                 
ZEXT4                                 |

     81 macros

 AS V1.42 Beta [Bld 87] - source file failertoo.asm - page 15 - 4/25/2013 10:39:31


  codepages:
  ----------

STANDARD (0 changed characters)


0.06 seconds assembly time

   1438 lines source file
   2206 lines incl. macro expansions
      2 passes
        additional necessary passes not started due to
        errors, listing possibly incorrect
      1 error
      0 warnings
