; generated by lcc-xr18fl $Version: 4.0 - XR18FL - St. Judy's Compiler $ on Thu Mar 21 10:18:38 2013

SP:	equ	2 ;stack pointer
memAddr: equ	14
retAddr: equ	6
retVal:	equ	15
regArg1: equ	12
regArg2: equ	13
	listing off
	include lcc1802ProloNO.inc
	listing on
_PIN4:
	db 0
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=6,sz=2  ret 3951360
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=6,sz=2  ret 3951360
_main:
	reserve 4; save room for local variables
	pushr r7
	reserve 4; save room for outgoing arguments
;{
;	printstr("long division mule\n");
	ldaD R12,L2; reg:acon
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
	Ccall _printstr
;	quotient=7;dividend=10*1000; divisor=10;
	ldaD R7,7; reg:acon
	ldaD R11,10000; reg:acon
	st2 R11,'O',sp,(-4+12); ASGNU2(addr,reg)*
	ldaD R11,10; reg:acon
	st2 R11,'O',sp,(-6+12); ASGNU2(addr,reg)*
;	printf("quotient was %d\n",quotient);
	ldaD R12,L3; reg:acon
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
	cpy2 R13,R7 ;LOADU2(reg)*
;argreg(argno=1,offset=2,ty=6,sz=2  ret 3951360
	Ccall _printf
;	quotient=dividend/divisor;
	ld2 R12,'O',sp,(-4+12); reg:INDIRU2(addr)
	ld2 R13,'O',sp,(-6+12); reg:INDIRU2(addr)
	Ccall _divu2
	cpy2 R11,R15 ;LOADU2(reg)*
	cpy2 R7,R11 ;LOADU2(reg)*
;	printf("quotient is %d\n",quotient);
	ldaD R12,L4; reg:acon
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
	cpy2 R13,R7 ;LOADU2(reg)*
;argreg(argno=1,offset=2,ty=6,sz=2  ret 3951360
	Ccall _printf
;}
L1:
	release 4; release room for outgoing arguments
	popr r7
	release 4; release room for local variables 
	Cretn

;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
_strcpy:
	reserve 2
;{
;	char *save = to;
	st2 R12,'O',sp,(-4+4); ASGNP2
;	for (; (*to = *from) != 0; ++from, ++to);
	lbr L9
L6:
L7:
	incm R13,1
	incm R12,1
L9:
	ldn1 R11,R13;reg:  INDIRU1(indaddr)
	str1 R11,R12; ASGNU1(indaddr,reg)
	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	jnzU2 r11,L6; NE 0
;	return(save);
	ld2 R15,'O',sp,(-4+4);reg:  INDIRP2(addr)
L5:
	release 2
	Cretn

;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=5,sz=2  ret 3951360
_printstr:
	reserve 0; save room for local variables
	pushr r7
	reserve 4; save room for outgoing arguments
	cpy2 r7,r12; function(2055) 1
;void printstr(char *ptr){
	lbr L12
L11:
;    while(*ptr) out(5,*ptr++);
	ldaD R12,5; reg:acon
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	cpy2 R11,R7 ;LOADP2(reg)
	cpy2 R7,R11
	incm R7,1
	ld1 R13,'O',R11,0
	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
;argreg(argno=1,offset=2,ty=5,sz=2  ret 3951360
	Ccall _out
L12:
	ld1 R11,'O',R7,0
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jnzU2 r11,L11; NE 0
;}
L10:
	release 4; release room for outgoing arguments
	popr r7
	release 0; release room for local variables 
	Cretn

;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
_itoa:
	reserve 4; save room for local variables
	pushr r0
	pushr r1
	pushr r7
	reserve 4; save room for outgoing arguments
	st2 r12,'O',sp,(16); flag1 
	st2 r13,'O',sp,(18); flag1 
;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
;	unsigned int flag=0;
	ld2z R11
	st2 R11,'O',sp,(-4+16); ASGNU2(addr,reg)*
;	char * bptr; bptr=buffer;
	ld2 R11,'O',sp,(2+16);reg:  INDIRP2(addr)
	st2 R11,'O',sp,(-6+16); ASGNP2
;	if (s<0){
	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
	jcI2I r11,0,lbdf,L15; GE is flipped test from LT
;		*bptr='-';bptr++;
	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
	ldaD R10,45; reg:acon
	str1 R10,R11; ASGNU1(indaddr,reg)
	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(-6+16); ASGNP2
;		n=-s;
	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
	cpy2 R1,R11 ;LOADU2(reg)*
;	} else{
	lbr L16
L15:
;		n=s;
	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
	cpy2 R1,R11 ;LOADU2(reg)*
;	}
L16:
;	k=10000;
	ldaD R7,10000; reg:acon
	lbr L18
L17:
;	while(k>0){
;		for(r=0;k<=n;r++,n-=k); // was r=n/k
	ld2z R0
	lbr L23
L20:
L21:
	incm R0,1
	alu2 R1,R1,R7,sm,smb
L23:
	jcU2 r1,r7,lbdf,L20 ;LE is flipped test & operands
;		if (flag || r>0||k==1){
	ld2 R11,'O',sp,(-4+16); reg:INDIRU2(addr)
	jnzU2 r11,L27; NE 0
	jnzU2 r0,L27; NE 0
	jneU2I r7,1,L24; NE
L27:
;			*bptr=('0'+r);bptr++;
	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
	ldA2 R10,'O',R0,(48); reg:addr
	str1 R10,R11; ASGNU1(indaddr,reg)
	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
	incm R11,1
	st2 R11,'O',sp,(-6+16); ASGNP2
;			flag='y';
	ldaD R11,121; reg:acon
	st2 R11,'O',sp,(-4+16); ASGNU2(addr,reg)*
;		}
L24:
;		k=k/10;
	cpy2 R12,R7 ;LOADU2(reg)*
	ldaD R13,10; reg:acon
	Ccall _divu2
	cpy2 R11,R15 ;LOADU2(reg)*
	cpy2 R7,R11 ;LOADU2(reg)*
;	}
L18:
;	while(k>0){
	jnzU2 r7,L17; NE 0
;	*bptr='\0';
	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
	ldaD R10,0; reg:acon
	str1 R10,R11; ASGNU1(indaddr,reg)
;	return buffer;
	ld2 R15,'O',sp,(2+16);reg:  INDIRP2(addr)
L14:
	release 4; release room for outgoing arguments
	popr r7
	popr r1
	popr r0
	release 4; release room for local variables 
	Cretn

;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
;argreg(argno=1,offset=4,ty=7,sz=2  ret null
;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
;argreg(argno=1,offset=4,ty=7,sz=2  ret null
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
_ltoa:
	reserve 0; save room for local variables
	pushr r0
	pushr r1
	pushr r7
	reserve 6; save room for outgoing arguments
	cpy4 RL0,RL12; halfbaked
;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
;	char* bptr=buffer;
	ld2 R7,'O',sp,(4+14);reg:  INDIRP2(addr)
;	if (s<0){
	ldI4 RL10,0 ;loading a long integer constant
	jcI4 RL0,RL10,lbdf,L29; GE is flipped test from LT
;		*bptr++='-';
	cpy2 R11,R7 ;LOADP2(reg)
	cpy2 R7,R11
	incm R7,1
	ldaD R10,45; reg:acon
	str1 R10,R11; ASGNU1(indaddr,reg)
;		s=-s;
	negI4 RL0,RL0 ;was alu4I RL0,RL0,0,sdi,sdbi
;	}
L29:
;	strcpy(bptr,dubdabx(s,bptr)); //uses assembler double-dabble routine
	cpy4 Rp1p2,RL0; LOADI4*
;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
;argreg(argno=1,offset=4,ty=7,sz=2  ret null
	st2 r7,'O',sp,(4); arg+f**
	Ccall _dubdabx
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R7 ;LOADP2(reg)
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
	cpy2 R13,R11 ;LOADP2(reg)
;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
	Ccall _strcpy
;	return buffer;
	ld2 R15,'O',sp,(4+14);reg:  INDIRP2(addr)
L28:
	release 6; release room for outgoing arguments
	popr r7
	popr r1
	popr r0
	release 0; release room for local variables 
	Cretn

;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
_printint:
	reserve 12
	st2 r12,'O',sp,(14); flag1 
;void printint(int s){ //print an integer
;	itoa(s,buffer);
	ld2 R12,'O',sp,(0+14) ;reg:INDIRI2(addr)
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	ldA2 R13,'O',sp,(-10+14); reg:addr
;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
	Ccall _itoa
;	printstr(buffer);
	ldA2 R12,'O',sp,(-10+14); reg:addr
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
	Ccall _printstr
;}
L31:
	release 12
	Cretn

;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
;argreg(argno=1,offset=4,ty=7,sz=2  ret null
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
_printlint:
	reserve 18
	st2 r12,'O',sp,(20); flag1 
	st2 r13,'O',sp,(22); flag1 
;void printlint(long s){ //print a long integer
;	printstr(ltoa(s,buffer));
	ld4 Rp1p2,'O',sp,(0+20)
;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
	ldA2 R11,'O',sp,(-14+20); reg:addr
;argreg(argno=1,offset=4,ty=7,sz=2  ret null
	st2 r11,'O',sp,(4); arg+f**
	Ccall _ltoa
	cpy2 R11,R15 ;LOADP2(reg)
	cpy2 R12,R11 ;LOADP2(reg)
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
	Ccall _printstr
;}
L32:
	release 18
	Cretn

;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
_putxn:
	reserve 4
	st2 r12,'O',sp,(6); flag1 
	ld2 R11,'O',sp,(0+6) ;reg:INDIRI2(addr)
	st1 R11,'O',sp,(0+6); ASGNU1
;void putxn(unsigned char x){ //print a nibble as ascii hex
;	if (x<10){
	ld1 R11,'O',sp,(0+6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jcI2I r11,10,lbdf,L34; GE is flipped test from LT
;		putc(x+'0');
	ld1 R11,'O',sp,(0+6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldA2 R11,'O',R11,(48); reg:addr
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putc
;	} else {
	lbr L35
L34:
;		putc(x+'A'-10);
	ld1 R11,'O',sp,(0+6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ldA2 R11,'O',R11,(65); reg:addr
	alu2I R11,R11,10,smi,smbi
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putc
;	}
L35:
;}
L33:
	release 4
	Cretn

;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
_putx:
	reserve 4
	st2 r12,'O',sp,(6); flag1 
	ld2 R11,'O',sp,(0+6) ;reg:INDIRI2(addr)
	st1 R11,'O',sp,(0+6); ASGNU1
;void putx(unsigned char x){ //print a unsigned char as ascii hex
;	putxn(x>>4);
	ld1 R11,'O',sp,(0+6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	shrI2I R11,4
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putxn
;	putxn(x & 0x0F);
	ld1 R11,'O',sp,(0+6)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	alu2I R11,R11,15,ani,ani
	;removed ?	cpy2 R11,R11
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putxn
;}
L36:
	release 4
	Cretn

;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
_printf:
	reserve 4; save room for local variables
	pushr r0
	pushr r1
	pushr r7
	reserve 4; save room for outgoing arguments
	st2 r12,'O',sp,(16); flag1 
	st2 r13,'O',sp,(18); flag2
;void printf(char *ptr,...){ //limited implementation of printf
;	int argslot=0;	//used to align longs
	ld2z R0
;	int * this=(int *)&ptr;
	ldA2 R1,'O',sp,(0+16); reg:addr
;	this++; argslot++; //advance argument pointer and slot #
	incm R1,2
	incm R0,1
	lbr L39
L38:
;    while(*ptr) {
;		c=*ptr++;
	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(0+16); ASGNP2
	ldn1 R7,R11;reg:  INDIRU1(indaddr)
;		if (c!='%'){
	cpy1 R11,R7
	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	jeqU2I r11,37,L41;EQI2(reg,con)
;			putc(c);
	cpy1 R12,R7
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putc
;		} else{
	lbr L42
L41:
;			c=*ptr++;
	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(0+16); ASGNP2
	ldn1 R7,R11;reg:  INDIRU1(indaddr)
;			switch (c){
	cpy1 R11,R7
	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
	st2 R11,'O',sp,(-5+16)
	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
	jeqU2I r11,105,L46;EQI2(reg,con)
	ldaD R10,108; reg:acon
	jeqI2 r11,r10,L50; EQI2(reg,reg)
	jcI2 r10,r11,lbnf,L58 ;GT is reversed operands from LT
L57:
	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
	ldaD R10,88; reg:acon
	jeqI2 r11,r10,L49; EQI2(reg,reg)
	jcI2 r11,r10,lbnf,L43; LT=lbnf i.e. subtract B from A and jump if borrow 
L59:
	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
	jeqU2I r11,99,L48;EQI2(reg,con)
	jeqU2I r11,100,L46;EQI2(reg,con)
	lbr L43
L58:
	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
	ldaD R10,115; reg:acon
	jeqI2 r11,r10,L47; EQI2(reg,reg)
	jcI2 r11,r10,lbnf,L43; LT=lbnf i.e. subtract B from A and jump if borrow 
L60:
	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
	jeqU2I r11,120,L49;EQI2(reg,con)
	lbr L43
L46:
;					printint(*this++);
	cpy2 R11,R1 ;LOADP2(reg)
	cpy2 R1,R11
	incm R1,2
	ld2 R12,'O',R11,0 ;reg:INDIRI2(addr)
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _printint
;					argslot+=1; //next argument slot
	incm R0,1
;					break;
	lbr L44
L47:
;					printstr((char*) *this++);
	cpy2 R11,R1 ;LOADP2(reg)
	cpy2 R1,R11
	incm R1,2
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	cpy2 R12,R11 ;LOADP2(reg)
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
	Ccall _printstr
;					argslot+=1; //next argument slot
	incm R0,1
;					break;
	lbr L44
L48:
;					putc((unsigned int) *this++);
	cpy2 R11,R1 ;LOADP2(reg)
	cpy2 R1,R11
	incm R1,2
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putc
;					argslot+=1; //next argument slot
	incm R0,1
;					break;
	lbr L44
L49:
;					putx(((unsigned int) *this)>>8);
	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
	shrU2I R11,8
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putx
;					putx(((unsigned int) *this++)&255);
	cpy2 R11,R1 ;LOADP2(reg)
	cpy2 R1,R11
	incm R1,2
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putx
;					argslot+=1; //next argument slot
	incm R0,1
;					break;
	lbr L44
L50:
;					if (*ptr){ //as long as there's something there
	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
	ld1 R11,'O',R11,0
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jzU2 r11,L51; EQ 0
;						xord=*ptr++;
	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
	cpy2 R10,R11
	incm R10,1
	st2 R10,'O',sp,(0+16); ASGNP2
	ldn1 R11,R11;reg:  INDIRU1(indaddr)
	st1 R11,'O',sp,(-3+16); ASGNU1
;						if (argslot&1) {
	alu2I R11,R0,1,ani,ani
	;removed ?	cpy2 R11,R0
	jzU2 r11,L53; EQ 0
;							this++;
	incm R1,2
;							argslot++;
	incm R0,1
;						}
L53:
;						if(xord=='d'){
	ld1 R11,'O',sp,(-3+16)
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jneU2I r11,100,L55; NE
;							printlint(*(long *)this);//treats "this" as a pointer to long
	ld4 Rp1p2,'O',R1,0
;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
	Ccall _printlint
;							this+=2;				// and advances it 4 bytes
	incm R1,4
;						} else{
	lbr L56
L55:
;							putx(((unsigned int) *this)>>8);
	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
	shrU2I R11,8
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putx
;							putx(((unsigned int) *this++)&255);
	cpy2 R11,R1 ;LOADP2(reg)
	cpy2 R1,R11
	incm R1,2
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putx
;							putx(((unsigned int) *this)>>8);
	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
	shrU2I R11,8
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putx
;							putx(((unsigned int) *this++)&255);
	cpy2 R11,R1 ;LOADP2(reg)
	cpy2 R1,R11
	incm R1,2
	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
	cpy1 R12,R11
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putx
;						}
L56:
;						argslot+=2;
	incm R0,2
;						break;
	lbr L44
L51:
L43:
;					putc('%');putc(c);
	ldaD R12,37; reg:acon
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putc
	cpy1 R12,R7
	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
	Ccall _putc
;			} //switch
L44:
;		} //%
L42:
;	} //while
L39:
;    while(*ptr) {
	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
	ld1 R11,'O',R11,0
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	jnzU2 r11,L38; NE 0
;} //prtf
L37:
	release 4; release room for outgoing arguments
	popr r7
	popr r1
	popr r0
	release 4; release room for local variables 
	Cretn

;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=5,sz=2  ret 3951360
_exit:
	reserve 4
	st2 r12,'O',sp,(6); flag1 
;void exit(int code){
;	printf("exit %d\n",code);
	ldaD R12,L62; reg:acon
;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
	ld2 R13,'O',sp,(0+6) ;reg:INDIRI2(addr)
;argreg(argno=1,offset=2,ty=5,sz=2  ret 3951360
	Ccall _printf
L63:
;	while(1);
L64:
	lbr L63
;}
L61:
	release 4
	Cretn

;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
;argreg(argno=2,offset=4,ty=6,sz=2  ret null
_memcmp:
	reserve 2; save room for local variables
	pushr r0
	pushr r1
	pushr r7
	reserve 0; save room for outgoing arguments
	ld2 R7,'O',sp,(4+10); reg:INDIRU2(addr)
;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
;    int v = 0;
	ld2z R1
;    p1 = (unsigned char *)Ptr1;
	cpy2 R0,R12 ;LOADP2(reg)
;    p2 = (unsigned char *)Ptr2;
	st2 R13,'O',sp,(-4+10); ASGNP2
	lbr L68
L67:
;    while(Count-- > 0 && v == 0) {
;        v = *(p1++) - *(p2++);
	cpy2 R11,R0 ;LOADP2(reg)
	cpy2 R0,R11
	incm R0,1
	ld2 R10,'O',sp,(-4+10);reg:  INDIRP2(addr)
	cpy2 R9,R10
	incm R9,1
	st2 R9,'O',sp,(-4+10); ASGNP2
	ld1 R11,'O',R11,0
	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
	ld1 R10,'O',R10,0
	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
	alu2 R1,R11,R10,sm,smb
;    }
L68:
;    while(Count-- > 0 && v == 0) {
	cpy2 R11,R7 ;LOADU2(reg)*
	cpy2 R7,R11
	decm R7,1
	jeqU2I r11,0,L70;EQU2(reg,con)
	jzU2 r1,L67; EQ 0
L70:
;    return v;
	cpy2 R15,R1 ;LOADI2(reg)
L66:
	release 0; release room for outgoing arguments
	popr r7
	popr r1
	popr r0
	release 2; release room for local variables 
	Cretn

;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
;argreg(argno=2,offset=4,ty=6,sz=2  ret null
_memcpy:
	reserve 0; save room for local variables
	pushr r0
	pushr r1
	pushr r7
	reserve 0; save room for outgoing arguments
	ld2 R7,'O',sp,(4+8); reg:INDIRU2(addr)
;void* memcpy(void* dest, const void* src, unsigned int count) {
;        char* dst8 = (char*)dest;
	cpy2 R1,R12 ;LOADP2(reg)
;        char* src8 = (char*)src;
	cpy2 R0,R13 ;LOADP2(reg)
	lbr L73
L72:
;        while (count--) {
;            *dst8++ = *src8++;
	cpy2 R11,R1 ;LOADP2(reg)
	cpy2 R1,R11
	incm R1,1
	cpy2 R10,R0 ;LOADP2(reg)
	cpy2 R0,R10
	incm R0,1
	ldn1 R10,R10;reg:  INDIRU1(indaddr)
	str1 R10,R11; ASGNU1(indaddr,reg)
;        }
L73:
;        while (count--) {
	cpy2 R11,R7 ;LOADU2(reg)*
	cpy2 R7,R11
	decm R7,1
	jnzU2 r11,L72; NE 0
;        return dest;
	cpy2 R15,R12 ;LOADP2(reg)
L71:
	release 0; release room for outgoing arguments
	popr r7
	popr r1
	popr r0
	release 0; release room for local variables 
	Cretn

;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
;argreg(argno=1,offset=2,ty=5,sz=2  ret 3951360
;argreg(argno=2,offset=4,ty=6,sz=2  ret null
_memset:
	reserve 0; save room for local variables
	pushr r1
	pushr r7
	reserve 0; save room for outgoing arguments
	ld2 R7,'O',sp,(4+6); reg:INDIRU2(addr)
;{
;    unsigned char* p=s;
	cpy2 R1,R12 ;LOADP2(reg)
	lbr L77
L76:
;        *p++ = (unsigned char)c;
	cpy2 R11,R1 ;LOADP2(reg)
	cpy2 R1,R11
	incm R1,1
	cpy2 R10,R13 ;LOADU2(reg)*
	str1 R10,R11; ASGNU1(indaddr,reg)
L77:
;    while(n--)
	cpy2 R11,R7 ;LOADU2(reg)*
	cpy2 R7,R11
	decm R7,1
	jnzU2 r11,L76; NE 0
;    return s;
	cpy2 R15,R12 ;LOADP2(reg)
L75:
	release 0; release room for outgoing arguments
	popr r7
	popr r1
	release 0; release room for local variables 
	Cretn

;argreg(argno=0,offset=0,ty=6,sz=2  ret 3951224
_delay:
	reserve 0; save room for local variables
	pushr r1
	pushr r7
	reserve 4; save room for outgoing arguments
	cpy2 r7,r12; function(2054) 1
;void delay(unsigned int howlong){
;	for (i=1;i!=howlong;i++){
	ldaD R1,1; reg:acon
	lbr L83
L80:
;		oneMs();
	Ccall _oneMs
;	}
L81:
;	for (i=1;i!=howlong;i++){
	incm R1,1
L83:
	jneU2 r1,r7,L80; NE
;}
L79:
	release 4; release room for outgoing arguments
	popr r7
	popr r1
	release 0; release room for local variables 
	Cretn

_olduinoincluder:
;void olduinoincluder(){
;	asm("\tinclude olduino.inc\n");
	include olduino.inc
;}
L84:
	Cretn

L62:
	db 101
	db 120
	db 105
	db 116
	db 32
	db 37
	db 100
	db 10
	db 0
L4:
	db 113
	db 117
	db 111
	db 116
	db 105
	db 101
	db 110
	db 116
	db 32
	db 105
	db 115
	db 32
	db 37
	db 100
	db 10
	db 0
L3:
	db 113
	db 117
	db 111
	db 116
	db 105
	db 101
	db 110
	db 116
	db 32
	db 119
	db 97
	db 115
	db 32
	db 37
	db 100
	db 10
	db 0
L2:
	db 108
	db 111
	db 110
	db 103
	db 32
	db 100
	db 105
	db 118
	db 105
	db 115
	db 105
	db 111
	db 110
	db 32
	db 109
	db 117
	db 108
	db 101
	db 10
	db 0
	include lcc1802EpiloNO.inc
	include IO1802.inc
