 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 1 - 3/21/2013 10:18:48


       1/       0 :                     ; generated by lcc-xr18fl $Version: 4.0 - XR18FL - St. Judy's Compiler $ on Thu Mar 21 10:18:38 2013
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1)  812/       0 :                     	listing	on
(1)  813/       0 : C0 0B AF            	lbr	lcc1802Init
(1)  814/       3 :                     
      11/       3 :                     	listing on
      12/       3 :                     _PIN4:
      13/       3 : 00                  	db 0
      14/       4 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
      15/       4 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
      16/       4 :                     ;argreg(argno=1,offset=2,ty=6,sz=2  ret 3951360
      17/       4 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
      18/       4 :                     ;argreg(argno=1,offset=2,ty=6,sz=2  ret 3951360
      19/       4 :                     _main:
      20/       4 : (MACRO)             	reserve 4; save room for local variables
      21/       8 : (MACRO)             	pushr r7
      22/       D : (MACRO)             	reserve 4; save room for outgoing arguments
      23/      11 :                     ;{
      24/      11 :                     ;	printstr("long division mule\n");
      25/      11 : (MACRO)             	ldaD R12,L2; reg:acon
      26/      17 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
      27/      17 : (MACRO)             	Ccall _printstr
      28/      1A :                     ;	quotient=7;dividend=10*1000; divisor=10;
      29/      1A : (MACRO)             	ldaD R7,7; reg:acon
      30/      20 : (MACRO)             	ldaD R11,10000; reg:acon
      31/      26 : (MACRO)             	st2 R11,'O',sp,(-4+12); ASGNU2(addr,reg)*
      32/      33 : (MACRO)             	ldaD R11,10; reg:acon
      33/      39 : (MACRO)             	st2 R11,'O',sp,(-6+12); ASGNU2(addr,reg)*
      34/      46 :                     ;	printf("quotient was %d\n",quotient);
      35/      46 : (MACRO)             	ldaD R12,L3; reg:acon
      36/      4C :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
      37/      4C : (MACRO)             	cpy2 R13,R7 ;LOADU2(reg)*
      38/      50 :                     ;argreg(argno=1,offset=2,ty=6,sz=2  ret 3951360
      39/      50 : (MACRO)             	Ccall _printf
      40/      53 :                     ;	quotient=dividend/divisor;
      41/      53 : (MACRO)             	ld2 R12,'O',sp,(-4+12); reg:INDIRU2(addr)
      42/      5F : (MACRO)             	ld2 R13,'O',sp,(-6+12); reg:INDIRU2(addr)
      43/      6B : (MACRO)             	Ccall _divu2
      44/      6E : (MACRO)             	cpy2 R11,R15 ;LOADU2(reg)*
      45/      72 : (MACRO)             	cpy2 R7,R11 ;LOADU2(reg)*
      46/      76 :                     ;	printf("quotient is %d\n",quotient);
      47/      76 : (MACRO)             	ldaD R12,L4; reg:acon
      48/      7C :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
      49/      7C : (MACRO)             	cpy2 R13,R7 ;LOADU2(reg)*
      50/      80 :                     ;argreg(argno=1,offset=2,ty=6,sz=2  ret 3951360
      51/      80 : (MACRO)             	Ccall _printf
      52/      83 :                     ;}
      53/      83 :                     L1:
      54/      83 : (MACRO)             	release 4; release room for outgoing arguments
      55/      87 : (MACRO)             	popr r7
      56/      8B : (MACRO)             	release 4; release room for local variables 
      57/      8F : (MACRO)             	Cretn
      58/      90 :                     
      59/      90 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 2 - 3/21/2013 10:18:48


      60/      90 :                     ;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
      61/      90 :                     _strcpy:
      62/      90 : (MACRO)             	reserve 2
      63/      92 :                     ;{
      64/      92 :                     ;	char *save = to;
      65/      92 : (MACRO)             	st2 R12,'O',sp,(-4+4); ASGNP2
      66/      9F :                     ;	for (; (*to = *from) != 0; ++from, ++to);
      67/      9F : C0 00 A4            	lbr L9
      68/      A2 :                     L6:
      69/      A2 :                     L7:
      70/      A2 : (MACRO)             	incm R13,1
      71/      A3 : (MACRO)             	incm R12,1
      72/      A4 :                     L9:
      73/      A4 : (MACRO)             	ldn1 R11,R13;reg:  INDIRU1(indaddr)
      74/      A6 : (MACRO)             	str1 R11,R12; ASGNU1(indaddr,reg)
      75/      A8 : (MACRO)             	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
      76/      AB : (MACRO)             	jnzU2 r11,L6; NE 0
      77/      B3 :                     ;	return(save);
      78/      B3 : (MACRO)             	ld2 R15,'O',sp,(-4+4);reg:  INDIRP2(addr)
      79/      BF :                     L5:
      80/      BF : (MACRO)             	release 2
      81/      C1 : (MACRO)             	Cretn
      82/      C2 :                     
      83/      C2 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
      84/      C2 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
      85/      C2 :                     ;argreg(argno=1,offset=2,ty=5,sz=2  ret 3951360
      86/      C2 :                     _printstr:
      87/      C2 : (MACRO)             	reserve 0; save room for local variables
      88/      C2 : (MACRO)             	pushr r7
      89/      C7 : (MACRO)             	reserve 4; save room for outgoing arguments
      90/      CB : (MACRO)             	cpy2 r7,r12; function(2055) 1
      91/      CF :                     ;void printstr(char *ptr){
      92/      CF : C0 00 F1            	lbr L12
      93/      D2 :                     L11:
      94/      D2 :                     ;    while(*ptr) out(5,*ptr++);
      95/      D2 : (MACRO)             	ldaD R12,5; reg:acon
      96/      D8 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
      97/      D8 : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg)
      98/      DC : (MACRO)             	cpy2 R7,R11
      99/      E0 : (MACRO)             	incm R7,1
     100/      E1 : (MACRO)             	ld1 R13,'O',R11,0
     101/      EB : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     102/      EE :                     ;argreg(argno=1,offset=2,ty=5,sz=2  ret 3951360
     103/      EE : (MACRO)             	Ccall _out
     104/      F1 :                     L12:
     105/      F1 : (MACRO)             	ld1 R11,'O',R7,0
     106/      FB : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     107/      FE : (MACRO)             	jnzU2 r11,L11; NE 0
     108/     106 :                     ;}
     109/     106 :                     L10:
     110/     106 : (MACRO)             	release 4; release room for outgoing arguments
     111/     10A : (MACRO)             	popr r7
     112/     10E : (MACRO)             	release 0; release room for local variables 
     113/     10E : (MACRO)             	Cretn
     114/     10F :                     
     115/     10F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     116/     10F :                     ;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
     117/     10F :                     _itoa:
     118/     10F : (MACRO)             	reserve 4; save room for local variables
     119/     113 : (MACRO)             	pushr r0
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 3 - 3/21/2013 10:18:48


     120/     118 : (MACRO)             	pushr r1
     121/     11D : (MACRO)             	pushr r7
     122/     122 : (MACRO)             	reserve 4; save room for outgoing arguments
     123/     126 : (MACRO)             	st2 r12,'O',sp,(16); flag1 
     124/     133 : (MACRO)             	st2 r13,'O',sp,(18); flag1 
     125/     140 :                     ;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
     126/     140 :                     ;	unsigned int flag=0;
     127/     140 : (MACRO)             	ld2z R11
     128/     144 : (MACRO)             	st2 R11,'O',sp,(-4+16); ASGNU2(addr,reg)*
     129/     151 :                     ;	char * bptr; bptr=buffer;
     130/     151 : (MACRO)             	ld2 R11,'O',sp,(2+16);reg:  INDIRP2(addr)
     131/     15D : (MACRO)             	st2 R11,'O',sp,(-6+16); ASGNP2
     132/     16A :                     ;	if (s<0){
     133/     16A : (MACRO)             	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
     134/     176 : (MACRO)             	jcI2I r11,0,lbdf,L15; GE is flipped test from LT
     135/     187 :                     ;		*bptr='-';bptr++;
     136/     187 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     137/     193 : (MACRO)             	ldaD R10,45; reg:acon
     138/     199 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     139/     19B : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     140/     1A7 : (MACRO)             	incm R11,1
     141/     1A8 : (MACRO)             	st2 R11,'O',sp,(-6+16); ASGNP2
     142/     1B5 :                     ;		n=-s;
     143/     1B5 : (MACRO)             	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
     144/     1C1 : (MACRO)             	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
     145/     1CA : (MACRO)             	cpy2 R1,R11 ;LOADU2(reg)*
     146/     1CE :                     ;	} else{
     147/     1CE : C0 01 E1            	lbr L16
     148/     1D1 :                     L15:
     149/     1D1 :                     ;		n=s;
     150/     1D1 : (MACRO)             	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
     151/     1DD : (MACRO)             	cpy2 R1,R11 ;LOADU2(reg)*
     152/     1E1 :                     ;	}
     153/     1E1 :                     L16:
     154/     1E1 :                     ;	k=10000;
     155/     1E1 : (MACRO)             	ldaD R7,10000; reg:acon
     156/     1E7 : C0 02 8B            	lbr L18
     157/     1EA :                     L17:
     158/     1EA :                     ;	while(k>0){
     159/     1EA :                     ;		for(r=0;k<=n;r++,n-=k); // was r=n/k
     160/     1EA : (MACRO)             	ld2z R0
     161/     1EE : C0 01 FE            	lbr L23
     162/     1F1 :                     L20:
     163/     1F1 :                     L21:
     164/     1F1 : (MACRO)             	incm R0,1
     165/     1F2 : (MACRO)             	alu2 R1,R1,R7,sm,smb
     166/     1FE :                     L23:
     167/     1FE : (MACRO)             	jcU2 r1,r7,lbdf,L20 ;LE is flipped test & operands
     168/     20B :                     ;		if (flag || r>0||k==1){
     169/     20B : (MACRO)             	ld2 R11,'O',sp,(-4+16); reg:INDIRU2(addr)
     170/     217 : (MACRO)             	jnzU2 r11,L27; NE 0
     171/     21F : (MACRO)             	jnzU2 r0,L27; NE 0
     172/     227 : (MACRO)             	jneU2I r7,1,L24; NE
     173/     233 :                     L27:
     174/     233 :                     ;			*bptr=('0'+r);bptr++;
     175/     233 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     176/     23F : (MACRO)             	ldA2 R10,'O',R0,(48); reg:addr
     177/     247 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     178/     249 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     179/     255 : (MACRO)             	incm R11,1
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 4 - 3/21/2013 10:18:48


     180/     256 : (MACRO)             	st2 R11,'O',sp,(-6+16); ASGNP2
     181/     263 :                     ;			flag='y';
     182/     263 : (MACRO)             	ldaD R11,121; reg:acon
     183/     269 : (MACRO)             	st2 R11,'O',sp,(-4+16); ASGNU2(addr,reg)*
     184/     276 :                     ;		}
     185/     276 :                     L24:
     186/     276 :                     ;		k=k/10;
     187/     276 : (MACRO)             	cpy2 R12,R7 ;LOADU2(reg)*
     188/     27A : (MACRO)             	ldaD R13,10; reg:acon
     189/     280 : (MACRO)             	Ccall _divu2
     190/     283 : (MACRO)             	cpy2 R11,R15 ;LOADU2(reg)*
     191/     287 : (MACRO)             	cpy2 R7,R11 ;LOADU2(reg)*
     192/     28B :                     ;	}
     193/     28B :                     L18:
     194/     28B :                     ;	while(k>0){
     195/     28B : (MACRO)             	jnzU2 r7,L17; NE 0
     196/     293 :                     ;	*bptr='\0';
     197/     293 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     198/     29F : (MACRO)             	ldaD R10,0; reg:acon
     199/     2A5 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     200/     2A7 :                     ;	return buffer;
     201/     2A7 : (MACRO)             	ld2 R15,'O',sp,(2+16);reg:  INDIRP2(addr)
     202/     2B3 :                     L14:
     203/     2B3 : (MACRO)             	release 4; release room for outgoing arguments
     204/     2B7 : (MACRO)             	popr r7
     205/     2BB : (MACRO)             	popr r1
     206/     2BF : (MACRO)             	popr r0
     207/     2C3 : (MACRO)             	release 4; release room for local variables 
     208/     2C7 : (MACRO)             	Cretn
     209/     2C8 :                     
     210/     2C8 :                     ;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
     211/     2C8 :                     ;argreg(argno=1,offset=4,ty=7,sz=2  ret null
     212/     2C8 :                     ;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
     213/     2C8 :                     ;argreg(argno=1,offset=4,ty=7,sz=2  ret null
     214/     2C8 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     215/     2C8 :                     ;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
     216/     2C8 :                     _ltoa:
     217/     2C8 : (MACRO)             	reserve 0; save room for local variables
     218/     2C8 : (MACRO)             	pushr r0
     219/     2CD : (MACRO)             	pushr r1
     220/     2D2 : (MACRO)             	pushr r7
     221/     2D7 : (MACRO)             	reserve 6; save room for outgoing arguments
     222/     2DD : (MACRO)             	cpy4 RL0,RL12; halfbaked
     223/     2E5 :                     ;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
     224/     2E5 :                     ;	char* bptr=buffer;
     225/     2E5 : (MACRO)             	ld2 R7,'O',sp,(4+14);reg:  INDIRP2(addr)
     226/     2F1 :                     ;	if (s<0){
     227/     2F1 : (MACRO)             	ldI4 RL10,0 ;loading a long integer constant
     228/     2FD : (MACRO)             	jcI4 RL0,RL10,lbdf,L29; GE is flipped test from LT
     229/     319 :                     ;		*bptr++='-';
     230/     319 : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg)
     231/     31D : (MACRO)             	cpy2 R7,R11
     232/     321 : (MACRO)             	incm R7,1
     233/     322 : (MACRO)             	ldaD R10,45; reg:acon
     234/     328 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     235/     32A :                     ;		s=-s;
     236/     32A : (MACRO)             	negI4 RL0,RL0 ;was alu4I RL0,RL0,0,sdi,sdbi
     237/     34A :                     ;	}
     238/     34A :                     L29:
     239/     34A :                     ;	strcpy(bptr,dubdabx(s,bptr)); //uses assembler double-dabble routine
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 5 - 3/21/2013 10:18:48


     240/     34A : (MACRO)             	cpy4 Rp1p2,RL0; LOADI4*
     241/     352 :                     ;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
     242/     352 :                     ;argreg(argno=1,offset=4,ty=7,sz=2  ret null
     243/     352 : (MACRO)             	st2 r7,'O',sp,(4); arg+f**
     244/     35F : (MACRO)             	Ccall _dubdabx
     245/     362 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     246/     366 : (MACRO)             	cpy2 R12,R7 ;LOADP2(reg)
     247/     36A :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     248/     36A : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     249/     36E :                     ;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
     250/     36E : (MACRO)             	Ccall _strcpy
     251/     371 :                     ;	return buffer;
     252/     371 : (MACRO)             	ld2 R15,'O',sp,(4+14);reg:  INDIRP2(addr)
     253/     37D :                     L28:
     254/     37D : (MACRO)             	release 6; release room for outgoing arguments
     255/     383 : (MACRO)             	popr r7
     256/     387 : (MACRO)             	popr r1
     257/     38B : (MACRO)             	popr r0
     258/     38F : (MACRO)             	release 0; release room for local variables 
     259/     38F : (MACRO)             	Cretn
     260/     390 :                     
     261/     390 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     262/     390 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     263/     390 :                     ;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
     264/     390 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     265/     390 :                     _printint:
     266/     390 : (MACRO)             	reserve 12
     267/     39A : (MACRO)             	st2 r12,'O',sp,(14); flag1 
     268/     3A7 :                     ;void printint(int s){ //print an integer
     269/     3A7 :                     ;	itoa(s,buffer);
     270/     3A7 : (MACRO)             	ld2 R12,'O',sp,(0+14) ;reg:INDIRI2(addr)
     271/     3B3 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     272/     3B3 : (MACRO)             	ldA2 R13,'O',sp,(-10+14); reg:addr
     273/     3BB :                     ;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
     274/     3BB : (MACRO)             	Ccall _itoa
     275/     3BE :                     ;	printstr(buffer);
     276/     3BE : (MACRO)             	ldA2 R12,'O',sp,(-10+14); reg:addr
     277/     3C6 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     278/     3C6 : (MACRO)             	Ccall _printstr
     279/     3C9 :                     ;}
     280/     3C9 :                     L31:
     281/     3C9 : (MACRO)             	release 12
     282/     3D1 : (MACRO)             	Cretn
     283/     3D2 :                     
     284/     3D2 :                     ;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
     285/     3D2 :                     ;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
     286/     3D2 :                     ;argreg(argno=1,offset=4,ty=7,sz=2  ret null
     287/     3D2 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     288/     3D2 :                     _printlint:
     289/     3D2 : (MACRO)             	reserve 18
     290/     3DC : (MACRO)             	st2 r12,'O',sp,(20); flag1 
     291/     3E9 : (MACRO)             	st2 r13,'O',sp,(22); flag1 
     292/     3F6 :                     ;void printlint(long s){ //print a long integer
     293/     3F6 :                     ;	printstr(ltoa(s,buffer));
     294/     3F6 : (MACRO)             	ld4 Rp1p2,'O',sp,(0+20)
     295/     406 :                     ;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
     296/     406 : (MACRO)             	ldA2 R11,'O',sp,(-14+20); reg:addr
     297/     40E :                     ;argreg(argno=1,offset=4,ty=7,sz=2  ret null
     298/     40E : (MACRO)             	st2 r11,'O',sp,(4); arg+f**
     299/     41B : (MACRO)             	Ccall _ltoa
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 6 - 3/21/2013 10:18:48


     300/     41E : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     301/     422 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     302/     426 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     303/     426 : (MACRO)             	Ccall _printstr
     304/     429 :                     ;}
     305/     429 :                     L32:
     306/     429 : (MACRO)             	release 18
     307/     431 : (MACRO)             	Cretn
     308/     432 :                     
     309/     432 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     310/     432 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     311/     432 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     312/     432 :                     _putxn:
     313/     432 : (MACRO)             	reserve 4
     314/     436 : (MACRO)             	st2 r12,'O',sp,(6); flag1 
     315/     443 : (MACRO)             	ld2 R11,'O',sp,(0+6) ;reg:INDIRI2(addr)
     316/     44F : (MACRO)             	st1 R11,'O',sp,(0+6); ASGNU1
     317/     459 :                     ;void putxn(unsigned char x){ //print a nibble as ascii hex
     318/     459 :                     ;	if (x<10){
     319/     459 : (MACRO)             	ld1 R11,'O',sp,(0+6)
     320/     463 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     321/     466 : (MACRO)             	jcI2I r11,10,lbdf,L34; GE is flipped test from LT
     322/     477 :                     ;		putc(x+'0');
     323/     477 : (MACRO)             	ld1 R11,'O',sp,(0+6)
     324/     481 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     325/     484 : (MACRO)             	ldA2 R11,'O',R11,(48); reg:addr
     326/     48C : (MACRO)             	cpy1 R12,R11
     327/     48E : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     328/     491 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     329/     491 : (MACRO)             	Ccall _putc
     330/     494 :                     ;	} else {
     331/     494 : C0 04 BC            	lbr L35
     332/     497 :                     L34:
     333/     497 :                     ;		putc(x+'A'-10);
     334/     497 : (MACRO)             	ld1 R11,'O',sp,(0+6)
     335/     4A1 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     336/     4A4 : (MACRO)             	ldA2 R11,'O',R11,(65); reg:addr
     337/     4AC : (MACRO)             	alu2I R11,R11,10,smi,smbi
     338/     4B4 : (MACRO)             	cpy1 R12,R11
     339/     4B6 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     340/     4B9 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     341/     4B9 : (MACRO)             	Ccall _putc
     342/     4BC :                     ;	}
     343/     4BC :                     L35:
     344/     4BC :                     ;}
     345/     4BC :                     L33:
     346/     4BC : (MACRO)             	release 4
     347/     4C0 : (MACRO)             	Cretn
     348/     4C1 :                     
     349/     4C1 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     350/     4C1 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     351/     4C1 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     352/     4C1 :                     _putx:
     353/     4C1 : (MACRO)             	reserve 4
     354/     4C5 : (MACRO)             	st2 r12,'O',sp,(6); flag1 
     355/     4D2 : (MACRO)             	ld2 R11,'O',sp,(0+6) ;reg:INDIRI2(addr)
     356/     4DE : (MACRO)             	st1 R11,'O',sp,(0+6); ASGNU1
     357/     4E8 :                     ;void putx(unsigned char x){ //print a unsigned char as ascii hex
     358/     4E8 :                     ;	putxn(x>>4);
     359/     4E8 : (MACRO)             	ld1 R11,'O',sp,(0+6)
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 7 - 3/21/2013 10:18:48


     360/     4F2 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     361/     4F5 : (MACRO)             	shrI2I R11,4
     362/     515 : (MACRO)             	cpy1 R12,R11
     363/     517 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     364/     51A :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     365/     51A : (MACRO)             	Ccall _putxn
     366/     51D :                     ;	putxn(x & 0x0F);
     367/     51D : (MACRO)             	ld1 R11,'O',sp,(0+6)
     368/     527 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     369/     52A : (MACRO)             	alu2I R11,R11,15,ani,ani
     370/     532 :                     	;removed ?	cpy2 R11,R11
     371/     532 : (MACRO)             	cpy1 R12,R11
     372/     534 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     373/     537 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     374/     537 : (MACRO)             	Ccall _putxn
     375/     53A :                     ;}
     376/     53A :                     L36:
     377/     53A : (MACRO)             	release 4
     378/     53E : (MACRO)             	Cretn
     379/     53F :                     
     380/     53F :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     381/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     382/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     383/     53F :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     384/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     385/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     386/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     387/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
     388/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     389/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     390/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     391/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     392/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     393/     53F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     394/     53F :                     _printf:
     395/     53F : (MACRO)             	reserve 4; save room for local variables
     396/     543 : (MACRO)             	pushr r0
     397/     548 : (MACRO)             	pushr r1
     398/     54D : (MACRO)             	pushr r7
     399/     552 : (MACRO)             	reserve 4; save room for outgoing arguments
     400/     556 : (MACRO)             	st2 r12,'O',sp,(16); flag1 
     401/     563 : (MACRO)             	st2 r13,'O',sp,(18); flag2
     402/     570 :                     ;void printf(char *ptr,...){ //limited implementation of printf
     403/     570 :                     ;	int argslot=0;	//used to align longs
     404/     570 : (MACRO)             	ld2z R0
     405/     574 :                     ;	int * this=(int *)&ptr;
     406/     574 : (MACRO)             	ldA2 R1,'O',sp,(0+16); reg:addr
     407/     57C :                     ;	this++; argslot++; //advance argument pointer and slot #
     408/     57C : (MACRO)             	incm R1,2
     409/     57E : (MACRO)             	incm R0,1
     410/     57F : C0 09 2F            	lbr L39
     411/     582 :                     L38:
     412/     582 :                     ;    while(*ptr) {
     413/     582 :                     ;		c=*ptr++;
     414/     582 : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     415/     58E : (MACRO)             	cpy2 R10,R11
     416/     592 : (MACRO)             	incm R10,1
     417/     593 : (MACRO)             	st2 R10,'O',sp,(0+16); ASGNP2
     418/     5A0 : (MACRO)             	ldn1 R7,R11;reg:  INDIRU1(indaddr)
     419/     5A2 :                     ;		if (c!='%'){
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 8 - 3/21/2013 10:18:48


     420/     5A2 : (MACRO)             	cpy1 R11,R7
     421/     5A4 : (MACRO)             	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     422/     5A7 : (MACRO)             	jeqU2I r11,37,L41;EQI2(reg,con)
     423/     5B3 :                     ;			putc(c);
     424/     5B3 : (MACRO)             	cpy1 R12,R7
     425/     5B5 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     426/     5B8 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     427/     5B8 : (MACRO)             	Ccall _putc
     428/     5BB :                     ;		} else{
     429/     5BB : C0 09 2F            	lbr L42
     430/     5BE :                     L41:
     431/     5BE :                     ;			c=*ptr++;
     432/     5BE : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     433/     5CA : (MACRO)             	cpy2 R10,R11
     434/     5CE : (MACRO)             	incm R10,1
     435/     5CF : (MACRO)             	st2 R10,'O',sp,(0+16); ASGNP2
     436/     5DC : (MACRO)             	ldn1 R7,R11;reg:  INDIRU1(indaddr)
     437/     5DE :                     ;			switch (c){
     438/     5DE : (MACRO)             	cpy1 R11,R7
     439/     5E0 : (MACRO)             	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     440/     5E3 : (MACRO)             	st2 R11,'O',sp,(-5+16)
     441/     5F0 : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     442/     5FC : (MACRO)             	jeqU2I r11,105,L46;EQI2(reg,con)
     443/     608 : (MACRO)             	ldaD R10,108; reg:acon
     444/     60E : (MACRO)             	jeqI2 r11,r10,L50; EQI2(reg,reg)
     445/     620 : (MACRO)             	jcI2 r10,r11,lbnf,L58 ;GT is reversed operands from LT
     446/     634 :                     L57:
     447/     634 : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     448/     640 : (MACRO)             	ldaD R10,88; reg:acon
     449/     646 : (MACRO)             	jeqI2 r11,r10,L49; EQI2(reg,reg)
     450/     658 : (MACRO)             	jcI2 r11,r10,lbnf,L43; LT=lbnf i.e. subtract B from A and jump if borrow 
     451/     66C :                     L59:
     452/     66C : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     453/     678 : (MACRO)             	jeqU2I r11,99,L48;EQI2(reg,con)
     454/     684 : (MACRO)             	jeqU2I r11,100,L46;EQI2(reg,con)
     455/     690 : C0 09 1E            	lbr L43
     456/     693 :                     L58:
     457/     693 : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     458/     69F : (MACRO)             	ldaD R10,115; reg:acon
     459/     6A5 : (MACRO)             	jeqI2 r11,r10,L47; EQI2(reg,reg)
     460/     6B7 : (MACRO)             	jcI2 r11,r10,lbnf,L43; LT=lbnf i.e. subtract B from A and jump if borrow 
     461/     6CB :                     L60:
     462/     6CB : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     463/     6D7 : (MACRO)             	jeqU2I r11,120,L49;EQI2(reg,con)
     464/     6E3 : C0 09 1E            	lbr L43
     465/     6E6 :                     L46:
     466/     6E6 :                     ;					printint(*this++);
     467/     6E6 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     468/     6EA : (MACRO)             	cpy2 R1,R11
     469/     6EE : (MACRO)             	incm R1,2
     470/     6F0 : (MACRO)             	ld2 R12,'O',R11,0 ;reg:INDIRI2(addr)
     471/     6FC :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     472/     6FC : (MACRO)             	Ccall _printint
     473/     6FF :                     ;					argslot+=1; //next argument slot
     474/     6FF : (MACRO)             	incm R0,1
     475/     700 :                     ;					break;
     476/     700 : C0 09 2F            	lbr L44
     477/     703 :                     L47:
     478/     703 :                     ;					printstr((char*) *this++);
     479/     703 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 9 - 3/21/2013 10:18:48


     480/     707 : (MACRO)             	cpy2 R1,R11
     481/     70B : (MACRO)             	incm R1,2
     482/     70D : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     483/     719 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     484/     71D :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     485/     71D : (MACRO)             	Ccall _printstr
     486/     720 :                     ;					argslot+=1; //next argument slot
     487/     720 : (MACRO)             	incm R0,1
     488/     721 :                     ;					break;
     489/     721 : C0 09 2F            	lbr L44
     490/     724 :                     L48:
     491/     724 :                     ;					putc((unsigned int) *this++);
     492/     724 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     493/     728 : (MACRO)             	cpy2 R1,R11
     494/     72C : (MACRO)             	incm R1,2
     495/     72E : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     496/     73A : (MACRO)             	cpy1 R12,R11
     497/     73C : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     498/     73F :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     499/     73F : (MACRO)             	Ccall _putc
     500/     742 :                     ;					argslot+=1; //next argument slot
     501/     742 : (MACRO)             	incm R0,1
     502/     743 :                     ;					break;
     503/     743 : C0 09 2F            	lbr L44
     504/     746 :                     L49:
     505/     746 :                     ;					putx(((unsigned int) *this)>>8);
     506/     746 : (MACRO)             	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
     507/     752 : (MACRO)             	shrU2I R11,8
     508/     782 : (MACRO)             	cpy1 R12,R11
     509/     784 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     510/     787 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     511/     787 : (MACRO)             	Ccall _putx
     512/     78A :                     ;					putx(((unsigned int) *this++)&255);
     513/     78A : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     514/     78E : (MACRO)             	cpy2 R1,R11
     515/     792 : (MACRO)             	incm R1,2
     516/     794 : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     517/     7A0 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     518/     7A8 : (MACRO)             	cpy1 R12,R11
     519/     7AA : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     520/     7AD :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     521/     7AD : (MACRO)             	Ccall _putx
     522/     7B0 :                     ;					argslot+=1; //next argument slot
     523/     7B0 : (MACRO)             	incm R0,1
     524/     7B1 :                     ;					break;
     525/     7B1 : C0 09 2F            	lbr L44
     526/     7B4 :                     L50:
     527/     7B4 :                     ;					if (*ptr){ //as long as there's something there
     528/     7B4 : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     529/     7C0 : (MACRO)             	ld1 R11,'O',R11,0
     530/     7CA : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     531/     7CD : (MACRO)             	jzU2 r11,L51; EQ 0
     532/     7D5 :                     ;						xord=*ptr++;
     533/     7D5 : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     534/     7E1 : (MACRO)             	cpy2 R10,R11
     535/     7E5 : (MACRO)             	incm R10,1
     536/     7E6 : (MACRO)             	st2 R10,'O',sp,(0+16); ASGNP2
     537/     7F3 : (MACRO)             	ldn1 R11,R11;reg:  INDIRU1(indaddr)
     538/     7F5 : (MACRO)             	st1 R11,'O',sp,(-3+16); ASGNU1
     539/     7FF :                     ;						if (argslot&1) {
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 10 - 3/21/2013 10:18:48


     540/     7FF : (MACRO)             	alu2I R11,R0,1,ani,ani
     541/     807 :                     	;removed ?	cpy2 R11,R0
     542/     807 : (MACRO)             	jzU2 r11,L53; EQ 0
     543/     80F :                     ;							this++;
     544/     80F : (MACRO)             	incm R1,2
     545/     811 :                     ;							argslot++;
     546/     811 : (MACRO)             	incm R0,1
     547/     812 :                     ;						}
     548/     812 :                     L53:
     549/     812 :                     ;						if(xord=='d'){
     550/     812 : (MACRO)             	ld1 R11,'O',sp,(-3+16)
     551/     81C : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     552/     81F : (MACRO)             	jneU2I r11,100,L55; NE
     553/     82B :                     ;							printlint(*(long *)this);//treats "this" as a pointer to long
     554/     82B : (MACRO)             	ld4 Rp1p2,'O',R1,0
     555/     83B :                     ;argreg(argno=0,offset=0,ty=5,sz=4  ret p1p2
     556/     83B : (MACRO)             	Ccall _printlint
     557/     83E :                     ;							this+=2;				// and advances it 4 bytes
     558/     83E : (MACRO)             	incm R1,4
     559/     842 :                     ;						} else{
     560/     842 : C0 09 19            	lbr L56
     561/     845 :                     L55:
     562/     845 :                     ;							putx(((unsigned int) *this)>>8);
     563/     845 : (MACRO)             	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
     564/     851 : (MACRO)             	shrU2I R11,8
     565/     881 : (MACRO)             	cpy1 R12,R11
     566/     883 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     567/     886 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     568/     886 : (MACRO)             	Ccall _putx
     569/     889 :                     ;							putx(((unsigned int) *this++)&255);
     570/     889 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     571/     88D : (MACRO)             	cpy2 R1,R11
     572/     891 : (MACRO)             	incm R1,2
     573/     893 : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     574/     89F : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     575/     8A7 : (MACRO)             	cpy1 R12,R11
     576/     8A9 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     577/     8AC :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     578/     8AC : (MACRO)             	Ccall _putx
     579/     8AF :                     ;							putx(((unsigned int) *this)>>8);
     580/     8AF : (MACRO)             	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
     581/     8BB : (MACRO)             	shrU2I R11,8
     582/     8EB : (MACRO)             	cpy1 R12,R11
     583/     8ED : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     584/     8F0 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     585/     8F0 : (MACRO)             	Ccall _putx
     586/     8F3 :                     ;							putx(((unsigned int) *this++)&255);
     587/     8F3 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     588/     8F7 : (MACRO)             	cpy2 R1,R11
     589/     8FB : (MACRO)             	incm R1,2
     590/     8FD : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     591/     909 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     592/     911 : (MACRO)             	cpy1 R12,R11
     593/     913 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     594/     916 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     595/     916 : (MACRO)             	Ccall _putx
     596/     919 :                     ;						}
     597/     919 :                     L56:
     598/     919 :                     ;						argslot+=2;
     599/     919 : (MACRO)             	incm R0,2
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 11 - 3/21/2013 10:18:48


     600/     91B :                     ;						break;
     601/     91B : C0 09 2F            	lbr L44
     602/     91E :                     L51:
     603/     91E :                     L43:
     604/     91E :                     ;					putc('%');putc(c);
     605/     91E : (MACRO)             	ldaD R12,37; reg:acon
     606/     924 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     607/     924 : (MACRO)             	Ccall _putc
     608/     927 : (MACRO)             	cpy1 R12,R7
     609/     929 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     610/     92C :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     611/     92C : (MACRO)             	Ccall _putc
     612/     92F :                     ;			} //switch
     613/     92F :                     L44:
     614/     92F :                     ;		} //%
     615/     92F :                     L42:
     616/     92F :                     ;	} //while
     617/     92F :                     L39:
     618/     92F :                     ;    while(*ptr) {
     619/     92F : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     620/     93B : (MACRO)             	ld1 R11,'O',R11,0
     621/     945 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     622/     948 : (MACRO)             	jnzU2 r11,L38; NE 0
     623/     950 :                     ;} //prtf
     624/     950 :                     L37:
     625/     950 : (MACRO)             	release 4; release room for outgoing arguments
     626/     954 : (MACRO)             	popr r7
     627/     958 : (MACRO)             	popr r1
     628/     95C : (MACRO)             	popr r0
     629/     960 : (MACRO)             	release 4; release room for local variables 
     630/     964 : (MACRO)             	Cretn
     631/     965 :                     
     632/     965 :                     ;argreg(argno=0,offset=0,ty=5,sz=2  ret 3951224
     633/     965 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     634/     965 :                     ;argreg(argno=1,offset=2,ty=5,sz=2  ret 3951360
     635/     965 :                     _exit:
     636/     965 : (MACRO)             	reserve 4
     637/     969 : (MACRO)             	st2 r12,'O',sp,(6); flag1 
     638/     976 :                     ;void exit(int code){
     639/     976 :                     ;	printf("exit %d\n",code);
     640/     976 : (MACRO)             	ldaD R12,L62; reg:acon
     641/     97C :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     642/     97C : (MACRO)             	ld2 R13,'O',sp,(0+6) ;reg:INDIRI2(addr)
     643/     988 :                     ;argreg(argno=1,offset=2,ty=5,sz=2  ret 3951360
     644/     988 : (MACRO)             	Ccall _printf
     645/     98B :                     L63:
     646/     98B :                     ;	while(1);
     647/     98B :                     L64:
     648/     98B : C0 09 8B            	lbr L63
     649/     98E :                     ;}
     650/     98E :                     L61:
     651/     98E : (MACRO)             	release 4
     652/     992 : (MACRO)             	Cretn
     653/     993 :                     
     654/     993 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     655/     993 :                     ;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
     656/     993 :                     ;argreg(argno=2,offset=4,ty=6,sz=2  ret null
     657/     993 :                     _memcmp:
     658/     993 : (MACRO)             	reserve 2; save room for local variables
     659/     995 : (MACRO)             	pushr r0
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 12 - 3/21/2013 10:18:48


     660/     99A : (MACRO)             	pushr r1
     661/     99F : (MACRO)             	pushr r7
     662/     9A4 : (MACRO)             	reserve 0; save room for outgoing arguments
     663/     9A4 : (MACRO)             	ld2 R7,'O',sp,(4+10); reg:INDIRU2(addr)
     664/     9B0 :                     ;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
     665/     9B0 :                     ;    int v = 0;
     666/     9B0 : (MACRO)             	ld2z R1
     667/     9B4 :                     ;    p1 = (unsigned char *)Ptr1;
     668/     9B4 : (MACRO)             	cpy2 R0,R12 ;LOADP2(reg)
     669/     9B8 :                     ;    p2 = (unsigned char *)Ptr2;
     670/     9B8 : (MACRO)             	st2 R13,'O',sp,(-4+10); ASGNP2
     671/     9C5 : C0 0A 15            	lbr L68
     672/     9C8 :                     L67:
     673/     9C8 :                     ;    while(Count-- > 0 && v == 0) {
     674/     9C8 :                     ;        v = *(p1++) - *(p2++);
     675/     9C8 : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg)
     676/     9CC : (MACRO)             	cpy2 R0,R11
     677/     9D0 : (MACRO)             	incm R0,1
     678/     9D1 : (MACRO)             	ld2 R10,'O',sp,(-4+10);reg:  INDIRP2(addr)
     679/     9DD : (MACRO)             	cpy2 R9,R10
     680/     9E1 : (MACRO)             	incm R9,1
     681/     9E2 : (MACRO)             	st2 R9,'O',sp,(-4+10); ASGNP2
     682/     9EF : (MACRO)             	ld1 R11,'O',R11,0
     683/     9F9 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     684/     9FC : (MACRO)             	ld1 R10,'O',R10,0
     685/     A06 : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     686/     A09 : (MACRO)             	alu2 R1,R11,R10,sm,smb
     687/     A15 :                     ;    }
     688/     A15 :                     L68:
     689/     A15 :                     ;    while(Count-- > 0 && v == 0) {
     690/     A15 : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg)*
     691/     A19 : (MACRO)             	cpy2 R7,R11
     692/     A1D : (MACRO)             	decm R7,1
     693/     A1E : (MACRO)             	jeqU2I r11,0,L70;EQU2(reg,con)
     694/     A2A : (MACRO)             	jzU2 r1,L67; EQ 0
     695/     A32 :                     L70:
     696/     A32 :                     ;    return v;
     697/     A32 : (MACRO)             	cpy2 R15,R1 ;LOADI2(reg)
     698/     A36 :                     L66:
     699/     A36 : (MACRO)             	release 0; release room for outgoing arguments
     700/     A36 : (MACRO)             	popr r7
     701/     A3A : (MACRO)             	popr r1
     702/     A3E : (MACRO)             	popr r0
     703/     A42 : (MACRO)             	release 2; release room for local variables 
     704/     A44 : (MACRO)             	Cretn
     705/     A45 :                     
     706/     A45 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     707/     A45 :                     ;argreg(argno=1,offset=2,ty=7,sz=2  ret 3951360
     708/     A45 :                     ;argreg(argno=2,offset=4,ty=6,sz=2  ret null
     709/     A45 :                     _memcpy:
     710/     A45 : (MACRO)             	reserve 0; save room for local variables
     711/     A45 : (MACRO)             	pushr r0
     712/     A4A : (MACRO)             	pushr r1
     713/     A4F : (MACRO)             	pushr r7
     714/     A54 : (MACRO)             	reserve 0; save room for outgoing arguments
     715/     A54 : (MACRO)             	ld2 R7,'O',sp,(4+8); reg:INDIRU2(addr)
     716/     A60 :                     ;void* memcpy(void* dest, const void* src, unsigned int count) {
     717/     A60 :                     ;        char* dst8 = (char*)dest;
     718/     A60 : (MACRO)             	cpy2 R1,R12 ;LOADP2(reg)
     719/     A64 :                     ;        char* src8 = (char*)src;
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 13 - 3/21/2013 10:18:48


     720/     A64 : (MACRO)             	cpy2 R0,R13 ;LOADP2(reg)
     721/     A68 : C0 0A 81            	lbr L73
     722/     A6B :                     L72:
     723/     A6B :                     ;        while (count--) {
     724/     A6B :                     ;            *dst8++ = *src8++;
     725/     A6B : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     726/     A6F : (MACRO)             	cpy2 R1,R11
     727/     A73 : (MACRO)             	incm R1,1
     728/     A74 : (MACRO)             	cpy2 R10,R0 ;LOADP2(reg)
     729/     A78 : (MACRO)             	cpy2 R0,R10
     730/     A7C : (MACRO)             	incm R0,1
     731/     A7D : (MACRO)             	ldn1 R10,R10;reg:  INDIRU1(indaddr)
     732/     A7F : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     733/     A81 :                     ;        }
     734/     A81 :                     L73:
     735/     A81 :                     ;        while (count--) {
     736/     A81 : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg)*
     737/     A85 : (MACRO)             	cpy2 R7,R11
     738/     A89 : (MACRO)             	decm R7,1
     739/     A8A : (MACRO)             	jnzU2 r11,L72; NE 0
     740/     A92 :                     ;        return dest;
     741/     A92 : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
     742/     A96 :                     L71:
     743/     A96 : (MACRO)             	release 0; release room for outgoing arguments
     744/     A96 : (MACRO)             	popr r7
     745/     A9A : (MACRO)             	popr r1
     746/     A9E : (MACRO)             	popr r0
     747/     AA2 : (MACRO)             	release 0; release room for local variables 
     748/     AA2 : (MACRO)             	Cretn
     749/     AA3 :                     
     750/     AA3 :                     ;argreg(argno=0,offset=0,ty=7,sz=2  ret 3951224
     751/     AA3 :                     ;argreg(argno=1,offset=2,ty=5,sz=2  ret 3951360
     752/     AA3 :                     ;argreg(argno=2,offset=4,ty=6,sz=2  ret null
     753/     AA3 :                     _memset:
     754/     AA3 : (MACRO)             	reserve 0; save room for local variables
     755/     AA3 : (MACRO)             	pushr r1
     756/     AA8 : (MACRO)             	pushr r7
     757/     AAD : (MACRO)             	reserve 0; save room for outgoing arguments
     758/     AAD : (MACRO)             	ld2 R7,'O',sp,(4+6); reg:INDIRU2(addr)
     759/     AB9 :                     ;{
     760/     AB9 :                     ;    unsigned char* p=s;
     761/     AB9 : (MACRO)             	cpy2 R1,R12 ;LOADP2(reg)
     762/     ABD : C0 0A CF            	lbr L77
     763/     AC0 :                     L76:
     764/     AC0 :                     ;        *p++ = (unsigned char)c;
     765/     AC0 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     766/     AC4 : (MACRO)             	cpy2 R1,R11
     767/     AC8 : (MACRO)             	incm R1,1
     768/     AC9 : (MACRO)             	cpy2 R10,R13 ;LOADU2(reg)*
     769/     ACD : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     770/     ACF :                     L77:
     771/     ACF :                     ;    while(n--)
     772/     ACF : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg)*
     773/     AD3 : (MACRO)             	cpy2 R7,R11
     774/     AD7 : (MACRO)             	decm R7,1
     775/     AD8 : (MACRO)             	jnzU2 r11,L76; NE 0
     776/     AE0 :                     ;    return s;
     777/     AE0 : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
     778/     AE4 :                     L75:
     779/     AE4 : (MACRO)             	release 0; release room for outgoing arguments
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 14 - 3/21/2013 10:18:48


     780/     AE4 : (MACRO)             	popr r7
     781/     AE8 : (MACRO)             	popr r1
     782/     AEC : (MACRO)             	release 0; release room for local variables 
     783/     AEC : (MACRO)             	Cretn
     784/     AED :                     
     785/     AED :                     ;argreg(argno=0,offset=0,ty=6,sz=2  ret 3951224
     786/     AED :                     _delay:
     787/     AED : (MACRO)             	reserve 0; save room for local variables
     788/     AED : (MACRO)             	pushr r1
     789/     AF2 : (MACRO)             	pushr r7
     790/     AF7 : (MACRO)             	reserve 4; save room for outgoing arguments
     791/     AFB : (MACRO)             	cpy2 r7,r12; function(2054) 1
     792/     AFF :                     ;void delay(unsigned int howlong){
     793/     AFF :                     ;	for (i=1;i!=howlong;i++){
     794/     AFF : (MACRO)             	ldaD R1,1; reg:acon
     795/     B05 : C0 0B 0C            	lbr L83
     796/     B08 :                     L80:
     797/     B08 :                     ;		oneMs();
     798/     B08 : (MACRO)             	Ccall _oneMs
     799/     B0B :                     ;	}
     800/     B0B :                     L81:
     801/     B0B :                     ;	for (i=1;i!=howlong;i++){
     802/     B0B : (MACRO)             	incm R1,1
     803/     B0C :                     L83:
     804/     B0C : (MACRO)             	jneU2 r1,r7,L80; NE
     805/     B1E :                     ;}
     806/     B1E :                     L79:
     807/     B1E : (MACRO)             	release 4; release room for outgoing arguments
     808/     B22 : (MACRO)             	popr r7
     809/     B26 : (MACRO)             	popr r1
     810/     B2A : (MACRO)             	release 0; release room for local variables 
     811/     B2A : (MACRO)             	Cretn
     812/     B2B :                     
     813/     B2B :                     _olduinoincluder:
     814/     B2B :                     ;void olduinoincluder(){
     815/     B2B :                     ;	asm("\tinclude olduino.inc\n");
     816/     B2B :                     	include olduino.inc
(1)    1/     B2B :                     ;Feb 8 2013, first version of assembler routines for olduino support	
(1)    2/     B2B :                     
(1)    3/     B2B :                     ;digitalWrite(unsigned char n, unsigned char hilo){ //set a bit in the output port on or off
(1)    4/     B2B :                     	align 64	;needed to make sure all on same page
(1)    5/     B40 :                     _digitalWrite:
(1)    6/     B40 : 8C                  	glo regArg1	;get the bit number
(1)    7/     B41 : FC 5F               	adi $$bvtable&255	;add the table offset
(1)    8/     B43 : AE                  	plo memaddr
(1)    9/     B44 : 93                  	ghi RPC		;get the top byte of the current page
(1)   10/     B45 : BE                  	phi memaddr	
(1)   11/     B46 : 0E                  	ldn memaddr	;pick up the bit pattern
(1)   12/     B47 : A8                  	plo rt1		;save it in a temp
(1)   13/     B48 : (MACRO)             	lda2 memaddr,_PIN4 ;address the current port value
(1)   14/     B4E : EE                  	sex memaddr	;prepare to change it
(1)   15/     B4F : 8D                  	glo regArg2	;get on/off switch
(1)   16/     B50 : 32 57               	bz $$setbitoff
(1)   17/     B52 :                     ; here we have the bit pattern in rt1 and we're ready to apply it with OR
(1)   18/     B52 : 88                  	glo rt1		;get the bit value back
(1)   19/     B53 : F1                  	or		;apply it
(1)   20/     B54 : 5E                  	str memaddr	;and save it
(1)   21/     B55 : 30 5C               	br $$outit	;go fnish up
(1)   22/     B57 :                     $$setbitoff:
(1)   23/     B57 : 88                  	glo rt1		;get the bit pattern
 AS V1.42 Beta [Bld 87] - source file longdivide.asm(olduino.inc) - page 15 - 3/21/2013 10:18:48


(1)   24/     B58 : FB FF               	xri 0xff	;reverse it
(1)   25/     B5A : F2                  	and		;combine it with the existing pin value
(1)   26/     B5B : 5E                  	str memaddr	;and save it
(1)   27/     B5C :                     ;here we gave set/reset the correct bit in PIN4 and we just have to send it out
(1)   28/     B5C :                     $$outit:
(1)   29/     B5C : 64                  	out 4		;X was already set to memaddr
(1)   30/     B5D : E2                  	sex sp		;reset X
(1)   31/     B5E : (MACRO)             	cretn
(1)   32/     B5F : 01 02 04 08 10 20   $$bvtable db 1,2,4,8,16,32,64,128	;table of bit values
                    40 80 
(1)   33/     B67 :                     ;int digitalRead(unsigned char pin){//for now this will always read ef3
(1)   34/     B67 :                     	align 8	;protect jump boundary
(1)   35/     B68 :                     _digitalRead:
(1)   36/     B68 : F8 00               	ldi 0		;default is false
(1)   37/     B6A : AF                  	plo R15
(1)   38/     B6B : BF                  	phi R15
(1)   39/     B6C : 36 6F               	b3 +		;i have to reverse the sense of the external line
(1)   40/     B6E : 1F                  	inc R15		;if external line is high, supply a 1
(1)   41/     B6F : (MACRO)             +	cretn
(1)   42/     B70 :                     
     817/     B70 :                     ;}
     818/     B70 :                     L84:
     819/     B70 : (MACRO)             	Cretn
     820/     B71 :                     
     821/     B71 :                     L62:
     822/     B71 : 65                  	db 101
     823/     B72 : 78                  	db 120
     824/     B73 : 69                  	db 105
     825/     B74 : 74                  	db 116
     826/     B75 : 20                  	db 32
     827/     B76 : 25                  	db 37
     828/     B77 : 64                  	db 100
     829/     B78 : 0A                  	db 10
     830/     B79 : 00                  	db 0
     831/     B7A :                     L4:
     832/     B7A : 71                  	db 113
     833/     B7B : 75                  	db 117
     834/     B7C : 6F                  	db 111
     835/     B7D : 74                  	db 116
     836/     B7E : 69                  	db 105
     837/     B7F : 65                  	db 101
     838/     B80 : 6E                  	db 110
     839/     B81 : 74                  	db 116
     840/     B82 : 20                  	db 32
     841/     B83 : 69                  	db 105
     842/     B84 : 73                  	db 115
     843/     B85 : 20                  	db 32
     844/     B86 : 25                  	db 37
     845/     B87 : 64                  	db 100
     846/     B88 : 0A                  	db 10
     847/     B89 : 00                  	db 0
     848/     B8A :                     L3:
     849/     B8A : 71                  	db 113
     850/     B8B : 75                  	db 117
     851/     B8C : 6F                  	db 111
     852/     B8D : 74                  	db 116
     853/     B8E : 69                  	db 105
     854/     B8F : 65                  	db 101
     855/     B90 : 6E                  	db 110
     856/     B91 : 74                  	db 116
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 16 - 3/21/2013 10:18:48


     857/     B92 : 20                  	db 32
     858/     B93 : 77                  	db 119
     859/     B94 : 61                  	db 97
     860/     B95 : 73                  	db 115
     861/     B96 : 20                  	db 32
     862/     B97 : 25                  	db 37
     863/     B98 : 64                  	db 100
     864/     B99 : 0A                  	db 10
     865/     B9A : 00                  	db 0
     866/     B9B :                     L2:
     867/     B9B : 6C                  	db 108
     868/     B9C : 6F                  	db 111
     869/     B9D : 6E                  	db 110
     870/     B9E : 67                  	db 103
     871/     B9F : 20                  	db 32
     872/     BA0 : 64                  	db 100
     873/     BA1 : 69                  	db 105
     874/     BA2 : 76                  	db 118
     875/     BA3 : 69                  	db 105
     876/     BA4 : 73                  	db 115
     877/     BA5 : 69                  	db 105
     878/     BA6 : 6F                  	db 111
     879/     BA7 : 6E                  	db 110
     880/     BA8 : 20                  	db 32
     881/     BA9 : 6D                  	db 109
     882/     BAA : 75                  	db 117
     883/     BAB : 6C                  	db 108
     884/     BAC : 65                  	db 101
     885/     BAD : 0A                  	db 10
     886/     BAE : 00                  	db 0
     887/     BAF :                     	include lcc1802EpiloNO.inc
(1)    1/     BAF :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/     BAF :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/     BAF :                     ;this is the version published with the lcc1802121229 release
(1)    4/     BAF :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/     BAF :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/     BAF :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/     BAF :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/     BAF :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/     BAF :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/     BAF :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/     BAF :                     ;feb 27 changed stack to start at 7fff
(1)   12/     BAF :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/     BAF : =EH                 rwork	equ	memAddr	;work register
(1)   14/     BAF :                     lcc1802init:	
(1)   15/     BAF : (MACRO)             	ldiReg	RCALL,_call
(1)   16/     BB5 : (MACRO)             	ldiReg	RRET,_return
(1)   17/     BBB : (MACRO)             	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1
(1)   18/     BC1 : E2                  	sex	SP
(1)   19/     BC2 : (MACRO)             	ldiReg	RPC,$$_00000
(1)   20/     BC8 : D3                  	sep	RPC
(1)   21/     BC9 :                     $$_00000:
(1)   22/     BC9 : (MACRO)             	Ccall _main	;call the main routine
(1)   23/     BCC : C0 0B CC            $$_die:	lbr	$$_die		;loop here when main returns
(1)   24/     BCF : DE AD               	db	0xde,0xad
(1)   25/     BD1 :                     
(1)   26/     BD1 :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   27/     BD1 :                     _setqOn:
(1)   28/     BD1 : 7B                  	seq
(1)   29/     BD2 : (MACRO)             	Cretn
 AS V1.42 Beta [Bld 87] - source file longdivide.asm(lcc1802EpiloNO.inc) - page 17 - 3/21/2013 10:18:48


(1)   30/     BD3 :                     _setqOff:
(1)   31/     BD3 : 7A                  	req
(1)   32/     BD4 : (MACRO)             	Cretn
(1)   33/     BD5 :                     
(1)   34/     BD5 :                     _modU2:	;16 bit unsigned remainder
(1)   35/     BD5 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   36/     BD5 : (MACRO)                 Ccall _divU2
(1)   37/     BD8 : 8D                      glo regArg2
(1)   38/     BD9 : AF                      plo retVal
(1)   39/     BDA : 9D                      ghi regArg2
(1)   40/     BDB : BF                      phi retVal
(1)   41/     BDC : (MACRO)                 Cretn
(1)   42/     BDD :                         
(1)   43/     BDD :                     _modI2:	;16 bit signed remainder
(1)   44/     BDD :                     	; just calls the 16 bit division then puts remainder into return value
(1)   45/     BDD : (MACRO)                 Ccall _divI2
(1)   46/     BE0 : 8D                      glo regArg2
(1)   47/     BE1 : AF                      plo retVal
(1)   48/     BE2 : 9D                      ghi regArg2
(1)   49/     BE3 : BF                      phi retVal
(1)   50/     BE4 : (MACRO)                 Cretn
(1)   51/     BE5 :                     
(1)   52/     BE5 :                     _out4:	
(1)   53/     BE5 : 8C                  	glo	regArg1
(1)   54/     BE6 : 22                  	dec	sp
(1)   55/     BE7 : 52                  	str	sp
(1)   56/     BE8 : 64                  	out	4
(1)   57/     BE9 : (MACRO)             	Cretn
(1)   58/     BEA :                     
(1)   59/     BEA :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   60/     BEA :                     	align 256
(1)   61/     C00 :                     ;non-standard Call routine invoked as D4xxxx - using z80 stack convention
(1)   62/     C00 :                     ;requires programs to save the return address if they destroy it (by using call for example)
(1)   63/     C00 : D3                  	sep     R3 ;go to subroutine
(1)   64/     C01 : E2                  _call	sex	SP ;make sure X=SP
(1)   65/     C02 : 96                  	ghi	retAddr ;save previous return pointer on stack
(1)   66/     C03 : 22                  	dec	sp
(1)   67/     C04 : 73                  	stxd
(1)   68/     C05 : 86                  	glo	retAddr
(1)   69/     C06 : 52                  	str	sp	
(1)   70/     C07 : 83                  	glo	RPC ;copy old PC to retAddr
(1)   71/     C08 : A6                  	plo	retAddr
(1)   72/     C09 : 93                  	ghi	RPC
(1)   73/     C0A : B6                  	phi	retAddr
(1)   74/     C0B : 46                  	lda	retAddr ;pick up subroutine address into RPC
(1)   75/     C0C : B3                  	phi	RPC
(1)   76/     C0D : 46                  	lda	retAddr
(1)   77/     C0E : A3                  	plo	RPC
(1)   78/     C0F : 30 00               	br	_call-1
(1)   79/     C11 :                     
(1)   80/     C11 :                     ;non-standard subroutine return - using z80 stack discipline (decrement 1st, little endian)
(1)   81/     C11 :                     ;requires programs to save the return address if they destroy it (by using call for example)
(1)   82/     C11 : D3                  	sep	RPC	;return to the original program
(1)   83/     C12 : 86                  _return	glo	retAddr	;transfer the current return address to RPC
(1)   84/     C13 : A3                  	plo	RPC
(1)   85/     C14 : 96                  	ghi	retAddr
(1)   86/     C15 : B3                  	phi	RPC
(1)   87/     C16 : 42                  	lda	SP	;pick up old return address
(1)   88/     C17 : A6                  	plo	retAddr
(1)   89/     C18 : 42                  	lda	SP
 AS V1.42 Beta [Bld 87] - source file longdivide.asm(lcc1802EpiloNO.inc) - page 18 - 3/21/2013 10:18:48


(1)   90/     C19 : B6                  	phi	retAddr
(1)   91/     C1A : 30 11               	br	_return-1
(1)   92/     C1C :                     
(1)   93/     C1C :                     _oneMs:		;execute 100 instructions including call(15)/return(10) sequence. takes about 1 ms
(1)   94/     C1C : F8 24               	ldi	(100-15-10-2)/2
(1)   95/     C1E : FF 01               $$mslp:	smi	1
(1)   96/     C20 : 3A 1E               	bnz	$$mslp
(1)   97/     C22 : (MACRO)             	Cretn
(1)   98/     C23 :                     
(1)   99/     C23 :                     
(1)  100/     C23 :                     	
(1)  101/     C23 :                     ;16 bit unsigned multiply thanks to Ted Rossin!
(1)  102/     C23 :                     ;retVal=regArg1*regArg2. uses register rwork as a work regitsr
(1)  103/     C23 :                     _mulu2:		
(1)  104/     C23 : 22                      dec sp
(1)  105/     C24 : F8 10                   ldi 16
(1)  106/     C26 : AE                      plo	rwork	;bit count
(1)  107/     C27 : F8 00                   ldi 0
(1)  108/     C29 : BF                      phi	retVal	;quotient
(1)  109/     C2A : AF                      plo retVal
(1)  110/     C2B :                     $$MultLoop16_16:
(1)  111/     C2B : 9C                      ghi regArg1
(1)  112/     C2C : F6                      shr
(1)  113/     C2D : BC                      phi regArg1
(1)  114/     C2E : 8C                      glo regArg1
(1)  115/     C2F : 76                      shrc
(1)  116/     C30 : AC                      plo regArg1
(1)  117/     C31 : 3B 3D                   bnf $$MultSkip16_16
(1)  118/     C33 : 8D                      glo regArg2
(1)  119/     C34 : 52                      str sp
(1)  120/     C35 : 8F                      glo retVal
(1)  121/     C36 : F4                      add 
(1)  122/     C37 : AF                      plo retVal
(1)  123/     C38 : 9D                      ghi regArg2
(1)  124/     C39 : 52                      str sp
(1)  125/     C3A : 9F                      ghi retVal
(1)  126/     C3B : 74                      adc
(1)  127/     C3C : BF                      phi retVal
(1)  128/     C3D :                     $$MultSkip16_16:
(1)  129/     C3D : 8D                      glo regArg2
(1)  130/     C3E : FE                      shl
(1)  131/     C3F : AD                      plo regArg2
(1)  132/     C40 : 9D                      ghi regArg2
(1)  133/     C41 : 7E                      shlc
(1)  134/     C42 : BD                      phi regArg2
(1)  135/     C43 : 2E                      dec rwork
(1)  136/     C44 : 8E                      glo rwork
(1)  137/     C45 : 3A 2B                   bnz $$MultLoop16_16
(1)  138/     C47 : 12                      inc sp
(1)  139/     C48 : D5                      sep 5
(1)  140/     C49 :                     
(1)  141/     C49 :                     
(1)  142/     C49 :                     _divU2:
(1)  143/     C49 :                     	; retVal = regArg1/regArg2  (remainder in regArg1)
(1)  144/     C49 :                     	; This is really an unsigned 23 bit divide
(1)  145/     C49 :                     	;thanks to Ted Rossin
(1)  146/     C49 :                     	;bodged Dec 12 to shuffle registers at the end.
(1)  147/     C49 : 22                      dec sp
(1)  148/     C4A : F8 10                   ldi 16
(1)  149/     C4C : AE                      plo rwork
 AS V1.42 Beta [Bld 87] - source file longdivide.asm(lcc1802EpiloNO.inc) - page 19 - 3/21/2013 10:18:48


(1)  150/     C4D : F8 00                   ldi 0
(1)  151/     C4F : BF                      phi retVal
(1)  152/     C50 : AF                      plo retVal
(1)  153/     C51 : BE                      phi rwork
(1)  154/     C52 :                     $$DivLoop16_16:
(1)  155/     C52 : 8C                      glo regArg1
(1)  156/     C53 : FE                      shl
(1)  157/     C54 : AC                      plo regArg1
(1)  158/     C55 : 9C                      ghi regArg1
(1)  159/     C56 : 7E                      shlc
(1)  160/     C57 : BC                      phi regArg1
(1)  161/     C58 : 8F                      glo retVal
(1)  162/     C59 : 7E                      shlc
(1)  163/     C5A : AF                      plo retVal
(1)  164/     C5B : 9F                      ghi retVal
(1)  165/     C5C : 7E                      shlc
(1)  166/     C5D : BF                      phi retVal
(1)  167/     C5E : 9E                      ghi rwork
(1)  168/     C5F : 7E                      shlc
(1)  169/     C60 : BE                      phi rwork
(1)  170/     C61 : 3B 73                   bnf $$DivSub16_16
(1)  171/     C63 : 8D                      glo regArg2
(1)  172/     C64 : 52                      str sp
(1)  173/     C65 : 8F                      glo retVal
(1)  174/     C66 : F4                      add 
(1)  175/     C67 : AF                      plo retVal
(1)  176/     C68 : 9D                      ghi regArg2
(1)  177/     C69 : 52                      str sp
(1)  178/     C6A : 9F                      ghi retVal
(1)  179/     C6B : 74                      adc 
(1)  180/     C6C : BF                      phi retVal
(1)  181/     C6D : 9E                      ghi rwork
(1)  182/     C6E : 7C 00                   adci 0
(1)  183/     C70 : BE                      phi rwork
(1)  184/     C71 : 30 81                   br $$DivSkip16_16
(1)  185/     C73 :                     $$DivSub16_16:
(1)  186/     C73 : 8D                      glo regArg2
(1)  187/     C74 : 52                      str sp
(1)  188/     C75 : 8F                      glo retVal
(1)  189/     C76 : F7                      sm
(1)  190/     C77 : AF                      plo retVal
(1)  191/     C78 : 9D                      ghi regArg2
(1)  192/     C79 : 52                      str sp
(1)  193/     C7A : 9F                      ghi retVal
(1)  194/     C7B : 77                      smb 
(1)  195/     C7C : BF                      phi retVal
(1)  196/     C7D : 9E                      ghi rwork
(1)  197/     C7E : 7F 00                   smbi 0
(1)  198/     C80 : BE                      phi rwork 
(1)  199/     C81 :                     $$DivSkip16_16:
(1)  200/     C81 : FE                      shl
(1)  201/     C82 : 33 88                   bdf $$DivSkipClear16_16
(1)  202/     C84 :                     $$DivSetBit16_16:
(1)  203/     C84 : 8C                      glo regArg1
(1)  204/     C85 : F9 01                   ori  0x01
(1)  205/     C87 : AC                      plo regArg1
(1)  206/     C88 :                     $$DivSkipClear16_16:
(1)  207/     C88 : 2E                      dec rwork
(1)  208/     C89 : 8E                      glo rwork
(1)  209/     C8A : 3A 52                   bnz $$DivLoop16_16
 AS V1.42 Beta [Bld 87] - source file longdivide.asm(lcc1802EpiloNO.inc) - page 20 - 3/21/2013 10:18:48


(1)  210/     C8C : 9E                      ghi rwork
(1)  211/     C8D : FE                      shl
(1)  212/     C8E : 3B 9A                   bnf $$DivSkipFinalAdd16_16
(1)  213/     C90 : 8D                      glo regArg2
(1)  214/     C91 : 52                      str sp
(1)  215/     C92 : 8F                      glo retVal
(1)  216/     C93 : F4                      add
(1)  217/     C94 : AF                      plo retVal
(1)  218/     C95 : 9D                      ghi regArg2
(1)  219/     C96 : 52                      str sp
(1)  220/     C97 : 9F                      ghi retVal
(1)  221/     C98 : 74                      adc
(1)  222/     C99 : BF                      phi retVal
(1)  223/     C9A :                     $$DivSkipFinalAdd16_16:
(1)  224/     C9A : 12                      inc sp
(1)  225/     C9B :                     ;here I have the quotient in regArg1 and remainder in retVal
(1)  226/     C9B : 8F                      glo retVal
(1)  227/     C9C : AD                      plo regArg2
(1)  228/     C9D : 9F                      ghi retVal
(1)  229/     C9E : BD                      phi regArg2
(1)  230/     C9F : 8C                      glo regArg1
(1)  231/     CA0 : AF                      plo retVal
(1)  232/     CA1 : 9C                      ghi regArg1
(1)  233/     CA2 : BF                      phi retVal
(1)  234/     CA3 :                         ;return with quotient in retVal and remainder in regArg2
(1)  235/     CA3 : D5                      sep 5
(1)  236/     CA4 :                     
(1)  237/     CA4 :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  238/     CA4 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  239/     CA4 :                     _divI2:
(1)  240/     CA4 :                         ;pushr retAddr	;save the return address NG doesnot need
(1)  241/     CA4 : 22                      dec	sp	;leave a work area available
(1)  242/     CA5 : 9C                      ghi regArg1
(1)  243/     CA6 : 52                      str sp	;save the sign of the 1st arg
(1)  244/     CA7 : FE                      shl
(1)  245/     CA8 : 3B B3                   bnf $$pos1	;if the 1st arg is -v
(1)  246/     CAA : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
(1)  247/     CB3 :                     $$pos1: ;1st is now +v, check 2nd
(1)  248/     CB3 : 9D                      ghi regArg2
(1)  249/     CB4 : F3                      xor	
(1)  250/     CB5 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  251/     CB6 : 9D                      ghi regArg2
(1)  252/     CB7 : FE                      shl
(1)  253/     CB8 : 3B C3                   bnf $$pos2	;if the 2nd arg is -v
(1)  254/     CBA : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  255/     CC3 :                     $$pos2: ; both args now +v
(1)  256/     CC3 : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  257/     CC6 :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  258/     CC6 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  259/     CC7 : FE                      shl
(1)  260/     CC8 : 3B D3                   bnf $$done ;if the signs were different
(1)  261/     CCA : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  262/     CD3 :                     $$done:
(1)  263/     CD3 :                         ;popr RetAddr ;restore the return address NG doesnot need
(1)  264/     CD3 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  265/     CD4 :                     
(1)  266/     CD4 :                     
(1)  267/     CD4 :                     	align 256    ;32 bit operations follow
(1)  268/     D00 :                     _divu4:
(1)  269/     D00 :                     ;This is an unsigned 32 bit restoring division
 AS V1.42 Beta [Bld 87] - source file longdivide.asm(lcc1802EpiloNO.inc) - page 21 - 3/21/2013 10:18:48


(1)  270/     D00 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  271/     D00 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  272/     D00 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  273/     D00 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  274/     D00 :                     
(1)  275/     D00 : F8 20               	ldi 32		;set loop count
(1)  276/     D02 : AE                  	plo memaddr	;in temp register
(1)  277/     D03 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  278/     D0F :                     $$loop:
(1)  279/     D0F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  280/     D1B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  281/     D27 :                     
(1)  282/     D27 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  283/     D3D :                     
(1)  284/     D3D : FA 80               	ani 0x80	;check the top bit
(1)  285/     D3F : 32 5D               	bz $$norestore	;if it's 0
(1)  286/     D41 : 89                  		glo RL8
(1)  287/     D42 : FA FE               		ani 0xfe	;turn off the bottom bit
(1)  288/     D44 : A9                  		plo RL8
(1)  289/     D45 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  290/     D5B : 30 61               	br $$endlp 	;else
(1)  291/     D5D :                     $$norestore:
(1)  292/     D5D : 89                  		glo RL8
(1)  293/     D5E : F9 01               		ori 1	;turn on the bottom bit
(1)  294/     D60 : A9                  		plo RL8
(1)  295/     D61 :                     	;end if
(1)  296/     D61 :                     $$endlp:
(1)  297/     D61 : 2E                  	dec memaddr	;check the cycle count
(1)  298/     D62 : 8E                  	glo memaddr
(1)  299/     D63 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  300/     D65 :                     	
(1)  301/     D65 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  302/     D66 :                     		
(1)  303/     D66 :                     
(1)  304/     D66 :                     _mulu4:
(1)  305/     D66 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  306/     D66 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  307/     D66 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  308/     D66 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  309/     D66 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  310/     D66 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  311/     D66 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  312/     D66 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  313/     D66 :                     	;for 10 we subtract and shift
(1)  314/     D66 :                     	;for 00 and 11 we just shift
(1)  315/     D66 :                     
(1)  316/     D66 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  317/     D72 : F8 20                   ldi 32
(1)  318/     D74 : AE                      plo memaddr		;cycle count
(1)  319/     D75 : FC 00                   adi 0		;clear df
(1)  320/     D77 :                     $$mloop:
(1)  321/     D77 : 89                      glo RL8
(1)  322/     D78 : FA 01                   ani 1		;isolate bottom bit of result
(1)  323/     D7A : 3B 96                   bnf	$$check_sub	;
(1)  324/     D7C : 3A AE                   bnz	$$shift		;that would be the 11 case
(1)  325/     D7E :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  326/     D7E : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  327/     D94 : 30 AE                   br $$shift
(1)  328/     D96 :                     $$check_sub:
(1)  329/     D96 : 32 AE                   bz $$shift	;that would be the 00 case
 AS V1.42 Beta [Bld 87] - source file longdivide.asm(lcc1802EpiloNO.inc) - page 22 - 3/21/2013 10:18:48


(1)  330/     D98 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  331/     D98 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  332/     DAE :                     $$shift:
(1)  333/     DAE : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  334/     DBC : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  335/     DC8 :                     
(1)  336/     DC8 : 2E                      dec memaddr		;cycle count
(1)  337/     DC9 : 8E                      glo memaddr
(1)  338/     DCA : 3A 77                   bnz $$mloop		;repeat cycle once for each bit position
(1)  339/     DCC :                         
(1)  340/     DCC : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  341/     DCD :                     
(1)  342/     DCD :                     	align 256
(1)  343/     E00 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  344/     E00 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  345/     E00 :                     _divI4:
(1)  346/     E00 : 22                      dec	sp	;leave a work area available
(1)  347/     E01 : 98                      ghi RL8-1	;get the top of the dividend
(1)  348/     E02 : 52                      str sp	;save the sign of the 1st arg
(1)  349/     E03 : FE                      shl
(1)  350/     E04 : 3B 26                   bnf $$pos1	;if the 1st arg is -v
(1)  351/     E06 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  352/     E26 :                     $$pos1: ;1st is now +v, check 2nd
(1)  353/     E26 : 9A                      ghi RL10-1
(1)  354/     E27 : F3                      xor	
(1)  355/     E28 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  356/     E29 : 9A                      ghi RL10-1
(1)  357/     E2A : FE                      shl
(1)  358/     E2B : 3B 4D                   bnf $$pos2	;if the 2nd arg is -v
(1)  359/     E2D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  360/     E4D :                     $$pos2: ; both args now +v
(1)  361/     E4D : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  362/     E50 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  363/     E50 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  364/     E51 : FE                      shl
(1)  365/     E52 : 3B 74                   bnf $$done ;if the signs were different
(1)  366/     E54 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  367/     E74 :                     $$done:
(1)  368/     E74 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  369/     E75 :                     
(1)  370/     E75 :                     _dubdabx:	
(1)  371/     E75 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  372/     E75 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  373/     E75 :                     ;long interger is passed in rp1p2
(1)  374/     E75 :                     ;buffer pointer is passed at sp+2+4
(1)  375/     E75 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
(1)  376/     E75 :                     ;r8-11 are used as temps
(1)  377/     E75 :                     ;r8 is the working pointer
(1)  378/     E75 :                     ;r9.0 is bit count(32)
(1)  379/     E75 :                     ;r10.0 is digit count
(1)  380/     E75 : (MACRO)             	ld2 r8,'O',sp,(2+4); pick up the buffer pointer
(1)  381/     E81 : (MACRO)             	cpy2 r15,r8 ;save it for now
(1)  382/     E85 : F8 0B               	ldi 11	;digit count+1 for trailing 0
(1)  383/     E87 : A9                  	plo r9
(1)  384/     E88 :                     $$clrlp:	;clear the passed buffer
(1)  385/     E88 : F8 00               	ldi 0	
(1)  386/     E8A : 58                  	str r8	;clear a byte
(1)  387/     E8B : 18                  	inc r8
(1)  388/     E8C : 29                  	dec r9
(1)  389/     E8D : 89                  	glo r9	;check the count
 AS V1.42 Beta [Bld 87] - source file longdivide.asm(lcc1802EpiloNO.inc) - page 23 - 3/21/2013 10:18:48


(1)  390/     E8E : 3A 88               	bnz $$clrlp ;back for more
(1)  391/     E90 : (MACRO)             	cpy2 r8,r15 ;get the address back
(1)  392/     E94 :                     
(1)  393/     E94 : F8 20               	ldi 32	;bit count
(1)  394/     E96 : AF                  	plo r15
(1)  395/     E97 :                     ;now i'm going to spin off any leading 0's in the binary number
(1)  396/     E97 :                     $$cktop:
(1)  397/     E97 : 9C                  	ghi rp1p2-1	;get the top bit of the number
(1)  398/     E98 : FE                  	shl		;check for a 1
(1)  399/     E99 : 33 AC               	bdf $$bitloop	;move on if we have one
(1)  400/     E9B : (MACRO)             	shl4 rp1p2	;shift the input number
(1)  401/     EA7 : 2F                  	dec r15		;reduce the number of times to shift
(1)  402/     EA8 : 8F                  	glo r15
(1)  403/     EA9 : 3A 97               	bnz $$cktop	;
(1)  404/     EAB : 1F                  	inc r15		;our whole number was 0 but force at least one pass
(1)  405/     EAC :                     $$bitloop:
(1)  406/     EAC : F8 0A               	ldi 10	;digit count
(1)  407/     EAE : A9                  	plo r9
(1)  408/     EAF :                     $$dcklp:
(1)  409/     EAF : 08                  	ldn r8 	;pick up a digit
(1)  410/     EB0 : FF 05               	smi 5	;see if it's greater than 4
(1)  411/     EB2 : 3B B7               	bnf $$dnoadd ;if not, bypass add
(1)  412/     EB4 : FC 08               	adi 0x08	;add the 5 black and 3 more
(1)  413/     EB6 : 58                  	str r8	;put it back
(1)  414/     EB7 :                     $$dnoadd:
(1)  415/     EB7 : 18                  	inc r8
(1)  416/     EB8 : 29                  	dec r9	;decrement digit count
(1)  417/     EB9 : 89                  	glo r9
(1)  418/     EBA : 3A AF               	bnz $$dcklp ;and back for next digit
(1)  419/     EBC :                     	
(1)  420/     EBC : (MACRO)             	shl4 rp1p2 ;shift the input number
(1)  421/     EC8 :                     	
(1)  422/     EC8 : F8 0A               	ldi 10	;load the digit count again
(1)  423/     ECA : A9                  	plo r9
(1)  424/     ECB :                     ;r8 is now just past the units location and ready to walk back
(1)  425/     ECB :                     $$dshlp:
(1)  426/     ECB : 28                  	dec r8	;walk back from 0's position
(1)  427/     ECC : 08                  	ldn r8	;get the digit back
(1)  428/     ECD : 7E                  	shlc	;continue the shift
(1)  429/     ECE : BF                  	phi r15 ;save it for the carry test
(1)  430/     ECF : FA 0F               	ani 0x0f ;clear the 10 bit
(1)  431/     ED1 : 58                  	str r8	;put the digit back
(1)  432/     ED2 : 9F                  	ghi r15	;now test for carry
(1)  433/     ED3 : FF 10               	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  434/     ED5 : 29                  	dec r9	;decrement the digit count
(1)  435/     ED6 : 89                  	glo r9
(1)  436/     ED7 : 3A CB               	bnz $$dshlp ;back for more if needed
(1)  437/     ED9 :                     	
(1)  438/     ED9 : 2F                  	dec r15
(1)  439/     EDA : 8F                  	glo r15
(1)  440/     EDB : 3A AC               	bnz $$bitloop
(1)  441/     EDD :                     	
(1)  442/     EDD : (MACRO)             	cpy2 r15,r8	;save the starting location of the digits
(1)  443/     EE1 : F8 0A               	ldi 10		;digit count again
(1)  444/     EE3 : A9                  	plo r9
(1)  445/     EE4 :                     $$upnxt:
(1)  446/     EE4 : 08                  	ldn r8		;get digit
(1)  447/     EE5 : F9 30               	ori 0x30	;make ascii
(1)  448/     EE7 : 58                  	str r8		;put it back
(1)  449/     EE8 : 18                  	inc r8		;next digit
 AS V1.42 Beta [Bld 87] - source file longdivide.asm(lcc1802EpiloNO.inc) - page 24 - 3/21/2013 10:18:48


(1)  450/     EE9 : 29                  	dec r9		;counter
(1)  451/     EEA : 89                  	glo r9
(1)  452/     EEB : 3A E4               	bnz $$upnxt	;upgrade all 10 spots
(1)  453/     EED :                     	
(1)  454/     EED : F8 09               	ldi 9		;now to skip up to 9 zeros
(1)  455/     EEF : A9                  	plo r9
(1)  456/     EF0 :                     $$cknext:
(1)  457/     EF0 : 0F                  	ldn r15		;check digit
(1)  458/     EF1 : FF 30               	smi 0x30	;for '0'
(1)  459/     EF3 : 3A FA               	bnz $$done
(1)  460/     EF5 : 1F                  	inc r15		;next digit
(1)  461/     EF6 : 29                  	dec r9		;reduce count
(1)  462/     EF7 : 89                  	glo r9
(1)  463/     EF8 : 3A F0               	bnz $$cknext
(1)  464/     EFA :                     $$done:
(1)  465/     EFA : (MACRO)             	cretn
(1)  466/     EFB :                     	
(1)  467/     EFB :                     	
(1)  468/     EFB :                     _modU4:	;32 bit unsigned remainder
(1)  469/     EFB :                     	; just calls the 32 bit division then puts remainder into return value
(1)  470/     EFB : (MACRO)                 Ccall _divU4
(1)  471/     EFE : (MACRO)                 cpy4 RL8,Rp1p2
(1)  472/     F06 : (MACRO)                 Cretn
(1)  473/     F07 :                         
(1)  474/     F07 :                     _modI4:	;32 bit signed remainder
(1)  475/     F07 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  476/     F07 : (MACRO)                 Ccall _divI4
(1)  477/     F0A : (MACRO)                 cpy4 RL8,Rp1p2
(1)  478/     F12 : (MACRO)                 Cretn
(1)  479/     F13 :                         
(1)  480/     F13 :                     	
(1)  481/     F13 :                      
     888/     F13 :                     	include IO1802.inc
(1)    1/     F13 :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/     F13 :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/     F13 :                     	align 64
(1)    4/     F40 :                     _putc:
(1)    5/     F40 :                     _out5:	
(1)    6/     F40 : 8C                  	glo	regArg1
(1)    7/     F41 : 22                  	dec	sp
(1)    8/     F42 : 52                  	str	sp
(1)    9/     F43 : 65                  	out	5
(1)   10/     F44 : (MACRO)             	Cretn
(1)   11/     F45 :                     _inp:		;raw port input
(1)   12/     F45 :                     		;stores a small tailored program on the stack and executes it
(1)   13/     F45 : 22                  	dec	sp	;work backwards
(1)   14/     F46 : F8 D3               	ldi	0xD3	;return instruction
(1)   15/     F48 : 73                  	stxd		
(1)   16/     F49 : 8C                  	glo	regarg1	;get the port number
(1)   17/     F4A : FA 07               	ani	0x07	;clean it
(1)   18/     F4C : 32 5C               	bz	+	; inp(0) isn't valid
(1)   19/     F4E : F9 68               	ori	0x68	;make it an input instruction
(1)   20/     F50 : 73                  	stxd		;store it for execution
(1)   21/     F51 : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   22/     F55 : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   23/     F56 : D8                  	sep	rt1	;execute it
(1)   24/     F57 :                     ;we will come back to here with the input byte in D
(1)   25/     F57 : 12                  	inc	sp	;step over the work area
(1)   26/     F58 : AF                  	plo	retVal	;save it to return
(1)   27/     F59 : F8 00               	ldi	0
 AS V1.42 Beta [Bld 87] - source file longdivide.asm(IO1802.inc) - page 25 - 3/21/2013 10:18:48


(1)   28/     F5B : BF                  	phi	retval	;clear top byte
(1)   29/     F5C : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   30/     F5D : 12                  	inc	sp	;and the D3
(1)   31/     F5E : (MACRO)             	Cretn		;and we're done
(1)   32/     F5F :                     	
(1)   33/     F5F :                     _out:		;raw port output
(1)   34/     F5F :                     		;stores a small tailored program on the stack and executes it
(1)   35/     F5F : 22                  	dec	sp	;work backwards
(1)   36/     F60 : F8 D3               	ldi	0xD3	;return instruction
(1)   37/     F62 : 73                  	stxd		
(1)   38/     F63 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the inp instruction
(1)   39/     F67 : 8C                  	glo	regarg1	;get the port number
(1)   40/     F68 : FA 07               	ani	0x07	;clean it
(1)   41/     F6A : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   42/     F6C : 73                  	stxd		;store it for execution
(1)   43/     F6D : 8D                  	glo	regarg2	;get the byte to be written
(1)   44/     F6E : 52                  	str	sp	;store it where sp points
(1)   45/     F6F : D8                  	sep	rt1	;execute it
(1)   46/     F70 :                     ;we will come back to here with sp stepped up by one
(1)   47/     F70 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   48/     F71 : 12                  	inc	sp	;and the D3
(1)   49/     F72 : (MACRO)             	Cretn		;and we're done
(1)   50/     F73 :                     	
(1)   51/     F73 :                     	
     889/     F73 :                     
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 26 - 3/21/2013 10:18:48


  symbol table (* = unused):
  ------------------------

*ARCHITECTURE :  i386-unknown-win32 - | *BIGENDIAN :                      0 - |
 BITLOOP146 :                   EAC C | *BRANCHEXT :                      0 - |
 BVTABLE122 :                   B5F C | *CASESENSITIVE :                  0 - |
 CHECK_SUB144 :                 D96 C |  CKNEXT146 :                    EF0 C |
 CKTOP146 :                     E97 C |  CLRLP146 :                     E88 C |
*CONSTPI :        3.141592653589793 - | *DATE :                   3/21/2013 - |
 DCKLP146 :                     EAF C |  DIVLOOP16_16141 :              C52 C |
*DIVSETBIT16_16141 :            C84 C |  DIVSKIP16_16141 :              C81 C |
 DIVSKIPCLEAR16_16141 :         C88 C |  DIVSKIPFINALADD16_16141 :      C9A C |
 DIVSUB16_16141 :               C73 C |  DNOADD146 :                    EB7 C |
 DONE142 :                      CD3 C |  DONE145 :                      E74 C |
 DONE146 :                      EFA C |  DSHLP146 :                     ECB C |
 ENDLP143 :                     D61 C | *FALSE :                          0 - |
*FULLPMMU :                       1 - | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*L1 :                            83 C | *L10 :                          106 C |
 L11 :                           D2 C |  L12 :                           F1 C |
*L14 :                          2B3 C |  L15 :                          1D1 C |
 L16 :                          1E1 C |  L17 :                          1EA C |
 L18 :                          28B C |  L2 :                           B9B C |
 L20 :                          1F1 C | *L21 :                          1F1 C |
 L23 :                          1FE C |  L24 :                          276 C |
 L27 :                          233 C | *L28 :                          37D C |
 L29 :                          34A C |  L3 :                           B8A C |
*L31 :                          3C9 C | *L32 :                          429 C |
*L33 :                          4BC C |  L34 :                          497 C |
 L35 :                          4BC C | *L36 :                          53A C |
*L37 :                          950 C |  L38 :                          582 C |
 L39 :                          92F C |  L4 :                           B7A C |
 L41 :                          5BE C |  L42 :                          92F C |
 L43 :                          91E C |  L44 :                          92F C |
 L46 :                          6E6 C |  L47 :                          703 C |
 L48 :                          724 C |  L49 :                          746 C |
*L5 :                            BF C |  L50 :                          7B4 C |
 L51 :                          91E C |  L53 :                          812 C |
 L55 :                          845 C |  L56 :                          919 C |
*L57 :                          634 C |  L58 :                          693 C |
*L59 :                          66C C |  L6 :                            A2 C |
*L60 :                          6CB C | *L61 :                          98E C |
 L62 :                          B71 C |  L63 :                          98B C |
*L64 :                          98B C | *L66 :                          A36 C |
 L67 :                          9C8 C |  L68 :                          A15 C |
*L7 :                            A2 C |  L70 :                          A32 C |
*L71 :                          A96 C |  L72 :                          A6B C |
 L73 :                          A81 C | *L75 :                          AE4 C |
 L76 :                          AC0 C |  L77 :                          ACF C |
*L79 :                          B1E C |  L80 :                          B08 C |
*L81 :                          B0B C |  L83 :                          B0C C |
*L84 :                          B70 C |  L9 :                            A4 C |
 LCC1802INIT :                  BAF C | *LISTON :                         1 - |
 LOOP143 :                      D0F C | *MACEXP :                         0 - |
 MEMADDR :                        E - |  MLOOP144 :                     D77 C |
*MOMCPU :                      1802 - | *MOMCPUNAME :                  1802 - |
 MSLP139 :                      C1E C |  MULTLOOP16_16140 :             C2B C |
 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 27 - 3/21/2013 10:18:48


 MULTSKIP16_16140 :             C3D C | *NESTMAX :                      100 - |
 NORESTORE143 :                 D5D C |  OUTIT122 :                     B5C C |
*PACKING :                        0 - | *PADDING :                        1 - |
 POS1142 :                      CB3 C |  POS1145 :                      E26 C |
 POS2142 :                      CC3 C |  POS2145 :                      E4D C |
 R0 :                             0 - |  R1 :                             1 - |
 R10 :                            A - |  R11 :                            B - |
 R12 :                            C - |  R13 :                            D - |
*R14 :                            E - |  R15 :                            F - |
*R2 :                             2 - |  R3 :                             3 - |
*R4 :                             4 - | *R5 :                             5 - |
*R6 :                             6 - |  R7 :                             7 - |
 R8 :                             8 - |  R9 :                             9 - |
 RCALL :                          4 - |  REGARG1 :                        C - |
 REGARG2 :                        D - | *RELAXED :                        1 - |
 RETADDR :                        6 - |  RETVAL :                         F - |
 RL0 :                            1 - |  RL10 :                           B - |
 RL12 :                           D - |  RL8 :                            9 - |
 RP1P2 :                          D - |  RPC :                            3 - |
 RRET :                           5 - |  RT1 :                            8 - |
*RT2 :                            9 - |  RWORK :                          E - |
 SETBITOFF122 :                 B57 C |  SHIFT144 :                     DAE C |
 SP :                             2 - | *TIME :                    10:18:48 - |
*TRUE :                           1 - |  UPNXT146 :                     EE4 C |
*VERSION :                     142F - |  _00000131 :                    BC9 C |
 _CALL :                        C01 C | *_DELAY :                       AED C |
 _DIE131 :                      BCC C | *_DIGITALREAD :                 B68 C |
*_DIGITALWRITE :                B40 C |  _DIVI2 :                       CA4 C |
 _DIVI4 :                       E00 C |  _DIVU2 :                       C49 C |
 _DIVU4 :                       D00 C |  _DUBDABX :                     E75 C |
*_EXIT :                        965 C | *_INP :                         F45 C |
 _ITOA :                        10F C |  _LTOA :                        2C8 C |
 _MAIN :                          4 C | *_MEMCMP :                      993 C |
*_MEMCPY :                      A45 C | *_MEMSET :                      AA3 C |
*_MODI2 :                       BDD C | *_MODI4 :                       F07 C |
*_MODU2 :                       BD5 C | *_MODU4 :                       EFB C |
*_MULU2 :                       C23 C | *_MULU4 :                       D66 C |
*_OLDUINOINCLUDER :             B2B C |  _ONEMS :                       C1C C |
 _OUT :                         F5F C | *_OUT4 :                        BE5 C |
*_OUT5 :                        F40 C |  _PIN4 :                          3 C |
 _PRINTF :                      53F C |  _PRINTINT :                    390 C |
 _PRINTLINT :                   3D2 C |  _PRINTSTR :                     C2 C |
 _PUTC :                        F40 C |  _PUTX :                        4C1 C |
 _PUTXN :                       432 C |  _RETURN :                      C12 C |
*_SETQOFF :                     BD3 C | *_SETQON :                      BD1 C |
 _STRCPY :                       90 C |  __FORW3 :                      B6F C |
 __FORW4 :                      F5C C | *__FORW5 :                      F70 C |

    208 symbols
     78 unused symbols

 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 28 - 3/21/2013 10:18:48


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU4                                  | ALU4I                                
BLKCPY                                | CCALL                                
CPY1                                  | CPY2                                 
CPY4                                  | CRETN                                
DECM                                  | INC4                                 
INCM                                  | JCI2                                 
JCI2I                                 | JCI4                                 
JCU2                                  | JCU2I                                
JCU4                                  | JEQI2                                
JEQI4                                 | JEQU2I                               
JNEU2                                 | JNEU2I                               
JNEU4                                 | JNI2I                                
JNU2I                                 | JNZU2                                
JZU2                                  | LD1                                  
LD2                                   | LD2Z                                 
LD4                                   | LDA2                                 
LDAD                                  | LDAX                                 
LDI4                                  | LDIREG                               
LDN1                                  | NEGI2                                
NEGI4                                 | POPR                                 
PUSHR                                 | RELEASE                              
RELEASEL                              | RELEASES                             
RESERVE                               | RESERVEL                             
RESERVES                              | RLDMI                                
SAVMI                                 | SEXT                                 
SEXT4                                 | SHL2                                 
SHL2I                                 | SHL2R                                
SHL4                                  | SHL4I                                
SHL4R                                 | SHLC4                                
SHRC4                                 | SHRI2                                
SHRI2I                                | SHRI2R                               
SHRI4                                 | SHRI4I                               
SHRI4R                                | SHRU2                                
SHRU2I                                | SHRU2R                               
SHRU4                                 | SHRU4I                               
SHRU4R                                | ST1                                  
ST2                                   | ST4                                  
STR1                                  | ZEXT                                 
ZEXT4                                 |

     79 macros

 AS V1.42 Beta [Bld 87] - source file longdivide.asm - page 29 - 3/21/2013 10:18:48


  codepages:
  ----------

STANDARD (0 changed characters)


0.06 seconds assembly time

   2277 lines source file
   6014 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
