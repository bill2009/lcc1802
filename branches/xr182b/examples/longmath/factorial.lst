 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 1 - 4/12/2013 12:43:12


       1/       0 :                     ; generated by lcc-xr18fl $Version: 4.0 - XR18FL - St. Judy's Compiler $ on Fri Apr 12 12:42:59 2013
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1)  830/       0 :                     	listing	on
(1)  831/       0 : C0 10 67            	lbr	lcc1802Init
(1)  832/       3 :                     	
      11/       3 :                     	listing on
      12/       3 :                     _fact:
      13/       3 : (MACRO)             	reserve 0; save room for local variables
      14/       3 : (MACRO)             	pushr r0
      15/       8 : (MACRO)             	pushr r1
      16/       D : (MACRO)             	reserve 4; save room for outgoing arguments
      17/      11 : (MACRO)             	cpy4 RL0,RL12; halfbaked
      18/      19 :                     ;long fact(long n){
      19/      19 :                     ;	if (0==n) return 1;
      20/      19 : (MACRO)             	ldI4 RL10,0 ;loading a long integer constant
      21/      25 : (MACRO)             	jneU4 rL0,rL10,L2; NE
      22/      4C : (MACRO)             	ldI4 RL10,1 ;loading a long integer constant
      23/      58 : (MACRO)             	cpy4 rp1p2,RL10
      24/      60 : C0 00 AB            	lbr L1
      25/      63 :                     L2:
      26/      63 :                     ;	return n*fact(n-1);
      27/      63 : (MACRO)             	ldI4 RL10,1 ;loading a long integer constant
      28/      6F : (MACRO)             	alu4 Rp1p2,RL0,RL10,sm,smb
      29/      85 : (MACRO)             	Ccall _fact
      30/      88 : (MACRO)             	cpy4 RL10,RL12; LOADI4*
      31/      90 : (MACRO)             	cpy4 RL8,RL0; LOADI4*
      32/      98 : (MACRO)             	Ccall _mulu4
      33/      9B : (MACRO)             	cpy4 RL10,RL8; LOADI4*
      34/      A3 : (MACRO)             	cpy4 rp1p2,RL10
      35/      AB :                     L1:
      36/      AB : (MACRO)             	release 4; release room for outgoing arguments
      37/      AF : (MACRO)             	popr r1
      38/      B3 : (MACRO)             	popr r0
      39/      B7 : (MACRO)             	release 0; release room for local variables 
      40/      B7 : (MACRO)             	Cretn
      41/      B8 :                     
      42/      B8 :                     _main:
      43/      B8 : (MACRO)             	reserve 0; save room for local variables
      44/      B8 : (MACRO)             	pushr r0
      45/      BD : (MACRO)             	pushr r1
      46/      C2 : (MACRO)             	reserve 12; save room for outgoing arguments
      47/      CC :                     ;{
      48/      CC :                     ;	for(n=1;n<=13;n++){
      49/      CC : (MACRO)             	ldI4 RL0,1 ;loading a long integer constant
      50/      D8 :                     L5:
      51/      D8 :                     ;		printf("fact(%ld)=%ld\n",n,fact(n));
      52/      D8 : (MACRO)             	cpy4 Rp1p2,RL0; LOADI4*
      53/      E0 : (MACRO)             	Ccall _fact
      54/      E3 : (MACRO)             	cpy4 RL10,RL12; LOADI4*
      55/      EB : (MACRO)             	ldaD R12,L9; reg:acon
      56/      F1 : (MACRO)             	st4 RL0,'O',sp,(4); arg+f**
      57/     104 : (MACRO)             	st4 RL10,'O',sp,(8); arg+f**
      58/     117 : (MACRO)             	Ccall _printf
      59/     11A :                     ;	}
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 2 - 4/12/2013 12:43:12


      60/     11A :                     L6:
      61/     11A :                     ;	for(n=1;n<=13;n++){
      62/     11A : (MACRO)             	ldI4 RL10,1 ;loading a long integer constant
      63/     126 : (MACRO)             	alu4 RL0,RL0,RL10,add,adc
      64/     13C : (MACRO)             	ldI4 RL10,13 ;loading a long integer constant
      65/     148 : (MACRO)             	jcI4 rL10,rL0,lbdf,L5 ;LE is flipped test & operands
      66/     164 :                     ;}
      67/     164 :                     L4:
      68/     164 : (MACRO)             	release 12; release room for outgoing arguments
      69/     16C : (MACRO)             	popr r1
      70/     170 : (MACRO)             	popr r0
      71/     174 : (MACRO)             	release 0; release room for local variables 
      72/     174 : (MACRO)             	Cretn
      73/     175 :                     
      74/     175 :                     _strcpy:
      75/     175 : (MACRO)             	reserve 2
      76/     177 :                     ;{
      77/     177 :                     ;	char *save = to;
      78/     177 : (MACRO)             	st2 R12,'O',sp,(-4+4); ASGNP2
      79/     184 :                     ;	for (; (*to = *from) != 0; ++from, ++to);
      80/     184 : C0 01 89            	lbr L14
      81/     187 :                     L11:
      82/     187 :                     L12:
      83/     187 : (MACRO)             	incm R13,1
      84/     188 : (MACRO)             	incm R12,1
      85/     189 :                     L14:
      86/     189 : (MACRO)             	ldn1 R11,R13;reg:  INDIRU1(indaddr)
      87/     18B : (MACRO)             	str1 R11,R12; ASGNU1(indaddr,reg)
      88/     18D : (MACRO)             	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
      89/     190 : (MACRO)             	jnzU2 r11,L11; NE 0
      90/     198 :                     ;	return(save);
      91/     198 : (MACRO)             	ld2 R15,'O',sp,(-4+4);reg:  INDIRP2(addr)
      92/     1A4 :                     L10:
      93/     1A4 : (MACRO)             	release 2
      94/     1A6 : (MACRO)             	Cretn
      95/     1A7 :                     
      96/     1A7 :                     _strlen:
      97/     1A7 : (MACRO)             	reserve 0; save room for local variables
      98/     1A7 : (MACRO)             	pushr r7
      99/     1AC : (MACRO)             	reserve 0; save room for outgoing arguments
     100/     1AC :                     ;{
     101/     1AC :                     ;	unsigned int slen = 0 ;
     102/     1AC : (MACRO)             	ld2z R7
     103/     1B0 : C0 01 B5            	lbr L17
     104/     1B3 :                     L16:
     105/     1B3 :                     ;	while (*str != 0) {
     106/     1B3 :                     ;      slen++ ;
     107/     1B3 : (MACRO)             	incm R7,1
     108/     1B4 :                     ;      str++ ;
     109/     1B4 : (MACRO)             	incm R12,1
     110/     1B5 :                     ;   }
     111/     1B5 :                     L17:
     112/     1B5 :                     ;	while (*str != 0) {
     113/     1B5 : (MACRO)             	ld1 R11,'O',R12,0
     114/     1BF : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     115/     1C2 : (MACRO)             	jnzU2 r11,L16; NE 0
     116/     1CA :                     ;   return slen;
     117/     1CA : (MACRO)             	cpy2 R15,R7 ;LOADU2(reg)*
     118/     1CE :                     L15:
     119/     1CE : (MACRO)             	release 0; release room for outgoing arguments
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 3 - 4/12/2013 12:43:12


     120/     1CE : (MACRO)             	popr r7
     121/     1D2 : (MACRO)             	release 0; release room for local variables 
     122/     1D2 : (MACRO)             	Cretn
     123/     1D3 :                     
     124/     1D3 :                     _printstr:
     125/     1D3 : (MACRO)             	reserve 0; save room for local variables
     126/     1D3 : (MACRO)             	pushr r7
     127/     1D8 : (MACRO)             	reserve 4; save room for outgoing arguments
     128/     1DC : (MACRO)             	cpy2 r7,r12; function(2055) 1
     129/     1E0 :                     ;void printstr(char *ptr){
     130/     1E0 : C0 02 02            	lbr L21
     131/     1E3 :                     L20:
     132/     1E3 :                     ;    while(*ptr) out(5,*ptr++);
     133/     1E3 : (MACRO)             	ldaD R12,5; reg:acon
     134/     1E9 : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg)
     135/     1ED : (MACRO)             	cpy2 R7,R11
     136/     1F1 : (MACRO)             	incm R7,1
     137/     1F2 : (MACRO)             	ld1 R13,'O',R11,0
     138/     1FC : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     139/     1FF : (MACRO)             	Ccall _out
     140/     202 :                     L21:
     141/     202 : (MACRO)             	ld1 R11,'O',R7,0
     142/     20C : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     143/     20F : (MACRO)             	jnzU2 r11,L20; NE 0
     144/     217 :                     ;}
     145/     217 :                     L19:
     146/     217 : (MACRO)             	release 4; release room for outgoing arguments
     147/     21B : (MACRO)             	popr r7
     148/     21F : (MACRO)             	release 0; release room for local variables 
     149/     21F : (MACRO)             	Cretn
     150/     220 :                     
     151/     220 :                     	align 4
     152/     220 :                     _round_nums:
     153/     220 : 3F 00 00 00         	dd 0x3f000000
     154/     224 : 3D 4C CC CD         	dd 0x3d4ccccd
     155/     228 : 3B A3 D7 0A         	dd 0x3ba3d70a
     156/     22C : 3A 03 12 6F         	dd 0x3a03126f
     157/     230 : 38 51 B7 17         	dd 0x3851b717
     158/     234 : 36 A7 C5 AC         	dd 0x36a7c5ac
     159/     238 : 35 06 37 BD         	dd 0x350637bd
     160/     23C : 33 56 BF 95         	dd 0x3356bf95
     161/     240 :                     	align 4
     162/     240 :                     _mult_nums:
     163/     240 : 3F 80 00 00         	dd 0x3f800000
     164/     244 : 41 20 00 00         	dd 0x41200000
     165/     248 : 42 C8 00 00         	dd 0x42c80000
     166/     24C : 44 7A 00 00         	dd 0x447a0000
     167/     250 : 46 1C 40 00         	dd 0x461c4000
     168/     254 : 47 C3 50 00         	dd 0x47c35000
     169/     258 : 49 74 24 00         	dd 0x49742400
     170/     25C : 4B 18 96 80         	dd 0x4b189680
     171/     260 :                     _ftoa:
     172/     260 : (MACRO)             	reserve 62; save room for local variables
     173/     26A : (MACRO)             	pushr r0
     174/     26F : (MACRO)             	pushr r1
     175/     274 : (MACRO)             	pushr r7
     176/     279 : (MACRO)             	reserve 8; save room for outgoing arguments
     177/     281 : (MACRO)             	cpy4 RL0,RL12; halfbaked&floaty
     178/     289 : (MACRO)             	ld2 R7,'O',sp,(6+78); reg:INDIRU2(addr)
     179/     295 :                     ;{
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 4 - 4/12/2013 12:43:12


     180/     295 :                     ;   char *output = outbfr ;
     181/     295 : (MACRO)             	ld2 R11,'O',sp,(4+78);reg:  INDIRP2(addr)
     182/     2A1 : (MACRO)             	st2 R11,'O',sp,(-4+78); ASGNP2
     183/     2AE :                     ;   if (flt < 0.0) {
     184/     2AE : (MACRO)             	ld4 RL10,'D',(L26),0;INDIRF4(addr)
     185/     2BC : (MACRO)             	jcF4 RL0,RL10,lbdf,L24;GEF4(reg,reg) - reverse test
     186/     301 :                     ;      *output++ = '-' ;
     187/     301 : (MACRO)             	ld2 R11,'O',sp,(-4+78);reg:  INDIRP2(addr)
     188/     30D : (MACRO)             	cpy2 R10,R11
     189/     311 : (MACRO)             	incm R10,1
     190/     312 : (MACRO)             	st2 R10,'O',sp,(-4+78); ASGNP2
     191/     31F : (MACRO)             	ldaD R10,45; reg:acon
     192/     325 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     193/     327 :                     ;      flt *= -1.0 ;
     194/     327 : (MACRO)             	ld4 RL8,'D',(L27),0;INDIRF4(addr)
     195/     335 : (MACRO)             	cpy4 RL10,RL0; LOADU4(reg)
     196/     33D : (MACRO)             	Ccall fp_mul ;MULF4(reg,reg)
     197/     340 : (MACRO)             	cpy4 RL0,RL8; LOADU4(reg)
     198/     348 :                     ;   } else {
     199/     348 : C0 03 74            	lbr L25
     200/     34B :                     L24:
     201/     34B :                     ;      if (use_leading_plus) {
     202/     34B : C0 03 74            	lbr L28
     203/     34E :                     ;         *output++ = '+' ;
     204/     34E : (MACRO)             	ld2 R11,'O',sp,(-4+78);reg:  INDIRP2(addr)
     205/     35A : (MACRO)             	cpy2 R10,R11
     206/     35E : (MACRO)             	incm R10,1
     207/     35F : (MACRO)             	st2 R10,'O',sp,(-4+78); ASGNP2
     208/     36C : (MACRO)             	ldaD R10,43; reg:acon
     209/     372 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     210/     374 :                     ;      }
     211/     374 :                     L28:
     212/     374 :                     ;   }
     213/     374 :                     L25:
     214/     374 :                     ;   if (dec_digits < 8) {
     215/     374 : (MACRO)             	jcI2I r7,8,lbdf,L30; GE is flipped test from LT
     216/     385 :                     ;      flt += round_nums[dec_digits] ;
     217/     385 : (MACRO)             	cpy4 RL8,RL0; LOADU4(reg)
     218/     38D : (MACRO)             	cpy2 R11,R7
     219/     391 : (MACRO)             	shl2I R11,2
     220/     39D : (MACRO)             	ld4 RL10,'O',R11,(_round_nums);INDIRF4(addr)
     221/     3AD : (MACRO)             	Ccall fp_add ;ADDF4(reg,reg)
     222/     3B0 : (MACRO)             	cpy4 RL0,RL8; LOADU4(reg)
     223/     3B8 :                     ;   }
     224/     3B8 :                     L30:
     225/     3B8 :                     ;	mult=mult_nums[dec_digits];
     226/     3B8 : (MACRO)             	cpy2 R11,R7
     227/     3BC : (MACRO)             	shl2I R11,2
     228/     3C8 : (MACRO)             	ld4 RL10,'O',R11,(_mult_nums);INDIRF4(addr)
     229/     3D8 : (MACRO)             	st4 RL10,'O',sp,(-12+78); ASGNF4(addr,reg)
     230/     3EB :                     ;   wholeNum = flt;
     231/     3EB : (MACRO)             	cpy4 RL8,RL0; LOADU4(reg)
     232/     3F3 : (MACRO)             	ccall cvfi4; CVFI4(reg) convert float to long
     233/     3F6 : (MACRO)             	st4 RL8,'O',sp,(-8+78)
     234/     409 :                     ;   decimalNum = ((flt - wholeNum) * mult);
     235/     409 : (MACRO)             	cpy4 RL8,RL0; LOADU4(reg)
     236/     411 : (MACRO)             	st4 RL8,'O',sp,(-64+78); ASGNF4(addr,reg)
     237/     424 : (MACRO)             	ld4 RL8,'O',sp,(-8+78);reg:  INDIRI4(addr)
     238/     434 : (MACRO)             	Ccall cvif4; emit2
     239/     437 : (MACRO)             	cpy4 RL10,RL8; LOADU4(reg)
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 5 - 4/12/2013 12:43:12


     240/     43F : (MACRO)             	ld4 RL8,'O',sp,(-64+78);INDIRF4(addr)
     241/     44F : (MACRO)             	Ccall fp_sub ;SUBF4(reg,reg)
     242/     452 : (MACRO)             	ld4 RL10,'O',sp,(-12+78);INDIRF4(addr)
     243/     462 : (MACRO)             	Ccall fp_mul ;MULF4(reg,reg)
     244/     465 : (MACRO)             	ccall cvfi4; CVFI4(reg) convert float to long
     245/     468 : (MACRO)             	st4 RL8,'O',sp,(-16+78)
     246/     47B :                     ;   strcpy(output,dubdabx(wholeNum,output,1));
     247/     47B : (MACRO)             	ld4 Rp1p2,'O',sp,(-8+78);reg:  INDIRI4(addr)
     248/     48B : (MACRO)             	ld2 R11,'O',sp,(-4+78);reg:  INDIRP2(addr)
     249/     497 : (MACRO)             	st2 r11,'O',sp,(4); arg+f**
     250/     4A4 : (MACRO)             	ldaD R11,1; reg:acon
     251/     4AA : (MACRO)             	st2 r11,'O',sp,(6); arg+f**
     252/     4B7 : (MACRO)             	Ccall _dubdabx
     253/     4BA : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     254/     4BE : (MACRO)             	ld2 R12,'O',sp,(-4+78);reg:  INDIRP2(addr)
     255/     4CA : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     256/     4CE : (MACRO)             	Ccall _strcpy
     257/     4D1 :                     ;   output+=strlen(output);
     258/     4D1 : (MACRO)             	ld2 R12,'O',sp,(-4+78);reg:  INDIRP2(addr)
     259/     4DD : (MACRO)             	Ccall _strlen;CALLU2(ar)*
     260/     4E0 : (MACRO)             	cpy2 R11,R15 ;LOADU2(reg)*
     261/     4E4 : (MACRO)             	ld2 R10,'O',sp,(-4+78);reg:  INDIRP2(addr)
     262/     4F0 : (MACRO)             	alu2 R11,R11,R10,add,adc
     263/     4FC : (MACRO)             	st2 R11,'O',sp,(-4+78); ASGNP2
     264/     509 :                     ;   if (dec_digits > 0) {
     265/     509 : (MACRO)             	jeqU2I r7,0,L32;EQU2(reg,con)
     266/     515 :                     ;		*output++ = '.' ;
     267/     515 : (MACRO)             	ld2 R11,'O',sp,(-4+78);reg:  INDIRP2(addr)
     268/     521 : (MACRO)             	cpy2 R10,R11
     269/     525 : (MACRO)             	incm R10,1
     270/     526 : (MACRO)             	st2 R10,'O',sp,(-4+78); ASGNP2
     271/     533 : (MACRO)             	ldaD R10,46; reg:acon
     272/     539 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     273/     53B :                     ;		strcpy(output,dubdabx(decimalNum,output,dec_digits));
     274/     53B : (MACRO)             	ld4 Rp1p2,'O',sp,(-16+78);reg:  INDIRI4(addr)
     275/     54B : (MACRO)             	ld2 R11,'O',sp,(-4+78);reg:  INDIRP2(addr)
     276/     557 : (MACRO)             	st2 r11,'O',sp,(4); arg+f**
     277/     564 : (MACRO)             	cpy2 R11,R7 ;LOADI2(reg)*
     278/     568 : (MACRO)             	st2 r11,'O',sp,(6); arg+f**
     279/     575 : (MACRO)             	Ccall _dubdabx
     280/     578 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     281/     57C : (MACRO)             	ld2 R12,'O',sp,(-4+78);reg:  INDIRP2(addr)
     282/     588 : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     283/     58C : (MACRO)             	Ccall _strcpy
     284/     58F :                     ;	}
     285/     58F :                     L32:
     286/     58F :                     ;   return outbfr;
     287/     58F : (MACRO)             	ld2 R15,'O',sp,(4+78);reg:  INDIRP2(addr)
     288/     59B :                     L23:
     289/     59B : (MACRO)             	release 8; release room for outgoing arguments
     290/     5A3 : (MACRO)             	popr r7
     291/     5A7 : (MACRO)             	popr r1
     292/     5AB : (MACRO)             	popr r0
     293/     5AF : (MACRO)             	release 62; release room for local variables 
     294/     5B7 : (MACRO)             	Cretn
     295/     5B8 :                     
     296/     5B8 :                     _itoa:
     297/     5B8 : (MACRO)             	reserve 4; save room for local variables
     298/     5BC : (MACRO)             	pushr r0
     299/     5C1 : (MACRO)             	pushr r1
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 6 - 4/12/2013 12:43:12


     300/     5C6 : (MACRO)             	pushr r7
     301/     5CB : (MACRO)             	reserve 4; save room for outgoing arguments
     302/     5CF : (MACRO)             	st2 r12,'O',sp,(16); flag1 
     303/     5DC : (MACRO)             	st2 r13,'O',sp,(18); flag1 
     304/     5E9 :                     ;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
     305/     5E9 :                     ;	unsigned int flag=0;
     306/     5E9 : (MACRO)             	ld2z R11
     307/     5ED : (MACRO)             	st2 R11,'O',sp,(-4+16); ASGNU2(addr,reg)*
     308/     5FA :                     ;	char * bptr; bptr=buffer;
     309/     5FA : (MACRO)             	ld2 R11,'O',sp,(2+16);reg:  INDIRP2(addr)
     310/     606 : (MACRO)             	st2 R11,'O',sp,(-6+16); ASGNP2
     311/     613 :                     ;	if (s<0){
     312/     613 : (MACRO)             	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
     313/     61F : (MACRO)             	jcI2I r11,0,lbdf,L35; GE is flipped test from LT
     314/     630 :                     ;		*bptr='-';bptr++;
     315/     630 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     316/     63C : (MACRO)             	ldaD R10,45; reg:acon
     317/     642 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     318/     644 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     319/     650 : (MACRO)             	incm R11,1
     320/     651 : (MACRO)             	st2 R11,'O',sp,(-6+16); ASGNP2
     321/     65E :                     ;		n=-s;
     322/     65E : (MACRO)             	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
     323/     66A : (MACRO)             	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
     324/     673 : (MACRO)             	cpy2 R1,R11 ;LOADU2(reg)*
     325/     677 :                     ;	} else{
     326/     677 : C0 06 8A            	lbr L36
     327/     67A :                     L35:
     328/     67A :                     ;		n=s;
     329/     67A : (MACRO)             	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
     330/     686 : (MACRO)             	cpy2 R1,R11 ;LOADU2(reg)*
     331/     68A :                     ;	}
     332/     68A :                     L36:
     333/     68A :                     ;	k=10000;
     334/     68A : (MACRO)             	ldaD R7,10000; reg:acon
     335/     690 : C0 07 34            	lbr L38
     336/     693 :                     L37:
     337/     693 :                     ;	while(k>0){
     338/     693 :                     ;		for(r=0;k<=n;r++,n-=k); // was r=n/k
     339/     693 : (MACRO)             	ld2z R0
     340/     697 : C0 06 A7            	lbr L43
     341/     69A :                     L40:
     342/     69A :                     L41:
     343/     69A : (MACRO)             	incm R0,1
     344/     69B : (MACRO)             	alu2 R1,R1,R7,sm,smb
     345/     6A7 :                     L43:
     346/     6A7 : (MACRO)             	jcU2 r1,r7,lbdf,L40 ;LE is flipped test & operands
     347/     6B4 :                     ;		if (flag || r>0||k==1){
     348/     6B4 : (MACRO)             	ld2 R11,'O',sp,(-4+16); reg:INDIRU2(addr)
     349/     6C0 : (MACRO)             	jnzU2 r11,L47; NE 0
     350/     6C8 : (MACRO)             	jnzU2 r0,L47; NE 0
     351/     6D0 : (MACRO)             	jneU2I r7,1,L44; NE
     352/     6DC :                     L47:
     353/     6DC :                     ;			*bptr=('0'+r);bptr++;
     354/     6DC : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     355/     6E8 : (MACRO)             	ldA2 R10,'O',R0,(48); reg:addr
     356/     6F0 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     357/     6F2 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     358/     6FE : (MACRO)             	incm R11,1
     359/     6FF : (MACRO)             	st2 R11,'O',sp,(-6+16); ASGNP2
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 7 - 4/12/2013 12:43:12


     360/     70C :                     ;			flag='y';
     361/     70C : (MACRO)             	ldaD R11,121; reg:acon
     362/     712 : (MACRO)             	st2 R11,'O',sp,(-4+16); ASGNU2(addr,reg)*
     363/     71F :                     ;		}
     364/     71F :                     L44:
     365/     71F :                     ;		k=k/10;
     366/     71F : (MACRO)             	cpy2 R12,R7 ;LOADU2(reg)*
     367/     723 : (MACRO)             	ldaD R13,10; reg:acon
     368/     729 : (MACRO)             	Ccall _divu2
     369/     72C : (MACRO)             	cpy2 R11,R15 ;LOADU2(reg)*
     370/     730 : (MACRO)             	cpy2 R7,R11 ;LOADU2(reg)*
     371/     734 :                     ;	}
     372/     734 :                     L38:
     373/     734 :                     ;	while(k>0){
     374/     734 : (MACRO)             	jnzU2 r7,L37; NE 0
     375/     73C :                     ;	*bptr='\0';
     376/     73C : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     377/     748 : (MACRO)             	ldaD R10,0; reg:acon
     378/     74E : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     379/     750 :                     ;	return buffer;
     380/     750 : (MACRO)             	ld2 R15,'O',sp,(2+16);reg:  INDIRP2(addr)
     381/     75C :                     L34:
     382/     75C : (MACRO)             	release 4; release room for outgoing arguments
     383/     760 : (MACRO)             	popr r7
     384/     764 : (MACRO)             	popr r1
     385/     768 : (MACRO)             	popr r0
     386/     76C : (MACRO)             	release 4; release room for local variables 
     387/     770 : (MACRO)             	Cretn
     388/     771 :                     
     389/     771 :                     _ltoa:
     390/     771 : (MACRO)             	reserve 0; save room for local variables
     391/     771 : (MACRO)             	pushr r0
     392/     776 : (MACRO)             	pushr r1
     393/     77B : (MACRO)             	pushr r7
     394/     780 : (MACRO)             	reserve 8; save room for outgoing arguments
     395/     788 : (MACRO)             	cpy4 RL0,RL12; halfbaked
     396/     790 :                     ;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
     397/     790 :                     ;	char* bptr=buffer;
     398/     790 : (MACRO)             	ld2 R7,'O',sp,(4+16);reg:  INDIRP2(addr)
     399/     79C :                     ;	if (s<0){
     400/     79C : (MACRO)             	ldI4 RL10,0 ;loading a long integer constant
     401/     7A8 : (MACRO)             	jcI4 RL0,RL10,lbdf,L49; GE is flipped test from LT
     402/     7C4 :                     ;		*bptr++='-';
     403/     7C4 : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg)
     404/     7C8 : (MACRO)             	cpy2 R7,R11
     405/     7CC : (MACRO)             	incm R7,1
     406/     7CD : (MACRO)             	ldaD R10,45; reg:acon
     407/     7D3 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     408/     7D5 :                     ;		s=-s;
     409/     7D5 : (MACRO)             	negI4 RL0,RL0 ;was alu4I RL0,RL0,0,sdi,sdbi
     410/     7F5 :                     ;	}
     411/     7F5 :                     L49:
     412/     7F5 :                     ;	strcpy(bptr,dubdabx(s,bptr,1)); //uses assembler double-dabble routine
     413/     7F5 : (MACRO)             	cpy4 Rp1p2,RL0; LOADI4*
     414/     7FD : (MACRO)             	st2 r7,'O',sp,(4); arg+f**
     415/     80A : (MACRO)             	ldaD R11,1; reg:acon
     416/     810 : (MACRO)             	st2 r11,'O',sp,(6); arg+f**
     417/     81D : (MACRO)             	Ccall _dubdabx
     418/     820 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     419/     824 : (MACRO)             	cpy2 R12,R7 ;LOADP2(reg)
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 8 - 4/12/2013 12:43:12


     420/     828 : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     421/     82C : (MACRO)             	Ccall _strcpy
     422/     82F :                     ;	return buffer;
     423/     82F : (MACRO)             	ld2 R15,'O',sp,(4+16);reg:  INDIRP2(addr)
     424/     83B :                     L48:
     425/     83B : (MACRO)             	release 8; release room for outgoing arguments
     426/     843 : (MACRO)             	popr r7
     427/     847 : (MACRO)             	popr r1
     428/     84B : (MACRO)             	popr r0
     429/     84F : (MACRO)             	release 0; release room for local variables 
     430/     84F : (MACRO)             	Cretn
     431/     850 :                     
     432/     850 :                     _printint:
     433/     850 : (MACRO)             	reserve 12
     434/     85A : (MACRO)             	st2 r12,'O',sp,(14); flag1 
     435/     867 :                     ;void printint(int s){ //print an integer
     436/     867 :                     ;	itoa(s,buffer);
     437/     867 : (MACRO)             	ld2 R12,'O',sp,(0+14) ;reg:INDIRI2(addr)
     438/     873 : (MACRO)             	ldA2 R13,'O',sp,(-10+14); reg:addr
     439/     87B : (MACRO)             	Ccall _itoa
     440/     87E :                     ;	printstr(buffer);
     441/     87E : (MACRO)             	ldA2 R12,'O',sp,(-10+14); reg:addr
     442/     886 : (MACRO)             	Ccall _printstr
     443/     889 :                     ;}
     444/     889 :                     L51:
     445/     889 : (MACRO)             	release 12
     446/     891 : (MACRO)             	Cretn
     447/     892 :                     
     448/     892 :                     _printlint:
     449/     892 : (MACRO)             	reserve 18
     450/     89C : (MACRO)             	st2 r12,'O',sp,(20); flag1 
     451/     8A9 : (MACRO)             	st2 r13,'O',sp,(22); flag1 
     452/     8B6 :                     ;void printlint(long s){ //print a long integer
     453/     8B6 :                     ;	printstr(ltoa(s,buffer));
     454/     8B6 : (MACRO)             	ld4 Rp1p2,'O',sp,(0+20);reg:  INDIRI4(addr)
     455/     8C6 : (MACRO)             	ldA2 R11,'O',sp,(-14+20); reg:addr
     456/     8CE : (MACRO)             	st2 r11,'O',sp,(4); arg+f**
     457/     8DB : (MACRO)             	Ccall _ltoa
     458/     8DE : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     459/     8E2 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     460/     8E6 : (MACRO)             	Ccall _printstr
     461/     8E9 :                     ;}
     462/     8E9 :                     L52:
     463/     8E9 : (MACRO)             	release 18
     464/     8F1 : (MACRO)             	Cretn
     465/     8F2 :                     
     466/     8F2 :                     _printflt:
     467/     8F2 : (MACRO)             	reserve 28
     468/     8FC : (MACRO)             	st2 r12,'O',sp,(30); flag1 
     469/     909 : (MACRO)             	st2 r13,'O',sp,(32); flag1 
     470/     916 :                     ;void printflt(float s){ //print a float
     471/     916 :                     ;	printstr(ftoa(s,buffer,3));
     472/     916 : (MACRO)             	ld4 Rp1p2,'O',sp,(0+30);INDIRF4(addr)
     473/     926 : (MACRO)             	ldA2 R11,'O',sp,(-22+30); reg:addr
     474/     92E : (MACRO)             	st2 r11,'O',sp,(4); arg+f**
     475/     93B : (MACRO)             	ldaD R11,3; reg:acon
     476/     941 : (MACRO)             	st2 r11,'O',sp,(6); arg+f**
     477/     94E : (MACRO)             	Ccall _ftoa
     478/     951 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     479/     955 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 9 - 4/12/2013 12:43:12


     480/     959 : (MACRO)             	Ccall _printstr
     481/     95C :                     ;}
     482/     95C :                     L53:
     483/     95C : (MACRO)             	release 28
     484/     964 : (MACRO)             	Cretn
     485/     965 :                     
     486/     965 :                     _putxn:
     487/     965 : (MACRO)             	reserve 4
     488/     969 : (MACRO)             	st2 r12,'O',sp,(6); flag1 
     489/     976 : (MACRO)             	ld2 R11,'O',sp,(0+6) ;reg:INDIRI2(addr)
     490/     982 : (MACRO)             	st1 R11,'O',sp,(0+6); ASGNU1
     491/     98C :                     ;void putxn(unsigned char x){ //print a nibble as ascii hex
     492/     98C :                     ;	if (x<10){
     493/     98C : (MACRO)             	ld1 R11,'O',sp,(0+6)
     494/     996 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     495/     999 : (MACRO)             	jcI2I r11,10,lbdf,L55; GE is flipped test from LT
     496/     9AA :                     ;		putc(x+'0');
     497/     9AA : (MACRO)             	ld1 R11,'O',sp,(0+6)
     498/     9B4 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     499/     9B7 : (MACRO)             	ldA2 R11,'O',R11,(48); reg:addr
     500/     9BF : (MACRO)             	cpy1 R12,R11
     501/     9C1 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     502/     9C4 : (MACRO)             	Ccall _putc
     503/     9C7 :                     ;	} else {
     504/     9C7 : C0 09 EF            	lbr L56
     505/     9CA :                     L55:
     506/     9CA :                     ;		putc(x+'A'-10);
     507/     9CA : (MACRO)             	ld1 R11,'O',sp,(0+6)
     508/     9D4 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     509/     9D7 : (MACRO)             	ldA2 R11,'O',R11,(65); reg:addr
     510/     9DF : (MACRO)             	alu2I R11,R11,10,smi,smbi
     511/     9E7 : (MACRO)             	cpy1 R12,R11
     512/     9E9 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     513/     9EC : (MACRO)             	Ccall _putc
     514/     9EF :                     ;	}
     515/     9EF :                     L56:
     516/     9EF :                     ;}
     517/     9EF :                     L54:
     518/     9EF : (MACRO)             	release 4
     519/     9F3 : (MACRO)             	Cretn
     520/     9F4 :                     
     521/     9F4 :                     _putx:
     522/     9F4 : (MACRO)             	reserve 4
     523/     9F8 : (MACRO)             	st2 r12,'O',sp,(6); flag1 
     524/     A05 : (MACRO)             	ld2 R11,'O',sp,(0+6) ;reg:INDIRI2(addr)
     525/     A11 : (MACRO)             	st1 R11,'O',sp,(0+6); ASGNU1
     526/     A1B :                     ;void putx(unsigned char x){ //print a unsigned char as ascii hex
     527/     A1B :                     ;	putxn(x>>4);
     528/     A1B : (MACRO)             	ld1 R11,'O',sp,(0+6)
     529/     A25 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     530/     A28 : (MACRO)             	shrI2I R11,4
     531/     A48 : (MACRO)             	cpy1 R12,R11
     532/     A4A : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     533/     A4D : (MACRO)             	Ccall _putxn
     534/     A50 :                     ;	putxn(x & 0x0F);
     535/     A50 : (MACRO)             	ld1 R11,'O',sp,(0+6)
     536/     A5A : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     537/     A5D : (MACRO)             	alu2I R11,R11,15,ani,ani
     538/     A65 :                     	;removed ?	cpy2 R11,R11
     539/     A65 : (MACRO)             	cpy1 R12,R11
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 10 - 4/12/2013 12:43:12


     540/     A67 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     541/     A6A : (MACRO)             	Ccall _putxn
     542/     A6D :                     ;}
     543/     A6D :                     L57:
     544/     A6D : (MACRO)             	release 4
     545/     A71 : (MACRO)             	Cretn
     546/     A72 :                     
     547/     A72 :                     _printf:
     548/     A72 : (MACRO)             	reserve 4; save room for local variables
     549/     A76 : (MACRO)             	pushr r0
     550/     A7B : (MACRO)             	pushr r1
     551/     A80 : (MACRO)             	pushr r7
     552/     A85 : (MACRO)             	reserve 4; save room for outgoing arguments
     553/     A89 : (MACRO)             	st2 r12,'O',sp,(16); flag1 
     554/     A96 : (MACRO)             	st2 r13,'O',sp,(18); flag2
     555/     AA3 :                     ;void printf(char *ptr,...){ //limited implementation of printf
     556/     AA3 :                     ;	int argslot=0;	//used to align longs
     557/     AA3 : (MACRO)             	ld2z R0
     558/     AA7 :                     ;	int * this=(int *)&ptr;
     559/     AA7 : (MACRO)             	ldA2 R1,'O',sp,(0+16); reg:addr
     560/     AAF :                     ;	this++; argslot++; //advance argument pointer and slot #
     561/     AAF : (MACRO)             	incm R1,2
     562/     AB1 : (MACRO)             	incm R0,1
     563/     AB2 : C0 0E 88            	lbr L60
     564/     AB5 :                     L59:
     565/     AB5 :                     ;    while(*ptr) {
     566/     AB5 :                     ;		c=*ptr++;
     567/     AB5 : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     568/     AC1 : (MACRO)             	cpy2 R10,R11
     569/     AC5 : (MACRO)             	incm R10,1
     570/     AC6 : (MACRO)             	st2 R10,'O',sp,(0+16); ASGNP2
     571/     AD3 : (MACRO)             	ldn1 R7,R11;reg:  INDIRU1(indaddr)
     572/     AD5 :                     ;		if (c!='%'){
     573/     AD5 : (MACRO)             	cpy1 R11,R7
     574/     AD7 : (MACRO)             	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     575/     ADA : (MACRO)             	jeqU2I r11,37,L62;EQI2(reg,con)
     576/     AE6 :                     ;			putc(c);
     577/     AE6 : (MACRO)             	cpy1 R12,R7
     578/     AE8 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     579/     AEB : (MACRO)             	Ccall _putc
     580/     AEE :                     ;		} else{
     581/     AEE : C0 0E 88            	lbr L63
     582/     AF1 :                     L62:
     583/     AF1 :                     ;			c=*ptr++;
     584/     AF1 : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     585/     AFD : (MACRO)             	cpy2 R10,R11
     586/     B01 : (MACRO)             	incm R10,1
     587/     B02 : (MACRO)             	st2 R10,'O',sp,(0+16); ASGNP2
     588/     B0F : (MACRO)             	ldn1 R7,R11;reg:  INDIRU1(indaddr)
     589/     B11 :                     ;			switch (c){
     590/     B11 : (MACRO)             	cpy1 R11,R7
     591/     B13 : (MACRO)             	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     592/     B16 : (MACRO)             	st2 R11,'O',sp,(-5+16); ASGNI2(addr,reg)*;
     593/     B23 : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     594/     B2F : (MACRO)             	jcI2I r11,99,lbnf,L83  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     595/     B40 : (MACRO)             	jnI2I r11,108,lbnf,L84; GT reverse  the subtraction
     596/     B51 : (MACRO)             	shl2I R11,1
     597/     B57 : (MACRO)             	ld2 R11,'O',R11,(L85-198);reg:  INDIRP2(addr)
     598/     B63 : (MACRO)             	jumpv r11; JUMPV(reg)
     599/     B6D :                     L85:
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 11 - 4/12/2013 12:43:12


     600/     B6D : 0C 2D               	dw L69
     601/     B6F : 0B EF               	dw L67
     602/     B71 : 0E 77               	dw L64
     603/     B73 : 0E 27               	dw L78
     604/     B75 : 0E 77               	dw L64
     605/     B77 : 0E 77               	dw L64
     606/     B79 : 0B EF               	dw L67
     607/     B7B : 0E 77               	dw L64
     608/     B7D : 0E 77               	dw L64
     609/     B7F : 0C BD               	dw L71
     610/     B81 :                     L83:
     611/     B81 : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     612/     B8D : (MACRO)             	jeqU2I r11,88,L70;EQI2(reg,con)
     613/     B99 : C0 0E 77            	lbr L64
     614/     B9C :                     L84:
     615/     B9C : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     616/     BA8 : (MACRO)             	ldaD R10,115; reg:acon
     617/     BAE : (MACRO)             	jeqI2 r11,r10,L68; EQI2(reg,reg)
     618/     BC0 : (MACRO)             	jcI2 r11,r10,lbnf,L64; LT=lbnf i.e. subtract B from A and jump if borrow 
     619/     BD4 :                     L87:
     620/     BD4 : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     621/     BE0 : (MACRO)             	jeqU2I r11,120,L70;EQI2(reg,con)
     622/     BEC : C0 0E 77            	lbr L64
     623/     BEF :                     L67:
     624/     BEF :                     ;					printint(*this++);
     625/     BEF : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     626/     BF3 : (MACRO)             	cpy2 R1,R11
     627/     BF7 : (MACRO)             	incm R1,2
     628/     BF9 : (MACRO)             	ld2 R12,'O',R11,0 ;reg:INDIRI2(addr)
     629/     C05 : (MACRO)             	Ccall _printint
     630/     C08 :                     ;					argslot+=1; //next argument slot
     631/     C08 : (MACRO)             	incm R0,1
     632/     C09 :                     ;					break;
     633/     C09 : C0 0E 88            	lbr L65
     634/     C0C :                     L68:
     635/     C0C :                     ;					printstr((char*) *this++);
     636/     C0C : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     637/     C10 : (MACRO)             	cpy2 R1,R11
     638/     C14 : (MACRO)             	incm R1,2
     639/     C16 : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     640/     C22 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     641/     C26 : (MACRO)             	Ccall _printstr
     642/     C29 :                     ;					argslot+=1; //next argument slot
     643/     C29 : (MACRO)             	incm R0,1
     644/     C2A :                     ;					break;
     645/     C2A : C0 0E 88            	lbr L65
     646/     C2D :                     L69:
     647/     C2D :                     ;					putc((unsigned int) *this++);
     648/     C2D : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     649/     C31 : (MACRO)             	cpy2 R1,R11
     650/     C35 : (MACRO)             	incm R1,2
     651/     C37 : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     652/     C43 : (MACRO)             	cpy1 R12,R11
     653/     C45 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     654/     C48 : (MACRO)             	Ccall _putc
     655/     C4B :                     ;					argslot+=1; //next argument slot
     656/     C4B : (MACRO)             	incm R0,1
     657/     C4C :                     ;					break;
     658/     C4C : C0 0E 88            	lbr L65
     659/     C4F :                     L70:
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 12 - 4/12/2013 12:43:12


     660/     C4F :                     ;					putx(((unsigned int) *this)>>8);
     661/     C4F : (MACRO)             	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
     662/     C5B : (MACRO)             	shrU2I R11,8
     663/     C8B : (MACRO)             	cpy1 R12,R11
     664/     C8D : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     665/     C90 : (MACRO)             	Ccall _putx
     666/     C93 :                     ;					putx(((unsigned int) *this++)&255);
     667/     C93 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     668/     C97 : (MACRO)             	cpy2 R1,R11
     669/     C9B : (MACRO)             	incm R1,2
     670/     C9D : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     671/     CA9 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     672/     CB1 : (MACRO)             	cpy1 R12,R11
     673/     CB3 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     674/     CB6 : (MACRO)             	Ccall _putx
     675/     CB9 :                     ;					argslot+=1; //next argument slot
     676/     CB9 : (MACRO)             	incm R0,1
     677/     CBA :                     ;					break;
     678/     CBA : C0 0E 88            	lbr L65
     679/     CBD :                     L71:
     680/     CBD :                     ;					if (*ptr){ //as long as there's something there
     681/     CBD : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     682/     CC9 : (MACRO)             	ld1 R11,'O',R11,0
     683/     CD3 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     684/     CD6 : (MACRO)             	jzU2 r11,L72; EQ 0
     685/     CDE :                     ;						xord=*ptr++;
     686/     CDE : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     687/     CEA : (MACRO)             	cpy2 R10,R11
     688/     CEE : (MACRO)             	incm R10,1
     689/     CEF : (MACRO)             	st2 R10,'O',sp,(0+16); ASGNP2
     690/     CFC : (MACRO)             	ldn1 R11,R11;reg:  INDIRU1(indaddr)
     691/     CFE : (MACRO)             	st1 R11,'O',sp,(-3+16); ASGNU1
     692/     D08 :                     ;						if (argslot&1) {
     693/     D08 : (MACRO)             	alu2I R11,R0,1,ani,ani
     694/     D10 :                     	;removed ?	cpy2 R11,R0
     695/     D10 : (MACRO)             	jzU2 r11,L74; EQ 0
     696/     D18 :                     ;							this++;
     697/     D18 : (MACRO)             	incm R1,2
     698/     D1A :                     ;							argslot++;
     699/     D1A : (MACRO)             	incm R0,1
     700/     D1B :                     ;						}
     701/     D1B :                     L74:
     702/     D1B :                     ;						if(xord=='d'){
     703/     D1B : (MACRO)             	ld1 R11,'O',sp,(-3+16)
     704/     D25 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     705/     D28 : (MACRO)             	jneU2I r11,100,L76; NE
     706/     D34 :                     ;							printlint(*(long *)this);//treats "this" as a pointer to long
     707/     D34 : (MACRO)             	ld4 Rp1p2,'O',R1,0;reg:  INDIRI4(addr)
     708/     D44 : (MACRO)             	Ccall _printlint
     709/     D47 :                     ;							this+=2;				// and advances it 4 bytes
     710/     D47 : (MACRO)             	incm R1,4
     711/     D4B :                     ;						} else{
     712/     D4B : C0 0E 22            	lbr L77
     713/     D4E :                     L76:
     714/     D4E :                     ;							putx(((unsigned int) *this)>>8);
     715/     D4E : (MACRO)             	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
     716/     D5A : (MACRO)             	shrU2I R11,8
     717/     D8A : (MACRO)             	cpy1 R12,R11
     718/     D8C : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     719/     D8F : (MACRO)             	Ccall _putx
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 13 - 4/12/2013 12:43:12


     720/     D92 :                     ;							putx(((unsigned int) *this++)&255);
     721/     D92 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     722/     D96 : (MACRO)             	cpy2 R1,R11
     723/     D9A : (MACRO)             	incm R1,2
     724/     D9C : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     725/     DA8 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     726/     DB0 : (MACRO)             	cpy1 R12,R11
     727/     DB2 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     728/     DB5 : (MACRO)             	Ccall _putx
     729/     DB8 :                     ;							putx(((unsigned int) *this)>>8);
     730/     DB8 : (MACRO)             	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
     731/     DC4 : (MACRO)             	shrU2I R11,8
     732/     DF4 : (MACRO)             	cpy1 R12,R11
     733/     DF6 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     734/     DF9 : (MACRO)             	Ccall _putx
     735/     DFC :                     ;							putx(((unsigned int) *this++)&255);
     736/     DFC : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     737/     E00 : (MACRO)             	cpy2 R1,R11
     738/     E04 : (MACRO)             	incm R1,2
     739/     E06 : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     740/     E12 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     741/     E1A : (MACRO)             	cpy1 R12,R11
     742/     E1C : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     743/     E1F : (MACRO)             	Ccall _putx
     744/     E22 :                     ;						}
     745/     E22 :                     L77:
     746/     E22 :                     ;						argslot+=2;
     747/     E22 : (MACRO)             	incm R0,2
     748/     E24 :                     ;						break;
     749/     E24 : C0 0E 88            	lbr L65
     750/     E27 :                     L72:
     751/     E27 :                     L78:
     752/     E27 :                     ;					if (*ptr){ //as long as there's something there
     753/     E27 : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     754/     E33 : (MACRO)             	ld1 R11,'O',R11,0
     755/     E3D : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     756/     E40 : (MACRO)             	jzU2 r11,L79; EQ 0
     757/     E48 :                     ;						if (argslot&1) { //adjust alignment
     758/     E48 : (MACRO)             	alu2I R11,R0,1,ani,ani
     759/     E50 :                     	;removed ?	cpy2 R11,R0
     760/     E50 : (MACRO)             	jzU2 r11,L81; EQ 0
     761/     E58 :                     ;							this++;
     762/     E58 : (MACRO)             	incm R1,2
     763/     E5A :                     ;							argslot++;
     764/     E5A : (MACRO)             	incm R0,1
     765/     E5B :                     ;						}
     766/     E5B :                     L81:
     767/     E5B :                     ;						printflt(*(float *)this);//treats "this" as a pointer to float
     768/     E5B : (MACRO)             	ld4 Rp1p2,'O',R1,0;INDIRF4(addr)
     769/     E6B : (MACRO)             	Ccall _printflt
     770/     E6E :                     ;						this+=2;				// and advances it 4 bytes
     771/     E6E : (MACRO)             	incm R1,4
     772/     E72 :                     ;						argslot+=2;
     773/     E72 : (MACRO)             	incm R0,2
     774/     E74 :                     ;						break;
     775/     E74 : C0 0E 88            	lbr L65
     776/     E77 :                     L79:
     777/     E77 :                     L64:
     778/     E77 :                     ;					putc('%');putc(c);
     779/     E77 : (MACRO)             	ldaD R12,37; reg:acon
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 14 - 4/12/2013 12:43:12


     780/     E7D : (MACRO)             	Ccall _putc
     781/     E80 : (MACRO)             	cpy1 R12,R7
     782/     E82 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     783/     E85 : (MACRO)             	Ccall _putc
     784/     E88 :                     ;			} //switch
     785/     E88 :                     L65:
     786/     E88 :                     ;		} //%
     787/     E88 :                     L63:
     788/     E88 :                     ;	} //while
     789/     E88 :                     L60:
     790/     E88 :                     ;    while(*ptr) {
     791/     E88 : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     792/     E94 : (MACRO)             	ld1 R11,'O',R11,0
     793/     E9E : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     794/     EA1 : (MACRO)             	jnzU2 r11,L59; NE 0
     795/     EA9 :                     ;} //prtf
     796/     EA9 :                     L58:
     797/     EA9 : (MACRO)             	release 4; release room for outgoing arguments
     798/     EAD : (MACRO)             	popr r7
     799/     EB1 : (MACRO)             	popr r1
     800/     EB5 : (MACRO)             	popr r0
     801/     EB9 : (MACRO)             	release 4; release room for local variables 
     802/     EBD : (MACRO)             	Cretn
     803/     EBE :                     
     804/     EBE :                     _exit:
     805/     EBE : (MACRO)             	reserve 4
     806/     EC2 : (MACRO)             	st2 r12,'O',sp,(6); flag1 
     807/     ECF :                     ;void exit(int code){
     808/     ECF :                     ;	printf("exit %d\n",code);
     809/     ECF : (MACRO)             	ldaD R12,L89; reg:acon
     810/     ED5 : (MACRO)             	ld2 R13,'O',sp,(0+6) ;reg:INDIRI2(addr)
     811/     EE1 : (MACRO)             	Ccall _printf
     812/     EE4 :                     L90:
     813/     EE4 :                     ;	while(1);
     814/     EE4 :                     L91:
     815/     EE4 : C0 0E E4            	lbr L90
     816/     EE7 :                     ;}
     817/     EE7 :                     L88:
     818/     EE7 : (MACRO)             	release 4
     819/     EEB : (MACRO)             	Cretn
     820/     EEC :                     
     821/     EEC :                     _memcmp:
     822/     EEC : (MACRO)             	reserve 2; save room for local variables
     823/     EEE : (MACRO)             	pushr r0
     824/     EF3 : (MACRO)             	pushr r1
     825/     EF8 : (MACRO)             	pushr r7
     826/     EFD : (MACRO)             	reserve 0; save room for outgoing arguments
     827/     EFD : (MACRO)             	ld2 R7,'O',sp,(4+10); reg:INDIRU2(addr)
     828/     F09 :                     ;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
     829/     F09 :                     ;    int v = 0;
     830/     F09 : (MACRO)             	ld2z R1
     831/     F0D :                     ;    p1 = (unsigned char *)Ptr1;
     832/     F0D : (MACRO)             	cpy2 R0,R12 ;LOADP2(reg)
     833/     F11 :                     ;    p2 = (unsigned char *)Ptr2;
     834/     F11 : (MACRO)             	st2 R13,'O',sp,(-4+10); ASGNP2
     835/     F1E : C0 0F 6E            	lbr L95
     836/     F21 :                     L94:
     837/     F21 :                     ;    while(Count-- > 0 && v == 0) {
     838/     F21 :                     ;        v = *(p1++) - *(p2++);
     839/     F21 : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg)
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 15 - 4/12/2013 12:43:12


     840/     F25 : (MACRO)             	cpy2 R0,R11
     841/     F29 : (MACRO)             	incm R0,1
     842/     F2A : (MACRO)             	ld2 R10,'O',sp,(-4+10);reg:  INDIRP2(addr)
     843/     F36 : (MACRO)             	cpy2 R9,R10
     844/     F3A : (MACRO)             	incm R9,1
     845/     F3B : (MACRO)             	st2 R9,'O',sp,(-4+10); ASGNP2
     846/     F48 : (MACRO)             	ld1 R11,'O',R11,0
     847/     F52 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     848/     F55 : (MACRO)             	ld1 R10,'O',R10,0
     849/     F5F : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     850/     F62 : (MACRO)             	alu2 R1,R11,R10,sm,smb
     851/     F6E :                     ;    }
     852/     F6E :                     L95:
     853/     F6E :                     ;    while(Count-- > 0 && v == 0) {
     854/     F6E : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg)*
     855/     F72 : (MACRO)             	cpy2 R7,R11
     856/     F76 : (MACRO)             	decm R7,1
     857/     F77 : (MACRO)             	jeqU2I r11,0,L97;EQU2(reg,con)
     858/     F83 : (MACRO)             	jzU2 r1,L94; EQ 0
     859/     F8B :                     L97:
     860/     F8B :                     ;    return v;
     861/     F8B : (MACRO)             	cpy2 R15,R1 ;LOADI2(reg)*
     862/     F8F :                     L93:
     863/     F8F : (MACRO)             	release 0; release room for outgoing arguments
     864/     F8F : (MACRO)             	popr r7
     865/     F93 : (MACRO)             	popr r1
     866/     F97 : (MACRO)             	popr r0
     867/     F9B : (MACRO)             	release 2; release room for local variables 
     868/     F9D : (MACRO)             	Cretn
     869/     F9E :                     
     870/     F9E :                     _memcpy:
     871/     F9E : (MACRO)             	reserve 0; save room for local variables
     872/     F9E : (MACRO)             	pushr r0
     873/     FA3 : (MACRO)             	pushr r1
     874/     FA8 : (MACRO)             	pushr r7
     875/     FAD : (MACRO)             	reserve 0; save room for outgoing arguments
     876/     FAD : (MACRO)             	ld2 R7,'O',sp,(4+8); reg:INDIRU2(addr)
     877/     FB9 :                     ;void* memcpy(void* dest, const void* src, unsigned int count) {
     878/     FB9 :                     ;        char* dst8 = (char*)dest;
     879/     FB9 : (MACRO)             	cpy2 R1,R12 ;LOADP2(reg)
     880/     FBD :                     ;        char* src8 = (char*)src;
     881/     FBD : (MACRO)             	cpy2 R0,R13 ;LOADP2(reg)
     882/     FC1 : C0 0F DA            	lbr L100
     883/     FC4 :                     L99:
     884/     FC4 :                     ;        while (count--) {
     885/     FC4 :                     ;            *dst8++ = *src8++;
     886/     FC4 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     887/     FC8 : (MACRO)             	cpy2 R1,R11
     888/     FCC : (MACRO)             	incm R1,1
     889/     FCD : (MACRO)             	cpy2 R10,R0 ;LOADP2(reg)
     890/     FD1 : (MACRO)             	cpy2 R0,R10
     891/     FD5 : (MACRO)             	incm R0,1
     892/     FD6 : (MACRO)             	ldn1 R10,R10;reg:  INDIRU1(indaddr)
     893/     FD8 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     894/     FDA :                     ;        }
     895/     FDA :                     L100:
     896/     FDA :                     ;        while (count--) {
     897/     FDA : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg)*
     898/     FDE : (MACRO)             	cpy2 R7,R11
     899/     FE2 : (MACRO)             	decm R7,1
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 16 - 4/12/2013 12:43:12


     900/     FE3 : (MACRO)             	jnzU2 r11,L99; NE 0
     901/     FEB :                     ;        return dest;
     902/     FEB : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
     903/     FEF :                     L98:
     904/     FEF : (MACRO)             	release 0; release room for outgoing arguments
     905/     FEF : (MACRO)             	popr r7
     906/     FF3 : (MACRO)             	popr r1
     907/     FF7 : (MACRO)             	popr r0
     908/     FFB : (MACRO)             	release 0; release room for local variables 
     909/     FFB : (MACRO)             	Cretn
     910/     FFC :                     
     911/     FFC :                     _memset:
     912/     FFC : (MACRO)             	reserve 0; save room for local variables
     913/     FFC : (MACRO)             	pushr r1
     914/    1001 : (MACRO)             	pushr r7
     915/    1006 : (MACRO)             	reserve 0; save room for outgoing arguments
     916/    1006 : (MACRO)             	ld2 R7,'O',sp,(4+6); reg:INDIRU2(addr)
     917/    1012 :                     ;{
     918/    1012 :                     ;    unsigned char* p=s;
     919/    1012 : (MACRO)             	cpy2 R1,R12 ;LOADP2(reg)
     920/    1016 : C0 10 28            	lbr L104
     921/    1019 :                     L103:
     922/    1019 :                     ;        *p++ = (unsigned char)c;
     923/    1019 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     924/    101D : (MACRO)             	cpy2 R1,R11
     925/    1021 : (MACRO)             	incm R1,1
     926/    1022 : (MACRO)             	cpy2 R10,R13 ;LOADU2(reg)*
     927/    1026 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     928/    1028 :                     L104:
     929/    1028 :                     ;    while(n--)
     930/    1028 : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg)*
     931/    102C : (MACRO)             	cpy2 R7,R11
     932/    1030 : (MACRO)             	decm R7,1
     933/    1031 : (MACRO)             	jnzU2 r11,L103; NE 0
     934/    1039 :                     ;    return s;
     935/    1039 : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
     936/    103D :                     L102:
     937/    103D : (MACRO)             	release 0; release room for outgoing arguments
     938/    103D : (MACRO)             	popr r7
     939/    1041 : (MACRO)             	popr r1
     940/    1045 : (MACRO)             	release 0; release room for local variables 
     941/    1045 : (MACRO)             	Cretn
     942/    1046 :                     
     943/    1046 :                     L89:
     944/    1046 : 65                  	db 101
     945/    1047 : 78                  	db 120
     946/    1048 : 69                  	db 105
     947/    1049 : 74                  	db 116
     948/    104A : 20                  	db 32
     949/    104B : 25                  	db 37
     950/    104C : 64                  	db 100
     951/    104D : 0A                  	db 10
     952/    104E : 00                  	db 0
     953/    104F :                     	align 4
     954/    1050 :                     L27:
     955/    1050 : BF 80 00 00         	dd 0xbf800000
     956/    1054 :                     	align 4
     957/    1054 :                     L26:
     958/    1054 : 00 00 00 00         	dd 0x0
     959/    1058 :                     L9:
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 17 - 4/12/2013 12:43:12


     960/    1058 : 66                  	db 102
     961/    1059 : 61                  	db 97
     962/    105A : 63                  	db 99
     963/    105B : 74                  	db 116
     964/    105C : 28                  	db 40
     965/    105D : 25                  	db 37
     966/    105E : 6C                  	db 108
     967/    105F : 64                  	db 100
     968/    1060 : 29                  	db 41
     969/    1061 : 3D                  	db 61
     970/    1062 : 25                  	db 37
     971/    1063 : 6C                  	db 108
     972/    1064 : 64                  	db 100
     973/    1065 : 0A                  	db 10
     974/    1066 : 00                  	db 0
     975/    1067 :                     	include lcc1802Epilofl.inc
(1)    1/    1067 :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/    1067 :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/    1067 :                     ;this is the version published with the lcc1802121229 release
(1)    4/    1067 :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/    1067 :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/    1067 :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/    1067 :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/    1067 :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/    1067 :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/    1067 :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/    1067 :                     ;feb 27 changed stack to start at 7fff
(1)   12/    1067 :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/    1067 :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/    1067 :                     ;april 4 adding digit count argument to dubdabx
(1)   15/    1067 :                     
(1)   16/    1067 : =EH                 rwork	equ	memAddr	;work register
(1)   17/    1067 :                     lcc1802init:	
(1)   18/    1067 : (MACRO)             	ldiReg	RCALL,_call
(1)   19/    106D : (MACRO)             	ldiReg	RRET,_return
(1)   20/    1073 : (MACRO)             	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1
(1)   21/    1079 : E2                  	sex	SP
(1)   22/    107A : (MACRO)             	ldiReg	RPC,$$_00000
(1)   23/    1080 : D3                  	sep	RPC
(1)   24/    1081 :                     $$_00000:
(1)   25/    1081 : (MACRO)             	Ccall _main	;call the main routine
(1)   26/    1084 : C0 10 84            $$_die:	lbr	$$_die		;loop here when main returns
(1)   27/    1087 : DE AD               	db	0xde,0xad
(1)   28/    1089 :                     
(1)   29/    1089 :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   30/    1089 :                     _setqOn:
(1)   31/    1089 : 7B                  	seq
(1)   32/    108A : (MACRO)             	Cretn
(1)   33/    108B :                     _setqOff:
(1)   34/    108B : 7A                  	req
(1)   35/    108C : (MACRO)             	Cretn
(1)   36/    108D :                     
(1)   37/    108D :                     _modU2:	;16 bit unsigned remainder
(1)   38/    108D :                     	; just calls the 16 bit division then puts remainder into return value
(1)   39/    108D : (MACRO)                 Ccall _divU2
(1)   40/    1090 : 8D                      glo regArg2
(1)   41/    1091 : AF                      plo retVal
(1)   42/    1092 : 9D                      ghi regArg2
(1)   43/    1093 : BF                      phi retVal
(1)   44/    1094 : (MACRO)                 Cretn
 AS V1.42 Beta [Bld 87] - source file factorial.asm(lcc1802Epilofl.inc) - page 18 - 4/12/2013 12:43:12


(1)   45/    1095 :                         
(1)   46/    1095 :                     _modI2:	;16 bit signed remainder
(1)   47/    1095 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   48/    1095 : (MACRO)                 Ccall _divI2
(1)   49/    1098 : 8D                      glo regArg2
(1)   50/    1099 : AF                      plo retVal
(1)   51/    109A : 9D                      ghi regArg2
(1)   52/    109B : BF                      phi retVal
(1)   53/    109C : (MACRO)                 Cretn
(1)   54/    109D :                     
(1)   55/    109D :                     _out4:	
(1)   56/    109D : 8C                  	glo	regArg1
(1)   57/    109E : 22                  	dec	sp
(1)   58/    109F : 52                  	str	sp
(1)   59/    10A0 : 64                  	out	4
(1)   60/    10A1 : (MACRO)             	Cretn
(1)   61/    10A2 :                     
(1)   62/    10A2 :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   63/    10A2 :                     	align 256
(1)   64/    1100 :                     ;non-standard Call routine invoked as D4xxxx - using z80 stack convention
(1)   65/    1100 :                     ;requires programs to save the return address if they destroy it (by using call for example)
(1)   66/    1100 :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)   67/    1100 : D3                  	sep     R3 ;go to subroutine
(1)   68/    1101 : E2                  _call	sex	SP ;make sure X=SP
(1)   69/    1102 : 86                  	glo	retAddr ;save previous return pointer on stack
(1)   70/    1103 : 22                  	dec	sp
(1)   71/    1104 : 73                  	stxd
(1)   72/    1105 : 96                  	ghi	retAddr
(1)   73/    1106 : 52                  	str	sp	
(1)   74/    1107 : 83                  	glo	RPC ;copy old PC to retAddr
(1)   75/    1108 : A6                  	plo	retAddr
(1)   76/    1109 : 93                  	ghi	RPC
(1)   77/    110A : B6                  	phi	retAddr
(1)   78/    110B : 46                  	lda	retAddr ;pick up subroutine address into RPC
(1)   79/    110C : B3                  	phi	RPC
(1)   80/    110D : 46                  	lda	retAddr
(1)   81/    110E : A3                  	plo	RPC
(1)   82/    110F : 30 00               	br	_call-1
(1)   83/    1111 :                     
(1)   84/    1111 :                     ;Standard subroutine return 
(1)   85/    1111 : D3                  	sep	RPC	;return to the original program
(1)   86/    1112 : 86                  _return	glo	retAddr	;transfer the current return address to RPC
(1)   87/    1113 : A3                  	plo	RPC
(1)   88/    1114 : 96                  	ghi	retAddr
(1)   89/    1115 : B3                  	phi	RPC
(1)   90/    1116 : 42                  	lda	SP	;pick up old return address
(1)   91/    1117 : B6                  	phi	retAddr
(1)   92/    1118 : 42                  	lda	SP
(1)   93/    1119 : A6                  	plo	retAddr
(1)   94/    111A : 30 11               	br	_return-1
(1)   95/    111C :                     
(1)   96/    111C :                     _oneMs:		;execute 100 instructions including call(15)/return(10) sequence. takes about 1 ms
(1)   97/    111C : F8 24               	ldi	(100-15-10-2)/2
(1)   98/    111E : FF 01               $$mslp:	smi	1
(1)   99/    1120 : 3A 1E               	bnz	$$mslp
(1)  100/    1122 : (MACRO)             	Cretn
(1)  101/    1123 :                     
(1)  102/    1123 :                     
(1)  103/    1123 :                     	
(1)  104/    1123 :                     ;16 bit unsigned multiply thanks to Ted Rossin!
 AS V1.42 Beta [Bld 87] - source file factorial.asm(lcc1802Epilofl.inc) - page 19 - 4/12/2013 12:43:12


(1)  105/    1123 :                     ;retVal=regArg1*regArg2. uses register rwork as a work regitsr
(1)  106/    1123 :                     _mulu2:		
(1)  107/    1123 : 22                      dec sp
(1)  108/    1124 : F8 10                   ldi 16
(1)  109/    1126 : AE                      plo	rwork	;bit count
(1)  110/    1127 : F8 00                   ldi 0
(1)  111/    1129 : BF                      phi	retVal	;quotient
(1)  112/    112A : AF                      plo retVal
(1)  113/    112B :                     $$MultLoop16_16:
(1)  114/    112B : 9C                      ghi regArg1
(1)  115/    112C : F6                      shr
(1)  116/    112D : BC                      phi regArg1
(1)  117/    112E : 8C                      glo regArg1
(1)  118/    112F : 76                      shrc
(1)  119/    1130 : AC                      plo regArg1
(1)  120/    1131 : 3B 3D                   bnf $$MultSkip16_16
(1)  121/    1133 : 8D                      glo regArg2
(1)  122/    1134 : 52                      str sp
(1)  123/    1135 : 8F                      glo retVal
(1)  124/    1136 : F4                      add 
(1)  125/    1137 : AF                      plo retVal
(1)  126/    1138 : 9D                      ghi regArg2
(1)  127/    1139 : 52                      str sp
(1)  128/    113A : 9F                      ghi retVal
(1)  129/    113B : 74                      adc
(1)  130/    113C : BF                      phi retVal
(1)  131/    113D :                     $$MultSkip16_16:
(1)  132/    113D : 8D                      glo regArg2
(1)  133/    113E : FE                      shl
(1)  134/    113F : AD                      plo regArg2
(1)  135/    1140 : 9D                      ghi regArg2
(1)  136/    1141 : 7E                      shlc
(1)  137/    1142 : BD                      phi regArg2
(1)  138/    1143 : 2E                      dec rwork
(1)  139/    1144 : 8E                      glo rwork
(1)  140/    1145 : 3A 2B                   bnz $$MultLoop16_16
(1)  141/    1147 : 12                      inc sp
(1)  142/    1148 : D5                      sep 5
(1)  143/    1149 :                     
(1)  144/    1149 :                     
(1)  145/    1149 :                     _divU2:
(1)  146/    1149 :                     	; retVal = regArg1/regArg2  (remainder in regArg1)
(1)  147/    1149 :                     	; This is really an unsigned 23 bit divide
(1)  148/    1149 :                     	;thanks to Ted Rossin
(1)  149/    1149 :                     	;bodged Dec 12 to shuffle registers at the end.
(1)  150/    1149 : 22                      dec sp
(1)  151/    114A : F8 10                   ldi 16
(1)  152/    114C : AE                      plo rwork
(1)  153/    114D : F8 00                   ldi 0
(1)  154/    114F : BF                      phi retVal
(1)  155/    1150 : AF                      plo retVal
(1)  156/    1151 : BE                      phi rwork
(1)  157/    1152 :                     $$DivLoop16_16:
(1)  158/    1152 : 8C                      glo regArg1
(1)  159/    1153 : FE                      shl
(1)  160/    1154 : AC                      plo regArg1
(1)  161/    1155 : 9C                      ghi regArg1
(1)  162/    1156 : 7E                      shlc
(1)  163/    1157 : BC                      phi regArg1
(1)  164/    1158 : 8F                      glo retVal
 AS V1.42 Beta [Bld 87] - source file factorial.asm(lcc1802Epilofl.inc) - page 20 - 4/12/2013 12:43:12


(1)  165/    1159 : 7E                      shlc
(1)  166/    115A : AF                      plo retVal
(1)  167/    115B : 9F                      ghi retVal
(1)  168/    115C : 7E                      shlc
(1)  169/    115D : BF                      phi retVal
(1)  170/    115E : 9E                      ghi rwork
(1)  171/    115F : 7E                      shlc
(1)  172/    1160 : BE                      phi rwork
(1)  173/    1161 : 3B 73                   bnf $$DivSub16_16
(1)  174/    1163 : 8D                      glo regArg2
(1)  175/    1164 : 52                      str sp
(1)  176/    1165 : 8F                      glo retVal
(1)  177/    1166 : F4                      add 
(1)  178/    1167 : AF                      plo retVal
(1)  179/    1168 : 9D                      ghi regArg2
(1)  180/    1169 : 52                      str sp
(1)  181/    116A : 9F                      ghi retVal
(1)  182/    116B : 74                      adc 
(1)  183/    116C : BF                      phi retVal
(1)  184/    116D : 9E                      ghi rwork
(1)  185/    116E : 7C 00                   adci 0
(1)  186/    1170 : BE                      phi rwork
(1)  187/    1171 : 30 81                   br $$DivSkip16_16
(1)  188/    1173 :                     $$DivSub16_16:
(1)  189/    1173 : 8D                      glo regArg2
(1)  190/    1174 : 52                      str sp
(1)  191/    1175 : 8F                      glo retVal
(1)  192/    1176 : F7                      sm
(1)  193/    1177 : AF                      plo retVal
(1)  194/    1178 : 9D                      ghi regArg2
(1)  195/    1179 : 52                      str sp
(1)  196/    117A : 9F                      ghi retVal
(1)  197/    117B : 77                      smb 
(1)  198/    117C : BF                      phi retVal
(1)  199/    117D : 9E                      ghi rwork
(1)  200/    117E : 7F 00                   smbi 0
(1)  201/    1180 : BE                      phi rwork 
(1)  202/    1181 :                     $$DivSkip16_16:
(1)  203/    1181 : FE                      shl
(1)  204/    1182 : 33 88                   bdf $$DivSkipClear16_16
(1)  205/    1184 :                     $$DivSetBit16_16:
(1)  206/    1184 : 8C                      glo regArg1
(1)  207/    1185 : F9 01                   ori  0x01
(1)  208/    1187 : AC                      plo regArg1
(1)  209/    1188 :                     $$DivSkipClear16_16:
(1)  210/    1188 : 2E                      dec rwork
(1)  211/    1189 : 8E                      glo rwork
(1)  212/    118A : 3A 52                   bnz $$DivLoop16_16
(1)  213/    118C : 9E                      ghi rwork
(1)  214/    118D : FE                      shl
(1)  215/    118E : 3B 9A                   bnf $$DivSkipFinalAdd16_16
(1)  216/    1190 : 8D                      glo regArg2
(1)  217/    1191 : 52                      str sp
(1)  218/    1192 : 8F                      glo retVal
(1)  219/    1193 : F4                      add
(1)  220/    1194 : AF                      plo retVal
(1)  221/    1195 : 9D                      ghi regArg2
(1)  222/    1196 : 52                      str sp
(1)  223/    1197 : 9F                      ghi retVal
(1)  224/    1198 : 74                      adc
 AS V1.42 Beta [Bld 87] - source file factorial.asm(lcc1802Epilofl.inc) - page 21 - 4/12/2013 12:43:12


(1)  225/    1199 : BF                      phi retVal
(1)  226/    119A :                     $$DivSkipFinalAdd16_16:
(1)  227/    119A : 12                      inc sp
(1)  228/    119B :                     ;here I have the quotient in regArg1 and remainder in retVal
(1)  229/    119B : 8F                      glo retVal
(1)  230/    119C : AD                      plo regArg2
(1)  231/    119D : 9F                      ghi retVal
(1)  232/    119E : BD                      phi regArg2
(1)  233/    119F : 8C                      glo regArg1
(1)  234/    11A0 : AF                      plo retVal
(1)  235/    11A1 : 9C                      ghi regArg1
(1)  236/    11A2 : BF                      phi retVal
(1)  237/    11A3 :                         ;return with quotient in retVal and remainder in regArg2
(1)  238/    11A3 : D5                      sep 5
(1)  239/    11A4 :                     
(1)  240/    11A4 :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  241/    11A4 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  242/    11A4 :                     _divI2:
(1)  243/    11A4 :                         ;pushr retAddr	;save the return address NG doesnot need
(1)  244/    11A4 : 22                      dec	sp	;leave a work area available
(1)  245/    11A5 : 9C                      ghi regArg1
(1)  246/    11A6 : 52                      str sp	;save the sign of the 1st arg
(1)  247/    11A7 : FE                      shl
(1)  248/    11A8 : 3B B3                   bnf $$pos1	;if the 1st arg is -v
(1)  249/    11AA : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
(1)  250/    11B3 :                     $$pos1: ;1st is now +v, check 2nd
(1)  251/    11B3 : 9D                      ghi regArg2
(1)  252/    11B4 : F3                      xor	
(1)  253/    11B5 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  254/    11B6 : 9D                      ghi regArg2
(1)  255/    11B7 : FE                      shl
(1)  256/    11B8 : 3B C3                   bnf $$pos2	;if the 2nd arg is -v
(1)  257/    11BA : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  258/    11C3 :                     $$pos2: ; both args now +v
(1)  259/    11C3 : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  260/    11C6 :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  261/    11C6 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  262/    11C7 : FE                      shl
(1)  263/    11C8 : 3B D3                   bnf $$done ;if the signs were different
(1)  264/    11CA : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  265/    11D3 :                     $$done:
(1)  266/    11D3 :                         ;popr RetAddr ;restore the return address NG doesnot need
(1)  267/    11D3 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  268/    11D4 :                     
(1)  269/    11D4 :                     
(1)  270/    11D4 :                     	align 256    ;32 bit operations follow
(1)  271/    1200 :                     _divu4:
(1)  272/    1200 :                     ;This is an unsigned 32 bit restoring division
(1)  273/    1200 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  274/    1200 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  275/    1200 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  276/    1200 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  277/    1200 :                     
(1)  278/    1200 : F8 20               	ldi 32		;set loop count
(1)  279/    1202 : AE                  	plo memaddr	;in temp register
(1)  280/    1203 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  281/    120F :                     $$loop:
(1)  282/    120F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  283/    121B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  284/    1227 :                     
 AS V1.42 Beta [Bld 87] - source file factorial.asm(lcc1802Epilofl.inc) - page 22 - 4/12/2013 12:43:12


(1)  285/    1227 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  286/    123D :                     
(1)  287/    123D : FA 80               	ani 0x80	;check the top bit
(1)  288/    123F : 32 5D               	bz $$norestore	;if it's 0
(1)  289/    1241 : 89                  		glo RL8
(1)  290/    1242 : FA FE               		ani 0xfe	;turn off the bottom bit
(1)  291/    1244 : A9                  		plo RL8
(1)  292/    1245 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  293/    125B : 30 61               	br $$endlp 	;else
(1)  294/    125D :                     $$norestore:
(1)  295/    125D : 89                  		glo RL8
(1)  296/    125E : F9 01               		ori 1	;turn on the bottom bit
(1)  297/    1260 : A9                  		plo RL8
(1)  298/    1261 :                     	;end if
(1)  299/    1261 :                     $$endlp:
(1)  300/    1261 : 2E                  	dec memaddr	;check the cycle count
(1)  301/    1262 : 8E                  	glo memaddr
(1)  302/    1263 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  303/    1265 :                     	
(1)  304/    1265 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  305/    1266 :                     		
(1)  306/    1266 :                     
(1)  307/    1266 :                     _mulu4:
(1)  308/    1266 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  309/    1266 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  310/    1266 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  311/    1266 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  312/    1266 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  313/    1266 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  314/    1266 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  315/    1266 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  316/    1266 :                     	;for 10 we subtract and shift
(1)  317/    1266 :                     	;for 00 and 11 we just shift
(1)  318/    1266 :                     
(1)  319/    1266 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  320/    1272 : F8 20                   ldi 32
(1)  321/    1274 : AE                      plo memaddr		;cycle count
(1)  322/    1275 : FC 00                   adi 0		;clear df
(1)  323/    1277 :                     $$mloop:
(1)  324/    1277 : 89                      glo RL8
(1)  325/    1278 : FA 01                   ani 1		;isolate bottom bit of result
(1)  326/    127A : 3B 96                   bnf	$$check_sub	;
(1)  327/    127C : 3A AE                   bnz	$$shift		;that would be the 11 case
(1)  328/    127E :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  329/    127E : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  330/    1294 : 30 AE                   br $$shift
(1)  331/    1296 :                     $$check_sub:
(1)  332/    1296 : 32 AE                   bz $$shift	;that would be the 00 case
(1)  333/    1298 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  334/    1298 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  335/    12AE :                     $$shift:
(1)  336/    12AE : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  337/    12BC : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  338/    12C8 :                     
(1)  339/    12C8 : 2E                      dec memaddr		;cycle count
(1)  340/    12C9 : 8E                      glo memaddr
(1)  341/    12CA : 3A 77                   bnz $$mloop		;repeat cycle once for each bit position
(1)  342/    12CC :                         
(1)  343/    12CC : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  344/    12CD :                     
 AS V1.42 Beta [Bld 87] - source file factorial.asm(lcc1802Epilofl.inc) - page 23 - 4/12/2013 12:43:12


(1)  345/    12CD :                     	align 256
(1)  346/    1300 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  347/    1300 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  348/    1300 :                     _divI4:
(1)  349/    1300 : 22                      dec	sp	;leave a work area available
(1)  350/    1301 : 98                      ghi RL8-1	;get the top of the dividend
(1)  351/    1302 : 52                      str sp	;save the sign of the 1st arg
(1)  352/    1303 : FE                      shl
(1)  353/    1304 : 3B 26                   bnf $$pos1	;if the 1st arg is -v
(1)  354/    1306 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  355/    1326 :                     $$pos1: ;1st is now +v, check 2nd
(1)  356/    1326 : 9A                      ghi RL10-1
(1)  357/    1327 : F3                      xor	
(1)  358/    1328 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  359/    1329 : 9A                      ghi RL10-1
(1)  360/    132A : FE                      shl
(1)  361/    132B : 3B 4D                   bnf $$pos2	;if the 2nd arg is -v
(1)  362/    132D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  363/    134D :                     $$pos2: ; both args now +v
(1)  364/    134D : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  365/    1350 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  366/    1350 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  367/    1351 : FE                      shl
(1)  368/    1352 : 3B 74                   bnf $$done ;if the signs were different
(1)  369/    1354 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  370/    1374 :                     $$done:
(1)  371/    1374 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  372/    1375 :                     
(1)  373/    1375 :                     _dubdabx:	
(1)  374/    1375 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  375/    1375 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  376/    1375 :                     ;long interger is passed in rp1p2
(1)  377/    1375 :                     ;buffer pointer is passed at sp+2+4
(1)  378/    1375 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
(1)  379/    1375 :                     ;r8-11 are used as temps
(1)  380/    1375 :                     ;r8 is the working pointer
(1)  381/    1375 :                     ;r15.0 is bit count(32) and the return value register
(1)  382/    1375 :                     ;r9.0 is digit count
(1)  383/    1375 :                     ;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
(1)  384/    1375 : (MACRO)             	ld2 r8,'O',sp,(2+4); pick up the buffer pointer
(1)  385/    1381 : (MACRO)             	ld2 r10,'O',sp,(2+4+2); pick up the number of digits wanted
(1)  386/    138D : (MACRO)             	cpy2 r15,r8 ;save address for now
(1)  387/    1391 : F8 0B               	ldi 11	;digit count+1 for trailing 0
(1)  388/    1393 : A9                  	plo r9
(1)  389/    1394 :                     $$clrlp:	;clear the passed buffer
(1)  390/    1394 : F8 00               	ldi 0	
(1)  391/    1396 : 58                  	str r8	;clear a byte
(1)  392/    1397 : 18                  	inc r8
(1)  393/    1398 : 29                  	dec r9
(1)  394/    1399 : 89                  	glo r9	;check the count
(1)  395/    139A : 3A 94               	bnz $$clrlp ;back for more
(1)  396/    139C : (MACRO)             	cpy2 r8,r15 ;get the address back
(1)  397/    13A0 :                     
(1)  398/    13A0 : F8 20               	ldi 32	;bit count
(1)  399/    13A2 : AF                  	plo r15
(1)  400/    13A3 :                     ;now i'm going to spin off any leading 0's in the binary number
(1)  401/    13A3 :                     $$cktop:
(1)  402/    13A3 : 9C                  	ghi rp1p2-1	;get the top bit of the number
(1)  403/    13A4 : FE                  	shl		;check for a 1
(1)  404/    13A5 : 33 B8               	bdf $$bitloop	;move on if we have one
 AS V1.42 Beta [Bld 87] - source file factorial.asm(lcc1802Epilofl.inc) - page 24 - 4/12/2013 12:43:12


(1)  405/    13A7 : (MACRO)             	shl4 rp1p2	;shift the input number
(1)  406/    13B3 : 2F                  	dec r15		;reduce the number of times to shift
(1)  407/    13B4 : 8F                  	glo r15
(1)  408/    13B5 : 3A A3               	bnz $$cktop	;
(1)  409/    13B7 : 1F                  	inc r15		;our whole number was 0 but force at least one pass
(1)  410/    13B8 :                     $$bitloop:
(1)  411/    13B8 : F8 0A               	ldi 10	;digit count
(1)  412/    13BA : A9                  	plo r9
(1)  413/    13BB :                     $$dcklp:
(1)  414/    13BB : 08                  	ldn r8 	;pick up a digit
(1)  415/    13BC : FF 05               	smi 5	;see if it's greater than 4
(1)  416/    13BE : 3B C3               	bnf $$dnoadd ;if not, bypass add
(1)  417/    13C0 : FC 08               	adi 0x08	;add the 5 black and 3 more
(1)  418/    13C2 : 58                  	str r8	;put it back
(1)  419/    13C3 :                     $$dnoadd:
(1)  420/    13C3 : 18                  	inc r8
(1)  421/    13C4 : 29                  	dec r9	;decrement digit count
(1)  422/    13C5 : 89                  	glo r9
(1)  423/    13C6 : 3A BB               	bnz $$dcklp ;and back for next digit
(1)  424/    13C8 :                     	
(1)  425/    13C8 : (MACRO)             	shl4 rp1p2 ;shift the input number
(1)  426/    13D4 :                     	
(1)  427/    13D4 : F8 0A               	ldi 10	;load the digit count again
(1)  428/    13D6 : A9                  	plo r9
(1)  429/    13D7 :                     ;r8 is now just past the units location and ready to walk back
(1)  430/    13D7 :                     $$dshlp:
(1)  431/    13D7 : 28                  	dec r8	;walk back from 0's position
(1)  432/    13D8 : 08                  	ldn r8	;get the digit back
(1)  433/    13D9 : 7E                  	shlc	;continue the shift
(1)  434/    13DA : BF                  	phi r15 ;save it for the carry test
(1)  435/    13DB : FA 0F               	ani 0x0f ;clear the 10 bit
(1)  436/    13DD : 58                  	str r8	;put the digit back
(1)  437/    13DE : 9F                  	ghi r15	;now test for carry
(1)  438/    13DF : FF 10               	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  439/    13E1 : 29                  	dec r9	;decrement the digit count
(1)  440/    13E2 : 89                  	glo r9
(1)  441/    13E3 : 3A D7               	bnz $$dshlp ;back for more if needed
(1)  442/    13E5 :                     	
(1)  443/    13E5 : 2F                  	dec r15
(1)  444/    13E6 : 8F                  	glo r15
(1)  445/    13E7 : 3A B8               	bnz $$bitloop
(1)  446/    13E9 :                     	
(1)  447/    13E9 : (MACRO)             	cpy2 r15,r8	;save the starting location of the digits
(1)  448/    13ED : F8 0A               	ldi 10		;digit count again
(1)  449/    13EF : A9                  	plo r9
(1)  450/    13F0 :                     $$upnxt:
(1)  451/    13F0 : 08                  	ldn r8		;get digit
(1)  452/    13F1 : F9 30               	ori 0x30	;make ascii
(1)  453/    13F3 : 58                  	str r8		;put it back
(1)  454/    13F4 : 18                  	inc r8		;next digit
(1)  455/    13F5 : 29                  	dec r9		;counter
(1)  456/    13F6 : 89                  	glo r9
(1)  457/    13F7 : 3A F0               	bnz $$upnxt	;upgrade all 10 spots
(1)  458/    13F9 :                     	
(1)  459/    13F9 : (MACRO)             	ldaX memaddr,sp,(2+4+2+1)	;point to lsb of desired digit count
(1)  460/    1401 : EE                  	sex memaddr	;set up
(1)  461/    1402 : F8 0A               	ldi 10		;max number of 0's to skip
(1)  462/    1404 : F7                  	sm		;desired number of digits to skip
(1)  463/    1405 : E2                  	sex sp		;reset index register
(1)  464/    1406 : A9                  	plo r9		;number of leading 0's to skip
 AS V1.42 Beta [Bld 87] - source file factorial.asm(lcc1802Epilofl.inc) - page 25 - 4/12/2013 12:43:12


(1)  465/    1407 :                     $$cknext:
(1)  466/    1407 : 0F                  	ldn r15		;check digit
(1)  467/    1408 : FF 30               	smi 0x30	;for '0'
(1)  468/    140A : 3A 11               	bnz $$done
(1)  469/    140C : 1F                  	inc r15		;next digit
(1)  470/    140D : 29                  	dec r9		;reduce count
(1)  471/    140E : 89                  	glo r9
(1)  472/    140F : 3A 07               	bnz $$cknext
(1)  473/    1411 :                     $$done:
(1)  474/    1411 : (MACRO)             	cretn
(1)  475/    1412 :                     	
(1)  476/    1412 :                     	
(1)  477/    1412 :                     _modU4:	;32 bit unsigned remainder
(1)  478/    1412 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  479/    1412 : (MACRO)                 Ccall _divU4
(1)  480/    1415 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  481/    141D : (MACRO)                 Cretn
(1)  482/    141E :                         
(1)  483/    141E :                     _modI4:	;32 bit signed remainder
(1)  484/    141E :                     	; just calls the 32 bit division then puts remainder into return value
(1)  485/    141E : (MACRO)                 Ccall _divI4
(1)  486/    1421 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  487/    1429 : (MACRO)                 Cretn
(1)  488/    142A :                         
(1)  489/    142A :                     	
(1)  490/    142A :                      
     976/    142A :                     	include LCC1802fp.inc
(1)    1/    142A :                     ;from http://www.elf-emulation.com/software/fp.asm - thanks to mike Reilley
(1)    2/    142A :                     ;maybe originally from RCA
(1)    3/    142A :                     ;these routines use ALL the registers from 6-15!
(1)    4/    142A :                     ;8-15 were more or less available to start with
(1)    5/    142A :                     ;it saves 6 when it uses it
(1)    6/    142A :                     ;I save 7 on entry and restore on exit
(1)    7/    142A :                     ;to keep my sanity I renamed some register equates where I was changing them e.g. F7 used to be RB
(1)    8/    142A : =BH                 FB	equ	11	;was R9
(1)    9/    142A : =9H                 F9	equ	9	;was R7
(1)   10/    142A : =7H                 F7	equ	7	;was RB
(1)   11/    142A :                     ;April 1 added code to fp_add to restore resgisters when returning a 0 - around add_nz:
(1)   12/    142A :                     ; *** Convert signed long to float
(1)   13/    142A :                     ; *** RL8-1:RL8 is the number to convert(8:9)
(1)   14/    142A :                     ; *** result in same register
(1)   15/    142A :                     ; *** uses memaddr.1 for sign, .0 for shift count/exponent
(1)   16/    142A :                     	align 256
(1)   17/    1500 : F8 00               cvif4:	ldi	0
(1)   18/    1502 : BE                  	phi	memaddr	;sign
(1)   19/    1503 : F8 96               	ldi	150	;150 is  the 127 exponent bias plus the 23 required to shift a long 1 to bit 23
(1)   20/    1505 : AE                  	plo	memaddr	;
(1)   21/    1506 : 98                  	ghi	RL8-1	;get sign and bits 7-1 of exponent
(1)   22/    1507 : 32 30               	bz	$$nxt	;keep testing for 0
(1)   23/    1509 : FE                  	shl		;sign bit to df
(1)   24/    150A : 3B 39               	bnf	$$sgnpos ;number is >0
(1)   25/    150C : 76                  	shrc		;shift it back so we know byte is non-zerro
(1)   26/    150D : BE                  	phi	memaddr	;save it
(1)   27/    150E : (MACRO)             	negi4	RL8,RL8	;flip the number
(1)   28/    152E : 30 39               	br	$$sgnpos ;go handle positive long
(1)   29/    1530 : 88                  $$nxt:	glo	RL8-1	;next byte
(1)   30/    1531 : 3A 39               	bnz	$$sgnpos ;sign is positive, number is not 0
(1)   31/    1533 : 99                  	ghi	RL8	;next byte
(1)   32/    1534 : 3A 39               	bnz	$$sgnpos ;sign is positive, number is not 0
(1)   33/    1536 : 89                  	glo	RL8	;last byte
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 26 - 4/12/2013 12:43:12


(1)   34/    1537 : 32 6F               	bz	$$done	;the whole thing is zero so we're done
(1)   35/    1539 : 98                  $$sgnpos: ghi	RL8-1	;top byte - begin shifting right to clear it
(1)   36/    153A : 32 4B               	bz	$$shl	;if it's zero we're done right shifting
(1)   37/    153C : 1E                  	inc	memaddr	;increase exponent 1 for each right shift
(1)   38/    153D : (MACRO)             	shru4	RL8
(1)   39/    1549 : 30 39               	br	$$sgnpos
(1)   40/    154B : 88                  $$shl:	glo	RL8-1	;check bit 23
(1)   41/    154C : FA 80               	ani	0x80	;isolate it
(1)   42/    154E : 3A 5F               	bnz	$$shdn	;if it's on we're done here
(1)   43/    1550 : 2E                  	dec	memaddr	;decrease exponent 1 for each left shift
(1)   44/    1551 : (MACRO)             	shl4	RL8	;shift mantissa left one
(1)   45/    155D : 30 4B               	br	$$shl
(1)   46/    155F : 8E                  $$shdn:	glo	memaddr	;get the exponent
(1)   47/    1560 : F6                  	shr		;shift right so it can go into bits 31-24
(1)   48/    1561 : B8                  	phi	RL8-1	;put top bits of exponent into place
(1)   49/    1562 : 33 68               	bdf	$$setsgn ;if the bit 0 is on we're done
(1)   50/    1564 : 88                  	glo	RL8-1	;get the byte
(1)   51/    1565 : FA 7F               	ani	0x7f	;clear bit 23
(1)   52/    1567 : A8                  	plo	RL8-1	;put it back
(1)   53/    1568 : 9E                  $$setsgn: ghi	memaddr	;get the original sign byte
(1)   54/    1569 : 32 6F               	bz	$$done	;sign bit is already zero so we're done
(1)   55/    156B : 98                  	ghi	RL8-1	;get the sign byte
(1)   56/    156C : F9 80               	ori	0x80	;set the sign bit
(1)   57/    156E : B8                  	phi	RL8-1	;place it
(1)   58/    156F : (MACRO)             $$done:	Cretn		;and we're done
(1)   59/    1570 :                     	
(1)   60/    1570 :                     
(1)   61/    1570 :                     
(1)   62/    1570 :                     ; *** Convert float to signed long
(1)   63/    1570 :                     ; *** RL8-1:RL8 is the number to convert(8:9)
(1)   64/    1570 :                     ; *** result in same register
(1)   65/    1570 :                     	align 256
(1)   66/    1600 :                     cvfi4:
(1)   67/    1600 : 98                  	ghi	RL8-1	;get sign and bits 7-1 of exponent
(1)   68/    1601 : BE                  	phi	memaddr ;save for later
(1)   69/    1602 : 88                  	glo	RL8-1	;get bit 0 of exponent
(1)   70/    1603 : FE                  	shl		;shift to df
(1)   71/    1604 : 9E                  	ghi	memaddr	;get exponent 7-1
(1)   72/    1605 : 7E                  	shlc		;combine with 0
(1)   73/    1606 :                     ;the following sequence is equivalent to sdi 150; I did it this way to coddle my emulator which doesn't do this properly.
(1)   74/    1606 : 22                  	dec	sp
(1)   75/    1607 : 52                  	str	sp
(1)   76/    1608 : F8 96               	ldi	150
(1)   77/    160A : F7                  	sm		;calculate shift count needed
(1)   78/    160B :                     ;*******note - the df flag set here is tested later
(1)   79/    160B : AE                  	plo	memaddr
(1)   80/    160C : 12                  	inc	sp	;release work area
(1)   81/    160D :                     ;end of sdi 150 sequence - now convert the mantissa to unsigned long
(1)   82/    160D : F8 00               	ldi	0
(1)   83/    160F : B8                  	phi	RL8-1	;clear the top byte of the float
(1)   84/    1610 : 88                  	glo	RL8-1	;get the next byte
(1)   85/    1611 : F9 80               	ori	0x80	;add in the implied 1 bit
(1)   86/    1613 : A8                  	plo	RL8-1	;put it back
(1)   87/    1614 : 8E                  	glo	memaddr	;make sure there's at least 1 shift
(1)   88/    1615 : 32 3B               	bz	$$sign
(1)   89/    1617 :                     ;**********note df is set from subtraction before setting mantissa
(1)   90/    1617 : 3B 2B               	bnf	$$lsh ; if the shift count is negative
(1)   91/    1619 :                     
(1)   92/    1619 : (MACRO)             $$shr:	shru4	RL8
(1)   93/    1625 : 2E                  	dec	memaddr	;check shift count
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 27 - 4/12/2013 12:43:12


(1)   94/    1626 : 8E                  	glo	memaddr
(1)   95/    1627 : 3A 19               	bnz	$$shr	;complete the shift
(1)   96/    1629 : 30 3B               	br	$$sign
(1)   97/    162B :                     
(1)   98/    162B :                     ;handle negative shift as best I can - gigo
(1)   99/    162B : (MACRO)             $$lsh: 	shl4	RL8	;shift once
(1)  100/    1637 : 1E                  	inc	memaddr
(1)  101/    1638 : 8E                  	glo	memaddr
(1)  102/    1639 : 3A 2B               	bnz	$$lsh	
(1)  103/    163B :                     	
(1)  104/    163B : 9E                  $$sign:	ghi	memaddr	;now the sign
(1)  105/    163C : FE                  	shl		;shift sign bit into df
(1)  106/    163D : 3B 61               	bnf	$$done
(1)  107/    163F : (MACRO)             	negi4	RL8,RL8	;negate the number if needed
(1)  108/    165F : 30 61               	br	$$done	; and return
(1)  109/    1661 :                     
(1)  110/    1661 : (MACRO)             $$done:	Cretn		;and we're done
(1)  111/    1662 :                     
(1)  112/    1662 :                     ; *** Check if character is numeric
(1)  113/    1662 :                     ; *** D - char to check
(1)  114/    1662 :                     ; *** Returns DF=1 if numeric
(1)  115/    1662 :                     ; ***         DF=0 if not
(1)  116/    1662 : AE                  f_isnum:   plo     r14                 ; save a copy
(1)  117/    1663 : FF 30                          smi     '0'                 ; check for below zero
(1)  118/    1665 : 3B 6E                          bnf     fails               ; jump if below
(1)  119/    1667 : FF 0A                          smi     10                  ; see if above
(1)  120/    1669 : 33 6E                          bdf     fails               ; fails if so
(1)  121/    166B : FF 00               passes:    smi     0                   ; signal success
(1)  122/    166D : C8                             lskp
(1)  123/    166E : FC 00               fails:     adi     0                   ; signal failure
(1)  124/    1670 : 8E                             glo     r14                 ; recover character
(1)  125/    1671 : D5                             sep     RRET                ; and return; *******************************
(1)  126/    1672 :                     ; *** Shift R8:F9 right 1 bit ***
(1)  127/    1672 :                     ; *******************************
(1)  128/    1672 : 98                  fp_shr_1:  ghi   r8                    ; shift high word right
(1)  129/    1673 : F6                             shr
(1)  130/    1674 : B8                             phi   r8
(1)  131/    1675 : 88                             glo   r8
(1)  132/    1676 : 76                             shrc
(1)  133/    1677 : A8                             plo   r8
(1)  134/    1678 : 99                             ghi   F9                    ; shift low word right
(1)  135/    1679 : 76                             shrc
(1)  136/    167A : B9                             phi   F9
(1)  137/    167B : 89                             glo   F9
(1)  138/    167C : 76                             shrc
(1)  139/    167D : A9                             plo   F9
(1)  140/    167E : (MACRO)                        Cretn
(1)  141/    167F :                     
(1)  142/    167F :                     ; ******************************
(1)  143/    167F :                     ; *** Shift R8:F9 left 1 bit ***
(1)  144/    167F :                     ; ******************************
(1)  145/    167F : 89                  fp_shl_1:  glo   F9
(1)  146/    1680 : FE                             shl
(1)  147/    1681 : A9                             plo   F9
(1)  148/    1682 : 99                             ghi   F9
(1)  149/    1683 : 7E                             shlc
(1)  150/    1684 : B9                             phi   F9
(1)  151/    1685 : 88                             glo   r8
(1)  152/    1686 : 7E                             shlc
(1)  153/    1687 : A8                             plo   r8
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 28 - 4/12/2013 12:43:12


(1)  154/    1688 : 98                             ghi   r8
(1)  155/    1689 : 7E                             shlc
(1)  156/    168A : B8                             phi   r8
(1)  157/    168B : D5                             sep   RRET
(1)  158/    168C :                     
(1)  159/    168C :                     ; **********************
(1)  160/    168C :                     ; *** R8:F9 += RA:FB ***
(1)  161/    168C :                     ; **********************
(1)  162/    168C : 8B                  fp_add_12: glo   FB
(1)  163/    168D : 22                  	   dec r2	;wjr - make a work area
(1)  164/    168E : 52                             str   r2
(1)  165/    168F : 89                             glo   F9
(1)  166/    1690 : F4                             add
(1)  167/    1691 : A9                             plo   F9
(1)  168/    1692 : 9B                             ghi   FB
(1)  169/    1693 : 52                             str   r2
(1)  170/    1694 : 99                             ghi   F9
(1)  171/    1695 : 74                             adc
(1)  172/    1696 : B9                             phi   F9
(1)  173/    1697 : 8A                             glo   R10
(1)  174/    1698 : 52                             str   r2
(1)  175/    1699 : 88                             glo   r8
(1)  176/    169A : 74                             adc
(1)  177/    169B : A8                             plo   r8
(1)  178/    169C : 9A                             ghi   R10
(1)  179/    169D : 52                             str   r2
(1)  180/    169E : 98                             ghi   r8
(1)  181/    169F : 74                             adc
(1)  182/    16A0 : B8                             phi   r8
(1)  183/    16A1 : 12                             inc	r2	;wjr - release work area
(1)  184/    16A2 : (MACRO)                        Cretn
(1)  185/    16A3 :                     
(1)  186/    16A3 :                     ; *******************************
(1)  187/    16A3 :                     ; *** Shift RF:RD right 1 bit ***
(1)  188/    16A3 :                     ; *******************************
(1)  189/    16A3 : 9F                  fp_shr_fd: ghi   R15                    ; shift high word right
(1)  190/    16A4 : F6                             shr
(1)  191/    16A5 : BF                             phi   R15
(1)  192/    16A6 : 8F                             glo   R15
(1)  193/    16A7 : 76                             shrc
(1)  194/    16A8 : AF                             plo   R15
(1)  195/    16A9 : 9D                             ghi   R13                    ; shift low word right
(1)  196/    16AA : 76                             shrc
(1)  197/    16AB : BD                             phi   R13
(1)  198/    16AC : 8D                             glo   R13
(1)  199/    16AD : 76                             shrc
(1)  200/    16AE : AD                             plo   R13
(1)  201/    16AF : (MACRO)                        Cretn
(1)  202/    16B0 :                     
(1)  203/    16B0 :                     ; *************************************
(1)  204/    16B0 :                     ; *** Scale number to high bit is 1 ***
(1)  205/    16B0 :                     ; *** R8:F9 - Number to scale       ***
(1)  206/    16B0 :                     ; *** RF.1  - Exponent for number   ***
(1)  207/    16B0 :                     ; *** F7.0  - Sign bit (bit 0) ***
(1)  208/    16B0 :                     ; *** Returns: R8:F9 - final sp num ***
(1)  209/    16B0 :                     ; *************************************
(1)  210/    16B0 : 88                  fp_sc_up:  glo   r8                    ; need high bit to be a 1
(1)  211/    16B1 : FA 80                          ani   080h                  ; check it
(1)  212/    16B3 : CA 16 C0                       lbnz  fp_sc_cln             ; jump if good
(1)  213/    16B6 : (MACRO)                        Ccall fp_shl_1              ; shift answer left
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 29 - 4/12/2013 12:43:12


(1)  214/    16B9 : 9F                             ghi   R15                    ; get exp1
(1)  215/    16BA : FF 01                          smi   1                     ; minus 1
(1)  216/    16BC : BF                             phi   R15                    ; and put it back
(1)  217/    16BD : C0 16 B0                       lbr   fp_sc_up              ; loop back intil msbit is 1
(1)  218/    16C0 : 88                  fp_sc_cln: glo   r8                    ; get high byte
(1)  219/    16C1 : FE                             shl                         ; shift out high 1 bit
(1)  220/    16C2 : A8                             plo   r8                    ; set aside
(1)  221/    16C3 : 9F                             ghi   R15                    ; get exponent byte
(1)  222/    16C4 : B8                             phi   r8                    ; write other 7 bits to r8.1
(1)  223/    16C5 : F6                             shr                         ; shift bit 0 into DF
(1)  224/    16C6 : 88                             glo   r8                    ; get high byte of mantissa
(1)  225/    16C7 : 76                             shrc                        ; shift bit 0 of expnent in
(1)  226/    16C8 : A8                             plo   r8                    ; and put it back
(1)  227/    16C9 : 87                             glo   F7                   ; get signs
(1)  228/    16CA : F6                             shr                         ; get sign 1
(1)  229/    16CB : 98                             ghi   r8                    ; recover exponent
(1)  230/    16CC : 76                             shrc                        ; shift in sign
(1)  231/    16CD : B8                             phi   r8                    ; put it back
(1)  232/    16CE : 12                             inc	r2	;wjr release work area
(1)  233/    16CF : (MACRO)             	   popr R13	;wjr restore param regs
(1)  234/    16D3 : (MACRO)             	   popr R12	;wjr
(1)  235/    16D7 : (MACRO)                        popr	F7	;wjr restore c variable register
(1)  236/    16DB : (MACRO)                        Cretn                       ; return to caller
(1)  237/    16DC :                     
(1)  238/    16DC :                     ; ************************************
(1)  239/    16DC :                     ; *** Get exponenst from arguments ***
(1)  240/    16DC :                     ; *** R8:F9 - Arg 1                ***
(1)  241/    16DC :                     ; *** RA:FB - Arg 2                ***
(1)  242/    16DC :                     ; *** Returns: RF.1 - exp1         ***
(1)  243/    16DC :                     ; ***          RF.0 - exp2         ***
(1)  244/    16DC :                     ; ************************************
(1)  245/    16DC : 88                  fp_getexp: glo   r8                    ; get exponent of arg1 (bit 0)
(1)  246/    16DD : FE                             shl                         ; shift it into DF
(1)  247/    16DE : 98                             ghi   r8                    ; get top 7 bits
(1)  248/    16DF : 7E                             shlc                        ; shift in first bit
(1)  249/    16E0 : BF                             phi   R15                    ; put exp1 into RF.1
(1)  250/    16E1 :                                ;str   r2    wjr - this is never used; place into memory as well
(1)  251/    16E1 : 8A                             glo   R10                    ; get exponent of arg2 (bit 0)
(1)  252/    16E2 : FE                             shl                         ; shift it into DF
(1)  253/    16E3 : 9A                             ghi   R10                    ; get top 7 bits
(1)  254/    16E4 : 7E                             shlc                        ; shift in first bit
(1)  255/    16E5 : AF                             plo   R15                    ; put into RF
(1)  256/    16E6 : D5                             sep   RRET                  ; return to caller
(1)  257/    16E7 :                     
(1)  258/    16E7 :                     ; ************************************
(1)  259/    16E7 :                     ; *** Get signs from arguments     ***
(1)  260/    16E7 :                     ; *** R8:F9 - Arg 1                ***
(1)  261/    16E7 :                     ; *** RA:FB - Arg 2                ***
(1)  262/    16E7 :                     ; *** Returns: F7.0 - signs        ***
(1)  263/    16E7 :                     ; ************************************
(1)  264/    16E7 : 98                  fp_getsgn: ghi   r8                    ; get sign of arg1
(1)  265/    16E8 : FE                             shl                         ; shift into DF
(1)  266/    16E9 : 9A                             ghi   R10                    ; get sign of arg2
(1)  267/    16EA : 7E                             shlc                        ; shift into DF, sign of arg1 to bit 0
(1)  268/    16EB : 7E                             shlc                        ; now shift in sign of arg2
(1)  269/    16EC : A7                             plo   F7                    ; save them
(1)  270/    16ED : (MACRO)                        Cretn                       ; return to caller
(1)  271/    16EE :                     
(1)  272/    16EE :                     ; ***************************************
(1)  273/    16EE :                     ; *** Add 2 SP floating point numbers ***
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 30 - 4/12/2013 12:43:12


(1)  274/    16EE :                     ; *** R8:F9 - Arg 1                   ***
(1)  275/    16EE :                     ; *** RA:FB - Arg 2                   ***
(1)  276/    16EE :                     ; *** Returns: R8:F9 - Answer         ***
(1)  277/    16EE :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  278/    16EE :                     ; ***        RF.1 - exponent of arg2  ***
(1)  279/    16EE :                     ; ***        F7.0 - signs        ***
(1)  280/    16EE :                     ; ***************************************
(1)  281/    16EE : 98                  fp_add:   ghi   r8                    ; check arg1 for zero
(1)  282/    16EF : CA 17 07                       lbnz  add_a1nz
(1)  283/    16F2 : 88                             glo   r8
(1)  284/    16F3 : CA 17 07                       lbnz  add_a1nz
(1)  285/    16F6 : 99                             ghi   F9
(1)  286/    16F7 : CA 17 07                       lbnz  add_a1nz
(1)  287/    16FA : 89                             glo   F9
(1)  288/    16FB : CA 17 07                       lbnz  add_a1nz
(1)  289/    16FE : 9A                             ghi   R10                    ; transfer arg2 to answer
(1)  290/    16FF : B8                             phi   r8
(1)  291/    1700 : 8A                             glo   R10
(1)  292/    1701 : A8                             plo   r8
(1)  293/    1702 : 9B                             ghi   FB
(1)  294/    1703 : B9                             phi   F9
(1)  295/    1704 : 8B                             glo   FB
(1)  296/    1705 : A9                             plo   F9
(1)  297/    1706 : (MACRO)                        Cretn                        ; return to caller
(1)  298/    1707 :                     
(1)  299/    1707 : 9A                  add_a1nz:  ghi   R10                    ; check arg2 for zero
(1)  300/    1708 : CA 17 18                       lbnz  add_a2nz
(1)  301/    170B : 8A                             glo   R10
(1)  302/    170C : CA 17 18                       lbnz  add_a2nz
(1)  303/    170F : 9B                             ghi   FB
(1)  304/    1710 : CA 17 18                       lbnz  add_a2nz
(1)  305/    1713 : 8B                             glo   FB
(1)  306/    1714 : CA 17 18                       lbnz  add_a2nz
(1)  307/    1717 : (MACRO)                        Cretn                       ; return arg1 as answer
(1)  308/    1718 :                                
(1)  309/    1718 : (MACRO)             add_a2nz:  pushr F7	;wjr save c variable register
(1)  310/    171D : (MACRO)             	   pushr R12	;wjr save param regs
(1)  311/    1722 : (MACRO)             	   pushr R13	;wjr
(1)  312/    1727 : 22                  	   dec	r2	;wjr - make a work area
(1)  313/    1728 : (MACRO)             	   Ccall fp_getexp             ; get exponents
(1)  314/    172B : 9F                             ghi   R15
(1)  315/    172C : 52                             str   r2
(1)  316/    172D : 8F                             glo   R15
(1)  317/    172E : F7                             sm                          ; perfrom exp2 - exp1
(1)  318/    172F : CB 17 50                       lbnf  add_ns                ; jump if no swap needed
(1)  319/    1732 :                     
(1)  320/    1732 : 98                             ghi   r8                    ; swap arg1 with arg2
(1)  321/    1733 : AE                             plo   R14
(1)  322/    1734 : 9A                             ghi   R10
(1)  323/    1735 : B8                             phi   r8
(1)  324/    1736 : 8E                             glo   R14
(1)  325/    1737 : BA                             phi   R10
(1)  326/    1738 : 88                             glo   r8
(1)  327/    1739 : AE                             plo   R14
(1)  328/    173A : 8A                             glo   R10
(1)  329/    173B : A8                             plo   r8
(1)  330/    173C : 8E                             glo   R14
(1)  331/    173D : AA                             plo   R10
(1)  332/    173E : 99                             ghi   F9                    ; swap arg1 with arg2
(1)  333/    173F : AE                             plo   R14
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 31 - 4/12/2013 12:43:12


(1)  334/    1740 : 9B                             ghi   FB
(1)  335/    1741 : B9                             phi   F9
(1)  336/    1742 : 8E                             glo   R14
(1)  337/    1743 : BB                             phi   FB
(1)  338/    1744 : 89                             glo   F9
(1)  339/    1745 : AE                             plo   R14
(1)  340/    1746 : 8B                             glo   FB
(1)  341/    1747 : A9                             plo   F9
(1)  342/    1748 : 8E                             glo   R14
(1)  343/    1749 : AB                             plo   FB
(1)  344/    174A : 9F                             ghi   R15                    ; swap exponents
(1)  345/    174B : AE                             plo   R14
(1)  346/    174C : 8F                             glo   R15
(1)  347/    174D : BF                             phi   R15
(1)  348/    174E : 8E                             glo   R14
(1)  349/    174F : AF                             plo   R15
(1)  350/    1750 : (MACRO)             add_ns:    ccall fp_getsgn              ; get signs of arguments
(1)  351/    1753 : F8 00                          ldi   0                     ; setup mantissas
(1)  352/    1755 : B8                             phi   r8
(1)  353/    1756 : BA                             phi   R10
(1)  354/    1757 : F8 80                          ldi   128                   ; need to set high bit in mantissa
(1)  355/    1759 : 52                             str   r2
(1)  356/    175A : 88                             glo   r8
(1)  357/    175B : F1                             or
(1)  358/    175C : A8                             plo   r8
(1)  359/    175D : 8A                             glo   R10
(1)  360/    175E : F1                             or
(1)  361/    175F : AA                             plo   R10
(1)  362/    1760 : 9F                             ghi   R15                    ; get exp1
(1)  363/    1761 : 52                             str   r2                    ; place into memory
(1)  364/    1762 : 8F                  add_lp1:   glo   R15                    ; get exp2
(1)  365/    1763 : F7                             sm                          ; see if match to exp1
(1)  366/    1764 : C2 17 77                       lbz   add_lp1dn             ; jump if match
(1)  367/    1767 : 8F                             glo   R15                    ; need to increase it
(1)  368/    1768 : FC 01                          adi   1
(1)  369/    176A : AF                             plo   R15
(1)  370/    176B : 8A                             glo   R10                    ; now shift arg2 over 1 bit
(1)  371/    176C : F6                             shr
(1)  372/    176D : AA                             plo   R10
(1)  373/    176E : 9B                             ghi   FB
(1)  374/    176F : 76                             shrc
(1)  375/    1770 : BB                             phi   FB
(1)  376/    1771 : 8B                             glo   FB
(1)  377/    1772 : 76                             shrc
(1)  378/    1773 : AB                             plo   FB
(1)  379/    1774 : C0 17 62                       lbr   add_lp1               ; keep shifting until exponents match
(1)  380/    1777 : 87                  add_lp1dn: glo   F7                    ; see if signs match
(1)  381/    1778 : 52                             str   r2
(1)  382/    1779 : F6                             shr
(1)  383/    177A : F3                             xor
(1)  384/    177B : FA 01                          ani   1                     ; keep only bottom bit
(1)  385/    177D : CA 17 86                       lbnz  add_nm                ; jump if signs do not match
(1)  386/    1780 : (MACRO)                        Ccall fp_add_12             ; perform arg1 += arg2
(1)  387/    1783 : C0 17 BF                       lbr   add_fnl               ; jump to clean up
(1)  388/    1786 : 8B                  add_nm:    glo   FB                    ; perform arg1 - arg2
(1)  389/    1787 : 52                             str   r2
(1)  390/    1788 : 89                             glo   F9
(1)  391/    1789 : F7                             sm
(1)  392/    178A : AC                             plo   R12                    ; place into RD:RC
(1)  393/    178B : 9B                             ghi   FB
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 32 - 4/12/2013 12:43:12


(1)  394/    178C : 52                             str   r2
(1)  395/    178D : 99                             ghi   F9
(1)  396/    178E : 77                             smb
(1)  397/    178F : BC                             phi   R12
(1)  398/    1790 : 8A                             glo   R10
(1)  399/    1791 : 52                             str   r2
(1)  400/    1792 : 88                             glo   r8
(1)  401/    1793 : 77                             smb
(1)  402/    1794 : AD                             plo   R13
(1)  403/    1795 : 9A                             ghi   R10
(1)  404/    1796 : 52                             str   r2
(1)  405/    1797 : 98                             ghi   r8
(1)  406/    1798 : 77                             smb
(1)  407/    1799 : BD                             phi   R13
(1)  408/    179A : CB 17 A8                       lbnf  add_no                ; jump if arg2 was larger than arg1
(1)  409/    179D : 9D                             ghi   R13                    ; transfer result to arg1
(1)  410/    179E : B8                             phi   r8
(1)  411/    179F : 8D                             glo   R13
(1)  412/    17A0 : A8                             plo   r8
(1)  413/    17A1 : 9C                             ghi   R12
(1)  414/    17A2 : B9                             phi   F9
(1)  415/    17A3 : 8C                             glo   R12
(1)  416/    17A4 : A9                             plo   F9
(1)  417/    17A5 : C0 17 BF                       lbr   add_fnl               ; finalize
(1)  418/    17A8 : 89                  add_no:    glo   F9                    ; perform arg1 = arg2 - arg1
(1)  419/    17A9 : 52                             str   r2
(1)  420/    17AA : 8B                             glo   FB
(1)  421/    17AB : F7                             sm
(1)  422/    17AC : A9                             plo   F9
(1)  423/    17AD : 99                             ghi   F9
(1)  424/    17AE : 52                             str   r2
(1)  425/    17AF : 9B                             ghi   FB
(1)  426/    17B0 : 77                             smb
(1)  427/    17B1 : B9                             phi   F9
(1)  428/    17B2 : 88                             glo   r8
(1)  429/    17B3 : 52                             str   r2
(1)  430/    17B4 : 8A                             glo   R10
(1)  431/    17B5 : 77                             smb
(1)  432/    17B6 : A8                             plo   r8
(1)  433/    17B7 : 98                             ghi   r8
(1)  434/    17B8 : 52                             str   r2
(1)  435/    17B9 : 9A                             ghi   R10
(1)  436/    17BA : 77                             smb
(1)  437/    17BB : B8                             phi   r8
(1)  438/    17BC : 87                             glo   F7                    ; move sign 2 to sign1
(1)  439/    17BD : FE                             shl
(1)  440/    17BE : A7                             plo   F7
(1)  441/    17BF : 98                  add_fnl:   ghi   r8                    ; check for zero result
(1)  442/    17C0 : CA 17 DD                       lbnz  add_nz                ; jump if not
(1)  443/    17C3 : 88                             glo   r8
(1)  444/    17C4 : CA 17 DD                       lbnz  add_nz
(1)  445/    17C7 : 99                             ghi   F9
(1)  446/    17C8 : CA 17 DD                       lbnz  add_nz
(1)  447/    17CB : 89                             glo   F9
(1)  448/    17CC : CA 17 DD                       lbnz  add_nz
(1)  449/    17CF : 12                             inc	r2	;wjr release work area
(1)  450/    17D0 : (MACRO)             	   popr R13	;wjr restore param regs
(1)  451/    17D4 : (MACRO)             	   popr R12	;wjr
(1)  452/    17D8 : (MACRO)                        popr	F7	;wjr restore c variable register
(1)  453/    17DC : (MACRO)                        Cretn                       ; return the zero
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 33 - 4/12/2013 12:43:12


(1)  454/    17DD : 98                  add_nz:    ghi   r8                    ; see if answer is beyond 24 bits
(1)  455/    17DE : C2 17 EB                       lbz   add_nx                ; jump if not
(1)  456/    17E1 : (MACRO)                        Ccall fp_shr_1              ; shift answer to the right
(1)  457/    17E4 : 9F                             ghi   R15                    ; get exp1
(1)  458/    17E5 : FC 01                          adi   1                     ; increment it
(1)  459/    17E7 : BF                             phi   R15                    ; and put it back
(1)  460/    17E8 : C0 17 DD                       lbr   add_nz                ; keep going until not > 24 bits
(1)  461/    17EB :                     
(1)  462/    17EB : 87                  add_nx:    glo   F7                    ; move sign 1 to low bit
(1)  463/    17EC : F6                             shr
(1)  464/    17ED : A7                             plo   F7
(1)  465/    17EE : C0 16 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  466/    17F1 :                     
(1)  467/    17F1 :                     ; ***************************************
(1)  468/    17F1 :                     ; *** sub 2 SP floating point numbers ***
(1)  469/    17F1 :                     ; *** R8:F9 - Arg 1                   ***
(1)  470/    17F1 :                     ; *** RA:FB - Arg 2                   ***
(1)  471/    17F1 :                     ; *** Returns: R8:F9 - Answer         ***
(1)  472/    17F1 :                     ; ***************************************
(1)  473/    17F1 : 9A                  fp_sub:    ghi   R10                    ; change sign of arg2
(1)  474/    17F2 : FB 80                          xri   080h
(1)  475/    17F4 : BA                             phi   R10                    ; and put it back
(1)  476/    17F5 : C0 16 EE                       lbr   fp_add                ; now just add
(1)  477/    17F8 :                     
(1)  478/    17F8 :                     ; ***************************************
(1)  479/    17F8 :                     ; *** Div 2 SP floating point numbers ***
(1)  480/    17F8 :                     ; *** R8:F9 - Arg 1                   ***
(1)  481/    17F8 :                     ; *** RA:FB - Arg 2                   ***
(1)  482/    17F8 :                     ; *** Returns: R8:F9 - Answer         ***
(1)  483/    17F8 :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  484/    17F8 :                     ; ***        RF.1 - exponent of arg2  ***
(1)  485/    17F8 :                     ; ***        F7.0 - signs        ***
(1)  486/    17F8 :                     ; ***************************************
(1)  487/    17F8 : 98                  fp_div:    ghi   r8                    ; check arg1 for zero
(1)  488/    17F9 : CA 18 09                       lbnz  div_a1nz
(1)  489/    17FC : 88                             glo   r8
(1)  490/    17FD : CA 18 09                       lbnz  div_a1nz
(1)  491/    1800 : 99                             ghi   F9
(1)  492/    1801 : CA 18 09                       lbnz  div_a1nz
(1)  493/    1804 : 89                             glo   F9
(1)  494/    1805 : CA 18 09                       lbnz  div_a1nz
(1)  495/    1808 : (MACRO)                        Cretn	                ; just return the zero
(1)  496/    1809 : 9A                  div_a1nz:  ghi   R10                    ; check arg2 for zero
(1)  497/    180A : CA 18 27                       lbnz  div_a2nz
(1)  498/    180D : 8A                             glo   R10
(1)  499/    180E : CA 18 27                       lbnz  div_a2nz
(1)  500/    1811 : 9B                             ghi   FB
(1)  501/    1812 : CA 18 27                       lbnz  div_a2nz
(1)  502/    1815 : 8B                             glo   FB
(1)  503/    1816 : CA 18 27                       lbnz  div_a2nz
(1)  504/    1819 : 98                             ghi   r8                    ; need sign of arg1
(1)  505/    181A : FA 80                          ani   080h                  ; want only sign
(1)  506/    181C : F9 7F                          ori   07fh                  ; exponent will be all ones
(1)  507/    181E : B8                             phi   r8                    ; put into answer
(1)  508/    181F : F8 80                          ldi   080h                  ; build rest of answer
(1)  509/    1821 : A8                             plo   r8 
(1)  510/    1822 : F8 00                          ldi   0
(1)  511/    1824 : B9                             phi   F9
(1)  512/    1825 : A9                             plo   F9
(1)  513/    1826 : (MACRO)                        Cretn                  	; and return to caller
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 34 - 4/12/2013 12:43:12


(1)  514/    1827 :                     
(1)  515/    1827 : (MACRO)             div_a2nz:  pushr F7	;wjr save the C variable
(1)  516/    182C : (MACRO)             	   pushr R12	;wjr save param regs
(1)  517/    1831 : (MACRO)             	   pushr R13	;wjr
(1)  518/    1836 : 22                  	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
(1)  519/    1837 :                     
(1)  520/    1837 : (MACRO)             	   Ccall fp_getexp              ; get exponents
(1)  521/    183A : (MACRO)                        Ccall fp_getsgn		; get signs
(1)  522/    183D : 8F                             glo   R15                    ; get exp2
(1)  523/    183E : FF 7F                          smi   127                   ; remove bias
(1)  524/    1840 : 52                             str   r2                    ; place into memory
(1)  525/    1841 : 9F                             ghi   R15                    ; get exp1
(1)  526/    1842 : FF 7F                          smi   127                   ; remove bias
(1)  527/    1844 : F7                             sm                          ; perform exp1 - exp2
(1)  528/    1845 : FC 7F                          adi   127                   ; put bias back in
(1)  529/    1847 : 73                             stxd                        ; save onto stack
(1)  530/    1848 : 87                             glo   F7                    ; determine sign for answer
(1)  531/    1849 : 52                             str   r2
(1)  532/    184A : F6                             shr
(1)  533/    184B : F3                             xor
(1)  534/    184C : 73                             stxd                        ; place onto stack
(1)  535/    184D : F8 00                          ldi   0                     ; setup man
(1)  536/    184F : BA                             phi   R10
(1)  537/    1850 : 8A                             glo   R10
(1)  538/    1851 : F9 80                          ori   080h
(1)  539/    1853 : AA                             plo   R10
(1)  540/    1854 : F8 00                          ldi   0                     ; setup div
(1)  541/    1856 : B8                             phi   r8
(1)  542/    1857 : 88                             glo   r8
(1)  543/    1858 : F9 80                          ori   080h
(1)  544/    185A : A8                             plo   r8
(1)  545/    185B : F8 00                          ldi   0                     ; setup result
(1)  546/    185D : BC                             phi   R12
(1)  547/    185E : AC                             plo   R12
(1)  548/    185F : B7                             phi   F7
(1)  549/    1860 : A7                             plo   F7
(1)  550/    1861 : AF                             plo   R15                    ; setup quotient
(1)  551/    1862 : BF                             phi   R15
(1)  552/    1863 : BD                             phi   R13
(1)  553/    1864 : AD                             plo   R13
(1)  554/    1865 : F8 80                          ldi   080h
(1)  555/    1867 : AF                             plo   R15
(1)  556/    1868 : 98                  div_lp:    ghi   r8                    ; check div for nonzero
(1)  557/    1869 : CA 18 7B                       lbnz  div_go1
(1)  558/    186C : 88                             glo   r8
(1)  559/    186D : CA 18 7B                       lbnz  div_go1
(1)  560/    1870 : 99                             ghi   F9
(1)  561/    1871 : CA 18 7B                       lbnz  div_go1
(1)  562/    1874 : 89                             glo   F9
(1)  563/    1875 : CA 18 7B                       lbnz  div_go1
(1)  564/    1878 : C0 18 DB                       lbr   div_z
(1)  565/    187B : 9A                  div_go1:   ghi   R10
(1)  566/    187C : CA 18 8E                       lbnz  div_go
(1)  567/    187F : 8A                             glo   R10
(1)  568/    1880 : CA 18 8E                       lbnz  div_go
(1)  569/    1883 : 9B                             ghi   FB
(1)  570/    1884 : CA 18 8E                       lbnz  div_go
(1)  571/    1887 : 8B                             glo   FB
(1)  572/    1888 : CA 18 8E                       lbnz  div_go
(1)  573/    188B : C0 18 DB                       lbr   div_z                 ; nothing more to do
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 35 - 4/12/2013 12:43:12


(1)  574/    188E : 8B                  div_go:    glo   FB                    ; see if div > man
(1)  575/    188F : 52                             str   r2
(1)  576/    1890 : 89                             glo   F9
(1)  577/    1891 : F7                             sm
(1)  578/    1892 : 9B                             ghi   FB
(1)  579/    1893 : 52                             str   r2
(1)  580/    1894 : 99                             ghi   F9
(1)  581/    1895 : 77                             smb
(1)  582/    1896 : 8A                             glo   R10
(1)  583/    1897 : 52                             str   r2
(1)  584/    1898 : 88                             glo   r8
(1)  585/    1899 : 77                             smb
(1)  586/    189A : 9A                             ghi   R10
(1)  587/    189B : 52                             str   r2
(1)  588/    189C : 98                             ghi   r8
(1)  589/    189D : 77                             smb
(1)  590/    189E : CB 18 C9                       lbnf  div_nope              ; jump if div was smaller
(1)  591/    18A1 : 8B                             glo   FB                    ; div -= man
(1)  592/    18A2 : 52                             str   r2
(1)  593/    18A3 : 89                             glo   F9
(1)  594/    18A4 : F7                             sm
(1)  595/    18A5 : A9                             plo   F9
(1)  596/    18A6 : 9B                             ghi   FB
(1)  597/    18A7 : 52                             str   r2
(1)  598/    18A8 : 99                             ghi   F9
(1)  599/    18A9 : 77                             smb
(1)  600/    18AA : B9                             phi   F9
(1)  601/    18AB : 8A                             glo   R10
(1)  602/    18AC : 52                             str   r2
(1)  603/    18AD : 88                             glo   r8
(1)  604/    18AE : 77                             smb
(1)  605/    18AF : A8                             plo   r8
(1)  606/    18B0 : 9A                             ghi   R10
(1)  607/    18B1 : 52                             str   r2
(1)  608/    18B2 : 98                             ghi   r8
(1)  609/    18B3 : 77                             smb
(1)  610/    18B4 : B8                             phi   r8
(1)  611/    18B5 : 9F                             ghi   R15                    ; merge quotient into result
(1)  612/    18B6 : 52                             str   r2
(1)  613/    18B7 : 9C                             ghi   R12
(1)  614/    18B8 : F1                             or
(1)  615/    18B9 : BC                             phi   R12
(1)  616/    18BA : 8F                             glo   R15
(1)  617/    18BB : 52                             str   r2
(1)  618/    18BC : 8C                             glo   R12
(1)  619/    18BD : F1                             or
(1)  620/    18BE : AC                             plo   R12
(1)  621/    18BF : 9D                             ghi   R13
(1)  622/    18C0 : 52                             str   r2
(1)  623/    18C1 : 97                             ghi   F7
(1)  624/    18C2 : F1                             or
(1)  625/    18C3 : B7                             phi   F7
(1)  626/    18C4 : 8D                             glo   R13
(1)  627/    18C5 : 52                             str   r2
(1)  628/    18C6 : 87                             glo   F7
(1)  629/    18C7 : F1                             or
(1)  630/    18C8 : A7                             plo   F7
(1)  631/    18C9 : D4                  div_nope:  sep   RCALL                 ; shift quotient right
(1)  632/    18CA : 16 A3                          dw    fp_shr_fd
(1)  633/    18CC : 9A                             ghi   R10                    ; shift divisor right
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 36 - 4/12/2013 12:43:12


(1)  634/    18CD : F6                             shr
(1)  635/    18CE : BA                             phi   R10
(1)  636/    18CF : 8A                             glo   R10
(1)  637/    18D0 : 76                             shrc
(1)  638/    18D1 : AA                             plo   R10
(1)  639/    18D2 : 9B                             ghi   FB
(1)  640/    18D3 : 76                             shrc
(1)  641/    18D4 : BB                             phi   FB
(1)  642/    18D5 : 8B                             glo   FB
(1)  643/    18D6 : 76                             shrc
(1)  644/    18D7 : AB                             plo   FB
(1)  645/    18D8 : C0 18 68                       lbr   div_lp                ; loop back until done
(1)  646/    18DB : 9C                  div_z:     ghi   R12                    ; move result to arg1
(1)  647/    18DC : B8                             phi   r8
(1)  648/    18DD : 8C                             glo   R12
(1)  649/    18DE : A8                             plo   r8
(1)  650/    18DF : 97                             ghi   F7
(1)  651/    18E0 : B9                             phi   F9
(1)  652/    18E1 : 87                             glo   F7
(1)  653/    18E2 : A9                             plo   F9
(1)  654/    18E3 : 60                             irx                         ; recover sign
(1)  655/    18E4 : 72                             ldxa
(1)  656/    18E5 : A7                             plo   F7
(1)  657/    18E6 : F0                             ldx                         ; recover answer exponent
(1)  658/    18E7 : BF                             phi   R15
(1)  659/    18E8 : C0 16 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  660/    18EB :                     
(1)  661/    18EB :                     ; ***************************************
(1)  662/    18EB :                     ; *** Mul 2 SP floating point numbers ***
(1)  663/    18EB :                     ; *** R8:F9 - Arg 1                   ***
(1)  664/    18EB :                     ; *** RA:FB - Arg 2                   ***
(1)  665/    18EB :                     ; *** Returns: R8:F9 - Answer         ***
(1)  666/    18EB :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  667/    18EB :                     ; ***        RF.1 - exponent of arg2  ***
(1)  668/    18EB :                     ; ***        F7.0 - signs             ***
(1)  669/    18EB :                     ; ***************************************
(1)  670/    18EB : (MACRO)             fp_mul:    pushr F7	;wjr save the C variable
(1)  671/    18F0 : (MACRO)             	   pushr R12	;wjr save param regs
(1)  672/    18F5 : (MACRO)             	   pushr R13	;wjr
(1)  673/    18FA : 22                  	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
(1)  674/    18FB :                     
(1)  675/    18FB : (MACRO)                        Ccall    fp_getexp	       ; get exponents
(1)  676/    18FE : (MACRO)                        Ccall    fp_getsgn            ; get signs
(1)  677/    1901 : 8F                             glo   R15                    ; get exp2
(1)  678/    1902 : FF 7F                          smi   127                   ; remove bias
(1)  679/    1904 : 52                             str   r2                    ; place into memory
(1)  680/    1905 : 9F                             ghi   R15                    ; get exp1
(1)  681/    1906 : FF 7F                          smi   127                   ; remove bias
(1)  682/    1908 : F4                             add                         ; add in exponent 2
(1)  683/    1909 : FC 7F                          adi   127                   ; put bias back in
(1)  684/    190B : 73                             stxd                        ; place onto stack
(1)  685/    190C : 87                             glo   F7                    ; determine sign for answer
(1)  686/    190D : 52                             str   r2
(1)  687/    190E : F6                             shr
(1)  688/    190F : F3                             xor
(1)  689/    1910 : 73                             stxd                        ; place onto stack
(1)  690/    1911 : 9E                             ghi   R14                    ; get baud constant
(1)  691/    1912 : 73                             stxd                        ; save on stack
(1)  692/    1913 : 96                             ghi   r6                    ; save return position on stack
(1)  693/    1914 : 73                             stxd
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 37 - 4/12/2013 12:43:12


(1)  694/    1915 : 86                             glo   r6
(1)  695/    1916 : 73                             stxd
(1)  696/    1917 : F8 00                          ldi   0                     ; initial value of ct
(1)  697/    1919 : 73                             stxd
(1)  698/    191A : BE                             phi   R14                    ; set mulH to 0
(1)  699/    191B : AE                             plo   R14
(1)  700/    191C : B6                             phi   r6
(1)  701/    191D : A6                             plo   r6
(1)  702/    191E : B8                             phi   r8                    ; mulL = arg1 & 0xffffff
(1)  703/    191F : 88                             glo   r8                    ; be sure high bit is set
(1)  704/    1920 : F9 80                          ori   080h
(1)  705/    1922 : A8                             plo   r8
(1)  706/    1923 : F8 00                          ldi   0
(1)  707/    1925 : BC                             phi   R12                    ; set result to 0
(1)  708/    1926 : AC                             plo   R12
(1)  709/    1927 : B7                             phi   F7
(1)  710/    1928 : A7                             plo   F7
(1)  711/    1929 : BF                             phi   R15
(1)  712/    192A : AF                             plo   R15
(1)  713/    192B : BD                             phi   R13
(1)  714/    192C : AD                             plo   R13
(1)  715/    192D : BA                             phi   R10                    ; arg2 &= 0ffffff
(1)  716/    192E : 8A                             glo   R10                    ; be sure high bit is set
(1)  717/    192F : F9 80                          ori   080h
(1)  718/    1931 : AA                             plo   R10
(1)  719/    1932 : 8B                  mul_lp1:   glo   FB                    ; check for zero multiplier
(1)  720/    1933 : CA 19 42                       lbnz  mul_go1               ; jump if not zero
(1)  721/    1936 : 9B                             ghi   FB
(1)  722/    1937 : CA 19 42                       lbnz  mul_go1
(1)  723/    193A : 8A                             glo   R10
(1)  724/    193B : CA 19 42                       lbnz  mul_go1
(1)  725/    193E : 9A                             ghi   R10
(1)  726/    193F : C2 19 BA                       lbz   mul_dn                ; jump if muliplier is zero
(1)  727/    1942 : 9A                  mul_go1:   ghi   R10                    ; shift multiplier right
(1)  728/    1943 : F6                             shr
(1)  729/    1944 : BA                             phi   R10
(1)  730/    1945 : 8A                             glo   R10
(1)  731/    1946 : 76                             shrc
(1)  732/    1947 : AA                             plo   R10
(1)  733/    1948 : 9B                             ghi   FB
(1)  734/    1949 : 76                             shrc
(1)  735/    194A : BB                             phi   FB
(1)  736/    194B : 8B                             glo   FB
(1)  737/    194C : 76                             shrc
(1)  738/    194D : AB                             plo   FB
(1)  739/    194E : CB 19 8F                       lbnf  mul_no                ; jump if low bit was zero
(1)  740/    1951 : 89                             glo   F9                    ; res += mul
(1)  741/    1952 : 52                             str   r2
(1)  742/    1953 : 87                             glo   F7
(1)  743/    1954 : F4                             add
(1)  744/    1955 : A7                             plo   F7
(1)  745/    1956 : 99                             ghi   F9
(1)  746/    1957 : 52                             str   r2
(1)  747/    1958 : 97                             ghi   F7
(1)  748/    1959 : 74                             adc
(1)  749/    195A : B7                             phi   F7
(1)  750/    195B : 88                             glo   r8
(1)  751/    195C : 52                             str   r2
(1)  752/    195D : 8C                             glo   R12
(1)  753/    195E : 74                             adc
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 38 - 4/12/2013 12:43:12


(1)  754/    195F : AC                             plo   R12
(1)  755/    1960 : 98                             ghi   r8
(1)  756/    1961 : 52                             str   r2
(1)  757/    1962 : 9C                             ghi   R12
(1)  758/    1963 : 74                             adc
(1)  759/    1964 : BC                             phi   R12
(1)  760/    1965 : 86                             glo   r6                    ; now high 32 bits
(1)  761/    1966 : 52                             str   r2
(1)  762/    1967 : 8D                             glo   R13
(1)  763/    1968 : F4                             add
(1)  764/    1969 : AD                             plo   R13
(1)  765/    196A : 96                             ghi   r6
(1)  766/    196B : 52                             str   r2
(1)  767/    196C : 96                             ghi   r6
(1)  768/    196D : 52                             str   r2
(1)  769/    196E : 9D                             ghi   R13
(1)  770/    196F : 74                             adc
(1)  771/    1970 : BD                             phi   R13
(1)  772/    1971 : 8E                             glo   R14
(1)  773/    1972 : 52                             str   r2
(1)  774/    1973 : 8F                             glo   R15
(1)  775/    1974 : 74                             adc
(1)  776/    1975 : AF                             plo   R15
(1)  777/    1976 : 9E                             ghi   R14
(1)  778/    1977 : 52                             str   r2
(1)  779/    1978 : 9F                             ghi   R15
(1)  780/    1979 : 74                             adc
(1)  781/    197A : BF                             phi   R15
(1)  782/    197B : 9C                             ghi   R12                    ; see if need carry from low to high
(1)  783/    197C : C2 19 8F                       lbz   mul_no                ; jump if no carry is needed
(1)  784/    197F : 8D                             glo   R13                    ; move the carry on over
(1)  785/    1980 : FC 01                          adi   1
(1)  786/    1982 : AD                             plo   R13
(1)  787/    1983 : 9D                             ghi   R13
(1)  788/    1984 : 7C 00                          adci  0
(1)  789/    1986 : BD                             phi   R13
(1)  790/    1987 : 8F                             glo   R15
(1)  791/    1988 : 7C 00                          adci  0
(1)  792/    198A : AF                             plo   R15
(1)  793/    198B : 9F                             ghi   R15
(1)  794/    198C : 7C 00                          adci  0
(1)  795/    198E : BF                             phi   R15
(1)  796/    198F : 60                  mul_no:    irx                         ; recover ct
(1)  797/    1990 : F0                             ldx
(1)  798/    1991 : FC 01                          adi   1                     ; increment by 1
(1)  799/    1993 : 73                             stxd                        ; and put it back
(1)  800/    1994 : 89                             glo   F9                    ; shift mulL left
(1)  801/    1995 : FE                             shl
(1)  802/    1996 : A9                             plo   F9
(1)  803/    1997 : 99                             ghi   F9
(1)  804/    1998 : 7E                             shlc
(1)  805/    1999 : B9                             phi   F9
(1)  806/    199A : 88                             glo   r8
(1)  807/    199B : 7E                             shlc
(1)  808/    199C : A8                             plo   r8
(1)  809/    199D : 98                             ghi   r8
(1)  810/    199E : 7E                             shlc
(1)  811/    199F : B8                             phi   r8
(1)  812/    19A0 : 86                             glo   r6                    ; shift mulH left
(1)  813/    19A1 : FE                             shl
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 39 - 4/12/2013 12:43:12


(1)  814/    19A2 : A6                             plo   r6
(1)  815/    19A3 : 96                             ghi   r6
(1)  816/    19A4 : 7E                             shlc
(1)  817/    19A5 : B6                             phi   r6
(1)  818/    19A6 : 8E                             glo   R14
(1)  819/    19A7 : 7E                             shlc
(1)  820/    19A8 : AE                             plo   R14
(1)  821/    19A9 : 9E                             ghi   R14
(1)  822/    19AA : 7E                             shlc
(1)  823/    19AB : BE                             phi   R14
(1)  824/    19AC : 98                             ghi   r8                    ; see if a carry is needed
(1)  825/    19AD : C2 19 32                       lbz   mul_lp1               ; jump if not
(1)  826/    19B0 : F8 00                          ldi   0                     ; zero the high byte
(1)  827/    19B2 : B8                             phi   r8
(1)  828/    19B3 : 86                             glo   r6                    ; add in the carry
(1)  829/    19B4 : F9 01                          ori   1
(1)  830/    19B6 : A6                             plo   r6
(1)  831/    19B7 : C0 19 32                       lbr   mul_lp1               ; loop back for more
(1)  832/    19BA : 60                  mul_dn:    irx                         ; recover ct
(1)  833/    19BB : 72                             ldxa
(1)  834/    19BC : AE                             plo   R14                    ; set aside
(1)  835/    19BD : 72                             ldxa
(1)  836/    19BE : A6                             plo   r6
(1)  837/    19BF : 72                             ldxa
(1)  838/    19C0 : B6                             phi   r6
(1)  839/    19C1 : F0                             ldx
(1)  840/    19C2 : BE                             phi   R14
(1)  841/    19C3 : 9C                             ghi   R12                    ; transfer resL to arg1
(1)  842/    19C4 : B8                             phi   r8
(1)  843/    19C5 : 8C                             glo   R12
(1)  844/    19C6 : A8                             plo   r8
(1)  845/    19C7 : 97                             ghi   F7
(1)  846/    19C8 : B9                             phi   F9
(1)  847/    19C9 : 87                             glo   F7
(1)  848/    19CA : A9                             plo   F9
(1)  849/    19CB : 8E                             glo   R14
(1)  850/    19CC : AC                             plo   R12                    ; put ct into RC.0
(1)  851/    19CD : 8C                  mul_lp2:   glo   R12                    ; get ct
(1)  852/    19CE : FF 02                          smi   2                     ; see if <2
(1)  853/    19D0 : CB 19 E4                       lbnf  mul_nxt1              ; jump if so
(1)  854/    19D3 : D4                             sep   RCALL                 ; shift answer to the right
(1)  855/    19D4 : 16 72                          dw    fp_shr_1
(1)  856/    19D6 : D4                             sep   RCALL                 ; shift resH right
(1)  857/    19D7 : 16 A3                          dw    fp_shr_fd
(1)  858/    19D9 : CB 19 E0                       lbnf  mul_lp2a              ; jump if no carry into low word
(1)  859/    19DC : 88                             glo   r8                    ; set high bit
(1)  860/    19DD : F9 80                          ori   080h
(1)  861/    19DF : A8                             plo   r8
(1)  862/    19E0 : 2C                  mul_lp2a:  dec   R12                    ; decrement count
(1)  863/    19E1 : C0 19 CD                       lbr   mul_lp2               ; loop back to keep checking
(1)  864/    19E4 : 60                  mul_nxt1:  irx                         ; recover sign
(1)  865/    19E5 : 72                             ldxa
(1)  866/    19E6 : A7                             plo   F7
(1)  867/    19E7 : F0                             ldx                         ; recover answer exponent
(1)  868/    19E8 : AC                             plo   R12
(1)  869/    19E9 : 9F                  mul_lp3:   ghi   R15                    ; check resH for nonzero
(1)  870/    19EA : CA 19 FC                       lbnz  mul_lp3a
(1)  871/    19ED : 8F                             glo   R15
(1)  872/    19EE : CA 19 FC                       lbnz  mul_lp3a
(1)  873/    19F1 : 9D                             ghi   R13
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 40 - 4/12/2013 12:43:12


(1)  874/    19F2 : CA 19 FC                       lbnz  mul_lp3a
(1)  875/    19F5 : 8D                             glo   R13
(1)  876/    19F6 : CA 19 FC                       lbnz  mul_lp3a
(1)  877/    19F9 : C0 1A 0D                       lbr   mul_lp4               ; jump if no bits set in resH
(1)  878/    19FC : 1C                  mul_lp3a:  inc   R12                    ; increment exponent
(1)  879/    19FD : (MACRO)                        Ccall fp_shr_1                ; shift answer to the right
(1)  880/    1A00 : (MACRO)                        Ccall fp_shr_fd               ; shift resH right
(1)  881/    1A03 : CB 19 E9                       lbnf  mul_lp3               ; jump if no carry into low word
(1)  882/    1A06 : 88                             glo   r8                    ; set high bit
(1)  883/    1A07 : F9 80                          ori   080h
(1)  884/    1A09 : A8                             plo   r8
(1)  885/    1A0A : C0 19 E9                       lbr   mul_lp3
(1)  886/    1A0D : 8C                  mul_lp4:   glo   R12                    ; transfer exponent
(1)  887/    1A0E : BF                             phi   R15                    ; to high R15
(1)  888/    1A0F : C0 16 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  889/    1A12 :                     
(1)  890/    1A12 :                     ; ***************************************
(1)  891/    1A12 :                     ; *** Convert ascii to floating point ***
(1)  892/    1A12 :                     ; *** RF - buffer to ascii text       ***
(1)  893/    1A12 :                     ; *** Returns: R8:F9 - number         ***
(1)  894/    1A12 :                     ; ***************************************
(1)  895/    1A12 : 4F                  fp_atof:   lda   R15                    ; get byte from buffer
(1)  896/    1A13 : FF 20                          smi   ' '                   ; check for space
(1)  897/    1A15 : C2 1A 12                       lbz   fp_atof               ; move past any spaces
(1)  898/    1A18 : 2F                             dec   R15                    ; point back to nonspace chara
(1)  899/    1A19 : 0F                             ldn   R15                    ; check for possible sign
(1)  900/    1A1A : FF 2D                          smi   '-'                   ; first check for minus
(1)  901/    1A1C : CA 1A 26                       lbnz   atof_nm              ; jump if not minus
(1)  902/    1A1F : F8 80                          ldi   080h                  ; high bit set for minus
(1)  903/    1A21 : 73                             stxd                        ; place onto stack
(1)  904/    1A22 : 1F                             inc   R15                    ; move past sign
(1)  905/    1A23 : C0 1A 30                       lbr   atof_go1              ; and continue
(1)  906/    1A26 : F8 00               atof_nm:   ldi   0                     ; indicate positive number
(1)  907/    1A28 : 73                             stxd                        ; place onto stack
(1)  908/    1A29 : 0F                             ldn   R15                    ; now check for + sign
(1)  909/    1A2A : FF 2B                          smi   '+'
(1)  910/    1A2C : CA 1A 30                       lbnz  atof_go1              ; jump if not plus
(1)  911/    1A2F : 1F                             inc   R15                    ; move past plus sign
(1)  912/    1A30 : F8 00               atof_go1:  ldi   0                     ; setup result
(1)  913/    1A32 : B8                             phi   r8
(1)  914/    1A33 : A8                             plo   r8
(1)  915/    1A34 : B9                             phi   F9
(1)  916/    1A35 : A9                             plo   F9
(1)  917/    1A36 : 0F                  atof_lp1:  ldn   R15                    ; get next byte from buffer
(1)  918/    1A37 : (MACRO)                        Ccall f_isnum                ; is it numeric
(1)  919/    1A3A : CB 1A 67                       lbnf  atof_no1              ; jump if not
(1)  920/    1A3D : 98                             ghi   r8                    ; copy arg1 to arg2
(1)  921/    1A3E : BA                             phi   R10
(1)  922/    1A3F : 88                             glo   r8
(1)  923/    1A40 : AA                             plo   R10
(1)  924/    1A41 : 99                             ghi   F9
(1)  925/    1A42 : BB                             phi   FB
(1)  926/    1A43 : 89                             glo   F9
(1)  927/    1A44 : AB                             plo   FB
(1)  928/    1A45 : (MACRO)                        Ccall fp_shl_1                ; multiply arg1 by 2
(1)  929/    1A48 : (MACRO)                        Ccall fp_shl_1                 ; multiply arg1 by 4
(1)  930/    1A4B : (MACRO)                        Ccall fp_add_12                ; multiply arg1 by 5
(1)  931/    1A4E : (MACRO)                        Ccall fp_shl_1                ; multiply arg1 by 10
(1)  932/    1A51 : 4F                             lda   R15                    ; get number
(1)  933/    1A52 : FF 30                          smi   '0'                   ; convert to binary
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 41 - 4/12/2013 12:43:12


(1)  934/    1A54 : 52                             str   r2                    ; setup for add
(1)  935/    1A55 : 89                             glo   F9                    ; add in next digit
(1)  936/    1A56 : F4                             add
(1)  937/    1A57 : A9                             plo   F9
(1)  938/    1A58 : 99                             ghi   F9                    ; propagate carry
(1)  939/    1A59 : 7C 00                          adci  0
(1)  940/    1A5B : B9                             phi   F9
(1)  941/    1A5C : 88                             glo   r8
(1)  942/    1A5D : 7C 00                          adci  0
(1)  943/    1A5F : A8                             plo   r8
(1)  944/    1A60 : 98                             ghi   r8
(1)  945/    1A61 : 7C 00                          adci  0
(1)  946/    1A63 : B8                             phi   r8
(1)  947/    1A64 : C0 1A 36                       lbr   atof_lp1              ; loop until no more digits
(1)  948/    1A67 : 0F                  atof_no1:  ldn   R15                    ; check for decimal point
(1)  949/    1A68 : FF 2E                          smi   '.'
(1)  950/    1A6A : CA 1A 6E                       lbnz  atof_ndp              ; jump if none
(1)  951/    1A6D : 1F                             inc   R15                    ; move past decimal
(1)  952/    1A6E : F8 1B               atof_ndp:  ldi   scratch>>8          ; point to scratch area
(1)  953/    1A70 : BA                             phi   R10
(1)  954/    1A71 : F8 A3                          ldi   scratch&255
(1)  955/    1A73 : AA                             plo   R10
(1)  956/    1A74 : F8 10                          ldi   16                    ; 16 bytes to clear
(1)  957/    1A76 : AC                             plo   R12
(1)  958/    1A77 : F8 00               atof_lpx:  ldi   0
(1)  959/    1A79 : 5A                             str   R10
(1)  960/    1A7A : 1A                             inc   R10
(1)  961/    1A7B : 2C                             dec   R12
(1)  962/    1A7C : 8C                             glo   R12
(1)  963/    1A7D : CA 1A 77                       lbnz  atof_lpx
(1)  964/    1A80 : F8 1B                          ldi   (scratch+1)>>8      ; point to scratch area
(1)  965/    1A82 : BA                             phi   R10
(1)  966/    1A83 : F8 A4                          ldi   (scratch+1)&255
(1)  967/    1A85 : AA                             plo   R10
(1)  968/    1A86 : F8 01                          ldi   1                     ; setup count
(1)  969/    1A88 : AC                             plo   R12
(1)  970/    1A89 : F8 00                          ldi   0                     ; setup exp flag
(1)  971/    1A8B : BC                             phi   R12
(1)  972/    1A8C : 8C                  atof_lp2:  glo   R12                    ; see if done making bcd
(1)  973/    1A8D : FF 11                          smi   17
(1)  974/    1A8F : C2 1A A8                       lbz   atof_dn3              ; jump if so
(1)  975/    1A92 : 0F                             ldn   R15                    ; get character
(1)  976/    1A93 : D4                             sep   RCALL                 ; is it numeric
(1)  977/    1A94 : 16 62                          dw    f_isnum
(1)  978/    1A96 : CB 1A A8                       lbnf  atof_dn3              ; jump if not
(1)  979/    1A99 : 4F                             lda   R15                    ; get character
(1)  980/    1A9A : FF 30                          smi   '0'                   ; converto to binary
(1)  981/    1A9C : 5A                             str   R10                    ; write into bcd area
(1)  982/    1A9D : 1A                             inc   R10
(1)  983/    1A9E : 1C                             inc   R12                    ; increment count
(1)  984/    1A9F : CA 1A 8C                       lbnz  atof_lp2              ; loop back until done
(1)  985/    1AA2 : F8 01                          ldi   1                     ; set non zero flag
(1)  986/    1AA4 : BC                             phi   R12
(1)  987/    1AA5 : C0 1A 8C                       lbr   atof_lp2
(1)  988/    1AA8 : 9C                  atof_dn3:  ghi   R12                    ; check for non-zero digits
(1)  989/    1AA9 : CA 1A C2                       lbnz  atof_nz
(1)  990/    1AAC : 98                             ghi   r8                    ; check for non-zero integer
(1)  991/    1AAD : CA 1A C2                       lbnz  atof_nz
(1)  992/    1AB0 : 88                             glo   r8
(1)  993/    1AB1 : CA 1A C2                       lbnz  atof_nz
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 42 - 4/12/2013 12:43:12


(1)  994/    1AB4 : 99                             ghi   F9
(1)  995/    1AB5 : CA 1A C2                       lbnz  atof_nz
(1)  996/    1AB8 : 89                             glo   F9
(1)  997/    1AB9 : CA 1A C2                       lbnz  atof_nz
(1)  998/    1ABC : 60                             irx                         ; recover sign
(1)  999/    1ABD : F0                             ldx
(1) 1000/    1ABE : B8                             phi   r8                    ; put in high of zero
(1) 1001/    1ABF : C0 1B 95                       lbr	atof_end               ; and return
(1) 1002/    1AC2 : F8 00               atof_nz:   ldi   0                     ; setup dp
(1) 1003/    1AC4 : BC                             phi   R12
(1) 1004/    1AC5 : 98                  atof_lp3:  ghi   r8                    ; check for high bit set
(1) 1005/    1AC6 : FA 80                          ani   080h
(1) 1006/    1AC8 : CA 1B 12                       lbnz  atof_dn4              ; jump if so
(1) 1007/    1ACB : (MACRO)                        Ccall fp_shl_1                ; shift answer left
(1) 1008/    1ACE : F8 1B                          ldi   scratch>>8          ; point to bcd number
(1) 1009/    1AD0 : BA                             phi   R10
(1) 1010/    1AD1 : F8 A3                          ldi   255&scratch
(1) 1011/    1AD3 : AA                             plo   R10
(1) 1012/    1AD4 : F8 00                          ldi   0                     ; set high byte to zero
(1) 1013/    1AD6 : 5A                             str   R10
(1) 1014/    1AD7 : F8 1B                          ldi   (scratch+15)>>8     ; point to last cell
(1) 1015/    1AD9 : BA                             phi   R10
(1) 1016/    1ADA : F8 B2                          ldi   255&(scratch+15)
(1) 1017/    1ADC : AA                             plo   R10
(1) 1018/    1ADD : F8 00                          ldi   0                     ; set carry forward
(1) 1019/    1ADF : AE                             plo   R14
(1) 1020/    1AE0 : F8 10                          ldi   16                    ; setup count
(1) 1021/    1AE2 : AC                             plo   R12
(1) 1022/    1AE3 : 8E                  atof_lp4:  glo   R14                    ; get carry
(1) 1023/    1AE4 : 52                             str   r2                    ; in memory for add
(1) 1024/    1AE5 : 0A                             ldn   R10                    ; get bcd digit
(1) 1025/    1AE6 : F4                             add                         ; add in carry
(1) 1026/    1AE7 : 52                             str   r2                    ; place into memory
(1) 1027/    1AE8 : 0A                             ldn   R10                    ; recover bcd digit
(1) 1028/    1AE9 : F4                             add                         ; digit now doubled with carry
(1) 1029/    1AEA : 5A                             str   R10                    ; put it back
(1) 1030/    1AEB : FF 0A                          smi   10
(1) 1031/    1AED : CB 1A F4                       lbnf  atof_no4              ; jump if below 10
(1) 1032/    1AF0 : 5A                             str   R10                    ; store value - 10
(1) 1033/    1AF1 : F8 01                          ldi   1                     ; carry set to 1
(1) 1034/    1AF3 : C8                             lskp                        ; skip next instruction
(1) 1035/    1AF4 : F8 00               atof_no4:  ldi   0                     ; reset carry
(1) 1036/    1AF6 : AE                             plo   R14
(1) 1037/    1AF7 : 2A                             dec   R10                    ; move to previous digit
(1) 1038/    1AF8 : 2C                             dec   R12                    ; decrement digit count
(1) 1039/    1AF9 : 8C                             glo   R12                    ; see if done
(1) 1040/    1AFA : CA 1A E3                       lbnz  atof_lp4              ; jump if not
(1) 1041/    1AFD : F8 1B                          ldi   scratch>>8	       ; point to first digit
(1) 1042/    1AFF : BA                             phi   R10
(1) 1043/    1B00 : F8 A3                          ldi   255&scratch
(1) 1044/    1B02 : AA                             plo   R10
(1) 1045/    1B03 : 0A                             ldn   R10                    ; retrieve it
(1) 1046/    1B04 : C2 1B 0B                       lbz   atof_nc4              ; jump if no carry
(1) 1047/    1B07 : 89                             glo   F9                    ; add in the carry
(1) 1048/    1B08 : F9 01                          ori   1
(1) 1049/    1B0A : A9                             plo   F9
(1) 1050/    1B0B : 9C                  atof_nc4:  ghi   R12                    ; increment dp
(1) 1051/    1B0C : FC 01                          adi   1
(1) 1052/    1B0E : BC                             phi   R12
(1) 1053/    1B0F : C0 1A C5                       lbr   atof_lp3              ; loop until full
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 43 - 4/12/2013 12:43:12


(1) 1054/    1B12 : 9C                  atof_dn4:  ghi   R12                    ; get dp
(1) 1055/    1B13 : 52                             str   r2                    ; into memory
(1) 1056/    1B14 : F8 1F                          ldi   31                    ; need to subtract from 31
(1) 1057/    1B16 : F7                             sm
(1) 1058/    1B17 : FC 7F                          adi   127                   ; add in bias
(1) 1059/    1B19 : BD                             phi   R13                    ; set aside
(1) 1060/    1B1A : 99                             ghi   F9                    ; shift result down 8 bits
(1) 1061/    1B1B : A9                             plo   F9
(1) 1062/    1B1C : 88                             glo   r8
(1) 1063/    1B1D : B9                             phi   F9
(1) 1064/    1B1E : 98                             ghi   r8
(1) 1065/    1B1F : FE                             shl                         ; shift out high bit
(1) 1066/    1B20 : A8                             plo   r8
(1) 1067/    1B21 : 9D                             ghi   R13                    ; get bit 0 of exponent
(1) 1068/    1B22 : F6                             shr
(1) 1069/    1B23 : B8                             phi   r8                    ; bits 1-7 into high byte
(1) 1070/    1B24 : 88                             glo   r8                    ; get mantissa
(1) 1071/    1B25 : 76                             shrc                        ; shift in bit 0 of exponent
(1) 1072/    1B26 : A8                             plo   r8                    ; and write it
(1) 1073/    1B27 : 60                             irx                         ; point to sign
(1) 1074/    1B28 : 98                             ghi   r8                    ; high byte
(1) 1075/    1B29 : F1                             or                          ; set sign
(1) 1076/    1B2A : B8                             phi   r8                    ; done with base conversion
(1) 1077/    1B2B : 0F                             ldn   R15                    ; get next byte
(1) 1078/    1B2C : FF 65                          smi   'e'                   ; check for exponents
(1) 1079/    1B2E : C2 1B 37                       lbz   atof_exp
(1) 1080/    1B31 : 0F                             ldn   R15
(1) 1081/    1B32 : FF 45                          smi   'E'
(1) 1082/    1B34 : CA 1B 95                       lbnz  atof_end
(1) 1083/    1B37 : 1F                  atof_exp:  inc   R15                    ; move past E
(1) 1084/    1B38 : 0F                             ldn   R15                    ; check for sign
(1) 1085/    1B39 : FF 2D                          smi   '-'
(1) 1086/    1B3B : C2 1B 48                       lbz   atof_n
(1) 1087/    1B3E : 0F                             ldn   R15
(1) 1088/    1B3F : FF 2B                          smi   '+'
(1) 1089/    1B41 : C2 1B 45                       lbz   atof_p
(1) 1090/    1B44 : 2F                             dec   R15                    ; positive if no sign
(1) 1091/    1B45 : F8 01               atof_p:    ldi   1                     ; indicate positive exponent
(1) 1092/    1B47 : C8                             lskp
(1) 1093/    1B48 : F8 00               atof_n:    ldi   0                     ; indicate negative exponent
(1) 1094/    1B4A : BC                             phi   R12                    ; place into sign variable
(1) 1095/    1B4B : 1F                             inc   R15                    ; move past sign
(1) 1096/    1B4C : F8 00                          ldi   0                     ; setup intial count
(1) 1097/    1B4E : AC                             plo   R12
(1) 1098/    1B4F : 0F                  atof_lp5:  ldn   R15                    ; get next byte
(1) 1099/    1B50 : (MACRO)                        Ccall f_isnum                ; see if numeric
(1) 1100/    1B53 : CB 1B 65                       lbnf  atof_dn5              ; jump if not
(1) 1101/    1B56 : 8C                             glo   R12                    ; make copy of exponent
(1) 1102/    1B57 : 52                             str   r2
(1) 1103/    1B58 : F6                             shr                         ; multiply by 2
(1) 1104/    1B59 : F6                             shr                         ; by 4
(1) 1105/    1B5A : F4                             add                         ; by 5
(1) 1106/    1B5B : F6                             shr                         ; by 10
(1) 1107/    1B5C : 52                             str   r2                    ; put here for add
(1) 1108/    1B5D : 4F                             lda   R15                    ; recover number
(1) 1109/    1B5E : FF 30                          smi   '0'                   ; convert to binary
(1) 1110/    1B60 : F4                             add                         ; add with total
(1) 1111/    1B61 : AC                             plo   R12                    ; copy back to R12
(1) 1112/    1B62 : C0 1B 4F                       lbr   atof_lp5              ; loop back until done reading exponent
(1) 1113/    1B65 : 8C                  atof_dn5:  glo   R12                    ; see if done
 AS V1.42 Beta [Bld 87] - source file factorial.asm(LCC1802fp.inc) - page 44 - 4/12/2013 12:43:12


(1) 1114/    1B66 : C2 1B 95                       lbz   atof_end              ; jump if so
(1) 1115/    1B69 : 2C                             dec   R12                    ; otherwise decrement count
(1) 1116/    1B6A : 8C                             glo   R12                    ; save count
(1) 1117/    1B6B : 73                             stxd
(1) 1118/    1B6C : 9C                             ghi   R12                    ; save sign
(1) 1119/    1B6D : 73                             stxd
(1) 1120/    1B6E : 8F                             glo   R15
(1) 1121/    1B6F : 73                             stxd
(1) 1122/    1B70 : 9F                             ghi   R15
(1) 1123/    1B71 : 73                             stxd
(1) 1124/    1B72 : F8 41                          ldi   041h                  ; setup 10.0
(1) 1125/    1B74 : BA                             phi   R10
(1) 1126/    1B75 : F8 20                          ldi   020h
(1) 1127/    1B77 : AA                             plo   R10
(1) 1128/    1B78 : F8 00                          ldi   0
(1) 1129/    1B7A : BB                             phi   FB
(1) 1130/    1B7B : AB                             plo   FB
(1) 1131/    1B7C : 9C                             ghi   R12
(1) 1132/    1B7D : C2 1B 86                       lbz   atof_div              ; jump if negative
(1) 1133/    1B80 : (MACRO)                        Ccall fp_mul                 ; multiply by 10
(1) 1134/    1B83 : C0 1B 89                       lbr   atof_go5              ; clean up call
(1) 1135/    1B86 : (MACRO)             atof_div:  Ccall fp_div                 ; divice by 10
(1) 1136/    1B89 : 60                  atof_go5:  irx                         ; recover variables
(1) 1137/    1B8A : 72                             ldxa
(1) 1138/    1B8B : BF                             phi   R15
(1) 1139/    1B8C : 72                             ldxa
(1) 1140/    1B8D : AF                             plo   R15
(1) 1141/    1B8E : 72                             ldxa
(1) 1142/    1B8F : BC                             phi   R12
(1) 1143/    1B90 : F0                             ldx
(1) 1144/    1B91 : AC                             plo   R12
(1) 1145/    1B92 : C0 1B 65                       lbr   atof_dn5              ; loop until exponent is zero
(1) 1146/    1B95 :                     atof_end:
(1) 1147/    1B95 : 12                  	   inc	r2	;wjr release work area
(1) 1148/    1B96 : (MACRO)             	   popr R13	;wjr restore param regs
(1) 1149/    1B9A : (MACRO)             	   popr R12	;wjr
(1) 1150/    1B9E : (MACRO)             	   popr	F7	;wjr restore c variable
(1) 1151/    1BA2 : (MACRO)             	   Cretn
(1) 1152/    1BA3 : 00 00               scratch:   db	00,00
     977/    1BA5 :                     	include IO1802.inc
(1)    1/    1BA5 :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/    1BA5 :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/    1BA5 :                     	align 64
(1)    4/    1BC0 :                     _putc:
(1)    5/    1BC0 :                     _out5:	
(1)    6/    1BC0 : 8C                  	glo	regArg1
(1)    7/    1BC1 : 22                  	dec	sp
(1)    8/    1BC2 : 52                  	str	sp
(1)    9/    1BC3 : 65                  	out	5
(1)   10/    1BC4 : (MACRO)             	Cretn
(1)   11/    1BC5 :                     _inp:		;raw port input
(1)   12/    1BC5 :                     		;stores a small tailored program on the stack and executes it
(1)   13/    1BC5 : 22                  	dec	sp	;work backwards
(1)   14/    1BC6 : F8 D3               	ldi	0xD3	;return instruction
(1)   15/    1BC8 : 73                  	stxd		
(1)   16/    1BC9 : 8C                  	glo	regarg1	;get the port number
(1)   17/    1BCA : FA 07               	ani	0x07	;clean it
(1)   18/    1BCC : 32 DC               	bz	+	; inp(0) isn't valid
(1)   19/    1BCE : F9 68               	ori	0x68	;make it an input instruction
(1)   20/    1BD0 : 73                  	stxd		;store it for execution
 AS V1.42 Beta [Bld 87] - source file factorial.asm(IO1802.inc) - page 45 - 4/12/2013 12:43:12


(1)   21/    1BD1 : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   22/    1BD5 : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   23/    1BD6 : D8                  	sep	rt1	;execute it
(1)   24/    1BD7 :                     ;we will come back to here with the input byte in D
(1)   25/    1BD7 : 12                  	inc	sp	;step over the work area
(1)   26/    1BD8 : AF                  	plo	retVal	;save it to return
(1)   27/    1BD9 : F8 00               	ldi	0
(1)   28/    1BDB : BF                  	phi	retval	;clear top byte
(1)   29/    1BDC : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   30/    1BDD : 12                  	inc	sp	;and the D3
(1)   31/    1BDE : (MACRO)             	Cretn		;and we're done
(1)   32/    1BDF :                     	
(1)   33/    1BDF :                     _out:		;raw port output
(1)   34/    1BDF :                     		;stores a small tailored program on the stack and executes it
(1)   35/    1BDF : 22                  	dec	sp	;work backwards
(1)   36/    1BE0 : F8 D3               	ldi	0xD3	;return instruction
(1)   37/    1BE2 : 73                  	stxd		
(1)   38/    1BE3 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the inp instruction
(1)   39/    1BE7 : 8C                  	glo	regarg1	;get the port number
(1)   40/    1BE8 : FA 07               	ani	0x07	;clean it
(1)   41/    1BEA : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   42/    1BEC : 73                  	stxd		;store it for execution
(1)   43/    1BED : 8D                  	glo	regarg2	;get the byte to be written
(1)   44/    1BEE : 52                  	str	sp	;store it where sp points
(1)   45/    1BEF : D8                  	sep	rt1	;execute it
(1)   46/    1BF0 :                     ;we will come back to here with sp stepped up by one
(1)   47/    1BF0 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   48/    1BF1 : 12                  	inc	sp	;and the D3
(1)   49/    1BF2 : (MACRO)             	Cretn		;and we're done
(1)   50/    1BF3 :                     	
(1)   51/    1BF3 :                     	
     978/    1BF3 :                     
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 46 - 4/12/2013 12:43:12


  symbol table (* = unused):
  ------------------------

 ADD_A1NZ :                    1707 C |  ADD_A2NZ :                    1718 C |
 ADD_FNL :                     17BF C |  ADD_LP1 :                     1762 C |
 ADD_LP1DN :                   1777 C |  ADD_NM :                      1786 C |
 ADD_NO :                      17A8 C |  ADD_NS :                      1750 C |
 ADD_NX :                      17EB C |  ADD_NZ :                      17DD C |
*ARCHITECTURE :  i386-unknown-win32 - |  ATOF_DIV :                    1B86 C |
 ATOF_DN3 :                    1AA8 C |  ATOF_DN4 :                    1B12 C |
 ATOF_DN5 :                    1B65 C |  ATOF_END :                    1B95 C |
 ATOF_EXP :                    1B37 C |  ATOF_GO1 :                    1A30 C |
 ATOF_GO5 :                    1B89 C |  ATOF_LP1 :                    1A36 C |
 ATOF_LP2 :                    1A8C C |  ATOF_LP3 :                    1AC5 C |
 ATOF_LP4 :                    1AE3 C |  ATOF_LP5 :                    1B4F C |
 ATOF_LPX :                    1A77 C |  ATOF_N :                      1B48 C |
 ATOF_NC4 :                    1B0B C |  ATOF_NDP :                    1A6E C |
 ATOF_NM :                     1A26 C |  ATOF_NO1 :                    1A67 C |
 ATOF_NO4 :                    1AF4 C |  ATOF_NZ :                     1AC2 C |
 ATOF_P :                      1B45 C | *BIGENDIAN :                      0 - |
 BITLOOP161 :                  13B8 C | *BRANCHEXT :                      0 - |
*CASESENSITIVE :                  0 - |  CHECK_SUB159 :                1296 C |
 CKNEXT161 :                   1407 C |  CKTOP161 :                    13A3 C |
 CLRLP161 :                    1394 C | *CONSTPI :        3.141592653589793 - |
 CVFI4 :                       1600 C |  CVIF4 :                       1500 C |
*DATE :                   4/12/2013 - |  DCKLP161 :                    13BB C |
 DIVLOOP16_16156 :             1152 C | *DIVSETBIT16_16156 :           1184 C |
 DIVSKIP16_16156 :             1181 C |  DIVSKIPCLEAR16_16156 :        1188 C |
 DIVSKIPFINALADD16_16156 :     119A C |  DIVSUB16_16156 :              1173 C |
 DIV_A1NZ :                    1809 C |  DIV_A2NZ :                    1827 C |
 DIV_GO :                      188E C |  DIV_GO1 :                     187B C |
 DIV_LP :                      1868 C |  DIV_NOPE :                    18C9 C |
 DIV_Z :                       18DB C |  DNOADD161 :                   13C3 C |
 DONE157 :                     11D3 C |  DONE160 :                     1374 C |
 DONE161 :                     1411 C |  DONE167 :                     156F C |
 DONE168 :                     1661 C |  DSHLP161 :                    13D7 C |
 ENDLP158 :                    1261 C |  F7 :                             7 - |
 F9 :                             9 - |  FAILS :                       166E C |
*FALSE :                          0 - |  FB :                             B - |
 FP_ADD :                      16EE C |  FP_ADD_12 :                   168C C |
 FP_ATOF :                     1A12 C |  FP_DIV :                      17F8 C |
 FP_GETEXP :                   16DC C |  FP_GETSGN :                   16E7 C |
 FP_MUL :                      18EB C |  FP_SC_CLN :                   16C0 C |
 FP_SC_UP :                    16B0 C |  FP_SHL_1 :                    167F C |
 FP_SHR_1 :                    1672 C |  FP_SHR_FD :                   16A3 C |
 FP_SUB :                      17F1 C | *FULLPMMU :                       1 - |
 F_ISNUM :                     1662 C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
 L1 :                            AB C | *L10 :                          1A4 C |
 L100 :                         FDA C | *L102 :                        103D C |
 L103 :                        1019 C |  L104 :                        1028 C |
 L11 :                          187 C | *L12 :                          187 C |
 L14 :                          189 C | *L15 :                          1CE C |
 L16 :                          1B3 C |  L17 :                          1B5 C |
*L19 :                          217 C |  L2 :                            63 C |
 L20 :                          1E3 C |  L21 :                          202 C |
*L23 :                          59B C |  L24 :                          34B C |
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 47 - 4/12/2013 12:43:12


 L25 :                          374 C |  L26 :                         1054 C |
 L27 :                         1050 C |  L28 :                          374 C |
 L30 :                          3B8 C |  L32 :                          58F C |
*L34 :                          75C C |  L35 :                          67A C |
 L36 :                          68A C |  L37 :                          693 C |
 L38 :                          734 C | *L4 :                           164 C |
 L40 :                          69A C | *L41 :                          69A C |
 L43 :                          6A7 C |  L44 :                          71F C |
 L47 :                          6DC C | *L48 :                          83B C |
 L49 :                          7F5 C |  L5 :                            D8 C |
*L51 :                          889 C | *L52 :                          8E9 C |
*L53 :                          95C C | *L54 :                          9EF C |
 L55 :                          9CA C |  L56 :                          9EF C |
*L57 :                          A6D C | *L58 :                          EA9 C |
 L59 :                          AB5 C | *L6 :                           11A C |
 L60 :                          E88 C |  L62 :                          AF1 C |
 L63 :                          E88 C |  L64 :                          E77 C |
 L65 :                          E88 C |  L67 :                          BEF C |
 L68 :                          C0C C |  L69 :                          C2D C |
 L70 :                          C4F C |  L71 :                          CBD C |
 L72 :                          E27 C |  L74 :                          D1B C |
 L76 :                          D4E C |  L77 :                          E22 C |
 L78 :                          E27 C |  L79 :                          E77 C |
 L81 :                          E5B C |  L83 :                          B81 C |
 L84 :                          B9C C |  L85 :                          B6D C |
*L87 :                          BD4 C | *L88 :                          EE7 C |
 L89 :                         1046 C |  L9 :                          1058 C |
 L90 :                          EE4 C | *L91 :                          EE4 C |
*L93 :                          F8F C |  L94 :                          F21 C |
 L95 :                          F6E C |  L97 :                          F8B C |
*L98 :                          FEF C |  L99 :                          FC4 C |
 LCC1802INIT :                 1067 C | *LISTON :                         1 - |
 LOOP158 :                     120F C |  LSH168 :                      162B C |
*MACEXP :                         0 - |  MEMADDR :                        E - |
 MLOOP159 :                    1277 C | *MOMCPU :                      1802 - |
*MOMCPUNAME :                  1802 - |  MSLP154 :                     111E C |
 MULTLOOP16_16155 :            112B C |  MULTSKIP16_16155 :            113D C |
 MUL_DN :                      19BA C |  MUL_GO1 :                     1942 C |
 MUL_LP1 :                     1932 C |  MUL_LP2 :                     19CD C |
 MUL_LP2A :                    19E0 C |  MUL_LP3 :                     19E9 C |
 MUL_LP3A :                    19FC C |  MUL_LP4 :                     1A0D C |
 MUL_NO :                      198F C |  MUL_NXT1 :                    19E4 C |
*NESTMAX :                      100 - |  NORESTORE158 :                125D C |
 NXT167 :                      1530 C | *PACKING :                        0 - |
*PADDING :                        1 - | *PASSES :                      166B C |
 POS1157 :                     11B3 C |  POS1160 :                     1326 C |
 POS2157 :                     11C3 C |  POS2160 :                     134D C |
 R0 :                             0 - |  R1 :                             1 - |
 R10 :                            A - |  R11 :                            B - |
 R12 :                            C - |  R13 :                            D - |
 R14 :                            E - |  R15 :                            F - |
 R2 :                             2 - |  R3 :                             3 - |
*R4 :                             4 - | *R5 :                             5 - |
 R6 :                             6 - |  R7 :                             7 - |
 R8 :                             8 - |  R9 :                             9 - |
 RCALL :                          4 - |  REGARG1 :                        C - |
 REGARG2 :                        D - | *RELAXED :                        1 - |
 RETADDR :                        6 - |  RETVAL :                         F - |
 RL0 :                            1 - |  RL10 :                           B - |
 RL12 :                           D - |  RL8 :                            9 - |
 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 48 - 4/12/2013 12:43:12


 RP1P2 :                          D - |  RPC :                            3 - |
 RRET :                           5 - |  RT1 :                            8 - |
*RT2 :                            9 - |  RWORK :                          E - |
 SCRATCH :                     1BA3 C |  SETSGN167 :                   1568 C |
 SGNPOS167 :                   1539 C |  SHDN167 :                     155F C |
 SHIFT159 :                    12AE C |  SHL167 :                      154B C |
 SHR168 :                      1619 C |  SIGN168 :                     163B C |
 SP :                             2 - | *TIME :                    12:43:12 - |
*TRUE :                           1 - |  UPNXT161 :                    13F0 C |
*VERSION :                     142F - |  _00000146 :                   1081 C |
 _CALL :                       1101 C |  _DIE146 :                     1084 C |
 _DIVI2 :                      11A4 C |  _DIVI4 :                      1300 C |
 _DIVU2 :                      1149 C |  _DIVU4 :                      1200 C |
 _DUBDABX :                    1375 C | *_EXIT :                        EBE C |
 _FACT :                          3 C |  _FTOA :                        260 C |
*_INP :                        1BC5 C |  _ITOA :                        5B8 C |
 _LTOA :                        771 C |  _MAIN :                         B8 C |
*_MEMCMP :                      EEC C | *_MEMCPY :                      F9E C |
*_MEMSET :                      FFC C | *_MODI2 :                      1095 C |
*_MODI4 :                      141E C | *_MODU2 :                      108D C |
*_MODU4 :                      1412 C |  _MULT_NUMS :                   240 C |
*_MULU2 :                      1123 C |  _MULU4 :                      1266 C |
*_ONEMS :                      111C C |  _OUT :                        1BDF C |
*_OUT4 :                       109D C | *_OUT5 :                       1BC0 C |
 _PRINTF :                      A72 C |  _PRINTFLT :                    8F2 C |
 _PRINTINT :                    850 C |  _PRINTLINT :                   892 C |
 _PRINTSTR :                    1D3 C |  _PUTC :                       1BC0 C |
 _PUTX :                        9F4 C |  _PUTXN :                       965 C |
 _RETURN :                     1112 C |  _ROUND_NUMS :                  220 C |
*_SETQOFF :                    108B C | *_SETQON :                     1089 C |
 _STRCPY :                      175 C |  _STRLEN :                      1A7 C |
 __FORW6 :                     1BDC C | *__FORW7 :                     1BF0 C |

    298 symbols
     71 unused symbols

 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 49 - 4/12/2013 12:43:12


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU4                                  | ALU4I                                
BLKCPY                                | CCALL                                
CPY1                                  | CPY2                                 
CPY4                                  | CRETN                                
DECM                                  | INC4                                 
INCM                                  | JCF4                                 
JCI2                                  | JCI2I                                
JCI4                                  | JCU2                                 
JCU2I                                 | JCU4                                 
JEQI2                                 | JEQI4                                
JEQU2I                                | JNEU2                                
JNEU2I                                | JNEU4                                
JNI2I                                 | JNU2I                                
JNZU2                                 | JUMPV                                
JZU2                                  | LD1                                  
LD2                                   | LD2Z                                 
LD4                                   | LDA2                                 
LDAD                                  | LDAX                                 
LDI4                                  | LDIREG                               
LDN1                                  | NEGI2                                
NEGI4                                 | POPR                                 
PUSHR                                 | RELEASE                              
RELEASEL                              | RELEASES                             
RESERVE                               | RESERVEL                             
RESERVES                              | RLDMI                                
SAVMI                                 | SEXT                                 
SEXT4                                 | SHL2                                 
SHL2I                                 | SHL2R                                
SHL4                                  | SHL4I                                
SHL4R                                 | SHLC4                                
SHRC4                                 | SHRI2                                
SHRI2I                                | SHRI2R                               
SHRI4                                 | SHRI4I                               
SHRI4R                                | SHRU2                                
SHRU2I                                | SHRU2R                               
SHRU4                                 | SHRU4I                               
SHRU4R                                | ST1                                  
ST2                                   | ST4                                  
STR1                                  | ZEXT                                 
ZEXT4                                 |

     81 macros

 AS V1.42 Beta [Bld 87] - source file factorial.asm - page 50 - 4/12/2013 12:43:12


  codepages:
  ----------

STANDARD (0 changed characters)


0.24 seconds assembly time

   3503 lines source file
   8897 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
