 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 1 - 4/4/2013 16:39:08


       1/       0 :                     ; generated by lcc-xr18fl $Version: 4.0 - XR18FL - St. Judy's Compiler $ on Thu Apr 04 16:39:00 2013
       2/       0 :                     
       3/       0 : =2H                 SP:	equ	2 ;stack pointer
       4/       0 : =EH                 memAddr: equ	14
       5/       0 : =6H                 retAddr: equ	6
       6/       0 : =FH                 retVal:	equ	15
       7/       0 : =CH                 regArg1: equ	12
       8/       0 : =DH                 regArg2: equ	13
(1)  830/       0 :                     	listing	on
(1)  831/       0 : C0 0F 3A            	lbr	lcc1802Init
(1)  832/       3 :                     	
      11/       3 :                     	listing on
      12/       3 :                     	align 4
      13/       4 :                     _round_nums:
      14/       4 : 3F 00 00 00         	dd 0x3f000000
      15/       8 : 3D 4C CC CD         	dd 0x3d4ccccd
      16/       C : 3B A3 D7 0A         	dd 0x3ba3d70a
      17/      10 : 3A 03 12 6F         	dd 0x3a03126f
      18/      14 : 38 51 B7 17         	dd 0x3851b717
      19/      18 : 36 A7 C5 AC         	dd 0x36a7c5ac
      20/      1C : 35 06 37 BD         	dd 0x350637bd
      21/      20 : 33 56 BF 95         	dd 0x3356bf95
      22/      24 :                     	align 4
      23/      24 :                     _mult_nums:
      24/      24 : 3F 80 00 00         	dd 0x3f800000
      25/      28 : 41 20 00 00         	dd 0x41200000
      26/      2C : 42 C8 00 00         	dd 0x42c80000
      27/      30 : 44 7A 00 00         	dd 0x447a0000
      28/      34 : 46 1C 40 00         	dd 0x461c4000
      29/      38 : 47 C3 50 00         	dd 0x47c35000
      30/      3C : 49 74 24 00         	dd 0x49742400
      31/      40 : 4B 18 96 80         	dd 0x4b189680
      32/      44 :                     	align 4
      33/      44 :                     _f1:
      34/      44 : 47 C3 50 00         	dd 0x47c35000
      35/      48 :                     _main:
      36/      48 : (MACRO)             	reserve 8
      37/      50 :                     ;void main(){
      38/      50 :                     ;	printf("%f\n",f1);
      39/      50 : (MACRO)             	ldaD R12,L2; reg:acon
      40/      56 : (MACRO)             	ld4 RL10,'D',(_f1),0;INDIRF4(addr)
      41/      64 : (MACRO)             	st4 RL10,'O',sp,(4); arg+f**
      42/      77 : (MACRO)             	Ccall _printf
      43/      7A :                     ;	printf("done\n");
      44/      7A : (MACRO)             	ldaD R12,L3; reg:acon
      45/      80 : (MACRO)             	Ccall _printf
      46/      83 :                     ;}
      47/      83 :                     L1:
      48/      83 : (MACRO)             	release 8
      49/      8B : (MACRO)             	Cretn
      50/      8C :                     
      51/      8C :                     _strcpy:
      52/      8C : (MACRO)             	reserve 2
      53/      8E :                     ;{
      54/      8E :                     ;	char *save = to;
      55/      8E : (MACRO)             	st2 R12,'O',sp,(-4+4); ASGNP2
      56/      9B :                     ;	for (; (*to = *from) != 0; ++from, ++to);
      57/      9B : C0 00 A0            	lbr L8
      58/      9E :                     L5:
      59/      9E :                     L6:
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 2 - 4/4/2013 16:39:08


      60/      9E : (MACRO)             	incm R13,1
      61/      9F : (MACRO)             	incm R12,1
      62/      A0 :                     L8:
      63/      A0 : (MACRO)             	ldn1 R11,R13;reg:  INDIRU1(indaddr)
      64/      A2 : (MACRO)             	str1 R11,R12; ASGNU1(indaddr,reg)
      65/      A4 : (MACRO)             	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
      66/      A7 : (MACRO)             	jnzU2 r11,L5; NE 0
      67/      AF :                     ;	return(save);
      68/      AF : (MACRO)             	ld2 R15,'O',sp,(-4+4);reg:  INDIRP2(addr)
      69/      BB :                     L4:
      70/      BB : (MACRO)             	release 2
      71/      BD : (MACRO)             	Cretn
      72/      BE :                     
      73/      BE :                     _strlen:
      74/      BE : (MACRO)             	reserve 0; save room for local variables
      75/      BE : (MACRO)             	pushr r7
      76/      C3 : (MACRO)             	reserve 0; save room for outgoing arguments
      77/      C3 :                     ;{
      78/      C3 :                     ;	unsigned int slen = 0 ;
      79/      C3 : (MACRO)             	ld2z R7
      80/      C7 : C0 00 CC            	lbr L11
      81/      CA :                     L10:
      82/      CA :                     ;	while (*str != 0) {
      83/      CA :                     ;      slen++ ;
      84/      CA : (MACRO)             	incm R7,1
      85/      CB :                     ;      str++ ;
      86/      CB : (MACRO)             	incm R12,1
      87/      CC :                     ;   }
      88/      CC :                     L11:
      89/      CC :                     ;	while (*str != 0) {
      90/      CC : (MACRO)             	ld1 R11,'O',R12,0
      91/      D6 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
      92/      D9 : (MACRO)             	jnzU2 r11,L10; NE 0
      93/      E1 :                     ;   return slen;
      94/      E1 : (MACRO)             	cpy2 R15,R7 ;LOADU2(reg)*
      95/      E5 :                     L9:
      96/      E5 : (MACRO)             	release 0; release room for outgoing arguments
      97/      E5 : (MACRO)             	popr r7
      98/      E9 : (MACRO)             	release 0; release room for local variables 
      99/      E9 : (MACRO)             	Cretn
     100/      EA :                     
     101/      EA :                     _printstr:
     102/      EA : (MACRO)             	reserve 0; save room for local variables
     103/      EA : (MACRO)             	pushr r7
     104/      EF : (MACRO)             	reserve 4; save room for outgoing arguments
     105/      F3 : (MACRO)             	cpy2 r7,r12; function(2055) 1
     106/      F7 :                     ;void printstr(char *ptr){
     107/      F7 : C0 01 19            	lbr L15
     108/      FA :                     L14:
     109/      FA :                     ;    while(*ptr) out(5,*ptr++);
     110/      FA : (MACRO)             	ldaD R12,5; reg:acon
     111/     100 : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg)
     112/     104 : (MACRO)             	cpy2 R7,R11
     113/     108 : (MACRO)             	incm R7,1
     114/     109 : (MACRO)             	ld1 R13,'O',R11,0
     115/     113 : (MACRO)             	zExt R13 ;CVUI2: widen unsigned char to signed int (zero extend)
     116/     116 : (MACRO)             	Ccall _out
     117/     119 :                     L15:
     118/     119 : (MACRO)             	ld1 R11,'O',R7,0
     119/     123 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 3 - 4/4/2013 16:39:08


     120/     126 : (MACRO)             	jnzU2 r11,L14; NE 0
     121/     12E :                     ;}
     122/     12E :                     L13:
     123/     12E : (MACRO)             	release 4; release room for outgoing arguments
     124/     132 : (MACRO)             	popr r7
     125/     136 : (MACRO)             	release 0; release room for local variables 
     126/     136 : (MACRO)             	Cretn
     127/     137 :                     
     128/     137 :                     _ftoa:
     129/     137 : (MACRO)             	reserve 62; save room for local variables
     130/     141 : (MACRO)             	pushr r0
     131/     146 : (MACRO)             	pushr r1
     132/     14B : (MACRO)             	pushr r7
     133/     150 : (MACRO)             	reserve 8; save room for outgoing arguments
     134/     158 : (MACRO)             	cpy4 RL0,RL12; halfbaked&floaty
     135/     160 : (MACRO)             	ld2 R7,'O',sp,(6+78); reg:INDIRU2(addr)
     136/     16C :                     ;{
     137/     16C :                     ;   char *output = outbfr ;
     138/     16C : (MACRO)             	ld2 R11,'O',sp,(4+78);reg:  INDIRP2(addr)
     139/     178 : (MACRO)             	st2 R11,'O',sp,(-4+78); ASGNP2
     140/     185 :                     ;   if (flt < 0.0) {
     141/     185 : (MACRO)             	ld4 RL10,'D',(L20),0;INDIRF4(addr)
     142/     193 : (MACRO)             	jcF4 RL0,RL10,lbdf,L18;GEF4(reg,reg) - reverse test
     143/     1D8 :                     ;      *output++ = '-' ;
     144/     1D8 : (MACRO)             	ld2 R11,'O',sp,(-4+78);reg:  INDIRP2(addr)
     145/     1E4 : (MACRO)             	cpy2 R10,R11
     146/     1E8 : (MACRO)             	incm R10,1
     147/     1E9 : (MACRO)             	st2 R10,'O',sp,(-4+78); ASGNP2
     148/     1F6 : (MACRO)             	ldaD R10,45; reg:acon
     149/     1FC : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     150/     1FE :                     ;      flt *= -1.0 ;
     151/     1FE : (MACRO)             	ld4 RL8,'D',(L21),0;INDIRF4(addr)
     152/     20C : (MACRO)             	cpy4 RL10,RL0; LOADU4(reg)
     153/     214 : (MACRO)             	Ccall fp_mul ;MULF4(reg,reg)
     154/     217 : (MACRO)             	cpy4 RL0,RL8; LOADU4(reg)
     155/     21F :                     ;   } else {
     156/     21F : C0 02 4B            	lbr L19
     157/     222 :                     L18:
     158/     222 :                     ;      if (use_leading_plus) {
     159/     222 : C0 02 4B            	lbr L22
     160/     225 :                     ;         *output++ = '+' ;
     161/     225 : (MACRO)             	ld2 R11,'O',sp,(-4+78);reg:  INDIRP2(addr)
     162/     231 : (MACRO)             	cpy2 R10,R11
     163/     235 : (MACRO)             	incm R10,1
     164/     236 : (MACRO)             	st2 R10,'O',sp,(-4+78); ASGNP2
     165/     243 : (MACRO)             	ldaD R10,43; reg:acon
     166/     249 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     167/     24B :                     ;      }
     168/     24B :                     L22:
     169/     24B :                     ;   }
     170/     24B :                     L19:
     171/     24B :                     ;   if (dec_digits < 8) {
     172/     24B : (MACRO)             	jcI2I r7,8,lbdf,L24; GE is flipped test from LT
     173/     25C :                     ;      flt += round_nums[dec_digits] ;
     174/     25C : (MACRO)             	cpy4 RL8,RL0; LOADU4(reg)
     175/     264 : (MACRO)             	cpy2 R11,R7
     176/     268 : (MACRO)             	shl2I R11,2
     177/     274 : (MACRO)             	ld4 RL10,'O',R11,(_round_nums);INDIRF4(addr)
     178/     284 : (MACRO)             	Ccall fp_add ;ADDF4(reg,reg)
     179/     287 : (MACRO)             	cpy4 RL0,RL8; LOADU4(reg)
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 4 - 4/4/2013 16:39:08


     180/     28F :                     ;   }
     181/     28F :                     L24:
     182/     28F :                     ;	mult=mult_nums[dec_digits];
     183/     28F : (MACRO)             	cpy2 R11,R7
     184/     293 : (MACRO)             	shl2I R11,2
     185/     29F : (MACRO)             	ld4 RL10,'O',R11,(_mult_nums);INDIRF4(addr)
     186/     2AF : (MACRO)             	st4 RL10,'O',sp,(-12+78); ASGNF4(addr,reg)
     187/     2C2 :                     ;   wholeNum = flt;
     188/     2C2 : (MACRO)             	cpy4 RL8,RL0; LOADU4(reg)
     189/     2CA : (MACRO)             	ccall cvfi4; CVFI4(reg) convert float to long
     190/     2CD : (MACRO)             	st4 RL8,'O',sp,(-8+78)
     191/     2E0 :                     ;   decimalNum = ((flt - wholeNum) * mult);
     192/     2E0 : (MACRO)             	cpy4 RL8,RL0; LOADU4(reg)
     193/     2E8 : (MACRO)             	st4 RL8,'O',sp,(-64+78); ASGNF4(addr,reg)
     194/     2FB : (MACRO)             	ld4 RL8,'O',sp,(-8+78);reg:  INDIRI4(addr)
     195/     30B : (MACRO)             	ccall cvif4; CVIF4(reg) convert long to float
     196/     30E : (MACRO)             	cpy4 RL10,RL8; LOADU4(reg)
     197/     316 : (MACRO)             	ld4 RL8,'O',sp,(-64+78);INDIRF4(addr)
     198/     326 : (MACRO)             	Ccall fp_sub ;SUBF4(reg,reg)
     199/     329 : (MACRO)             	ld4 RL10,'O',sp,(-12+78);INDIRF4(addr)
     200/     339 : (MACRO)             	Ccall fp_mul ;MULF4(reg,reg)
     201/     33C : (MACRO)             	ccall cvfi4; CVFI4(reg) convert float to long
     202/     33F : (MACRO)             	st4 RL8,'O',sp,(-16+78)
     203/     352 :                     ;   strcpy(output,dubdabx(wholeNum,output,1));
     204/     352 : (MACRO)             	ld4 Rp1p2,'O',sp,(-8+78);reg:  INDIRI4(addr)
     205/     362 : (MACRO)             	ld2 R11,'O',sp,(-4+78);reg:  INDIRP2(addr)
     206/     36E : (MACRO)             	st2 r11,'O',sp,(4); arg+f**
     207/     37B : (MACRO)             	ldaD R11,1; reg:acon
     208/     381 : (MACRO)             	st2 r11,'O',sp,(6); arg+f**
     209/     38E : (MACRO)             	Ccall _dubdabx
     210/     391 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     211/     395 : (MACRO)             	ld2 R12,'O',sp,(-4+78);reg:  INDIRP2(addr)
     212/     3A1 : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     213/     3A5 : (MACRO)             	Ccall _strcpy
     214/     3A8 :                     ;   output+=strlen(output);
     215/     3A8 : (MACRO)             	ld2 R12,'O',sp,(-4+78);reg:  INDIRP2(addr)
     216/     3B4 : (MACRO)             	Ccall _strlen;CALLU2(ar)*
     217/     3B7 : (MACRO)             	cpy2 R11,R15 ;LOADU2(reg)*
     218/     3BB : (MACRO)             	ld2 R10,'O',sp,(-4+78);reg:  INDIRP2(addr)
     219/     3C7 : (MACRO)             	alu2 R11,R11,R10,add,adc
     220/     3D3 : (MACRO)             	st2 R11,'O',sp,(-4+78); ASGNP2
     221/     3E0 :                     ;   if (dec_digits > 0) {
     222/     3E0 : (MACRO)             	jeqU2I r7,0,L26;EQU2(reg,con)
     223/     3EC :                     ;		*output++ = '.' ;
     224/     3EC : (MACRO)             	ld2 R11,'O',sp,(-4+78);reg:  INDIRP2(addr)
     225/     3F8 : (MACRO)             	cpy2 R10,R11
     226/     3FC : (MACRO)             	incm R10,1
     227/     3FD : (MACRO)             	st2 R10,'O',sp,(-4+78); ASGNP2
     228/     40A : (MACRO)             	ldaD R10,46; reg:acon
     229/     410 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     230/     412 :                     ;		strcpy(output,dubdabx(decimalNum,output,dec_digits));
     231/     412 : (MACRO)             	ld4 Rp1p2,'O',sp,(-16+78);reg:  INDIRI4(addr)
     232/     422 : (MACRO)             	ld2 R11,'O',sp,(-4+78);reg:  INDIRP2(addr)
     233/     42E : (MACRO)             	st2 r11,'O',sp,(4); arg+f**
     234/     43B : (MACRO)             	cpy2 R11,R7 ;LOADI2(reg)
     235/     43F : (MACRO)             	st2 r11,'O',sp,(6); arg+f**
     236/     44C : (MACRO)             	Ccall _dubdabx
     237/     44F : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     238/     453 : (MACRO)             	ld2 R12,'O',sp,(-4+78);reg:  INDIRP2(addr)
     239/     45F : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 5 - 4/4/2013 16:39:08


     240/     463 : (MACRO)             	Ccall _strcpy
     241/     466 :                     ;	}
     242/     466 :                     L26:
     243/     466 :                     ;   return outbfr;
     244/     466 : (MACRO)             	ld2 R15,'O',sp,(4+78);reg:  INDIRP2(addr)
     245/     472 :                     L17:
     246/     472 : (MACRO)             	release 8; release room for outgoing arguments
     247/     47A : (MACRO)             	popr r7
     248/     47E : (MACRO)             	popr r1
     249/     482 : (MACRO)             	popr r0
     250/     486 : (MACRO)             	release 62; release room for local variables 
     251/     48E : (MACRO)             	Cretn
     252/     48F :                     
     253/     48F :                     _itoa:
     254/     48F : (MACRO)             	reserve 4; save room for local variables
     255/     493 : (MACRO)             	pushr r0
     256/     498 : (MACRO)             	pushr r1
     257/     49D : (MACRO)             	pushr r7
     258/     4A2 : (MACRO)             	reserve 4; save room for outgoing arguments
     259/     4A6 : (MACRO)             	st2 r12,'O',sp,(16); flag1 
     260/     4B3 : (MACRO)             	st2 r13,'O',sp,(18); flag1 
     261/     4C0 :                     ;char * itoa(int s, char *buffer){ //convert an integer to printable ascii in a buffer supplied by the caller
     262/     4C0 :                     ;	unsigned int flag=0;
     263/     4C0 : (MACRO)             	ld2z R11
     264/     4C4 : (MACRO)             	st2 R11,'O',sp,(-4+16); ASGNU2(addr,reg)*
     265/     4D1 :                     ;	char * bptr; bptr=buffer;
     266/     4D1 : (MACRO)             	ld2 R11,'O',sp,(2+16);reg:  INDIRP2(addr)
     267/     4DD : (MACRO)             	st2 R11,'O',sp,(-6+16); ASGNP2
     268/     4EA :                     ;	if (s<0){
     269/     4EA : (MACRO)             	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
     270/     4F6 : (MACRO)             	jcI2I r11,0,lbdf,L29; GE is flipped test from LT
     271/     507 :                     ;		*bptr='-';bptr++;
     272/     507 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     273/     513 : (MACRO)             	ldaD R10,45; reg:acon
     274/     519 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     275/     51B : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     276/     527 : (MACRO)             	incm R11,1
     277/     528 : (MACRO)             	st2 R11,'O',sp,(-6+16); ASGNP2
     278/     535 :                     ;		n=-s;
     279/     535 : (MACRO)             	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
     280/     541 : (MACRO)             	negI2 R11,R11 ;was alu2I R11,R11,0,sdi,sdbi
     281/     54A : (MACRO)             	cpy2 R1,R11 ;LOADU2(reg)*
     282/     54E :                     ;	} else{
     283/     54E : C0 05 61            	lbr L30
     284/     551 :                     L29:
     285/     551 :                     ;		n=s;
     286/     551 : (MACRO)             	ld2 R11,'O',sp,(0+16) ;reg:INDIRI2(addr)
     287/     55D : (MACRO)             	cpy2 R1,R11 ;LOADU2(reg)*
     288/     561 :                     ;	}
     289/     561 :                     L30:
     290/     561 :                     ;	k=10000;
     291/     561 : (MACRO)             	ldaD R7,10000; reg:acon
     292/     567 : C0 06 0B            	lbr L32
     293/     56A :                     L31:
     294/     56A :                     ;	while(k>0){
     295/     56A :                     ;		for(r=0;k<=n;r++,n-=k); // was r=n/k
     296/     56A : (MACRO)             	ld2z R0
     297/     56E : C0 05 7E            	lbr L37
     298/     571 :                     L34:
     299/     571 :                     L35:
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 6 - 4/4/2013 16:39:08


     300/     571 : (MACRO)             	incm R0,1
     301/     572 : (MACRO)             	alu2 R1,R1,R7,sm,smb
     302/     57E :                     L37:
     303/     57E : (MACRO)             	jcU2 r1,r7,lbdf,L34 ;LE is flipped test & operands
     304/     58B :                     ;		if (flag || r>0||k==1){
     305/     58B : (MACRO)             	ld2 R11,'O',sp,(-4+16); reg:INDIRU2(addr)
     306/     597 : (MACRO)             	jnzU2 r11,L41; NE 0
     307/     59F : (MACRO)             	jnzU2 r0,L41; NE 0
     308/     5A7 : (MACRO)             	jneU2I r7,1,L38; NE
     309/     5B3 :                     L41:
     310/     5B3 :                     ;			*bptr=('0'+r);bptr++;
     311/     5B3 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     312/     5BF : (MACRO)             	ldA2 R10,'O',R0,(48); reg:addr
     313/     5C7 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     314/     5C9 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     315/     5D5 : (MACRO)             	incm R11,1
     316/     5D6 : (MACRO)             	st2 R11,'O',sp,(-6+16); ASGNP2
     317/     5E3 :                     ;			flag='y';
     318/     5E3 : (MACRO)             	ldaD R11,121; reg:acon
     319/     5E9 : (MACRO)             	st2 R11,'O',sp,(-4+16); ASGNU2(addr,reg)*
     320/     5F6 :                     ;		}
     321/     5F6 :                     L38:
     322/     5F6 :                     ;		k=k/10;
     323/     5F6 : (MACRO)             	cpy2 R12,R7 ;LOADU2(reg)*
     324/     5FA : (MACRO)             	ldaD R13,10; reg:acon
     325/     600 : (MACRO)             	Ccall _divu2
     326/     603 : (MACRO)             	cpy2 R11,R15 ;LOADU2(reg)*
     327/     607 : (MACRO)             	cpy2 R7,R11 ;LOADU2(reg)*
     328/     60B :                     ;	}
     329/     60B :                     L32:
     330/     60B :                     ;	while(k>0){
     331/     60B : (MACRO)             	jnzU2 r7,L31; NE 0
     332/     613 :                     ;	*bptr='\0';
     333/     613 : (MACRO)             	ld2 R11,'O',sp,(-6+16);reg:  INDIRP2(addr)
     334/     61F : (MACRO)             	ldaD R10,0; reg:acon
     335/     625 : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     336/     627 :                     ;	return buffer;
     337/     627 : (MACRO)             	ld2 R15,'O',sp,(2+16);reg:  INDIRP2(addr)
     338/     633 :                     L28:
     339/     633 : (MACRO)             	release 4; release room for outgoing arguments
     340/     637 : (MACRO)             	popr r7
     341/     63B : (MACRO)             	popr r1
     342/     63F : (MACRO)             	popr r0
     343/     643 : (MACRO)             	release 4; release room for local variables 
     344/     647 : (MACRO)             	Cretn
     345/     648 :                     
     346/     648 :                     _ltoa:
     347/     648 : (MACRO)             	reserve 0; save room for local variables
     348/     648 : (MACRO)             	pushr r0
     349/     64D : (MACRO)             	pushr r1
     350/     652 : (MACRO)             	pushr r7
     351/     657 : (MACRO)             	reserve 8; save room for outgoing arguments
     352/     65F : (MACRO)             	cpy4 RL0,RL12; halfbaked
     353/     667 :                     ;char * ltoa(long s, char *buffer){ //convert a long integer to printable ascii in a buffer supplied by the caller
     354/     667 :                     ;	char* bptr=buffer;
     355/     667 : (MACRO)             	ld2 R7,'O',sp,(4+16);reg:  INDIRP2(addr)
     356/     673 :                     ;	if (s<0){
     357/     673 : (MACRO)             	ldI4 RL10,0 ;loading a long integer constant
     358/     67F : (MACRO)             	jcI4 RL0,RL10,lbdf,L43; GE is flipped test from LT
     359/     69B :                     ;		*bptr++='-';
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 7 - 4/4/2013 16:39:08


     360/     69B : (MACRO)             	cpy2 R11,R7 ;LOADP2(reg)
     361/     69F : (MACRO)             	cpy2 R7,R11
     362/     6A3 : (MACRO)             	incm R7,1
     363/     6A4 : (MACRO)             	ldaD R10,45; reg:acon
     364/     6AA : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     365/     6AC :                     ;		s=-s;
     366/     6AC : (MACRO)             	negI4 RL0,RL0 ;was alu4I RL0,RL0,0,sdi,sdbi
     367/     6CC :                     ;	}
     368/     6CC :                     L43:
     369/     6CC :                     ;	strcpy(bptr,dubdabx(s,bptr,1)); //uses assembler double-dabble routine
     370/     6CC : (MACRO)             	cpy4 Rp1p2,RL0; LOADI4*
     371/     6D4 : (MACRO)             	st2 r7,'O',sp,(4); arg+f**
     372/     6E1 : (MACRO)             	ldaD R11,1; reg:acon
     373/     6E7 : (MACRO)             	st2 r11,'O',sp,(6); arg+f**
     374/     6F4 : (MACRO)             	Ccall _dubdabx
     375/     6F7 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     376/     6FB : (MACRO)             	cpy2 R12,R7 ;LOADP2(reg)
     377/     6FF : (MACRO)             	cpy2 R13,R11 ;LOADP2(reg)
     378/     703 : (MACRO)             	Ccall _strcpy
     379/     706 :                     ;	return buffer;
     380/     706 : (MACRO)             	ld2 R15,'O',sp,(4+16);reg:  INDIRP2(addr)
     381/     712 :                     L42:
     382/     712 : (MACRO)             	release 8; release room for outgoing arguments
     383/     71A : (MACRO)             	popr r7
     384/     71E : (MACRO)             	popr r1
     385/     722 : (MACRO)             	popr r0
     386/     726 : (MACRO)             	release 0; release room for local variables 
     387/     726 : (MACRO)             	Cretn
     388/     727 :                     
     389/     727 :                     _printint:
     390/     727 : (MACRO)             	reserve 12
     391/     731 : (MACRO)             	st2 r12,'O',sp,(14); flag1 
     392/     73E :                     ;void printint(int s){ //print an integer
     393/     73E :                     ;	itoa(s,buffer);
     394/     73E : (MACRO)             	ld2 R12,'O',sp,(0+14) ;reg:INDIRI2(addr)
     395/     74A : (MACRO)             	ldA2 R13,'O',sp,(-10+14); reg:addr
     396/     752 : (MACRO)             	Ccall _itoa
     397/     755 :                     ;	printstr(buffer);
     398/     755 : (MACRO)             	ldA2 R12,'O',sp,(-10+14); reg:addr
     399/     75D : (MACRO)             	Ccall _printstr
     400/     760 :                     ;}
     401/     760 :                     L45:
     402/     760 : (MACRO)             	release 12
     403/     768 : (MACRO)             	Cretn
     404/     769 :                     
     405/     769 :                     _printlint:
     406/     769 : (MACRO)             	reserve 18
     407/     773 : (MACRO)             	st2 r12,'O',sp,(20); flag1 
     408/     780 : (MACRO)             	st2 r13,'O',sp,(22); flag1 
     409/     78D :                     ;void printlint(long s){ //print a long integer
     410/     78D :                     ;	printstr(ltoa(s,buffer));
     411/     78D : (MACRO)             	ld4 Rp1p2,'O',sp,(0+20);reg:  INDIRI4(addr)
     412/     79D : (MACRO)             	ldA2 R11,'O',sp,(-14+20); reg:addr
     413/     7A5 : (MACRO)             	st2 r11,'O',sp,(4); arg+f**
     414/     7B2 : (MACRO)             	Ccall _ltoa
     415/     7B5 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     416/     7B9 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     417/     7BD : (MACRO)             	Ccall _printstr
     418/     7C0 :                     ;}
     419/     7C0 :                     L46:
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 8 - 4/4/2013 16:39:08


     420/     7C0 : (MACRO)             	release 18
     421/     7C8 : (MACRO)             	Cretn
     422/     7C9 :                     
     423/     7C9 :                     _printflt:
     424/     7C9 : (MACRO)             	reserve 24
     425/     7D3 : (MACRO)             	st2 r12,'O',sp,(26); flag1 
     426/     7E0 : (MACRO)             	st2 r13,'O',sp,(28); flag1 
     427/     7ED :                     ;void printflt(float s){ //print a float
     428/     7ED :                     ;	printstr(ftoa(s,buffer,3));
     429/     7ED : (MACRO)             	ld4 Rp1p2,'O',sp,(0+26);INDIRF4(addr)
     430/     7FD : (MACRO)             	ldA2 R11,'O',sp,(-18+26); reg:addr
     431/     805 : (MACRO)             	st2 r11,'O',sp,(4); arg+f**
     432/     812 : (MACRO)             	ldaD R11,3; reg:acon
     433/     818 : (MACRO)             	st2 r11,'O',sp,(6); arg+f**
     434/     825 : (MACRO)             	Ccall _ftoa
     435/     828 : (MACRO)             	cpy2 R11,R15 ;LOADP2(reg)
     436/     82C : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     437/     830 : (MACRO)             	Ccall _printstr
     438/     833 :                     ;}
     439/     833 :                     L47:
     440/     833 : (MACRO)             	release 24
     441/     83B : (MACRO)             	Cretn
     442/     83C :                     
     443/     83C :                     _putxn:
     444/     83C : (MACRO)             	reserve 4
     445/     840 : (MACRO)             	st2 r12,'O',sp,(6); flag1 
     446/     84D : (MACRO)             	ld2 R11,'O',sp,(0+6) ;reg:INDIRI2(addr)
     447/     859 : (MACRO)             	st1 R11,'O',sp,(0+6); ASGNU1
     448/     863 :                     ;void putxn(unsigned char x){ //print a nibble as ascii hex
     449/     863 :                     ;	if (x<10){
     450/     863 : (MACRO)             	ld1 R11,'O',sp,(0+6)
     451/     86D : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     452/     870 : (MACRO)             	jcI2I r11,10,lbdf,L49; GE is flipped test from LT
     453/     881 :                     ;		putc(x+'0');
     454/     881 : (MACRO)             	ld1 R11,'O',sp,(0+6)
     455/     88B : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     456/     88E : (MACRO)             	ldA2 R11,'O',R11,(48); reg:addr
     457/     896 : (MACRO)             	cpy1 R12,R11
     458/     898 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     459/     89B : (MACRO)             	Ccall _putc
     460/     89E :                     ;	} else {
     461/     89E : C0 08 C6            	lbr L50
     462/     8A1 :                     L49:
     463/     8A1 :                     ;		putc(x+'A'-10);
     464/     8A1 : (MACRO)             	ld1 R11,'O',sp,(0+6)
     465/     8AB : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     466/     8AE : (MACRO)             	ldA2 R11,'O',R11,(65); reg:addr
     467/     8B6 : (MACRO)             	alu2I R11,R11,10,smi,smbi
     468/     8BE : (MACRO)             	cpy1 R12,R11
     469/     8C0 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     470/     8C3 : (MACRO)             	Ccall _putc
     471/     8C6 :                     ;	}
     472/     8C6 :                     L50:
     473/     8C6 :                     ;}
     474/     8C6 :                     L48:
     475/     8C6 : (MACRO)             	release 4
     476/     8CA : (MACRO)             	Cretn
     477/     8CB :                     
     478/     8CB :                     _putx:
     479/     8CB : (MACRO)             	reserve 4
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 9 - 4/4/2013 16:39:08


     480/     8CF : (MACRO)             	st2 r12,'O',sp,(6); flag1 
     481/     8DC : (MACRO)             	ld2 R11,'O',sp,(0+6) ;reg:INDIRI2(addr)
     482/     8E8 : (MACRO)             	st1 R11,'O',sp,(0+6); ASGNU1
     483/     8F2 :                     ;void putx(unsigned char x){ //print a unsigned char as ascii hex
     484/     8F2 :                     ;	putxn(x>>4);
     485/     8F2 : (MACRO)             	ld1 R11,'O',sp,(0+6)
     486/     8FC : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     487/     8FF : (MACRO)             	shrI2I R11,4
     488/     91F : (MACRO)             	cpy1 R12,R11
     489/     921 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     490/     924 : (MACRO)             	Ccall _putxn
     491/     927 :                     ;	putxn(x & 0x0F);
     492/     927 : (MACRO)             	ld1 R11,'O',sp,(0+6)
     493/     931 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     494/     934 : (MACRO)             	alu2I R11,R11,15,ani,ani
     495/     93C :                     	;removed ?	cpy2 R11,R11
     496/     93C : (MACRO)             	cpy1 R12,R11
     497/     93E : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     498/     941 : (MACRO)             	Ccall _putxn
     499/     944 :                     ;}
     500/     944 :                     L51:
     501/     944 : (MACRO)             	release 4
     502/     948 : (MACRO)             	Cretn
     503/     949 :                     
     504/     949 :                     _printf:
     505/     949 : (MACRO)             	reserve 4; save room for local variables
     506/     94D : (MACRO)             	pushr r0
     507/     952 : (MACRO)             	pushr r1
     508/     957 : (MACRO)             	pushr r7
     509/     95C : (MACRO)             	reserve 4; save room for outgoing arguments
     510/     960 : (MACRO)             	st2 r12,'O',sp,(16); flag1 
     511/     96D : (MACRO)             	st2 r13,'O',sp,(18); flag2
     512/     97A :                     ;void printf(char *ptr,...){ //limited implementation of printf
     513/     97A :                     ;	int argslot=0;	//used to align longs
     514/     97A : (MACRO)             	ld2z R0
     515/     97E :                     ;	int * this=(int *)&ptr;
     516/     97E : (MACRO)             	ldA2 R1,'O',sp,(0+16); reg:addr
     517/     986 :                     ;	this++; argslot++; //advance argument pointer and slot #
     518/     986 : (MACRO)             	incm R1,2
     519/     988 : (MACRO)             	incm R0,1
     520/     989 : C0 0D 5F            	lbr L54
     521/     98C :                     L53:
     522/     98C :                     ;    while(*ptr) {
     523/     98C :                     ;		c=*ptr++;
     524/     98C : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     525/     998 : (MACRO)             	cpy2 R10,R11
     526/     99C : (MACRO)             	incm R10,1
     527/     99D : (MACRO)             	st2 R10,'O',sp,(0+16); ASGNP2
     528/     9AA : (MACRO)             	ldn1 R7,R11;reg:  INDIRU1(indaddr)
     529/     9AC :                     ;		if (c!='%'){
     530/     9AC : (MACRO)             	cpy1 R11,R7
     531/     9AE : (MACRO)             	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     532/     9B1 : (MACRO)             	jeqU2I r11,37,L56;EQI2(reg,con)
     533/     9BD :                     ;			putc(c);
     534/     9BD : (MACRO)             	cpy1 R12,R7
     535/     9BF : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     536/     9C2 : (MACRO)             	Ccall _putc
     537/     9C5 :                     ;		} else{
     538/     9C5 : C0 0D 5F            	lbr L57
     539/     9C8 :                     L56:
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 10 - 4/4/2013 16:39:08


     540/     9C8 :                     ;			c=*ptr++;
     541/     9C8 : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     542/     9D4 : (MACRO)             	cpy2 R10,R11
     543/     9D8 : (MACRO)             	incm R10,1
     544/     9D9 : (MACRO)             	st2 R10,'O',sp,(0+16); ASGNP2
     545/     9E6 : (MACRO)             	ldn1 R7,R11;reg:  INDIRU1(indaddr)
     546/     9E8 :                     ;			switch (c){
     547/     9E8 : (MACRO)             	cpy1 R11,R7
     548/     9EA : (MACRO)             	zExt 11 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     549/     9ED : (MACRO)             	st2 R11,'O',sp,(-5+16)
     550/     9FA : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     551/     A06 : (MACRO)             	jcI2I r11,99,lbnf,L77  ;LT=lbnf i.e. subtract immedB from A and jump if borrow
     552/     A17 : (MACRO)             	jnI2I r11,108,lbnf,L78; GT reverse  the subtraction
     553/     A28 : (MACRO)             	shl2I R11,1
     554/     A2E : (MACRO)             	ld2 R11,'O',R11,(L79-198);reg:  INDIRP2(addr)
     555/     A3A : (MACRO)             	jumpv r11; JUMPV(reg)
     556/     A44 :                     L79:
     557/     A44 : 0B 04               	dw L63
     558/     A46 : 0A C6               	dw L61
     559/     A48 : 0D 4E               	dw L58
     560/     A4A : 0C FE               	dw L72
     561/     A4C : 0D 4E               	dw L58
     562/     A4E : 0D 4E               	dw L58
     563/     A50 : 0A C6               	dw L61
     564/     A52 : 0D 4E               	dw L58
     565/     A54 : 0D 4E               	dw L58
     566/     A56 : 0B 94               	dw L65
     567/     A58 :                     L77:
     568/     A58 : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     569/     A64 : (MACRO)             	jeqU2I r11,88,L64;EQI2(reg,con)
     570/     A70 : C0 0D 4E            	lbr L58
     571/     A73 :                     L78:
     572/     A73 : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     573/     A7F : (MACRO)             	ldaD R10,115; reg:acon
     574/     A85 : (MACRO)             	jeqI2 r11,r10,L62; EQI2(reg,reg)
     575/     A97 : (MACRO)             	jcI2 r11,r10,lbnf,L58; LT=lbnf i.e. subtract B from A and jump if borrow 
     576/     AAB :                     L81:
     577/     AAB : (MACRO)             	ld2 R11,'O',sp,(-5+16) ;reg:INDIRI2(addr)
     578/     AB7 : (MACRO)             	jeqU2I r11,120,L64;EQI2(reg,con)
     579/     AC3 : C0 0D 4E            	lbr L58
     580/     AC6 :                     L61:
     581/     AC6 :                     ;					printint(*this++);
     582/     AC6 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     583/     ACA : (MACRO)             	cpy2 R1,R11
     584/     ACE : (MACRO)             	incm R1,2
     585/     AD0 : (MACRO)             	ld2 R12,'O',R11,0 ;reg:INDIRI2(addr)
     586/     ADC : (MACRO)             	Ccall _printint
     587/     ADF :                     ;					argslot+=1; //next argument slot
     588/     ADF : (MACRO)             	incm R0,1
     589/     AE0 :                     ;					break;
     590/     AE0 : C0 0D 5F            	lbr L59
     591/     AE3 :                     L62:
     592/     AE3 :                     ;					printstr((char*) *this++);
     593/     AE3 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     594/     AE7 : (MACRO)             	cpy2 R1,R11
     595/     AEB : (MACRO)             	incm R1,2
     596/     AED : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     597/     AF9 : (MACRO)             	cpy2 R12,R11 ;LOADP2(reg)
     598/     AFD : (MACRO)             	Ccall _printstr
     599/     B00 :                     ;					argslot+=1; //next argument slot
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 11 - 4/4/2013 16:39:08


     600/     B00 : (MACRO)             	incm R0,1
     601/     B01 :                     ;					break;
     602/     B01 : C0 0D 5F            	lbr L59
     603/     B04 :                     L63:
     604/     B04 :                     ;					putc((unsigned int) *this++);
     605/     B04 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     606/     B08 : (MACRO)             	cpy2 R1,R11
     607/     B0C : (MACRO)             	incm R1,2
     608/     B0E : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     609/     B1A : (MACRO)             	cpy1 R12,R11
     610/     B1C : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     611/     B1F : (MACRO)             	Ccall _putc
     612/     B22 :                     ;					argslot+=1; //next argument slot
     613/     B22 : (MACRO)             	incm R0,1
     614/     B23 :                     ;					break;
     615/     B23 : C0 0D 5F            	lbr L59
     616/     B26 :                     L64:
     617/     B26 :                     ;					putx(((unsigned int) *this)>>8);
     618/     B26 : (MACRO)             	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
     619/     B32 : (MACRO)             	shrU2I R11,8
     620/     B62 : (MACRO)             	cpy1 R12,R11
     621/     B64 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     622/     B67 : (MACRO)             	Ccall _putx
     623/     B6A :                     ;					putx(((unsigned int) *this++)&255);
     624/     B6A : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     625/     B6E : (MACRO)             	cpy2 R1,R11
     626/     B72 : (MACRO)             	incm R1,2
     627/     B74 : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     628/     B80 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     629/     B88 : (MACRO)             	cpy1 R12,R11
     630/     B8A : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     631/     B8D : (MACRO)             	Ccall _putx
     632/     B90 :                     ;					argslot+=1; //next argument slot
     633/     B90 : (MACRO)             	incm R0,1
     634/     B91 :                     ;					break;
     635/     B91 : C0 0D 5F            	lbr L59
     636/     B94 :                     L65:
     637/     B94 :                     ;					if (*ptr){ //as long as there's something there
     638/     B94 : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     639/     BA0 : (MACRO)             	ld1 R11,'O',R11,0
     640/     BAA : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     641/     BAD : (MACRO)             	jzU2 r11,L66; EQ 0
     642/     BB5 :                     ;						xord=*ptr++;
     643/     BB5 : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     644/     BC1 : (MACRO)             	cpy2 R10,R11
     645/     BC5 : (MACRO)             	incm R10,1
     646/     BC6 : (MACRO)             	st2 R10,'O',sp,(0+16); ASGNP2
     647/     BD3 : (MACRO)             	ldn1 R11,R11;reg:  INDIRU1(indaddr)
     648/     BD5 : (MACRO)             	st1 R11,'O',sp,(-3+16); ASGNU1
     649/     BDF :                     ;						if (argslot&1) {
     650/     BDF : (MACRO)             	alu2I R11,R0,1,ani,ani
     651/     BE7 :                     	;removed ?	cpy2 R11,R0
     652/     BE7 : (MACRO)             	jzU2 r11,L68; EQ 0
     653/     BEF :                     ;							this++;
     654/     BEF : (MACRO)             	incm R1,2
     655/     BF1 :                     ;							argslot++;
     656/     BF1 : (MACRO)             	incm R0,1
     657/     BF2 :                     ;						}
     658/     BF2 :                     L68:
     659/     BF2 :                     ;						if(xord=='d'){
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 12 - 4/4/2013 16:39:08


     660/     BF2 : (MACRO)             	ld1 R11,'O',sp,(-3+16)
     661/     BFC : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     662/     BFF : (MACRO)             	jneU2I r11,100,L70; NE
     663/     C0B :                     ;							printlint(*(long *)this);//treats "this" as a pointer to long
     664/     C0B : (MACRO)             	ld4 Rp1p2,'O',R1,0;reg:  INDIRI4(addr)
     665/     C1B : (MACRO)             	Ccall _printlint
     666/     C1E :                     ;							this+=2;				// and advances it 4 bytes
     667/     C1E : (MACRO)             	incm R1,4
     668/     C22 :                     ;						} else{
     669/     C22 : C0 0C F9            	lbr L71
     670/     C25 :                     L70:
     671/     C25 :                     ;							putx(((unsigned int) *this)>>8);
     672/     C25 : (MACRO)             	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
     673/     C31 : (MACRO)             	shrU2I R11,8
     674/     C61 : (MACRO)             	cpy1 R12,R11
     675/     C63 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     676/     C66 : (MACRO)             	Ccall _putx
     677/     C69 :                     ;							putx(((unsigned int) *this++)&255);
     678/     C69 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     679/     C6D : (MACRO)             	cpy2 R1,R11
     680/     C71 : (MACRO)             	incm R1,2
     681/     C73 : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     682/     C7F : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     683/     C87 : (MACRO)             	cpy1 R12,R11
     684/     C89 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     685/     C8C : (MACRO)             	Ccall _putx
     686/     C8F :                     ;							putx(((unsigned int) *this)>>8);
     687/     C8F : (MACRO)             	ld2 R11,'O',R1,0 ;reg:INDIRI2(addr)
     688/     C9B : (MACRO)             	shrU2I R11,8
     689/     CCB : (MACRO)             	cpy1 R12,R11
     690/     CCD : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     691/     CD0 : (MACRO)             	Ccall _putx
     692/     CD3 :                     ;							putx(((unsigned int) *this++)&255);
     693/     CD3 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     694/     CD7 : (MACRO)             	cpy2 R1,R11
     695/     CDB : (MACRO)             	incm R1,2
     696/     CDD : (MACRO)             	ld2 R11,'O',R11,0 ;reg:INDIRI2(addr)
     697/     CE9 : (MACRO)             	alu2I R11,R11,255,ani,ani ;removed copy;BANDU2(reg,con)  
     698/     CF1 : (MACRO)             	cpy1 R12,R11
     699/     CF3 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     700/     CF6 : (MACRO)             	Ccall _putx
     701/     CF9 :                     ;						}
     702/     CF9 :                     L71:
     703/     CF9 :                     ;						argslot+=2;
     704/     CF9 : (MACRO)             	incm R0,2
     705/     CFB :                     ;						break;
     706/     CFB : C0 0D 5F            	lbr L59
     707/     CFE :                     L66:
     708/     CFE :                     L72:
     709/     CFE :                     ;					if (*ptr){ //as long as there's something there
     710/     CFE : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     711/     D0A : (MACRO)             	ld1 R11,'O',R11,0
     712/     D14 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     713/     D17 : (MACRO)             	jzU2 r11,L73; EQ 0
     714/     D1F :                     ;						if (argslot&1) { //adjust alignment
     715/     D1F : (MACRO)             	alu2I R11,R0,1,ani,ani
     716/     D27 :                     	;removed ?	cpy2 R11,R0
     717/     D27 : (MACRO)             	jzU2 r11,L75; EQ 0
     718/     D2F :                     ;							this++;
     719/     D2F : (MACRO)             	incm R1,2
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 13 - 4/4/2013 16:39:08


     720/     D31 :                     ;							argslot++;
     721/     D31 : (MACRO)             	incm R0,1
     722/     D32 :                     ;						}
     723/     D32 :                     L75:
     724/     D32 :                     ;						printflt(*(float *)this);//treats "this" as a pointer to float
     725/     D32 : (MACRO)             	ld4 Rp1p2,'O',R1,0;INDIRF4(addr)
     726/     D42 : (MACRO)             	Ccall _printflt
     727/     D45 :                     ;						this+=2;				// and advances it 4 bytes
     728/     D45 : (MACRO)             	incm R1,4
     729/     D49 :                     ;						argslot+=2;
     730/     D49 : (MACRO)             	incm R0,2
     731/     D4B :                     ;						break;
     732/     D4B : C0 0D 5F            	lbr L59
     733/     D4E :                     L73:
     734/     D4E :                     L58:
     735/     D4E :                     ;					putc('%');putc(c);
     736/     D4E : (MACRO)             	ldaD R12,37; reg:acon
     737/     D54 : (MACRO)             	Ccall _putc
     738/     D57 : (MACRO)             	cpy1 R12,R7
     739/     D59 : (MACRO)             	zExt 12 ;CVUI2(reg): widen unsigned char to signed int (zero extend)*
     740/     D5C : (MACRO)             	Ccall _putc
     741/     D5F :                     ;			} //switch
     742/     D5F :                     L59:
     743/     D5F :                     ;		} //%
     744/     D5F :                     L57:
     745/     D5F :                     ;	} //while
     746/     D5F :                     L54:
     747/     D5F :                     ;    while(*ptr) {
     748/     D5F : (MACRO)             	ld2 R11,'O',sp,(0+16);reg:  INDIRP2(addr)
     749/     D6B : (MACRO)             	ld1 R11,'O',R11,0
     750/     D75 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     751/     D78 : (MACRO)             	jnzU2 r11,L53; NE 0
     752/     D80 :                     ;} //prtf
     753/     D80 :                     L52:
     754/     D80 : (MACRO)             	release 4; release room for outgoing arguments
     755/     D84 : (MACRO)             	popr r7
     756/     D88 : (MACRO)             	popr r1
     757/     D8C : (MACRO)             	popr r0
     758/     D90 : (MACRO)             	release 4; release room for local variables 
     759/     D94 : (MACRO)             	Cretn
     760/     D95 :                     
     761/     D95 :                     _exit:
     762/     D95 : (MACRO)             	reserve 4
     763/     D99 : (MACRO)             	st2 r12,'O',sp,(6); flag1 
     764/     DA6 :                     ;void exit(int code){
     765/     DA6 :                     ;	printf("exit %d\n",code);
     766/     DA6 : (MACRO)             	ldaD R12,L83; reg:acon
     767/     DAC : (MACRO)             	ld2 R13,'O',sp,(0+6) ;reg:INDIRI2(addr)
     768/     DB8 : (MACRO)             	Ccall _printf
     769/     DBB :                     L84:
     770/     DBB :                     ;	while(1);
     771/     DBB :                     L85:
     772/     DBB : C0 0D BB            	lbr L84
     773/     DBE :                     ;}
     774/     DBE :                     L82:
     775/     DBE : (MACRO)             	release 4
     776/     DC2 : (MACRO)             	Cretn
     777/     DC3 :                     
     778/     DC3 :                     _memcmp:
     779/     DC3 : (MACRO)             	reserve 2; save room for local variables
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 14 - 4/4/2013 16:39:08


     780/     DC5 : (MACRO)             	pushr r0
     781/     DCA : (MACRO)             	pushr r1
     782/     DCF : (MACRO)             	pushr r7
     783/     DD4 : (MACRO)             	reserve 0; save room for outgoing arguments
     784/     DD4 : (MACRO)             	ld2 R7,'O',sp,(4+10); reg:INDIRU2(addr)
     785/     DE0 :                     ;int memcmp(const void *Ptr1, const void *Ptr2, unsigned int Count){
     786/     DE0 :                     ;    int v = 0;
     787/     DE0 : (MACRO)             	ld2z R1
     788/     DE4 :                     ;    p1 = (unsigned char *)Ptr1;
     789/     DE4 : (MACRO)             	cpy2 R0,R12 ;LOADP2(reg)
     790/     DE8 :                     ;    p2 = (unsigned char *)Ptr2;
     791/     DE8 : (MACRO)             	st2 R13,'O',sp,(-4+10); ASGNP2
     792/     DF5 : C0 0E 45            	lbr L89
     793/     DF8 :                     L88:
     794/     DF8 :                     ;    while(Count-- > 0 && v == 0) {
     795/     DF8 :                     ;        v = *(p1++) - *(p2++);
     796/     DF8 : (MACRO)             	cpy2 R11,R0 ;LOADP2(reg)
     797/     DFC : (MACRO)             	cpy2 R0,R11
     798/     E00 : (MACRO)             	incm R0,1
     799/     E01 : (MACRO)             	ld2 R10,'O',sp,(-4+10);reg:  INDIRP2(addr)
     800/     E0D : (MACRO)             	cpy2 R9,R10
     801/     E11 : (MACRO)             	incm R9,1
     802/     E12 : (MACRO)             	st2 R9,'O',sp,(-4+10); ASGNP2
     803/     E1F : (MACRO)             	ld1 R11,'O',R11,0
     804/     E29 : (MACRO)             	zExt R11 ;CVUI2: widen unsigned char to signed int (zero extend)
     805/     E2C : (MACRO)             	ld1 R10,'O',R10,0
     806/     E36 : (MACRO)             	zExt R10 ;CVUI2: widen unsigned char to signed int (zero extend)
     807/     E39 : (MACRO)             	alu2 R1,R11,R10,sm,smb
     808/     E45 :                     ;    }
     809/     E45 :                     L89:
     810/     E45 :                     ;    while(Count-- > 0 && v == 0) {
     811/     E45 : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg)*
     812/     E49 : (MACRO)             	cpy2 R7,R11
     813/     E4D : (MACRO)             	decm R7,1
     814/     E4E : (MACRO)             	jeqU2I r11,0,L91;EQU2(reg,con)
     815/     E5A : (MACRO)             	jzU2 r1,L88; EQ 0
     816/     E62 :                     L91:
     817/     E62 :                     ;    return v;
     818/     E62 : (MACRO)             	cpy2 R15,R1 ;LOADI2(reg)
     819/     E66 :                     L87:
     820/     E66 : (MACRO)             	release 0; release room for outgoing arguments
     821/     E66 : (MACRO)             	popr r7
     822/     E6A : (MACRO)             	popr r1
     823/     E6E : (MACRO)             	popr r0
     824/     E72 : (MACRO)             	release 2; release room for local variables 
     825/     E74 : (MACRO)             	Cretn
     826/     E75 :                     
     827/     E75 :                     _memcpy:
     828/     E75 : (MACRO)             	reserve 0; save room for local variables
     829/     E75 : (MACRO)             	pushr r0
     830/     E7A : (MACRO)             	pushr r1
     831/     E7F : (MACRO)             	pushr r7
     832/     E84 : (MACRO)             	reserve 0; save room for outgoing arguments
     833/     E84 : (MACRO)             	ld2 R7,'O',sp,(4+8); reg:INDIRU2(addr)
     834/     E90 :                     ;void* memcpy(void* dest, const void* src, unsigned int count) {
     835/     E90 :                     ;        char* dst8 = (char*)dest;
     836/     E90 : (MACRO)             	cpy2 R1,R12 ;LOADP2(reg)
     837/     E94 :                     ;        char* src8 = (char*)src;
     838/     E94 : (MACRO)             	cpy2 R0,R13 ;LOADP2(reg)
     839/     E98 : C0 0E B1            	lbr L94
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 15 - 4/4/2013 16:39:08


     840/     E9B :                     L93:
     841/     E9B :                     ;        while (count--) {
     842/     E9B :                     ;            *dst8++ = *src8++;
     843/     E9B : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     844/     E9F : (MACRO)             	cpy2 R1,R11
     845/     EA3 : (MACRO)             	incm R1,1
     846/     EA4 : (MACRO)             	cpy2 R10,R0 ;LOADP2(reg)
     847/     EA8 : (MACRO)             	cpy2 R0,R10
     848/     EAC : (MACRO)             	incm R0,1
     849/     EAD : (MACRO)             	ldn1 R10,R10;reg:  INDIRU1(indaddr)
     850/     EAF : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     851/     EB1 :                     ;        }
     852/     EB1 :                     L94:
     853/     EB1 :                     ;        while (count--) {
     854/     EB1 : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg)*
     855/     EB5 : (MACRO)             	cpy2 R7,R11
     856/     EB9 : (MACRO)             	decm R7,1
     857/     EBA : (MACRO)             	jnzU2 r11,L93; NE 0
     858/     EC2 :                     ;        return dest;
     859/     EC2 : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
     860/     EC6 :                     L92:
     861/     EC6 : (MACRO)             	release 0; release room for outgoing arguments
     862/     EC6 : (MACRO)             	popr r7
     863/     ECA : (MACRO)             	popr r1
     864/     ECE : (MACRO)             	popr r0
     865/     ED2 : (MACRO)             	release 0; release room for local variables 
     866/     ED2 : (MACRO)             	Cretn
     867/     ED3 :                     
     868/     ED3 :                     _memset:
     869/     ED3 : (MACRO)             	reserve 0; save room for local variables
     870/     ED3 : (MACRO)             	pushr r1
     871/     ED8 : (MACRO)             	pushr r7
     872/     EDD : (MACRO)             	reserve 0; save room for outgoing arguments
     873/     EDD : (MACRO)             	ld2 R7,'O',sp,(4+6); reg:INDIRU2(addr)
     874/     EE9 :                     ;{
     875/     EE9 :                     ;    unsigned char* p=s;
     876/     EE9 : (MACRO)             	cpy2 R1,R12 ;LOADP2(reg)
     877/     EED : C0 0E FF            	lbr L98
     878/     EF0 :                     L97:
     879/     EF0 :                     ;        *p++ = (unsigned char)c;
     880/     EF0 : (MACRO)             	cpy2 R11,R1 ;LOADP2(reg)
     881/     EF4 : (MACRO)             	cpy2 R1,R11
     882/     EF8 : (MACRO)             	incm R1,1
     883/     EF9 : (MACRO)             	cpy2 R10,R13 ;LOADU2(reg)*
     884/     EFD : (MACRO)             	str1 R10,R11; ASGNU1(indaddr,reg)
     885/     EFF :                     L98:
     886/     EFF :                     ;    while(n--)
     887/     EFF : (MACRO)             	cpy2 R11,R7 ;LOADU2(reg)*
     888/     F03 : (MACRO)             	cpy2 R7,R11
     889/     F07 : (MACRO)             	decm R7,1
     890/     F08 : (MACRO)             	jnzU2 r11,L97; NE 0
     891/     F10 :                     ;    return s;
     892/     F10 : (MACRO)             	cpy2 R15,R12 ;LOADP2(reg)
     893/     F14 :                     L96:
     894/     F14 : (MACRO)             	release 0; release room for outgoing arguments
     895/     F14 : (MACRO)             	popr r7
     896/     F18 : (MACRO)             	popr r1
     897/     F1C : (MACRO)             	release 0; release room for local variables 
     898/     F1C : (MACRO)             	Cretn
     899/     F1D :                     
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 16 - 4/4/2013 16:39:08


     900/     F1D :                     L83:
     901/     F1D : 65                  	db 101
     902/     F1E : 78                  	db 120
     903/     F1F : 69                  	db 105
     904/     F20 : 74                  	db 116
     905/     F21 : 20                  	db 32
     906/     F22 : 25                  	db 37
     907/     F23 : 64                  	db 100
     908/     F24 : 0A                  	db 10
     909/     F25 : 00                  	db 0
     910/     F26 :                     	align 4
     911/     F28 :                     L21:
     912/     F28 : BF 80 00 00         	dd 0xbf800000
     913/     F2C :                     	align 4
     914/     F2C :                     L20:
     915/     F2C : 00 00 00 00         	dd 0x0
     916/     F30 :                     L3:
     917/     F30 : 64                  	db 100
     918/     F31 : 6F                  	db 111
     919/     F32 : 6E                  	db 110
     920/     F33 : 65                  	db 101
     921/     F34 : 0A                  	db 10
     922/     F35 : 00                  	db 0
     923/     F36 :                     L2:
     924/     F36 : 25                  	db 37
     925/     F37 : 66                  	db 102
     926/     F38 : 0A                  	db 10
     927/     F39 : 00                  	db 0
     928/     F3A :                     	include lcc1802Epilofl.inc
(1)    1/     F3A :                     ;lcc1802Epilog.inc initialization and runtime functions needed for lcc1802 programs
(1)    2/     F3A :                     ;Dec 21 2012 - out5/putc moved to separate putc.inc for christmas compiler
(1)    3/     F3A :                     ;this is the version published with the lcc1802121229 release
(1)    4/     F3A :                     ;jan 1 2013 incleasing stack beginning lcation to 3fff (16K)
(1)    5/     F3A :                     ;jan 2 removed test routines, moved code not needing short branches to before the align 256
(1)    6/     F3A :                     ;jan 11 going back to SCRT conventions for NG compiler
(1)    7/     F3A :                     ;Jan 21 adding _mulu4 32 bit multiplication - really s.b. mulI4
(1)    8/     F3A :                     ;Jan 28 archived before beginning work on Birthday Compiler
(1)    9/     F3A :                     ;Feb 5 dubdab algorithm being brought in for ltoa itoa
(1)   10/     F3A :                     ;Feb 12 fixed bugs in modi2/u2
(1)   11/     F3A :                     ;feb 27 changed stack to start at 7fff
(1)   12/     F3A :                     ;mar 3, 2013 saved as epiloNO for optimization round
(1)   13/     F3A :                     ;mar 28,2013 - LCCepilofl.inc changes scrt to standard big-endian stack
(1)   14/     F3A :                     ;april 4 adding digit count argument to dubdabx
(1)   15/     F3A :                     
(1)   16/     F3A : =EH                 rwork	equ	memAddr	;work register
(1)   17/     F3A :                     lcc1802init:	
(1)   18/     F3A : (MACRO)             	ldiReg	RCALL,_call
(1)   19/     F40 : (MACRO)             	ldiReg	RRET,_return
(1)   20/     F46 : (MACRO)             	ldiReg	SP,0x7fff	;wjr jan 1 start stack at 32K-1
(1)   21/     F4C : E2                  	sex	SP
(1)   22/     F4D : (MACRO)             	ldiReg	RPC,$$_00000
(1)   23/     F53 : D3                  	sep	RPC
(1)   24/     F54 :                     $$_00000:
(1)   25/     F54 : (MACRO)             	Ccall _main	;call the main routine
(1)   26/     F57 : C0 0F 57            $$_die:	lbr	$$_die		;loop here when main returns
(1)   27/     F5A : DE AD               	db	0xde,0xad
(1)   28/     F5C :                     
(1)   29/     F5C :                     ;the following routines don't have short jumps and don't need to worry about alignment
(1)   30/     F5C :                     _setqOn:
(1)   31/     F5C : 7B                  	seq
 AS V1.42 Beta [Bld 87] - source file fragment.asm(lcc1802Epilofl.inc) - page 17 - 4/4/2013 16:39:08


(1)   32/     F5D : (MACRO)             	Cretn
(1)   33/     F5E :                     _setqOff:
(1)   34/     F5E : 7A                  	req
(1)   35/     F5F : (MACRO)             	Cretn
(1)   36/     F60 :                     
(1)   37/     F60 :                     _modU2:	;16 bit unsigned remainder
(1)   38/     F60 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   39/     F60 : (MACRO)                 Ccall _divU2
(1)   40/     F63 : 8D                      glo regArg2
(1)   41/     F64 : AF                      plo retVal
(1)   42/     F65 : 9D                      ghi regArg2
(1)   43/     F66 : BF                      phi retVal
(1)   44/     F67 : (MACRO)                 Cretn
(1)   45/     F68 :                         
(1)   46/     F68 :                     _modI2:	;16 bit signed remainder
(1)   47/     F68 :                     	; just calls the 16 bit division then puts remainder into return value
(1)   48/     F68 : (MACRO)                 Ccall _divI2
(1)   49/     F6B : 8D                      glo regArg2
(1)   50/     F6C : AF                      plo retVal
(1)   51/     F6D : 9D                      ghi regArg2
(1)   52/     F6E : BF                      phi retVal
(1)   53/     F6F : (MACRO)                 Cretn
(1)   54/     F70 :                     
(1)   55/     F70 :                     _out4:	
(1)   56/     F70 : 8C                  	glo	regArg1
(1)   57/     F71 : 22                  	dec	sp
(1)   58/     F72 : 52                  	str	sp
(1)   59/     F73 : 64                  	out	4
(1)   60/     F74 : (MACRO)             	Cretn
(1)   61/     F75 :                     
(1)   62/     F75 :                     ;the following routines have short branches so all the code has to stay within the same page
(1)   63/     F75 :                     	align 256
(1)   64/    1000 :                     ;non-standard Call routine invoked as D4xxxx - using z80 stack convention
(1)   65/    1000 :                     ;requires programs to save the return address if they destroy it (by using call for example)
(1)   66/    1000 :                     ;Standard Call routine invoked as D4xxxx - big-endian stack convention
(1)   67/    1000 : D3                  	sep     R3 ;go to subroutine
(1)   68/    1001 : E2                  _call	sex	SP ;make sure X=SP
(1)   69/    1002 : 86                  	glo	retAddr ;save previous return pointer on stack
(1)   70/    1003 : 22                  	dec	sp
(1)   71/    1004 : 73                  	stxd
(1)   72/    1005 : 96                  	ghi	retAddr
(1)   73/    1006 : 52                  	str	sp	
(1)   74/    1007 : 83                  	glo	RPC ;copy old PC to retAddr
(1)   75/    1008 : A6                  	plo	retAddr
(1)   76/    1009 : 93                  	ghi	RPC
(1)   77/    100A : B6                  	phi	retAddr
(1)   78/    100B : 46                  	lda	retAddr ;pick up subroutine address into RPC
(1)   79/    100C : B3                  	phi	RPC
(1)   80/    100D : 46                  	lda	retAddr
(1)   81/    100E : A3                  	plo	RPC
(1)   82/    100F : 30 00               	br	_call-1
(1)   83/    1011 :                     
(1)   84/    1011 :                     ;Standard subroutine return 
(1)   85/    1011 : D3                  	sep	RPC	;return to the original program
(1)   86/    1012 : 86                  _return	glo	retAddr	;transfer the current return address to RPC
(1)   87/    1013 : A3                  	plo	RPC
(1)   88/    1014 : 96                  	ghi	retAddr
(1)   89/    1015 : B3                  	phi	RPC
(1)   90/    1016 : 42                  	lda	SP	;pick up old return address
(1)   91/    1017 : B6                  	phi	retAddr
 AS V1.42 Beta [Bld 87] - source file fragment.asm(lcc1802Epilofl.inc) - page 18 - 4/4/2013 16:39:08


(1)   92/    1018 : 42                  	lda	SP
(1)   93/    1019 : A6                  	plo	retAddr
(1)   94/    101A : 30 11               	br	_return-1
(1)   95/    101C :                     
(1)   96/    101C :                     _oneMs:		;execute 100 instructions including call(15)/return(10) sequence. takes about 1 ms
(1)   97/    101C : F8 24               	ldi	(100-15-10-2)/2
(1)   98/    101E : FF 01               $$mslp:	smi	1
(1)   99/    1020 : 3A 1E               	bnz	$$mslp
(1)  100/    1022 : (MACRO)             	Cretn
(1)  101/    1023 :                     
(1)  102/    1023 :                     
(1)  103/    1023 :                     	
(1)  104/    1023 :                     ;16 bit unsigned multiply thanks to Ted Rossin!
(1)  105/    1023 :                     ;retVal=regArg1*regArg2. uses register rwork as a work regitsr
(1)  106/    1023 :                     _mulu2:		
(1)  107/    1023 : 22                      dec sp
(1)  108/    1024 : F8 10                   ldi 16
(1)  109/    1026 : AE                      plo	rwork	;bit count
(1)  110/    1027 : F8 00                   ldi 0
(1)  111/    1029 : BF                      phi	retVal	;quotient
(1)  112/    102A : AF                      plo retVal
(1)  113/    102B :                     $$MultLoop16_16:
(1)  114/    102B : 9C                      ghi regArg1
(1)  115/    102C : F6                      shr
(1)  116/    102D : BC                      phi regArg1
(1)  117/    102E : 8C                      glo regArg1
(1)  118/    102F : 76                      shrc
(1)  119/    1030 : AC                      plo regArg1
(1)  120/    1031 : 3B 3D                   bnf $$MultSkip16_16
(1)  121/    1033 : 8D                      glo regArg2
(1)  122/    1034 : 52                      str sp
(1)  123/    1035 : 8F                      glo retVal
(1)  124/    1036 : F4                      add 
(1)  125/    1037 : AF                      plo retVal
(1)  126/    1038 : 9D                      ghi regArg2
(1)  127/    1039 : 52                      str sp
(1)  128/    103A : 9F                      ghi retVal
(1)  129/    103B : 74                      adc
(1)  130/    103C : BF                      phi retVal
(1)  131/    103D :                     $$MultSkip16_16:
(1)  132/    103D : 8D                      glo regArg2
(1)  133/    103E : FE                      shl
(1)  134/    103F : AD                      plo regArg2
(1)  135/    1040 : 9D                      ghi regArg2
(1)  136/    1041 : 7E                      shlc
(1)  137/    1042 : BD                      phi regArg2
(1)  138/    1043 : 2E                      dec rwork
(1)  139/    1044 : 8E                      glo rwork
(1)  140/    1045 : 3A 2B                   bnz $$MultLoop16_16
(1)  141/    1047 : 12                      inc sp
(1)  142/    1048 : D5                      sep 5
(1)  143/    1049 :                     
(1)  144/    1049 :                     
(1)  145/    1049 :                     _divU2:
(1)  146/    1049 :                     	; retVal = regArg1/regArg2  (remainder in regArg1)
(1)  147/    1049 :                     	; This is really an unsigned 23 bit divide
(1)  148/    1049 :                     	;thanks to Ted Rossin
(1)  149/    1049 :                     	;bodged Dec 12 to shuffle registers at the end.
(1)  150/    1049 : 22                      dec sp
(1)  151/    104A : F8 10                   ldi 16
 AS V1.42 Beta [Bld 87] - source file fragment.asm(lcc1802Epilofl.inc) - page 19 - 4/4/2013 16:39:08


(1)  152/    104C : AE                      plo rwork
(1)  153/    104D : F8 00                   ldi 0
(1)  154/    104F : BF                      phi retVal
(1)  155/    1050 : AF                      plo retVal
(1)  156/    1051 : BE                      phi rwork
(1)  157/    1052 :                     $$DivLoop16_16:
(1)  158/    1052 : 8C                      glo regArg1
(1)  159/    1053 : FE                      shl
(1)  160/    1054 : AC                      plo regArg1
(1)  161/    1055 : 9C                      ghi regArg1
(1)  162/    1056 : 7E                      shlc
(1)  163/    1057 : BC                      phi regArg1
(1)  164/    1058 : 8F                      glo retVal
(1)  165/    1059 : 7E                      shlc
(1)  166/    105A : AF                      plo retVal
(1)  167/    105B : 9F                      ghi retVal
(1)  168/    105C : 7E                      shlc
(1)  169/    105D : BF                      phi retVal
(1)  170/    105E : 9E                      ghi rwork
(1)  171/    105F : 7E                      shlc
(1)  172/    1060 : BE                      phi rwork
(1)  173/    1061 : 3B 73                   bnf $$DivSub16_16
(1)  174/    1063 : 8D                      glo regArg2
(1)  175/    1064 : 52                      str sp
(1)  176/    1065 : 8F                      glo retVal
(1)  177/    1066 : F4                      add 
(1)  178/    1067 : AF                      plo retVal
(1)  179/    1068 : 9D                      ghi regArg2
(1)  180/    1069 : 52                      str sp
(1)  181/    106A : 9F                      ghi retVal
(1)  182/    106B : 74                      adc 
(1)  183/    106C : BF                      phi retVal
(1)  184/    106D : 9E                      ghi rwork
(1)  185/    106E : 7C 00                   adci 0
(1)  186/    1070 : BE                      phi rwork
(1)  187/    1071 : 30 81                   br $$DivSkip16_16
(1)  188/    1073 :                     $$DivSub16_16:
(1)  189/    1073 : 8D                      glo regArg2
(1)  190/    1074 : 52                      str sp
(1)  191/    1075 : 8F                      glo retVal
(1)  192/    1076 : F7                      sm
(1)  193/    1077 : AF                      plo retVal
(1)  194/    1078 : 9D                      ghi regArg2
(1)  195/    1079 : 52                      str sp
(1)  196/    107A : 9F                      ghi retVal
(1)  197/    107B : 77                      smb 
(1)  198/    107C : BF                      phi retVal
(1)  199/    107D : 9E                      ghi rwork
(1)  200/    107E : 7F 00                   smbi 0
(1)  201/    1080 : BE                      phi rwork 
(1)  202/    1081 :                     $$DivSkip16_16:
(1)  203/    1081 : FE                      shl
(1)  204/    1082 : 33 88                   bdf $$DivSkipClear16_16
(1)  205/    1084 :                     $$DivSetBit16_16:
(1)  206/    1084 : 8C                      glo regArg1
(1)  207/    1085 : F9 01                   ori  0x01
(1)  208/    1087 : AC                      plo regArg1
(1)  209/    1088 :                     $$DivSkipClear16_16:
(1)  210/    1088 : 2E                      dec rwork
(1)  211/    1089 : 8E                      glo rwork
 AS V1.42 Beta [Bld 87] - source file fragment.asm(lcc1802Epilofl.inc) - page 20 - 4/4/2013 16:39:08


(1)  212/    108A : 3A 52                   bnz $$DivLoop16_16
(1)  213/    108C : 9E                      ghi rwork
(1)  214/    108D : FE                      shl
(1)  215/    108E : 3B 9A                   bnf $$DivSkipFinalAdd16_16
(1)  216/    1090 : 8D                      glo regArg2
(1)  217/    1091 : 52                      str sp
(1)  218/    1092 : 8F                      glo retVal
(1)  219/    1093 : F4                      add
(1)  220/    1094 : AF                      plo retVal
(1)  221/    1095 : 9D                      ghi regArg2
(1)  222/    1096 : 52                      str sp
(1)  223/    1097 : 9F                      ghi retVal
(1)  224/    1098 : 74                      adc
(1)  225/    1099 : BF                      phi retVal
(1)  226/    109A :                     $$DivSkipFinalAdd16_16:
(1)  227/    109A : 12                      inc sp
(1)  228/    109B :                     ;here I have the quotient in regArg1 and remainder in retVal
(1)  229/    109B : 8F                      glo retVal
(1)  230/    109C : AD                      plo regArg2
(1)  231/    109D : 9F                      ghi retVal
(1)  232/    109E : BD                      phi regArg2
(1)  233/    109F : 8C                      glo regArg1
(1)  234/    10A0 : AF                      plo retVal
(1)  235/    10A1 : 9C                      ghi regArg1
(1)  236/    10A2 : BF                      phi retVal
(1)  237/    10A3 :                         ;return with quotient in retVal and remainder in regArg2
(1)  238/    10A3 : D5                      sep 5
(1)  239/    10A4 :                     
(1)  240/    10A4 :                     ;signed integer division retVal=regArg1/regArg2, remainder in regArg1
(1)  241/    10A4 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  242/    10A4 :                     _divI2:
(1)  243/    10A4 :                         ;pushr retAddr	;save the return address NG doesnot need
(1)  244/    10A4 : 22                      dec	sp	;leave a work area available
(1)  245/    10A5 : 9C                      ghi regArg1
(1)  246/    10A6 : 52                      str sp	;save the sign of the 1st arg
(1)  247/    10A7 : FE                      shl
(1)  248/    10A8 : 3B B3                   bnf $$pos1	;if the 1st arg is -v
(1)  249/    10AA : (MACRO)                 negI2 regArg1,regArg1 ;flip it to positive
(1)  250/    10B3 :                     $$pos1: ;1st is now +v, check 2nd
(1)  251/    10B3 : 9D                      ghi regArg2
(1)  252/    10B4 : F3                      xor	
(1)  253/    10B5 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  254/    10B6 : 9D                      ghi regArg2
(1)  255/    10B7 : FE                      shl
(1)  256/    10B8 : 3B C3                   bnf $$pos2	;if the 2nd arg is -v
(1)  257/    10BA : (MACRO)                 negI2 regArg2,regArg2 ;flip it to +v
(1)  258/    10C3 :                     $$pos2: ; both args now +v
(1)  259/    10C3 : (MACRO)                 Ccall _divU2	;call unsigned division
(1)  260/    10C6 :                     ;now the quotient is in retVal and the remainder is in regArg2
(1)  261/    10C6 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  262/    10C7 : FE                      shl
(1)  263/    10C8 : 3B D3                   bnf $$done ;if the signs were different
(1)  264/    10CA : (MACRO)                 negI2 retVal,retVal ;negate the quotient
(1)  265/    10D3 :                     $$done:
(1)  266/    10D3 :                         ;popr RetAddr ;restore the return address NG doesnot need
(1)  267/    10D3 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  268/    10D4 :                     
(1)  269/    10D4 :                     
(1)  270/    10D4 :                     	align 256    ;32 bit operations follow
(1)  271/    1100 :                     _divu4:
 AS V1.42 Beta [Bld 87] - source file fragment.asm(lcc1802Epilofl.inc) - page 21 - 4/4/2013 16:39:08


(1)  272/    1100 :                     ;This is an unsigned 32 bit restoring division
(1)  273/    1100 :                     ;The arguments are in RL8 and RL10, the result RL8/RL10 is in RL8, and the remainder is in Rp1p2
(1)  274/    1100 :                     ;Rp1p2:RL8 form a 64 bit work area A:Q
(1)  275/    1100 :                     ;the dividend, in RL10 is repeatedly combined with the top 32 bits and the two shifted left
(1)  276/    1100 :                     ;the algorithm is described in http://www2.informatik.hu-berlin.de/~rok/ca/TEMP/CA_2000/engl/ca12/ca12_1-4.pdf
(1)  277/    1100 :                     
(1)  278/    1100 : F8 20               	ldi 32		;set loop count
(1)  279/    1102 : AE                  	plo memaddr	;in temp register
(1)  280/    1103 : (MACRO)             	ldi4 Rp1p2,0	;clear Rp1p2
(1)  281/    110F :                     $$loop:
(1)  282/    110F : (MACRO)             	shL4 RL8	;shift bottom 32 bits left 1
(1)  283/    111B : (MACRO)             	shLC4 Rp1p2	;continue the shift into the top 32 bits
(1)  284/    1127 :                     
(1)  285/    1127 : (MACRO)             	alu4 Rp1p2,Rp1p2,RL10,sm,smb	;subtract dividend from top 32 bits
(1)  286/    113D :                     
(1)  287/    113D : FA 80               	ani 0x80	;check the top bit
(1)  288/    113F : 32 5D               	bz $$norestore	;if it's 0
(1)  289/    1141 : 89                  		glo RL8
(1)  290/    1142 : FA FE               		ani 0xfe	;turn off the bottom bit
(1)  291/    1144 : A9                  		plo RL8
(1)  292/    1145 : (MACRO)             		alu4 Rp1p2,Rp1p2,RL10,add,adc
(1)  293/    115B : 30 61               	br $$endlp 	;else
(1)  294/    115D :                     $$norestore:
(1)  295/    115D : 89                  		glo RL8
(1)  296/    115E : F9 01               		ori 1	;turn on the bottom bit
(1)  297/    1160 : A9                  		plo RL8
(1)  298/    1161 :                     	;end if
(1)  299/    1161 :                     $$endlp:
(1)  300/    1161 : 2E                  	dec memaddr	;check the cycle count
(1)  301/    1162 : 8E                  	glo memaddr
(1)  302/    1163 : 3A 0F               	bnz $$loop	;back for more if needed
(1)  303/    1165 :                     	
(1)  304/    1165 : (MACRO)             	Cretn		;and we're done - quotient is in RL8, remainder in Rp1p2
(1)  305/    1166 :                     		
(1)  306/    1166 :                     
(1)  307/    1166 :                     _mulu4:
(1)  308/    1166 :                     	;this is a 32 bit signed multiplication using booth's algorithm
(1)  309/    1166 :                     	;much thanks to David Schultz for the code and Charles Richmond for help with the algorithm
(1)  310/    1166 :                     	;input is in register pairs R8:R9 and R10:R11 (called RL8 and RL10)
(1)  311/    1166 :                     	;output is in R8:R9, with the top 32 bits in r12:13 (called Rp1p2)
(1)  312/    1166 :                     	;the bottom byte of memaddr is used as a cycle count
(1)  313/    1166 :                     	;initially	R12:13=0,	R8:R9=operand 1, DF=0
(1)  314/    1166 :                     	;for 32 cycles we check the low bit of R8:R9 and DF
(1)  315/    1166 :                     	;for 01 we add the R10:R11 to R12:13 and shift the whole 64 bits right once into DF
(1)  316/    1166 :                     	;for 10 we subtract and shift
(1)  317/    1166 :                     	;for 00 and 11 we just shift
(1)  318/    1166 :                     
(1)  319/    1166 : (MACRO)                 ldi4 rp1p2,0	;eventual product top 32 bits
(1)  320/    1172 : F8 20                   ldi 32
(1)  321/    1174 : AE                      plo memaddr		;cycle count
(1)  322/    1175 : FC 00                   adi 0		;clear df
(1)  323/    1177 :                     $$mloop:
(1)  324/    1177 : 89                      glo RL8
(1)  325/    1178 : FA 01                   ani 1		;isolate bottom bit of result
(1)  326/    117A : 3B 96                   bnf	$$check_sub	;
(1)  327/    117C : 3A AE                   bnz	$$shift		;that would be the 11 case
(1)  328/    117E :                     ;this is case 01: add second operand to top 32 bits and shift all 64 bits right
(1)  329/    117E : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,add,adc	;32 bit add
(1)  330/    1194 : 30 AE                   br $$shift
(1)  331/    1196 :                     $$check_sub:
 AS V1.42 Beta [Bld 87] - source file fragment.asm(lcc1802Epilofl.inc) - page 22 - 4/4/2013 16:39:08


(1)  332/    1196 : 32 AE                   bz $$shift	;that would be the 00 case
(1)  333/    1198 :                     ;this is case 10: subtract 2nd operand from top 32 bits then shift right
(1)  334/    1198 : (MACRO)                 alu4 Rp1p2,Rp1p2,RL10,sm,smb
(1)  335/    11AE :                     $$shift:
(1)  336/    11AE : (MACRO)                 shRI4 Rp1p2		;shift the top 32 bits
(1)  337/    11BC : (MACRO)                 shRC4 RL8		;continue the shift to the bottom 32 bits
(1)  338/    11C8 :                     
(1)  339/    11C8 : 2E                      dec memaddr		;cycle count
(1)  340/    11C9 : 8E                      glo memaddr
(1)  341/    11CA : 3A 77                   bnz $$mloop		;repeat cycle once for each bit position
(1)  342/    11CC :                         
(1)  343/    11CC : (MACRO)                 cretn	;and we're done. if Rp1p2 is not 0 or -1 we've overflowed 
(1)  344/    11CD :                     
(1)  345/    11CD :                     	align 256
(1)  346/    1200 :                     ;signed integer division RL8=RL8/RL10, remainder in Rp1p2
(1)  347/    1200 :                     ;uses unsigned division of absolute values then negates the quotient if the signs were originally different
(1)  348/    1200 :                     _divI4:
(1)  349/    1200 : 22                      dec	sp	;leave a work area available
(1)  350/    1201 : 98                      ghi RL8-1	;get the top of the dividend
(1)  351/    1202 : 52                      str sp	;save the sign of the 1st arg
(1)  352/    1203 : FE                      shl
(1)  353/    1204 : 3B 26                   bnf $$pos1	;if the 1st arg is -v
(1)  354/    1206 : (MACRO)                 negI4 RL8,RL8 ;flip it to positive
(1)  355/    1226 :                     $$pos1: ;1st is now +v, check 2nd
(1)  356/    1226 : 9A                      ghi RL10-1
(1)  357/    1227 : F3                      xor	
(1)  358/    1228 : 52                      str sp ;the stack now has bit 8 set if the signs are different
(1)  359/    1229 : 9A                      ghi RL10-1
(1)  360/    122A : FE                      shl
(1)  361/    122B : 3B 4D                   bnf $$pos2	;if the 2nd arg is -v
(1)  362/    122D : (MACRO)                 negI4 RL10,RL10 ;flip it to +v
(1)  363/    124D :                     $$pos2: ; both args now +v
(1)  364/    124D : (MACRO)                 Ccall _divU4	;call unsigned division
(1)  365/    1250 :                     ;now the quotient is in RL8 and the remainder is in Rp1p2
(1)  366/    1250 : 42                      lda	sp ;get back the sign bits and restore SP
(1)  367/    1251 : FE                      shl
(1)  368/    1252 : 3B 74                   bnf $$done ;if the signs were different
(1)  369/    1254 : (MACRO)                 negI4 RL8,RL8 ;negate the quotient
(1)  370/    1274 :                     $$done:
(1)  371/    1274 : (MACRO)                 Cretn ;and we're done - I hope!
(1)  372/    1275 :                     
(1)  373/    1275 :                     _dubdabx:	
(1)  374/    1275 :                     ;experimental binay-ascii conversion using the double-dabble algorithm
(1)  375/    1275 :                     ;thanks to Charles Richmond for the suggestion and code
(1)  376/    1275 :                     ;long interger is passed in rp1p2
(1)  377/    1275 :                     ;buffer pointer is passed at sp+2+4
(1)  378/    1275 :                     ;a pointer to the 1st non-zero byte in the buffer is passed back in r15
(1)  379/    1275 :                     ;r8-11 are used as temps
(1)  380/    1275 :                     ;r8 is the working pointer
(1)  381/    1275 :                     ;r15.0 is bit count(32) and the return value register
(1)  382/    1275 :                     ;r9.0 is digit count
(1)  383/    1275 :                     ;r10 is the number of digits wanted in the result including leading 0's - 0 means no leading 0's
(1)  384/    1275 : (MACRO)             	ld2 r8,'O',sp,(2+4); pick up the buffer pointer
(1)  385/    1281 : (MACRO)             	ld2 r10,'O',sp,(2+4+2); pick up the number of digits wanted
(1)  386/    128D : (MACRO)             	cpy2 r15,r8 ;save address for now
(1)  387/    1291 : F8 0B               	ldi 11	;digit count+1 for trailing 0
(1)  388/    1293 : A9                  	plo r9
(1)  389/    1294 :                     $$clrlp:	;clear the passed buffer
(1)  390/    1294 : F8 00               	ldi 0	
(1)  391/    1296 : 58                  	str r8	;clear a byte
 AS V1.42 Beta [Bld 87] - source file fragment.asm(lcc1802Epilofl.inc) - page 23 - 4/4/2013 16:39:08


(1)  392/    1297 : 18                  	inc r8
(1)  393/    1298 : 29                  	dec r9
(1)  394/    1299 : 89                  	glo r9	;check the count
(1)  395/    129A : 3A 94               	bnz $$clrlp ;back for more
(1)  396/    129C : (MACRO)             	cpy2 r8,r15 ;get the address back
(1)  397/    12A0 :                     
(1)  398/    12A0 : F8 20               	ldi 32	;bit count
(1)  399/    12A2 : AF                  	plo r15
(1)  400/    12A3 :                     ;now i'm going to spin off any leading 0's in the binary number
(1)  401/    12A3 :                     $$cktop:
(1)  402/    12A3 : 9C                  	ghi rp1p2-1	;get the top bit of the number
(1)  403/    12A4 : FE                  	shl		;check for a 1
(1)  404/    12A5 : 33 B8               	bdf $$bitloop	;move on if we have one
(1)  405/    12A7 : (MACRO)             	shl4 rp1p2	;shift the input number
(1)  406/    12B3 : 2F                  	dec r15		;reduce the number of times to shift
(1)  407/    12B4 : 8F                  	glo r15
(1)  408/    12B5 : 3A A3               	bnz $$cktop	;
(1)  409/    12B7 : 1F                  	inc r15		;our whole number was 0 but force at least one pass
(1)  410/    12B8 :                     $$bitloop:
(1)  411/    12B8 : F8 0A               	ldi 10	;digit count
(1)  412/    12BA : A9                  	plo r9
(1)  413/    12BB :                     $$dcklp:
(1)  414/    12BB : 08                  	ldn r8 	;pick up a digit
(1)  415/    12BC : FF 05               	smi 5	;see if it's greater than 4
(1)  416/    12BE : 3B C3               	bnf $$dnoadd ;if not, bypass add
(1)  417/    12C0 : FC 08               	adi 0x08	;add the 5 black and 3 more
(1)  418/    12C2 : 58                  	str r8	;put it back
(1)  419/    12C3 :                     $$dnoadd:
(1)  420/    12C3 : 18                  	inc r8
(1)  421/    12C4 : 29                  	dec r9	;decrement digit count
(1)  422/    12C5 : 89                  	glo r9
(1)  423/    12C6 : 3A BB               	bnz $$dcklp ;and back for next digit
(1)  424/    12C8 :                     	
(1)  425/    12C8 : (MACRO)             	shl4 rp1p2 ;shift the input number
(1)  426/    12D4 :                     	
(1)  427/    12D4 : F8 0A               	ldi 10	;load the digit count again
(1)  428/    12D6 : A9                  	plo r9
(1)  429/    12D7 :                     ;r8 is now just past the units location and ready to walk back
(1)  430/    12D7 :                     $$dshlp:
(1)  431/    12D7 : 28                  	dec r8	;walk back from 0's position
(1)  432/    12D8 : 08                  	ldn r8	;get the digit back
(1)  433/    12D9 : 7E                  	shlc	;continue the shift
(1)  434/    12DA : BF                  	phi r15 ;save it for the carry test
(1)  435/    12DB : FA 0F               	ani 0x0f ;clear the 10 bit
(1)  436/    12DD : 58                  	str r8	;put the digit back
(1)  437/    12DE : 9F                  	ghi r15	;now test for carry
(1)  438/    12DF : FF 10               	smi 0x10 ; this will make df 1 if the 10 bit is set
(1)  439/    12E1 : 29                  	dec r9	;decrement the digit count
(1)  440/    12E2 : 89                  	glo r9
(1)  441/    12E3 : 3A D7               	bnz $$dshlp ;back for more if needed
(1)  442/    12E5 :                     	
(1)  443/    12E5 : 2F                  	dec r15
(1)  444/    12E6 : 8F                  	glo r15
(1)  445/    12E7 : 3A B8               	bnz $$bitloop
(1)  446/    12E9 :                     	
(1)  447/    12E9 : (MACRO)             	cpy2 r15,r8	;save the starting location of the digits
(1)  448/    12ED : F8 0A               	ldi 10		;digit count again
(1)  449/    12EF : A9                  	plo r9
(1)  450/    12F0 :                     $$upnxt:
(1)  451/    12F0 : 08                  	ldn r8		;get digit
 AS V1.42 Beta [Bld 87] - source file fragment.asm(lcc1802Epilofl.inc) - page 24 - 4/4/2013 16:39:08


(1)  452/    12F1 : F9 30               	ori 0x30	;make ascii
(1)  453/    12F3 : 58                  	str r8		;put it back
(1)  454/    12F4 : 18                  	inc r8		;next digit
(1)  455/    12F5 : 29                  	dec r9		;counter
(1)  456/    12F6 : 89                  	glo r9
(1)  457/    12F7 : 3A F0               	bnz $$upnxt	;upgrade all 10 spots
(1)  458/    12F9 :                     	
(1)  459/    12F9 : (MACRO)             	ldaX memaddr,sp,(2+4+2+1)	;point to lsb of desired digit count
(1)  460/    1301 : EE                  	sex memaddr	;set up
(1)  461/    1302 : F8 0A               	ldi 10		;max number of 0's to skip
(1)  462/    1304 : F7                  	sm		;desired number of digits to skip
(1)  463/    1305 : E2                  	sex sp		;reset index register
(1)  464/    1306 : A9                  	plo r9		;number of leading 0's to skip
(1)  465/    1307 :                     $$cknext:
(1)  466/    1307 : 0F                  	ldn r15		;check digit
(1)  467/    1308 : FF 30               	smi 0x30	;for '0'
(1)  468/    130A : 3A 11               	bnz $$done
(1)  469/    130C : 1F                  	inc r15		;next digit
(1)  470/    130D : 29                  	dec r9		;reduce count
(1)  471/    130E : 89                  	glo r9
(1)  472/    130F : 3A 07               	bnz $$cknext
(1)  473/    1311 :                     $$done:
(1)  474/    1311 : (MACRO)             	cretn
(1)  475/    1312 :                     	
(1)  476/    1312 :                     	
(1)  477/    1312 :                     _modU4:	;32 bit unsigned remainder
(1)  478/    1312 :                     	; just calls the 32 bit division then puts remainder into return value
(1)  479/    1312 : (MACRO)                 Ccall _divU4
(1)  480/    1315 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  481/    131D : (MACRO)                 Cretn
(1)  482/    131E :                         
(1)  483/    131E :                     _modI4:	;32 bit signed remainder
(1)  484/    131E :                     	; just calls the 32 bit division then puts remainder into return value
(1)  485/    131E : (MACRO)                 Ccall _divI4
(1)  486/    1321 : (MACRO)                 cpy4 RL8,Rp1p2
(1)  487/    1329 : (MACRO)                 Cretn
(1)  488/    132A :                         
(1)  489/    132A :                     	
(1)  490/    132A :                      
     929/    132A :                     	include LCC1802fp.inc
(1)    1/    132A :                     ;from http://www.elf-emulation.com/software/fp.asm - thanks to mike Reilley
(1)    2/    132A :                     ;maybe originally from RCA
(1)    3/    132A :                     ;these routines use ALL the registers from 6-15!
(1)    4/    132A :                     ;8-15 were more or less available to start with
(1)    5/    132A :                     ;it saves 6 when it uses it
(1)    6/    132A :                     ;I save 7 on entry and restore on exit
(1)    7/    132A :                     ;to keep my sanity I renamed some register equates where I was changing them e.g. F7 used to be RB
(1)    8/    132A : =BH                 FB	equ	11	;was R9
(1)    9/    132A : =9H                 F9	equ	9	;was R7
(1)   10/    132A : =7H                 F7	equ	7	;was RB
(1)   11/    132A :                     ;April 1 added code to fp_add to restore resgisters when returning a 0 - around add_nz:
(1)   12/    132A :                     ; *** Convert signed long to float
(1)   13/    132A :                     ; *** RL8-1:RL8 is the number to convert(8:9)
(1)   14/    132A :                     ; *** result in same register
(1)   15/    132A :                     ; *** uses memaddr.1 for sign, .0 for shift count/exponent
(1)   16/    132A :                     	align 256
(1)   17/    1400 : F8 00               cvif4:	ldi	0
(1)   18/    1402 : BE                  	phi	memaddr	;sign
(1)   19/    1403 : F8 96               	ldi	150	;150 is  the 127 exponent bias plus the 23 required to shift a long 1 to bit 23
(1)   20/    1405 : AE                  	plo	memaddr	;
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 25 - 4/4/2013 16:39:08


(1)   21/    1406 : 98                  	ghi	RL8-1	;get sign and bits 7-1 of exponent
(1)   22/    1407 : 32 30               	bz	$$nxt	;keep testing for 0
(1)   23/    1409 : FE                  	shl		;sign bit to df
(1)   24/    140A : 3B 39               	bnf	$$sgnpos ;number is >0
(1)   25/    140C : 76                  	shrc		;shift it back so we know byte is non-zerro
(1)   26/    140D : BE                  	phi	memaddr	;save it
(1)   27/    140E : (MACRO)             	negi4	RL8,RL8	;flip the number
(1)   28/    142E : 30 39               	br	$$sgnpos ;go handle positive long
(1)   29/    1430 : 88                  $$nxt:	glo	RL8-1	;next byte
(1)   30/    1431 : 3A 39               	bnz	$$sgnpos ;sign is positive, number is not 0
(1)   31/    1433 : 99                  	ghi	RL8	;next byte
(1)   32/    1434 : 3A 39               	bnz	$$sgnpos ;sign is positive, number is not 0
(1)   33/    1436 : 89                  	glo	RL8	;last byte
(1)   34/    1437 : 32 6F               	bz	$$done	;the whole thing is zero so we're done
(1)   35/    1439 : 98                  $$sgnpos: ghi	RL8-1	;top byte - begin shifting right to clear it
(1)   36/    143A : 32 4B               	bz	$$shl	;if it's zero we're done right shifting
(1)   37/    143C : 1E                  	inc	memaddr	;increase exponent 1 for each right shift
(1)   38/    143D : (MACRO)             	shru4	RL8
(1)   39/    1449 : 30 39               	br	$$sgnpos
(1)   40/    144B : 88                  $$shl:	glo	RL8-1	;check bit 23
(1)   41/    144C : FA 80               	ani	0x80	;isolate it
(1)   42/    144E : 3A 5F               	bnz	$$shdn	;if it's on we're done here
(1)   43/    1450 : 2E                  	dec	memaddr	;decrease exponent 1 for each left shift
(1)   44/    1451 : (MACRO)             	shl4	RL8	;shift mantissa left one
(1)   45/    145D : 30 4B               	br	$$shl
(1)   46/    145F : 8E                  $$shdn:	glo	memaddr	;get the exponent
(1)   47/    1460 : F6                  	shr		;shift right so it can go into bits 31-24
(1)   48/    1461 : B8                  	phi	RL8-1	;put top bits of exponent into place
(1)   49/    1462 : 33 68               	bdf	$$setsgn ;if the bit 0 is on we're done
(1)   50/    1464 : 88                  	glo	RL8-1	;get the byte
(1)   51/    1465 : FA 7F               	ani	0x7f	;clear bit 23
(1)   52/    1467 : A8                  	plo	RL8-1	;put it back
(1)   53/    1468 : 9E                  $$setsgn: ghi	memaddr	;get the original sign byte
(1)   54/    1469 : 32 6F               	bz	$$done	;sign bit is already zero so we're done
(1)   55/    146B : 98                  	ghi	RL8-1	;get the sign byte
(1)   56/    146C : F9 80               	ori	0x80	;set the sign bit
(1)   57/    146E : B8                  	phi	RL8-1	;place it
(1)   58/    146F : (MACRO)             $$done:	Cretn		;and we're done
(1)   59/    1470 :                     	
(1)   60/    1470 :                     
(1)   61/    1470 :                     
(1)   62/    1470 :                     ; *** Convert float to signed long
(1)   63/    1470 :                     ; *** RL8-1:RL8 is the number to convert(8:9)
(1)   64/    1470 :                     ; *** result in same register
(1)   65/    1470 :                     	align 256
(1)   66/    1500 :                     cvfi4:
(1)   67/    1500 : 98                  	ghi	RL8-1	;get sign and bits 7-1 of exponent
(1)   68/    1501 : BE                  	phi	memaddr ;save for later
(1)   69/    1502 : 88                  	glo	RL8-1	;get bit 0 of exponent
(1)   70/    1503 : FE                  	shl		;shift to df
(1)   71/    1504 : 9E                  	ghi	memaddr	;get exponent 7-1
(1)   72/    1505 : 7E                  	shlc		;combine with 0
(1)   73/    1506 :                     ;the following sequence is equivalent to sdi 150; I did it this way to coddle my emulator which doesn't do this properly.
(1)   74/    1506 : 22                  	dec	sp
(1)   75/    1507 : 52                  	str	sp
(1)   76/    1508 : F8 96               	ldi	150
(1)   77/    150A : F7                  	sm		;calculate shift count needed
(1)   78/    150B :                     ;*******note - the df flag set here is tested later
(1)   79/    150B : AE                  	plo	memaddr
(1)   80/    150C : 12                  	inc	sp	;release work area
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 26 - 4/4/2013 16:39:08


(1)   81/    150D :                     ;end of sdi 150 sequence - now convert the mantissa to unsigned long
(1)   82/    150D : F8 00               	ldi	0
(1)   83/    150F : B8                  	phi	RL8-1	;clear the top byte of the float
(1)   84/    1510 : 88                  	glo	RL8-1	;get the next byte
(1)   85/    1511 : F9 80               	ori	0x80	;add in the implied 1 bit
(1)   86/    1513 : A8                  	plo	RL8-1	;put it back
(1)   87/    1514 : 8E                  	glo	memaddr	;make sure there's at least 1 shift
(1)   88/    1515 : 32 3B               	bz	$$sign
(1)   89/    1517 :                     ;**********note df is set from subtraction before setting mantissa
(1)   90/    1517 : 3B 2B               	bnf	$$lsh ; if the shift count is negative
(1)   91/    1519 :                     
(1)   92/    1519 : (MACRO)             $$shr:	shru4	RL8
(1)   93/    1525 : 2E                  	dec	memaddr	;check shift count
(1)   94/    1526 : 8E                  	glo	memaddr
(1)   95/    1527 : 3A 19               	bnz	$$shr	;complete the shift
(1)   96/    1529 : 30 3B               	br	$$sign
(1)   97/    152B :                     
(1)   98/    152B :                     ;handle negative shift as best I can - gigo
(1)   99/    152B : (MACRO)             $$lsh: 	shl4	RL8	;shift once
(1)  100/    1537 : 1E                  	inc	memaddr
(1)  101/    1538 : 8E                  	glo	memaddr
(1)  102/    1539 : 3A 2B               	bnz	$$lsh	
(1)  103/    153B :                     	
(1)  104/    153B : 9E                  $$sign:	ghi	memaddr	;now the sign
(1)  105/    153C : FE                  	shl		;shift sign bit into df
(1)  106/    153D : 3B 61               	bnf	$$done
(1)  107/    153F : (MACRO)             	negi4	RL8,RL8	;negate the number if needed
(1)  108/    155F : 30 61               	br	$$done	; and return
(1)  109/    1561 :                     
(1)  110/    1561 : (MACRO)             $$done:	Cretn		;and we're done
(1)  111/    1562 :                     
(1)  112/    1562 :                     ; *** Check if character is numeric
(1)  113/    1562 :                     ; *** D - char to check
(1)  114/    1562 :                     ; *** Returns DF=1 if numeric
(1)  115/    1562 :                     ; ***         DF=0 if not
(1)  116/    1562 : AE                  f_isnum:   plo     r14                 ; save a copy
(1)  117/    1563 : FF 30                          smi     '0'                 ; check for below zero
(1)  118/    1565 : 3B 6E                          bnf     fails               ; jump if below
(1)  119/    1567 : FF 0A                          smi     10                  ; see if above
(1)  120/    1569 : 33 6E                          bdf     fails               ; fails if so
(1)  121/    156B : FF 00               passes:    smi     0                   ; signal success
(1)  122/    156D : C8                             lskp
(1)  123/    156E : FC 00               fails:     adi     0                   ; signal failure
(1)  124/    1570 : 8E                             glo     r14                 ; recover character
(1)  125/    1571 : D5                             sep     RRET                ; and return; *******************************
(1)  126/    1572 :                     ; *** Shift R8:F9 right 1 bit ***
(1)  127/    1572 :                     ; *******************************
(1)  128/    1572 : 98                  fp_shr_1:  ghi   r8                    ; shift high word right
(1)  129/    1573 : F6                             shr
(1)  130/    1574 : B8                             phi   r8
(1)  131/    1575 : 88                             glo   r8
(1)  132/    1576 : 76                             shrc
(1)  133/    1577 : A8                             plo   r8
(1)  134/    1578 : 99                             ghi   F9                    ; shift low word right
(1)  135/    1579 : 76                             shrc
(1)  136/    157A : B9                             phi   F9
(1)  137/    157B : 89                             glo   F9
(1)  138/    157C : 76                             shrc
(1)  139/    157D : A9                             plo   F9
(1)  140/    157E : (MACRO)                        Cretn
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 27 - 4/4/2013 16:39:08


(1)  141/    157F :                     
(1)  142/    157F :                     ; ******************************
(1)  143/    157F :                     ; *** Shift R8:F9 left 1 bit ***
(1)  144/    157F :                     ; ******************************
(1)  145/    157F : 89                  fp_shl_1:  glo   F9
(1)  146/    1580 : FE                             shl
(1)  147/    1581 : A9                             plo   F9
(1)  148/    1582 : 99                             ghi   F9
(1)  149/    1583 : 7E                             shlc
(1)  150/    1584 : B9                             phi   F9
(1)  151/    1585 : 88                             glo   r8
(1)  152/    1586 : 7E                             shlc
(1)  153/    1587 : A8                             plo   r8
(1)  154/    1588 : 98                             ghi   r8
(1)  155/    1589 : 7E                             shlc
(1)  156/    158A : B8                             phi   r8
(1)  157/    158B : D5                             sep   RRET
(1)  158/    158C :                     
(1)  159/    158C :                     ; **********************
(1)  160/    158C :                     ; *** R8:F9 += RA:FB ***
(1)  161/    158C :                     ; **********************
(1)  162/    158C : 8B                  fp_add_12: glo   FB
(1)  163/    158D : 22                  	   dec r2	;wjr - make a work area
(1)  164/    158E : 52                             str   r2
(1)  165/    158F : 89                             glo   F9
(1)  166/    1590 : F4                             add
(1)  167/    1591 : A9                             plo   F9
(1)  168/    1592 : 9B                             ghi   FB
(1)  169/    1593 : 52                             str   r2
(1)  170/    1594 : 99                             ghi   F9
(1)  171/    1595 : 74                             adc
(1)  172/    1596 : B9                             phi   F9
(1)  173/    1597 : 8A                             glo   R10
(1)  174/    1598 : 52                             str   r2
(1)  175/    1599 : 88                             glo   r8
(1)  176/    159A : 74                             adc
(1)  177/    159B : A8                             plo   r8
(1)  178/    159C : 9A                             ghi   R10
(1)  179/    159D : 52                             str   r2
(1)  180/    159E : 98                             ghi   r8
(1)  181/    159F : 74                             adc
(1)  182/    15A0 : B8                             phi   r8
(1)  183/    15A1 : 12                             inc	r2	;wjr - release work area
(1)  184/    15A2 : (MACRO)                        Cretn
(1)  185/    15A3 :                     
(1)  186/    15A3 :                     ; *******************************
(1)  187/    15A3 :                     ; *** Shift RF:RD right 1 bit ***
(1)  188/    15A3 :                     ; *******************************
(1)  189/    15A3 : 9F                  fp_shr_fd: ghi   R15                    ; shift high word right
(1)  190/    15A4 : F6                             shr
(1)  191/    15A5 : BF                             phi   R15
(1)  192/    15A6 : 8F                             glo   R15
(1)  193/    15A7 : 76                             shrc
(1)  194/    15A8 : AF                             plo   R15
(1)  195/    15A9 : 9D                             ghi   R13                    ; shift low word right
(1)  196/    15AA : 76                             shrc
(1)  197/    15AB : BD                             phi   R13
(1)  198/    15AC : 8D                             glo   R13
(1)  199/    15AD : 76                             shrc
(1)  200/    15AE : AD                             plo   R13
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 28 - 4/4/2013 16:39:08


(1)  201/    15AF : (MACRO)                        Cretn
(1)  202/    15B0 :                     
(1)  203/    15B0 :                     ; *************************************
(1)  204/    15B0 :                     ; *** Scale number to high bit is 1 ***
(1)  205/    15B0 :                     ; *** R8:F9 - Number to scale       ***
(1)  206/    15B0 :                     ; *** RF.1  - Exponent for number   ***
(1)  207/    15B0 :                     ; *** F7.0  - Sign bit (bit 0) ***
(1)  208/    15B0 :                     ; *** Returns: R8:F9 - final sp num ***
(1)  209/    15B0 :                     ; *************************************
(1)  210/    15B0 : 88                  fp_sc_up:  glo   r8                    ; need high bit to be a 1
(1)  211/    15B1 : FA 80                          ani   080h                  ; check it
(1)  212/    15B3 : CA 15 C0                       lbnz  fp_sc_cln             ; jump if good
(1)  213/    15B6 : (MACRO)                        Ccall fp_shl_1              ; shift answer left
(1)  214/    15B9 : 9F                             ghi   R15                    ; get exp1
(1)  215/    15BA : FF 01                          smi   1                     ; minus 1
(1)  216/    15BC : BF                             phi   R15                    ; and put it back
(1)  217/    15BD : C0 15 B0                       lbr   fp_sc_up              ; loop back intil msbit is 1
(1)  218/    15C0 : 88                  fp_sc_cln: glo   r8                    ; get high byte
(1)  219/    15C1 : FE                             shl                         ; shift out high 1 bit
(1)  220/    15C2 : A8                             plo   r8                    ; set aside
(1)  221/    15C3 : 9F                             ghi   R15                    ; get exponent byte
(1)  222/    15C4 : B8                             phi   r8                    ; write other 7 bits to r8.1
(1)  223/    15C5 : F6                             shr                         ; shift bit 0 into DF
(1)  224/    15C6 : 88                             glo   r8                    ; get high byte of mantissa
(1)  225/    15C7 : 76                             shrc                        ; shift bit 0 of expnent in
(1)  226/    15C8 : A8                             plo   r8                    ; and put it back
(1)  227/    15C9 : 87                             glo   F7                   ; get signs
(1)  228/    15CA : F6                             shr                         ; get sign 1
(1)  229/    15CB : 98                             ghi   r8                    ; recover exponent
(1)  230/    15CC : 76                             shrc                        ; shift in sign
(1)  231/    15CD : B8                             phi   r8                    ; put it back
(1)  232/    15CE : 12                             inc	r2	;wjr release work area
(1)  233/    15CF : (MACRO)             	   popr R13	;wjr restore param regs
(1)  234/    15D3 : (MACRO)             	   popr R12	;wjr
(1)  235/    15D7 : (MACRO)                        popr	F7	;wjr restore c variable register
(1)  236/    15DB : (MACRO)                        Cretn                       ; return to caller
(1)  237/    15DC :                     
(1)  238/    15DC :                     ; ************************************
(1)  239/    15DC :                     ; *** Get exponenst from arguments ***
(1)  240/    15DC :                     ; *** R8:F9 - Arg 1                ***
(1)  241/    15DC :                     ; *** RA:FB - Arg 2                ***
(1)  242/    15DC :                     ; *** Returns: RF.1 - exp1         ***
(1)  243/    15DC :                     ; ***          RF.0 - exp2         ***
(1)  244/    15DC :                     ; ************************************
(1)  245/    15DC : 88                  fp_getexp: glo   r8                    ; get exponent of arg1 (bit 0)
(1)  246/    15DD : FE                             shl                         ; shift it into DF
(1)  247/    15DE : 98                             ghi   r8                    ; get top 7 bits
(1)  248/    15DF : 7E                             shlc                        ; shift in first bit
(1)  249/    15E0 : BF                             phi   R15                    ; put exp1 into RF.1
(1)  250/    15E1 :                                ;str   r2    wjr - this is never used; place into memory as well
(1)  251/    15E1 : 8A                             glo   R10                    ; get exponent of arg2 (bit 0)
(1)  252/    15E2 : FE                             shl                         ; shift it into DF
(1)  253/    15E3 : 9A                             ghi   R10                    ; get top 7 bits
(1)  254/    15E4 : 7E                             shlc                        ; shift in first bit
(1)  255/    15E5 : AF                             plo   R15                    ; put into RF
(1)  256/    15E6 : D5                             sep   RRET                  ; return to caller
(1)  257/    15E7 :                     
(1)  258/    15E7 :                     ; ************************************
(1)  259/    15E7 :                     ; *** Get signs from arguments     ***
(1)  260/    15E7 :                     ; *** R8:F9 - Arg 1                ***
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 29 - 4/4/2013 16:39:08


(1)  261/    15E7 :                     ; *** RA:FB - Arg 2                ***
(1)  262/    15E7 :                     ; *** Returns: F7.0 - signs        ***
(1)  263/    15E7 :                     ; ************************************
(1)  264/    15E7 : 98                  fp_getsgn: ghi   r8                    ; get sign of arg1
(1)  265/    15E8 : FE                             shl                         ; shift into DF
(1)  266/    15E9 : 9A                             ghi   R10                    ; get sign of arg2
(1)  267/    15EA : 7E                             shlc                        ; shift into DF, sign of arg1 to bit 0
(1)  268/    15EB : 7E                             shlc                        ; now shift in sign of arg2
(1)  269/    15EC : A7                             plo   F7                    ; save them
(1)  270/    15ED : (MACRO)                        Cretn                       ; return to caller
(1)  271/    15EE :                     
(1)  272/    15EE :                     ; ***************************************
(1)  273/    15EE :                     ; *** Add 2 SP floating point numbers ***
(1)  274/    15EE :                     ; *** R8:F9 - Arg 1                   ***
(1)  275/    15EE :                     ; *** RA:FB - Arg 2                   ***
(1)  276/    15EE :                     ; *** Returns: R8:F9 - Answer         ***
(1)  277/    15EE :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  278/    15EE :                     ; ***        RF.1 - exponent of arg2  ***
(1)  279/    15EE :                     ; ***        F7.0 - signs        ***
(1)  280/    15EE :                     ; ***************************************
(1)  281/    15EE : 98                  fp_add:   ghi   r8                    ; check arg1 for zero
(1)  282/    15EF : CA 16 07                       lbnz  add_a1nz
(1)  283/    15F2 : 88                             glo   r8
(1)  284/    15F3 : CA 16 07                       lbnz  add_a1nz
(1)  285/    15F6 : 99                             ghi   F9
(1)  286/    15F7 : CA 16 07                       lbnz  add_a1nz
(1)  287/    15FA : 89                             glo   F9
(1)  288/    15FB : CA 16 07                       lbnz  add_a1nz
(1)  289/    15FE : 9A                             ghi   R10                    ; transfer arg2 to answer
(1)  290/    15FF : B8                             phi   r8
(1)  291/    1600 : 8A                             glo   R10
(1)  292/    1601 : A8                             plo   r8
(1)  293/    1602 : 9B                             ghi   FB
(1)  294/    1603 : B9                             phi   F9
(1)  295/    1604 : 8B                             glo   FB
(1)  296/    1605 : A9                             plo   F9
(1)  297/    1606 : (MACRO)                        Cretn                        ; return to caller
(1)  298/    1607 :                     
(1)  299/    1607 : 9A                  add_a1nz:  ghi   R10                    ; check arg2 for zero
(1)  300/    1608 : CA 16 18                       lbnz  add_a2nz
(1)  301/    160B : 8A                             glo   R10
(1)  302/    160C : CA 16 18                       lbnz  add_a2nz
(1)  303/    160F : 9B                             ghi   FB
(1)  304/    1610 : CA 16 18                       lbnz  add_a2nz
(1)  305/    1613 : 8B                             glo   FB
(1)  306/    1614 : CA 16 18                       lbnz  add_a2nz
(1)  307/    1617 : (MACRO)                        Cretn                       ; return arg1 as answer
(1)  308/    1618 :                                
(1)  309/    1618 : (MACRO)             add_a2nz:  pushr F7	;wjr save c variable register
(1)  310/    161D : (MACRO)             	   pushr R12	;wjr save param regs
(1)  311/    1622 : (MACRO)             	   pushr R13	;wjr
(1)  312/    1627 : 22                  	   dec	r2	;wjr - make a work area
(1)  313/    1628 : (MACRO)             	   Ccall fp_getexp             ; get exponents
(1)  314/    162B : 9F                             ghi   R15
(1)  315/    162C : 52                             str   r2
(1)  316/    162D : 8F                             glo   R15
(1)  317/    162E : F7                             sm                          ; perfrom exp2 - exp1
(1)  318/    162F : CB 16 50                       lbnf  add_ns                ; jump if no swap needed
(1)  319/    1632 :                     
(1)  320/    1632 : 98                             ghi   r8                    ; swap arg1 with arg2
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 30 - 4/4/2013 16:39:08


(1)  321/    1633 : AE                             plo   R14
(1)  322/    1634 : 9A                             ghi   R10
(1)  323/    1635 : B8                             phi   r8
(1)  324/    1636 : 8E                             glo   R14
(1)  325/    1637 : BA                             phi   R10
(1)  326/    1638 : 88                             glo   r8
(1)  327/    1639 : AE                             plo   R14
(1)  328/    163A : 8A                             glo   R10
(1)  329/    163B : A8                             plo   r8
(1)  330/    163C : 8E                             glo   R14
(1)  331/    163D : AA                             plo   R10
(1)  332/    163E : 99                             ghi   F9                    ; swap arg1 with arg2
(1)  333/    163F : AE                             plo   R14
(1)  334/    1640 : 9B                             ghi   FB
(1)  335/    1641 : B9                             phi   F9
(1)  336/    1642 : 8E                             glo   R14
(1)  337/    1643 : BB                             phi   FB
(1)  338/    1644 : 89                             glo   F9
(1)  339/    1645 : AE                             plo   R14
(1)  340/    1646 : 8B                             glo   FB
(1)  341/    1647 : A9                             plo   F9
(1)  342/    1648 : 8E                             glo   R14
(1)  343/    1649 : AB                             plo   FB
(1)  344/    164A : 9F                             ghi   R15                    ; swap exponents
(1)  345/    164B : AE                             plo   R14
(1)  346/    164C : 8F                             glo   R15
(1)  347/    164D : BF                             phi   R15
(1)  348/    164E : 8E                             glo   R14
(1)  349/    164F : AF                             plo   R15
(1)  350/    1650 : (MACRO)             add_ns:    ccall fp_getsgn              ; get signs of arguments
(1)  351/    1653 : F8 00                          ldi   0                     ; setup mantissas
(1)  352/    1655 : B8                             phi   r8
(1)  353/    1656 : BA                             phi   R10
(1)  354/    1657 : F8 80                          ldi   128                   ; need to set high bit in mantissa
(1)  355/    1659 : 52                             str   r2
(1)  356/    165A : 88                             glo   r8
(1)  357/    165B : F1                             or
(1)  358/    165C : A8                             plo   r8
(1)  359/    165D : 8A                             glo   R10
(1)  360/    165E : F1                             or
(1)  361/    165F : AA                             plo   R10
(1)  362/    1660 : 9F                             ghi   R15                    ; get exp1
(1)  363/    1661 : 52                             str   r2                    ; place into memory
(1)  364/    1662 : 8F                  add_lp1:   glo   R15                    ; get exp2
(1)  365/    1663 : F7                             sm                          ; see if match to exp1
(1)  366/    1664 : C2 16 77                       lbz   add_lp1dn             ; jump if match
(1)  367/    1667 : 8F                             glo   R15                    ; need to increase it
(1)  368/    1668 : FC 01                          adi   1
(1)  369/    166A : AF                             plo   R15
(1)  370/    166B : 8A                             glo   R10                    ; now shift arg2 over 1 bit
(1)  371/    166C : F6                             shr
(1)  372/    166D : AA                             plo   R10
(1)  373/    166E : 9B                             ghi   FB
(1)  374/    166F : 76                             shrc
(1)  375/    1670 : BB                             phi   FB
(1)  376/    1671 : 8B                             glo   FB
(1)  377/    1672 : 76                             shrc
(1)  378/    1673 : AB                             plo   FB
(1)  379/    1674 : C0 16 62                       lbr   add_lp1               ; keep shifting until exponents match
(1)  380/    1677 : 87                  add_lp1dn: glo   F7                    ; see if signs match
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 31 - 4/4/2013 16:39:08


(1)  381/    1678 : 52                             str   r2
(1)  382/    1679 : F6                             shr
(1)  383/    167A : F3                             xor
(1)  384/    167B : FA 01                          ani   1                     ; keep only bottom bit
(1)  385/    167D : CA 16 86                       lbnz  add_nm                ; jump if signs do not match
(1)  386/    1680 : (MACRO)                        Ccall fp_add_12             ; perform arg1 += arg2
(1)  387/    1683 : C0 16 BF                       lbr   add_fnl               ; jump to clean up
(1)  388/    1686 : 8B                  add_nm:    glo   FB                    ; perform arg1 - arg2
(1)  389/    1687 : 52                             str   r2
(1)  390/    1688 : 89                             glo   F9
(1)  391/    1689 : F7                             sm
(1)  392/    168A : AC                             plo   R12                    ; place into RD:RC
(1)  393/    168B : 9B                             ghi   FB
(1)  394/    168C : 52                             str   r2
(1)  395/    168D : 99                             ghi   F9
(1)  396/    168E : 77                             smb
(1)  397/    168F : BC                             phi   R12
(1)  398/    1690 : 8A                             glo   R10
(1)  399/    1691 : 52                             str   r2
(1)  400/    1692 : 88                             glo   r8
(1)  401/    1693 : 77                             smb
(1)  402/    1694 : AD                             plo   R13
(1)  403/    1695 : 9A                             ghi   R10
(1)  404/    1696 : 52                             str   r2
(1)  405/    1697 : 98                             ghi   r8
(1)  406/    1698 : 77                             smb
(1)  407/    1699 : BD                             phi   R13
(1)  408/    169A : CB 16 A8                       lbnf  add_no                ; jump if arg2 was larger than arg1
(1)  409/    169D : 9D                             ghi   R13                    ; transfer result to arg1
(1)  410/    169E : B8                             phi   r8
(1)  411/    169F : 8D                             glo   R13
(1)  412/    16A0 : A8                             plo   r8
(1)  413/    16A1 : 9C                             ghi   R12
(1)  414/    16A2 : B9                             phi   F9
(1)  415/    16A3 : 8C                             glo   R12
(1)  416/    16A4 : A9                             plo   F9
(1)  417/    16A5 : C0 16 BF                       lbr   add_fnl               ; finalize
(1)  418/    16A8 : 89                  add_no:    glo   F9                    ; perform arg1 = arg2 - arg1
(1)  419/    16A9 : 52                             str   r2
(1)  420/    16AA : 8B                             glo   FB
(1)  421/    16AB : F7                             sm
(1)  422/    16AC : A9                             plo   F9
(1)  423/    16AD : 99                             ghi   F9
(1)  424/    16AE : 52                             str   r2
(1)  425/    16AF : 9B                             ghi   FB
(1)  426/    16B0 : 77                             smb
(1)  427/    16B1 : B9                             phi   F9
(1)  428/    16B2 : 88                             glo   r8
(1)  429/    16B3 : 52                             str   r2
(1)  430/    16B4 : 8A                             glo   R10
(1)  431/    16B5 : 77                             smb
(1)  432/    16B6 : A8                             plo   r8
(1)  433/    16B7 : 98                             ghi   r8
(1)  434/    16B8 : 52                             str   r2
(1)  435/    16B9 : 9A                             ghi   R10
(1)  436/    16BA : 77                             smb
(1)  437/    16BB : B8                             phi   r8
(1)  438/    16BC : 87                             glo   F7                    ; move sign 2 to sign1
(1)  439/    16BD : FE                             shl
(1)  440/    16BE : A7                             plo   F7
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 32 - 4/4/2013 16:39:08


(1)  441/    16BF : 98                  add_fnl:   ghi   r8                    ; check for zero result
(1)  442/    16C0 : CA 16 DD                       lbnz  add_nz                ; jump if not
(1)  443/    16C3 : 88                             glo   r8
(1)  444/    16C4 : CA 16 DD                       lbnz  add_nz
(1)  445/    16C7 : 99                             ghi   F9
(1)  446/    16C8 : CA 16 DD                       lbnz  add_nz
(1)  447/    16CB : 89                             glo   F9
(1)  448/    16CC : CA 16 DD                       lbnz  add_nz
(1)  449/    16CF : 12                             inc	r2	;wjr release work area
(1)  450/    16D0 : (MACRO)             	   popr R13	;wjr restore param regs
(1)  451/    16D4 : (MACRO)             	   popr R12	;wjr
(1)  452/    16D8 : (MACRO)                        popr	F7	;wjr restore c variable register
(1)  453/    16DC : (MACRO)                        Cretn                       ; return the zero
(1)  454/    16DD : 98                  add_nz:    ghi   r8                    ; see if answer is beyond 24 bits
(1)  455/    16DE : C2 16 EB                       lbz   add_nx                ; jump if not
(1)  456/    16E1 : (MACRO)                        Ccall fp_shr_1              ; shift answer to the right
(1)  457/    16E4 : 9F                             ghi   R15                    ; get exp1
(1)  458/    16E5 : FC 01                          adi   1                     ; increment it
(1)  459/    16E7 : BF                             phi   R15                    ; and put it back
(1)  460/    16E8 : C0 16 DD                       lbr   add_nz                ; keep going until not > 24 bits
(1)  461/    16EB :                     
(1)  462/    16EB : 87                  add_nx:    glo   F7                    ; move sign 1 to low bit
(1)  463/    16EC : F6                             shr
(1)  464/    16ED : A7                             plo   F7
(1)  465/    16EE : C0 15 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  466/    16F1 :                     
(1)  467/    16F1 :                     ; ***************************************
(1)  468/    16F1 :                     ; *** sub 2 SP floating point numbers ***
(1)  469/    16F1 :                     ; *** R8:F9 - Arg 1                   ***
(1)  470/    16F1 :                     ; *** RA:FB - Arg 2                   ***
(1)  471/    16F1 :                     ; *** Returns: R8:F9 - Answer         ***
(1)  472/    16F1 :                     ; ***************************************
(1)  473/    16F1 : 9A                  fp_sub:    ghi   R10                    ; change sign of arg2
(1)  474/    16F2 : FB 80                          xri   080h
(1)  475/    16F4 : BA                             phi   R10                    ; and put it back
(1)  476/    16F5 : C0 15 EE                       lbr   fp_add                ; now just add
(1)  477/    16F8 :                     
(1)  478/    16F8 :                     ; ***************************************
(1)  479/    16F8 :                     ; *** Div 2 SP floating point numbers ***
(1)  480/    16F8 :                     ; *** R8:F9 - Arg 1                   ***
(1)  481/    16F8 :                     ; *** RA:FB - Arg 2                   ***
(1)  482/    16F8 :                     ; *** Returns: R8:F9 - Answer         ***
(1)  483/    16F8 :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  484/    16F8 :                     ; ***        RF.1 - exponent of arg2  ***
(1)  485/    16F8 :                     ; ***        F7.0 - signs        ***
(1)  486/    16F8 :                     ; ***************************************
(1)  487/    16F8 : 98                  fp_div:    ghi   r8                    ; check arg1 for zero
(1)  488/    16F9 : CA 17 09                       lbnz  div_a1nz
(1)  489/    16FC : 88                             glo   r8
(1)  490/    16FD : CA 17 09                       lbnz  div_a1nz
(1)  491/    1700 : 99                             ghi   F9
(1)  492/    1701 : CA 17 09                       lbnz  div_a1nz
(1)  493/    1704 : 89                             glo   F9
(1)  494/    1705 : CA 17 09                       lbnz  div_a1nz
(1)  495/    1708 : (MACRO)                        Cretn	                ; just return the zero
(1)  496/    1709 : 9A                  div_a1nz:  ghi   R10                    ; check arg2 for zero
(1)  497/    170A : CA 17 27                       lbnz  div_a2nz
(1)  498/    170D : 8A                             glo   R10
(1)  499/    170E : CA 17 27                       lbnz  div_a2nz
(1)  500/    1711 : 9B                             ghi   FB
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 33 - 4/4/2013 16:39:08


(1)  501/    1712 : CA 17 27                       lbnz  div_a2nz
(1)  502/    1715 : 8B                             glo   FB
(1)  503/    1716 : CA 17 27                       lbnz  div_a2nz
(1)  504/    1719 : 98                             ghi   r8                    ; need sign of arg1
(1)  505/    171A : FA 80                          ani   080h                  ; want only sign
(1)  506/    171C : F9 7F                          ori   07fh                  ; exponent will be all ones
(1)  507/    171E : B8                             phi   r8                    ; put into answer
(1)  508/    171F : F8 80                          ldi   080h                  ; build rest of answer
(1)  509/    1721 : A8                             plo   r8 
(1)  510/    1722 : F8 00                          ldi   0
(1)  511/    1724 : B9                             phi   F9
(1)  512/    1725 : A9                             plo   F9
(1)  513/    1726 : (MACRO)                        Cretn                  	; and return to caller
(1)  514/    1727 :                     
(1)  515/    1727 : (MACRO)             div_a2nz:  pushr F7	;wjr save the C variable
(1)  516/    172C : (MACRO)             	   pushr R12	;wjr save param regs
(1)  517/    1731 : (MACRO)             	   pushr R13	;wjr
(1)  518/    1736 : 22                  	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
(1)  519/    1737 :                     
(1)  520/    1737 : (MACRO)             	   Ccall fp_getexp              ; get exponents
(1)  521/    173A : (MACRO)                        Ccall fp_getsgn		; get signs
(1)  522/    173D : 8F                             glo   R15                    ; get exp2
(1)  523/    173E : FF 7F                          smi   127                   ; remove bias
(1)  524/    1740 : 52                             str   r2                    ; place into memory
(1)  525/    1741 : 9F                             ghi   R15                    ; get exp1
(1)  526/    1742 : FF 7F                          smi   127                   ; remove bias
(1)  527/    1744 : F7                             sm                          ; perform exp1 - exp2
(1)  528/    1745 : FC 7F                          adi   127                   ; put bias back in
(1)  529/    1747 : 73                             stxd                        ; save onto stack
(1)  530/    1748 : 87                             glo   F7                    ; determine sign for answer
(1)  531/    1749 : 52                             str   r2
(1)  532/    174A : F6                             shr
(1)  533/    174B : F3                             xor
(1)  534/    174C : 73                             stxd                        ; place onto stack
(1)  535/    174D : F8 00                          ldi   0                     ; setup man
(1)  536/    174F : BA                             phi   R10
(1)  537/    1750 : 8A                             glo   R10
(1)  538/    1751 : F9 80                          ori   080h
(1)  539/    1753 : AA                             plo   R10
(1)  540/    1754 : F8 00                          ldi   0                     ; setup div
(1)  541/    1756 : B8                             phi   r8
(1)  542/    1757 : 88                             glo   r8
(1)  543/    1758 : F9 80                          ori   080h
(1)  544/    175A : A8                             plo   r8
(1)  545/    175B : F8 00                          ldi   0                     ; setup result
(1)  546/    175D : BC                             phi   R12
(1)  547/    175E : AC                             plo   R12
(1)  548/    175F : B7                             phi   F7
(1)  549/    1760 : A7                             plo   F7
(1)  550/    1761 : AF                             plo   R15                    ; setup quotient
(1)  551/    1762 : BF                             phi   R15
(1)  552/    1763 : BD                             phi   R13
(1)  553/    1764 : AD                             plo   R13
(1)  554/    1765 : F8 80                          ldi   080h
(1)  555/    1767 : AF                             plo   R15
(1)  556/    1768 : 98                  div_lp:    ghi   r8                    ; check div for nonzero
(1)  557/    1769 : CA 17 7B                       lbnz  div_go1
(1)  558/    176C : 88                             glo   r8
(1)  559/    176D : CA 17 7B                       lbnz  div_go1
(1)  560/    1770 : 99                             ghi   F9
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 34 - 4/4/2013 16:39:08


(1)  561/    1771 : CA 17 7B                       lbnz  div_go1
(1)  562/    1774 : 89                             glo   F9
(1)  563/    1775 : CA 17 7B                       lbnz  div_go1
(1)  564/    1778 : C0 17 DB                       lbr   div_z
(1)  565/    177B : 9A                  div_go1:   ghi   R10
(1)  566/    177C : CA 17 8E                       lbnz  div_go
(1)  567/    177F : 8A                             glo   R10
(1)  568/    1780 : CA 17 8E                       lbnz  div_go
(1)  569/    1783 : 9B                             ghi   FB
(1)  570/    1784 : CA 17 8E                       lbnz  div_go
(1)  571/    1787 : 8B                             glo   FB
(1)  572/    1788 : CA 17 8E                       lbnz  div_go
(1)  573/    178B : C0 17 DB                       lbr   div_z                 ; nothing more to do
(1)  574/    178E : 8B                  div_go:    glo   FB                    ; see if div > man
(1)  575/    178F : 52                             str   r2
(1)  576/    1790 : 89                             glo   F9
(1)  577/    1791 : F7                             sm
(1)  578/    1792 : 9B                             ghi   FB
(1)  579/    1793 : 52                             str   r2
(1)  580/    1794 : 99                             ghi   F9
(1)  581/    1795 : 77                             smb
(1)  582/    1796 : 8A                             glo   R10
(1)  583/    1797 : 52                             str   r2
(1)  584/    1798 : 88                             glo   r8
(1)  585/    1799 : 77                             smb
(1)  586/    179A : 9A                             ghi   R10
(1)  587/    179B : 52                             str   r2
(1)  588/    179C : 98                             ghi   r8
(1)  589/    179D : 77                             smb
(1)  590/    179E : CB 17 C9                       lbnf  div_nope              ; jump if div was smaller
(1)  591/    17A1 : 8B                             glo   FB                    ; div -= man
(1)  592/    17A2 : 52                             str   r2
(1)  593/    17A3 : 89                             glo   F9
(1)  594/    17A4 : F7                             sm
(1)  595/    17A5 : A9                             plo   F9
(1)  596/    17A6 : 9B                             ghi   FB
(1)  597/    17A7 : 52                             str   r2
(1)  598/    17A8 : 99                             ghi   F9
(1)  599/    17A9 : 77                             smb
(1)  600/    17AA : B9                             phi   F9
(1)  601/    17AB : 8A                             glo   R10
(1)  602/    17AC : 52                             str   r2
(1)  603/    17AD : 88                             glo   r8
(1)  604/    17AE : 77                             smb
(1)  605/    17AF : A8                             plo   r8
(1)  606/    17B0 : 9A                             ghi   R10
(1)  607/    17B1 : 52                             str   r2
(1)  608/    17B2 : 98                             ghi   r8
(1)  609/    17B3 : 77                             smb
(1)  610/    17B4 : B8                             phi   r8
(1)  611/    17B5 : 9F                             ghi   R15                    ; merge quotient into result
(1)  612/    17B6 : 52                             str   r2
(1)  613/    17B7 : 9C                             ghi   R12
(1)  614/    17B8 : F1                             or
(1)  615/    17B9 : BC                             phi   R12
(1)  616/    17BA : 8F                             glo   R15
(1)  617/    17BB : 52                             str   r2
(1)  618/    17BC : 8C                             glo   R12
(1)  619/    17BD : F1                             or
(1)  620/    17BE : AC                             plo   R12
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 35 - 4/4/2013 16:39:08


(1)  621/    17BF : 9D                             ghi   R13
(1)  622/    17C0 : 52                             str   r2
(1)  623/    17C1 : 97                             ghi   F7
(1)  624/    17C2 : F1                             or
(1)  625/    17C3 : B7                             phi   F7
(1)  626/    17C4 : 8D                             glo   R13
(1)  627/    17C5 : 52                             str   r2
(1)  628/    17C6 : 87                             glo   F7
(1)  629/    17C7 : F1                             or
(1)  630/    17C8 : A7                             plo   F7
(1)  631/    17C9 : D4                  div_nope:  sep   RCALL                 ; shift quotient right
(1)  632/    17CA : 15 A3                          dw    fp_shr_fd
(1)  633/    17CC : 9A                             ghi   R10                    ; shift divisor right
(1)  634/    17CD : F6                             shr
(1)  635/    17CE : BA                             phi   R10
(1)  636/    17CF : 8A                             glo   R10
(1)  637/    17D0 : 76                             shrc
(1)  638/    17D1 : AA                             plo   R10
(1)  639/    17D2 : 9B                             ghi   FB
(1)  640/    17D3 : 76                             shrc
(1)  641/    17D4 : BB                             phi   FB
(1)  642/    17D5 : 8B                             glo   FB
(1)  643/    17D6 : 76                             shrc
(1)  644/    17D7 : AB                             plo   FB
(1)  645/    17D8 : C0 17 68                       lbr   div_lp                ; loop back until done
(1)  646/    17DB : 9C                  div_z:     ghi   R12                    ; move result to arg1
(1)  647/    17DC : B8                             phi   r8
(1)  648/    17DD : 8C                             glo   R12
(1)  649/    17DE : A8                             plo   r8
(1)  650/    17DF : 97                             ghi   F7
(1)  651/    17E0 : B9                             phi   F9
(1)  652/    17E1 : 87                             glo   F7
(1)  653/    17E2 : A9                             plo   F9
(1)  654/    17E3 : 60                             irx                         ; recover sign
(1)  655/    17E4 : 72                             ldxa
(1)  656/    17E5 : A7                             plo   F7
(1)  657/    17E6 : F0                             ldx                         ; recover answer exponent
(1)  658/    17E7 : BF                             phi   R15
(1)  659/    17E8 : C0 15 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  660/    17EB :                     
(1)  661/    17EB :                     ; ***************************************
(1)  662/    17EB :                     ; *** Mul 2 SP floating point numbers ***
(1)  663/    17EB :                     ; *** R8:F9 - Arg 1                   ***
(1)  664/    17EB :                     ; *** RA:FB - Arg 2                   ***
(1)  665/    17EB :                     ; *** Returns: R8:F9 - Answer         ***
(1)  666/    17EB :                     ; *** Usage: RF.0 - exponent of arg1  ***
(1)  667/    17EB :                     ; ***        RF.1 - exponent of arg2  ***
(1)  668/    17EB :                     ; ***        F7.0 - signs             ***
(1)  669/    17EB :                     ; ***************************************
(1)  670/    17EB : (MACRO)             fp_mul:    pushr F7	;wjr save the C variable
(1)  671/    17F0 : (MACRO)             	   pushr R12	;wjr save param regs
(1)  672/    17F5 : (MACRO)             	   pushr R13	;wjr
(1)  673/    17FA : 22                  	   dec r2	;wjr make a work area -r7 is restores and 2 inc'd in the cleanup routine fp_sc_up
(1)  674/    17FB :                     
(1)  675/    17FB : (MACRO)                        Ccall    fp_getexp	       ; get exponents
(1)  676/    17FE : (MACRO)                        Ccall    fp_getsgn            ; get signs
(1)  677/    1801 : 8F                             glo   R15                    ; get exp2
(1)  678/    1802 : FF 7F                          smi   127                   ; remove bias
(1)  679/    1804 : 52                             str   r2                    ; place into memory
(1)  680/    1805 : 9F                             ghi   R15                    ; get exp1
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 36 - 4/4/2013 16:39:08


(1)  681/    1806 : FF 7F                          smi   127                   ; remove bias
(1)  682/    1808 : F4                             add                         ; add in exponent 2
(1)  683/    1809 : FC 7F                          adi   127                   ; put bias back in
(1)  684/    180B : 73                             stxd                        ; place onto stack
(1)  685/    180C : 87                             glo   F7                    ; determine sign for answer
(1)  686/    180D : 52                             str   r2
(1)  687/    180E : F6                             shr
(1)  688/    180F : F3                             xor
(1)  689/    1810 : 73                             stxd                        ; place onto stack
(1)  690/    1811 : 9E                             ghi   R14                    ; get baud constant
(1)  691/    1812 : 73                             stxd                        ; save on stack
(1)  692/    1813 : 96                             ghi   r6                    ; save return position on stack
(1)  693/    1814 : 73                             stxd
(1)  694/    1815 : 86                             glo   r6
(1)  695/    1816 : 73                             stxd
(1)  696/    1817 : F8 00                          ldi   0                     ; initial value of ct
(1)  697/    1819 : 73                             stxd
(1)  698/    181A : BE                             phi   R14                    ; set mulH to 0
(1)  699/    181B : AE                             plo   R14
(1)  700/    181C : B6                             phi   r6
(1)  701/    181D : A6                             plo   r6
(1)  702/    181E : B8                             phi   r8                    ; mulL = arg1 & 0xffffff
(1)  703/    181F : 88                             glo   r8                    ; be sure high bit is set
(1)  704/    1820 : F9 80                          ori   080h
(1)  705/    1822 : A8                             plo   r8
(1)  706/    1823 : F8 00                          ldi   0
(1)  707/    1825 : BC                             phi   R12                    ; set result to 0
(1)  708/    1826 : AC                             plo   R12
(1)  709/    1827 : B7                             phi   F7
(1)  710/    1828 : A7                             plo   F7
(1)  711/    1829 : BF                             phi   R15
(1)  712/    182A : AF                             plo   R15
(1)  713/    182B : BD                             phi   R13
(1)  714/    182C : AD                             plo   R13
(1)  715/    182D : BA                             phi   R10                    ; arg2 &= 0ffffff
(1)  716/    182E : 8A                             glo   R10                    ; be sure high bit is set
(1)  717/    182F : F9 80                          ori   080h
(1)  718/    1831 : AA                             plo   R10
(1)  719/    1832 : 8B                  mul_lp1:   glo   FB                    ; check for zero multiplier
(1)  720/    1833 : CA 18 42                       lbnz  mul_go1               ; jump if not zero
(1)  721/    1836 : 9B                             ghi   FB
(1)  722/    1837 : CA 18 42                       lbnz  mul_go1
(1)  723/    183A : 8A                             glo   R10
(1)  724/    183B : CA 18 42                       lbnz  mul_go1
(1)  725/    183E : 9A                             ghi   R10
(1)  726/    183F : C2 18 BA                       lbz   mul_dn                ; jump if muliplier is zero
(1)  727/    1842 : 9A                  mul_go1:   ghi   R10                    ; shift multiplier right
(1)  728/    1843 : F6                             shr
(1)  729/    1844 : BA                             phi   R10
(1)  730/    1845 : 8A                             glo   R10
(1)  731/    1846 : 76                             shrc
(1)  732/    1847 : AA                             plo   R10
(1)  733/    1848 : 9B                             ghi   FB
(1)  734/    1849 : 76                             shrc
(1)  735/    184A : BB                             phi   FB
(1)  736/    184B : 8B                             glo   FB
(1)  737/    184C : 76                             shrc
(1)  738/    184D : AB                             plo   FB
(1)  739/    184E : CB 18 8F                       lbnf  mul_no                ; jump if low bit was zero
(1)  740/    1851 : 89                             glo   F9                    ; res += mul
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 37 - 4/4/2013 16:39:08


(1)  741/    1852 : 52                             str   r2
(1)  742/    1853 : 87                             glo   F7
(1)  743/    1854 : F4                             add
(1)  744/    1855 : A7                             plo   F7
(1)  745/    1856 : 99                             ghi   F9
(1)  746/    1857 : 52                             str   r2
(1)  747/    1858 : 97                             ghi   F7
(1)  748/    1859 : 74                             adc
(1)  749/    185A : B7                             phi   F7
(1)  750/    185B : 88                             glo   r8
(1)  751/    185C : 52                             str   r2
(1)  752/    185D : 8C                             glo   R12
(1)  753/    185E : 74                             adc
(1)  754/    185F : AC                             plo   R12
(1)  755/    1860 : 98                             ghi   r8
(1)  756/    1861 : 52                             str   r2
(1)  757/    1862 : 9C                             ghi   R12
(1)  758/    1863 : 74                             adc
(1)  759/    1864 : BC                             phi   R12
(1)  760/    1865 : 86                             glo   r6                    ; now high 32 bits
(1)  761/    1866 : 52                             str   r2
(1)  762/    1867 : 8D                             glo   R13
(1)  763/    1868 : F4                             add
(1)  764/    1869 : AD                             plo   R13
(1)  765/    186A : 96                             ghi   r6
(1)  766/    186B : 52                             str   r2
(1)  767/    186C : 96                             ghi   r6
(1)  768/    186D : 52                             str   r2
(1)  769/    186E : 9D                             ghi   R13
(1)  770/    186F : 74                             adc
(1)  771/    1870 : BD                             phi   R13
(1)  772/    1871 : 8E                             glo   R14
(1)  773/    1872 : 52                             str   r2
(1)  774/    1873 : 8F                             glo   R15
(1)  775/    1874 : 74                             adc
(1)  776/    1875 : AF                             plo   R15
(1)  777/    1876 : 9E                             ghi   R14
(1)  778/    1877 : 52                             str   r2
(1)  779/    1878 : 9F                             ghi   R15
(1)  780/    1879 : 74                             adc
(1)  781/    187A : BF                             phi   R15
(1)  782/    187B : 9C                             ghi   R12                    ; see if need carry from low to high
(1)  783/    187C : C2 18 8F                       lbz   mul_no                ; jump if no carry is needed
(1)  784/    187F : 8D                             glo   R13                    ; move the carry on over
(1)  785/    1880 : FC 01                          adi   1
(1)  786/    1882 : AD                             plo   R13
(1)  787/    1883 : 9D                             ghi   R13
(1)  788/    1884 : 7C 00                          adci  0
(1)  789/    1886 : BD                             phi   R13
(1)  790/    1887 : 8F                             glo   R15
(1)  791/    1888 : 7C 00                          adci  0
(1)  792/    188A : AF                             plo   R15
(1)  793/    188B : 9F                             ghi   R15
(1)  794/    188C : 7C 00                          adci  0
(1)  795/    188E : BF                             phi   R15
(1)  796/    188F : 60                  mul_no:    irx                         ; recover ct
(1)  797/    1890 : F0                             ldx
(1)  798/    1891 : FC 01                          adi   1                     ; increment by 1
(1)  799/    1893 : 73                             stxd                        ; and put it back
(1)  800/    1894 : 89                             glo   F9                    ; shift mulL left
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 38 - 4/4/2013 16:39:08


(1)  801/    1895 : FE                             shl
(1)  802/    1896 : A9                             plo   F9
(1)  803/    1897 : 99                             ghi   F9
(1)  804/    1898 : 7E                             shlc
(1)  805/    1899 : B9                             phi   F9
(1)  806/    189A : 88                             glo   r8
(1)  807/    189B : 7E                             shlc
(1)  808/    189C : A8                             plo   r8
(1)  809/    189D : 98                             ghi   r8
(1)  810/    189E : 7E                             shlc
(1)  811/    189F : B8                             phi   r8
(1)  812/    18A0 : 86                             glo   r6                    ; shift mulH left
(1)  813/    18A1 : FE                             shl
(1)  814/    18A2 : A6                             plo   r6
(1)  815/    18A3 : 96                             ghi   r6
(1)  816/    18A4 : 7E                             shlc
(1)  817/    18A5 : B6                             phi   r6
(1)  818/    18A6 : 8E                             glo   R14
(1)  819/    18A7 : 7E                             shlc
(1)  820/    18A8 : AE                             plo   R14
(1)  821/    18A9 : 9E                             ghi   R14
(1)  822/    18AA : 7E                             shlc
(1)  823/    18AB : BE                             phi   R14
(1)  824/    18AC : 98                             ghi   r8                    ; see if a carry is needed
(1)  825/    18AD : C2 18 32                       lbz   mul_lp1               ; jump if not
(1)  826/    18B0 : F8 00                          ldi   0                     ; zero the high byte
(1)  827/    18B2 : B8                             phi   r8
(1)  828/    18B3 : 86                             glo   r6                    ; add in the carry
(1)  829/    18B4 : F9 01                          ori   1
(1)  830/    18B6 : A6                             plo   r6
(1)  831/    18B7 : C0 18 32                       lbr   mul_lp1               ; loop back for more
(1)  832/    18BA : 60                  mul_dn:    irx                         ; recover ct
(1)  833/    18BB : 72                             ldxa
(1)  834/    18BC : AE                             plo   R14                    ; set aside
(1)  835/    18BD : 72                             ldxa
(1)  836/    18BE : A6                             plo   r6
(1)  837/    18BF : 72                             ldxa
(1)  838/    18C0 : B6                             phi   r6
(1)  839/    18C1 : F0                             ldx
(1)  840/    18C2 : BE                             phi   R14
(1)  841/    18C3 : 9C                             ghi   R12                    ; transfer resL to arg1
(1)  842/    18C4 : B8                             phi   r8
(1)  843/    18C5 : 8C                             glo   R12
(1)  844/    18C6 : A8                             plo   r8
(1)  845/    18C7 : 97                             ghi   F7
(1)  846/    18C8 : B9                             phi   F9
(1)  847/    18C9 : 87                             glo   F7
(1)  848/    18CA : A9                             plo   F9
(1)  849/    18CB : 8E                             glo   R14
(1)  850/    18CC : AC                             plo   R12                    ; put ct into RC.0
(1)  851/    18CD : 8C                  mul_lp2:   glo   R12                    ; get ct
(1)  852/    18CE : FF 02                          smi   2                     ; see if <2
(1)  853/    18D0 : CB 18 E4                       lbnf  mul_nxt1              ; jump if so
(1)  854/    18D3 : D4                             sep   RCALL                 ; shift answer to the right
(1)  855/    18D4 : 15 72                          dw    fp_shr_1
(1)  856/    18D6 : D4                             sep   RCALL                 ; shift resH right
(1)  857/    18D7 : 15 A3                          dw    fp_shr_fd
(1)  858/    18D9 : CB 18 E0                       lbnf  mul_lp2a              ; jump if no carry into low word
(1)  859/    18DC : 88                             glo   r8                    ; set high bit
(1)  860/    18DD : F9 80                          ori   080h
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 39 - 4/4/2013 16:39:08


(1)  861/    18DF : A8                             plo   r8
(1)  862/    18E0 : 2C                  mul_lp2a:  dec   R12                    ; decrement count
(1)  863/    18E1 : C0 18 CD                       lbr   mul_lp2               ; loop back to keep checking
(1)  864/    18E4 : 60                  mul_nxt1:  irx                         ; recover sign
(1)  865/    18E5 : 72                             ldxa
(1)  866/    18E6 : A7                             plo   F7
(1)  867/    18E7 : F0                             ldx                         ; recover answer exponent
(1)  868/    18E8 : AC                             plo   R12
(1)  869/    18E9 : 9F                  mul_lp3:   ghi   R15                    ; check resH for nonzero
(1)  870/    18EA : CA 18 FC                       lbnz  mul_lp3a
(1)  871/    18ED : 8F                             glo   R15
(1)  872/    18EE : CA 18 FC                       lbnz  mul_lp3a
(1)  873/    18F1 : 9D                             ghi   R13
(1)  874/    18F2 : CA 18 FC                       lbnz  mul_lp3a
(1)  875/    18F5 : 8D                             glo   R13
(1)  876/    18F6 : CA 18 FC                       lbnz  mul_lp3a
(1)  877/    18F9 : C0 19 0D                       lbr   mul_lp4               ; jump if no bits set in resH
(1)  878/    18FC : 1C                  mul_lp3a:  inc   R12                    ; increment exponent
(1)  879/    18FD : (MACRO)                        Ccall fp_shr_1                ; shift answer to the right
(1)  880/    1900 : (MACRO)                        Ccall fp_shr_fd               ; shift resH right
(1)  881/    1903 : CB 18 E9                       lbnf  mul_lp3               ; jump if no carry into low word
(1)  882/    1906 : 88                             glo   r8                    ; set high bit
(1)  883/    1907 : F9 80                          ori   080h
(1)  884/    1909 : A8                             plo   r8
(1)  885/    190A : C0 18 E9                       lbr   mul_lp3
(1)  886/    190D : 8C                  mul_lp4:   glo   R12                    ; transfer exponent
(1)  887/    190E : BF                             phi   R15                    ; to high R15
(1)  888/    190F : C0 15 B0                       lbr   fp_sc_up              ; scale number and build answer
(1)  889/    1912 :                     
(1)  890/    1912 :                     ; ***************************************
(1)  891/    1912 :                     ; *** Convert ascii to floating point ***
(1)  892/    1912 :                     ; *** RF - buffer to ascii text       ***
(1)  893/    1912 :                     ; *** Returns: R8:F9 - number         ***
(1)  894/    1912 :                     ; ***************************************
(1)  895/    1912 : 4F                  fp_atof:   lda   R15                    ; get byte from buffer
(1)  896/    1913 : FF 20                          smi   ' '                   ; check for space
(1)  897/    1915 : C2 19 12                       lbz   fp_atof               ; move past any spaces
(1)  898/    1918 : 2F                             dec   R15                    ; point back to nonspace chara
(1)  899/    1919 : 0F                             ldn   R15                    ; check for possible sign
(1)  900/    191A : FF 2D                          smi   '-'                   ; first check for minus
(1)  901/    191C : CA 19 26                       lbnz   atof_nm              ; jump if not minus
(1)  902/    191F : F8 80                          ldi   080h                  ; high bit set for minus
(1)  903/    1921 : 73                             stxd                        ; place onto stack
(1)  904/    1922 : 1F                             inc   R15                    ; move past sign
(1)  905/    1923 : C0 19 30                       lbr   atof_go1              ; and continue
(1)  906/    1926 : F8 00               atof_nm:   ldi   0                     ; indicate positive number
(1)  907/    1928 : 73                             stxd                        ; place onto stack
(1)  908/    1929 : 0F                             ldn   R15                    ; now check for + sign
(1)  909/    192A : FF 2B                          smi   '+'
(1)  910/    192C : CA 19 30                       lbnz  atof_go1              ; jump if not plus
(1)  911/    192F : 1F                             inc   R15                    ; move past plus sign
(1)  912/    1930 : F8 00               atof_go1:  ldi   0                     ; setup result
(1)  913/    1932 : B8                             phi   r8
(1)  914/    1933 : A8                             plo   r8
(1)  915/    1934 : B9                             phi   F9
(1)  916/    1935 : A9                             plo   F9
(1)  917/    1936 : 0F                  atof_lp1:  ldn   R15                    ; get next byte from buffer
(1)  918/    1937 : (MACRO)                        Ccall f_isnum                ; is it numeric
(1)  919/    193A : CB 19 67                       lbnf  atof_no1              ; jump if not
(1)  920/    193D : 98                             ghi   r8                    ; copy arg1 to arg2
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 40 - 4/4/2013 16:39:08


(1)  921/    193E : BA                             phi   R10
(1)  922/    193F : 88                             glo   r8
(1)  923/    1940 : AA                             plo   R10
(1)  924/    1941 : 99                             ghi   F9
(1)  925/    1942 : BB                             phi   FB
(1)  926/    1943 : 89                             glo   F9
(1)  927/    1944 : AB                             plo   FB
(1)  928/    1945 : (MACRO)                        Ccall fp_shl_1                ; multiply arg1 by 2
(1)  929/    1948 : (MACRO)                        Ccall fp_shl_1                 ; multiply arg1 by 4
(1)  930/    194B : (MACRO)                        Ccall fp_add_12                ; multiply arg1 by 5
(1)  931/    194E : (MACRO)                        Ccall fp_shl_1                ; multiply arg1 by 10
(1)  932/    1951 : 4F                             lda   R15                    ; get number
(1)  933/    1952 : FF 30                          smi   '0'                   ; convert to binary
(1)  934/    1954 : 52                             str   r2                    ; setup for add
(1)  935/    1955 : 89                             glo   F9                    ; add in next digit
(1)  936/    1956 : F4                             add
(1)  937/    1957 : A9                             plo   F9
(1)  938/    1958 : 99                             ghi   F9                    ; propagate carry
(1)  939/    1959 : 7C 00                          adci  0
(1)  940/    195B : B9                             phi   F9
(1)  941/    195C : 88                             glo   r8
(1)  942/    195D : 7C 00                          adci  0
(1)  943/    195F : A8                             plo   r8
(1)  944/    1960 : 98                             ghi   r8
(1)  945/    1961 : 7C 00                          adci  0
(1)  946/    1963 : B8                             phi   r8
(1)  947/    1964 : C0 19 36                       lbr   atof_lp1              ; loop until no more digits
(1)  948/    1967 : 0F                  atof_no1:  ldn   R15                    ; check for decimal point
(1)  949/    1968 : FF 2E                          smi   '.'
(1)  950/    196A : CA 19 6E                       lbnz  atof_ndp              ; jump if none
(1)  951/    196D : 1F                             inc   R15                    ; move past decimal
(1)  952/    196E : F8 1A               atof_ndp:  ldi   scratch>>8          ; point to scratch area
(1)  953/    1970 : BA                             phi   R10
(1)  954/    1971 : F8 A3                          ldi   scratch&255
(1)  955/    1973 : AA                             plo   R10
(1)  956/    1974 : F8 10                          ldi   16                    ; 16 bytes to clear
(1)  957/    1976 : AC                             plo   R12
(1)  958/    1977 : F8 00               atof_lpx:  ldi   0
(1)  959/    1979 : 5A                             str   R10
(1)  960/    197A : 1A                             inc   R10
(1)  961/    197B : 2C                             dec   R12
(1)  962/    197C : 8C                             glo   R12
(1)  963/    197D : CA 19 77                       lbnz  atof_lpx
(1)  964/    1980 : F8 1A                          ldi   (scratch+1)>>8      ; point to scratch area
(1)  965/    1982 : BA                             phi   R10
(1)  966/    1983 : F8 A4                          ldi   (scratch+1)&255
(1)  967/    1985 : AA                             plo   R10
(1)  968/    1986 : F8 01                          ldi   1                     ; setup count
(1)  969/    1988 : AC                             plo   R12
(1)  970/    1989 : F8 00                          ldi   0                     ; setup exp flag
(1)  971/    198B : BC                             phi   R12
(1)  972/    198C : 8C                  atof_lp2:  glo   R12                    ; see if done making bcd
(1)  973/    198D : FF 11                          smi   17
(1)  974/    198F : C2 19 A8                       lbz   atof_dn3              ; jump if so
(1)  975/    1992 : 0F                             ldn   R15                    ; get character
(1)  976/    1993 : D4                             sep   RCALL                 ; is it numeric
(1)  977/    1994 : 15 62                          dw    f_isnum
(1)  978/    1996 : CB 19 A8                       lbnf  atof_dn3              ; jump if not
(1)  979/    1999 : 4F                             lda   R15                    ; get character
(1)  980/    199A : FF 30                          smi   '0'                   ; converto to binary
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 41 - 4/4/2013 16:39:08


(1)  981/    199C : 5A                             str   R10                    ; write into bcd area
(1)  982/    199D : 1A                             inc   R10
(1)  983/    199E : 1C                             inc   R12                    ; increment count
(1)  984/    199F : CA 19 8C                       lbnz  atof_lp2              ; loop back until done
(1)  985/    19A2 : F8 01                          ldi   1                     ; set non zero flag
(1)  986/    19A4 : BC                             phi   R12
(1)  987/    19A5 : C0 19 8C                       lbr   atof_lp2
(1)  988/    19A8 : 9C                  atof_dn3:  ghi   R12                    ; check for non-zero digits
(1)  989/    19A9 : CA 19 C2                       lbnz  atof_nz
(1)  990/    19AC : 98                             ghi   r8                    ; check for non-zero integer
(1)  991/    19AD : CA 19 C2                       lbnz  atof_nz
(1)  992/    19B0 : 88                             glo   r8
(1)  993/    19B1 : CA 19 C2                       lbnz  atof_nz
(1)  994/    19B4 : 99                             ghi   F9
(1)  995/    19B5 : CA 19 C2                       lbnz  atof_nz
(1)  996/    19B8 : 89                             glo   F9
(1)  997/    19B9 : CA 19 C2                       lbnz  atof_nz
(1)  998/    19BC : 60                             irx                         ; recover sign
(1)  999/    19BD : F0                             ldx
(1) 1000/    19BE : B8                             phi   r8                    ; put in high of zero
(1) 1001/    19BF : C0 1A 95                       lbr	atof_end               ; and return
(1) 1002/    19C2 : F8 00               atof_nz:   ldi   0                     ; setup dp
(1) 1003/    19C4 : BC                             phi   R12
(1) 1004/    19C5 : 98                  atof_lp3:  ghi   r8                    ; check for high bit set
(1) 1005/    19C6 : FA 80                          ani   080h
(1) 1006/    19C8 : CA 1A 12                       lbnz  atof_dn4              ; jump if so
(1) 1007/    19CB : (MACRO)                        Ccall fp_shl_1                ; shift answer left
(1) 1008/    19CE : F8 1A                          ldi   scratch>>8          ; point to bcd number
(1) 1009/    19D0 : BA                             phi   R10
(1) 1010/    19D1 : F8 A3                          ldi   255&scratch
(1) 1011/    19D3 : AA                             plo   R10
(1) 1012/    19D4 : F8 00                          ldi   0                     ; set high byte to zero
(1) 1013/    19D6 : 5A                             str   R10
(1) 1014/    19D7 : F8 1A                          ldi   (scratch+15)>>8     ; point to last cell
(1) 1015/    19D9 : BA                             phi   R10
(1) 1016/    19DA : F8 B2                          ldi   255&(scratch+15)
(1) 1017/    19DC : AA                             plo   R10
(1) 1018/    19DD : F8 00                          ldi   0                     ; set carry forward
(1) 1019/    19DF : AE                             plo   R14
(1) 1020/    19E0 : F8 10                          ldi   16                    ; setup count
(1) 1021/    19E2 : AC                             plo   R12
(1) 1022/    19E3 : 8E                  atof_lp4:  glo   R14                    ; get carry
(1) 1023/    19E4 : 52                             str   r2                    ; in memory for add
(1) 1024/    19E5 : 0A                             ldn   R10                    ; get bcd digit
(1) 1025/    19E6 : F4                             add                         ; add in carry
(1) 1026/    19E7 : 52                             str   r2                    ; place into memory
(1) 1027/    19E8 : 0A                             ldn   R10                    ; recover bcd digit
(1) 1028/    19E9 : F4                             add                         ; digit now doubled with carry
(1) 1029/    19EA : 5A                             str   R10                    ; put it back
(1) 1030/    19EB : FF 0A                          smi   10
(1) 1031/    19ED : CB 19 F4                       lbnf  atof_no4              ; jump if below 10
(1) 1032/    19F0 : 5A                             str   R10                    ; store value - 10
(1) 1033/    19F1 : F8 01                          ldi   1                     ; carry set to 1
(1) 1034/    19F3 : C8                             lskp                        ; skip next instruction
(1) 1035/    19F4 : F8 00               atof_no4:  ldi   0                     ; reset carry
(1) 1036/    19F6 : AE                             plo   R14
(1) 1037/    19F7 : 2A                             dec   R10                    ; move to previous digit
(1) 1038/    19F8 : 2C                             dec   R12                    ; decrement digit count
(1) 1039/    19F9 : 8C                             glo   R12                    ; see if done
(1) 1040/    19FA : CA 19 E3                       lbnz  atof_lp4              ; jump if not
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 42 - 4/4/2013 16:39:08


(1) 1041/    19FD : F8 1A                          ldi   scratch>>8	       ; point to first digit
(1) 1042/    19FF : BA                             phi   R10
(1) 1043/    1A00 : F8 A3                          ldi   255&scratch
(1) 1044/    1A02 : AA                             plo   R10
(1) 1045/    1A03 : 0A                             ldn   R10                    ; retrieve it
(1) 1046/    1A04 : C2 1A 0B                       lbz   atof_nc4              ; jump if no carry
(1) 1047/    1A07 : 89                             glo   F9                    ; add in the carry
(1) 1048/    1A08 : F9 01                          ori   1
(1) 1049/    1A0A : A9                             plo   F9
(1) 1050/    1A0B : 9C                  atof_nc4:  ghi   R12                    ; increment dp
(1) 1051/    1A0C : FC 01                          adi   1
(1) 1052/    1A0E : BC                             phi   R12
(1) 1053/    1A0F : C0 19 C5                       lbr   atof_lp3              ; loop until full
(1) 1054/    1A12 : 9C                  atof_dn4:  ghi   R12                    ; get dp
(1) 1055/    1A13 : 52                             str   r2                    ; into memory
(1) 1056/    1A14 : F8 1F                          ldi   31                    ; need to subtract from 31
(1) 1057/    1A16 : F7                             sm
(1) 1058/    1A17 : FC 7F                          adi   127                   ; add in bias
(1) 1059/    1A19 : BD                             phi   R13                    ; set aside
(1) 1060/    1A1A : 99                             ghi   F9                    ; shift result down 8 bits
(1) 1061/    1A1B : A9                             plo   F9
(1) 1062/    1A1C : 88                             glo   r8
(1) 1063/    1A1D : B9                             phi   F9
(1) 1064/    1A1E : 98                             ghi   r8
(1) 1065/    1A1F : FE                             shl                         ; shift out high bit
(1) 1066/    1A20 : A8                             plo   r8
(1) 1067/    1A21 : 9D                             ghi   R13                    ; get bit 0 of exponent
(1) 1068/    1A22 : F6                             shr
(1) 1069/    1A23 : B8                             phi   r8                    ; bits 1-7 into high byte
(1) 1070/    1A24 : 88                             glo   r8                    ; get mantissa
(1) 1071/    1A25 : 76                             shrc                        ; shift in bit 0 of exponent
(1) 1072/    1A26 : A8                             plo   r8                    ; and write it
(1) 1073/    1A27 : 60                             irx                         ; point to sign
(1) 1074/    1A28 : 98                             ghi   r8                    ; high byte
(1) 1075/    1A29 : F1                             or                          ; set sign
(1) 1076/    1A2A : B8                             phi   r8                    ; done with base conversion
(1) 1077/    1A2B : 0F                             ldn   R15                    ; get next byte
(1) 1078/    1A2C : FF 65                          smi   'e'                   ; check for exponents
(1) 1079/    1A2E : C2 1A 37                       lbz   atof_exp
(1) 1080/    1A31 : 0F                             ldn   R15
(1) 1081/    1A32 : FF 45                          smi   'E'
(1) 1082/    1A34 : CA 1A 95                       lbnz  atof_end
(1) 1083/    1A37 : 1F                  atof_exp:  inc   R15                    ; move past E
(1) 1084/    1A38 : 0F                             ldn   R15                    ; check for sign
(1) 1085/    1A39 : FF 2D                          smi   '-'
(1) 1086/    1A3B : C2 1A 48                       lbz   atof_n
(1) 1087/    1A3E : 0F                             ldn   R15
(1) 1088/    1A3F : FF 2B                          smi   '+'
(1) 1089/    1A41 : C2 1A 45                       lbz   atof_p
(1) 1090/    1A44 : 2F                             dec   R15                    ; positive if no sign
(1) 1091/    1A45 : F8 01               atof_p:    ldi   1                     ; indicate positive exponent
(1) 1092/    1A47 : C8                             lskp
(1) 1093/    1A48 : F8 00               atof_n:    ldi   0                     ; indicate negative exponent
(1) 1094/    1A4A : BC                             phi   R12                    ; place into sign variable
(1) 1095/    1A4B : 1F                             inc   R15                    ; move past sign
(1) 1096/    1A4C : F8 00                          ldi   0                     ; setup intial count
(1) 1097/    1A4E : AC                             plo   R12
(1) 1098/    1A4F : 0F                  atof_lp5:  ldn   R15                    ; get next byte
(1) 1099/    1A50 : (MACRO)                        Ccall f_isnum                ; see if numeric
(1) 1100/    1A53 : CB 1A 65                       lbnf  atof_dn5              ; jump if not
 AS V1.42 Beta [Bld 87] - source file fragment.asm(LCC1802fp.inc) - page 43 - 4/4/2013 16:39:08


(1) 1101/    1A56 : 8C                             glo   R12                    ; make copy of exponent
(1) 1102/    1A57 : 52                             str   r2
(1) 1103/    1A58 : F6                             shr                         ; multiply by 2
(1) 1104/    1A59 : F6                             shr                         ; by 4
(1) 1105/    1A5A : F4                             add                         ; by 5
(1) 1106/    1A5B : F6                             shr                         ; by 10
(1) 1107/    1A5C : 52                             str   r2                    ; put here for add
(1) 1108/    1A5D : 4F                             lda   R15                    ; recover number
(1) 1109/    1A5E : FF 30                          smi   '0'                   ; convert to binary
(1) 1110/    1A60 : F4                             add                         ; add with total
(1) 1111/    1A61 : AC                             plo   R12                    ; copy back to R12
(1) 1112/    1A62 : C0 1A 4F                       lbr   atof_lp5              ; loop back until done reading exponent
(1) 1113/    1A65 : 8C                  atof_dn5:  glo   R12                    ; see if done
(1) 1114/    1A66 : C2 1A 95                       lbz   atof_end              ; jump if so
(1) 1115/    1A69 : 2C                             dec   R12                    ; otherwise decrement count
(1) 1116/    1A6A : 8C                             glo   R12                    ; save count
(1) 1117/    1A6B : 73                             stxd
(1) 1118/    1A6C : 9C                             ghi   R12                    ; save sign
(1) 1119/    1A6D : 73                             stxd
(1) 1120/    1A6E : 8F                             glo   R15
(1) 1121/    1A6F : 73                             stxd
(1) 1122/    1A70 : 9F                             ghi   R15
(1) 1123/    1A71 : 73                             stxd
(1) 1124/    1A72 : F8 41                          ldi   041h                  ; setup 10.0
(1) 1125/    1A74 : BA                             phi   R10
(1) 1126/    1A75 : F8 20                          ldi   020h
(1) 1127/    1A77 : AA                             plo   R10
(1) 1128/    1A78 : F8 00                          ldi   0
(1) 1129/    1A7A : BB                             phi   FB
(1) 1130/    1A7B : AB                             plo   FB
(1) 1131/    1A7C : 9C                             ghi   R12
(1) 1132/    1A7D : C2 1A 86                       lbz   atof_div              ; jump if negative
(1) 1133/    1A80 : (MACRO)                        Ccall fp_mul                 ; multiply by 10
(1) 1134/    1A83 : C0 1A 89                       lbr   atof_go5              ; clean up call
(1) 1135/    1A86 : (MACRO)             atof_div:  Ccall fp_div                 ; divice by 10
(1) 1136/    1A89 : 60                  atof_go5:  irx                         ; recover variables
(1) 1137/    1A8A : 72                             ldxa
(1) 1138/    1A8B : BF                             phi   R15
(1) 1139/    1A8C : 72                             ldxa
(1) 1140/    1A8D : AF                             plo   R15
(1) 1141/    1A8E : 72                             ldxa
(1) 1142/    1A8F : BC                             phi   R12
(1) 1143/    1A90 : F0                             ldx
(1) 1144/    1A91 : AC                             plo   R12
(1) 1145/    1A92 : C0 1A 65                       lbr   atof_dn5              ; loop until exponent is zero
(1) 1146/    1A95 :                     atof_end:
(1) 1147/    1A95 : 12                  	   inc	r2	;wjr release work area
(1) 1148/    1A96 : (MACRO)             	   popr R13	;wjr restore param regs
(1) 1149/    1A9A : (MACRO)             	   popr R12	;wjr
(1) 1150/    1A9E : (MACRO)             	   popr	F7	;wjr restore c variable
(1) 1151/    1AA2 : (MACRO)             	   Cretn
(1) 1152/    1AA3 : 00 00               scratch:   db	00,00
     930/    1AA5 :                     	include IO1802.inc
(1)    1/    1AA5 :                     ;IO1802.inc contains input/output runtime routines for LCC1802
(1)    2/    1AA5 :                     ;The port is in regArg1, the output byte is in regArg2
(1)    3/    1AA5 :                     	align 64
(1)    4/    1AC0 :                     _putc:
(1)    5/    1AC0 :                     _out5:	
(1)    6/    1AC0 : 8C                  	glo	regArg1
(1)    7/    1AC1 : 22                  	dec	sp
 AS V1.42 Beta [Bld 87] - source file fragment.asm(IO1802.inc) - page 44 - 4/4/2013 16:39:08


(1)    8/    1AC2 : 52                  	str	sp
(1)    9/    1AC3 : 65                  	out	5
(1)   10/    1AC4 : (MACRO)             	Cretn
(1)   11/    1AC5 :                     _inp:		;raw port input
(1)   12/    1AC5 :                     		;stores a small tailored program on the stack and executes it
(1)   13/    1AC5 : 22                  	dec	sp	;work backwards
(1)   14/    1AC6 : F8 D3               	ldi	0xD3	;return instruction
(1)   15/    1AC8 : 73                  	stxd		
(1)   16/    1AC9 : 8C                  	glo	regarg1	;get the port number
(1)   17/    1ACA : FA 07               	ani	0x07	;clean it
(1)   18/    1ACC : 32 DC               	bz	+	; inp(0) isn't valid
(1)   19/    1ACE : F9 68               	ori	0x68	;make it an input instruction
(1)   20/    1AD0 : 73                  	stxd		;store it for execution
(1)   21/    1AD1 : (MACRO)             	cpy2	rt1,sp	;rt1&sp now point to an empty byte to be overwritten by the inp instruction
(1)   22/    1AD5 : 18                  	inc	rt1	;rt1 points to the 6x instruction
(1)   23/    1AD6 : D8                  	sep	rt1	;execute it
(1)   24/    1AD7 :                     ;we will come back to here with the input byte in D
(1)   25/    1AD7 : 12                  	inc	sp	;step over the work area
(1)   26/    1AD8 : AF                  	plo	retVal	;save it to return
(1)   27/    1AD9 : F8 00               	ldi	0
(1)   28/    1ADB : BF                  	phi	retval	;clear top byte
(1)   29/    1ADC : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   30/    1ADD : 12                  	inc	sp	;and the D3
(1)   31/    1ADE : (MACRO)             	Cretn		;and we're done
(1)   32/    1ADF :                     	
(1)   33/    1ADF :                     _out:		;raw port output
(1)   34/    1ADF :                     		;stores a small tailored program on the stack and executes it
(1)   35/    1ADF : 22                  	dec	sp	;work backwards
(1)   36/    1AE0 : F8 D3               	ldi	0xD3	;return instruction
(1)   37/    1AE2 : 73                  	stxd		
(1)   38/    1AE3 : (MACRO)             	cpy2	rt1,sp	;rt1 will point to the inp instruction
(1)   39/    1AE7 : 8C                  	glo	regarg1	;get the port number
(1)   40/    1AE8 : FA 07               	ani	0x07	;clean it
(1)   41/    1AEA : F9 60               	ori	0x60	;make it an out instruction - 60 is harmless
(1)   42/    1AEC : 73                  	stxd		;store it for execution
(1)   43/    1AED : 8D                  	glo	regarg2	;get the byte to be written
(1)   44/    1AEE : 52                  	str	sp	;store it where sp points
(1)   45/    1AEF : D8                  	sep	rt1	;execute it
(1)   46/    1AF0 :                     ;we will come back to here with sp stepped up by one
(1)   47/    1AF0 : 12                  +	inc	sp	;need to get rid of the 6x instruction
(1)   48/    1AF1 : 12                  	inc	sp	;and the D3
(1)   49/    1AF2 : (MACRO)             	Cretn		;and we're done
(1)   50/    1AF3 :                     	
(1)   51/    1AF3 :                     	
     931/    1AF3 :                     
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 45 - 4/4/2013 16:39:08


  symbol table (* = unused):
  ------------------------

 ADD_A1NZ :                    1607 C |  ADD_A2NZ :                    1618 C |
 ADD_FNL :                     16BF C |  ADD_LP1 :                     1662 C |
 ADD_LP1DN :                   1677 C |  ADD_NM :                      1686 C |
 ADD_NO :                      16A8 C |  ADD_NS :                      1650 C |
 ADD_NX :                      16EB C |  ADD_NZ :                      16DD C |
*ARCHITECTURE :  i386-unknown-win32 - |  ATOF_DIV :                    1A86 C |
 ATOF_DN3 :                    19A8 C |  ATOF_DN4 :                    1A12 C |
 ATOF_DN5 :                    1A65 C |  ATOF_END :                    1A95 C |
 ATOF_EXP :                    1A37 C |  ATOF_GO1 :                    1930 C |
 ATOF_GO5 :                    1A89 C |  ATOF_LP1 :                    1936 C |
 ATOF_LP2 :                    198C C |  ATOF_LP3 :                    19C5 C |
 ATOF_LP4 :                    19E3 C |  ATOF_LP5 :                    1A4F C |
 ATOF_LPX :                    1977 C |  ATOF_N :                      1A48 C |
 ATOF_NC4 :                    1A0B C |  ATOF_NDP :                    196E C |
 ATOF_NM :                     1926 C |  ATOF_NO1 :                    1967 C |
 ATOF_NO4 :                    19F4 C |  ATOF_NZ :                     19C2 C |
 ATOF_P :                      1A45 C | *BIGENDIAN :                      0 - |
 BITLOOP157 :                  12B8 C | *BRANCHEXT :                      0 - |
*CASESENSITIVE :                  0 - |  CHECK_SUB155 :                1196 C |
 CKNEXT157 :                   1307 C |  CKTOP157 :                    12A3 C |
 CLRLP157 :                    1294 C | *CONSTPI :        3.141592653589793 - |
 CVFI4 :                       1500 C |  CVIF4 :                       1400 C |
*DATE :                    4/4/2013 - |  DCKLP157 :                    12BB C |
 DIVLOOP16_16152 :             1052 C | *DIVSETBIT16_16152 :           1084 C |
 DIVSKIP16_16152 :             1081 C |  DIVSKIPCLEAR16_16152 :        1088 C |
 DIVSKIPFINALADD16_16152 :     109A C |  DIVSUB16_16152 :              1073 C |
 DIV_A1NZ :                    1709 C |  DIV_A2NZ :                    1727 C |
 DIV_GO :                      178E C |  DIV_GO1 :                     177B C |
 DIV_LP :                      1768 C |  DIV_NOPE :                    17C9 C |
 DIV_Z :                       17DB C |  DNOADD157 :                   12C3 C |
 DONE153 :                     10D3 C |  DONE156 :                     1274 C |
 DONE157 :                     1311 C |  DONE163 :                     146F C |
 DONE164 :                     1561 C |  DSHLP157 :                    12D7 C |
 ENDLP154 :                    1161 C |  F7 :                             7 - |
 F9 :                             9 - |  FAILS :                       156E C |
*FALSE :                          0 - |  FB :                             B - |
 FP_ADD :                      15EE C |  FP_ADD_12 :                   158C C |
 FP_ATOF :                     1912 C |  FP_DIV :                      16F8 C |
 FP_GETEXP :                   15DC C |  FP_GETSGN :                   15E7 C |
 FP_MUL :                      17EB C |  FP_SC_CLN :                   15C0 C |
 FP_SC_UP :                    15B0 C |  FP_SHL_1 :                    157F C |
 FP_SHR_1 :                    1572 C |  FP_SHR_FD :                   15A3 C |
 FP_SUB :                      16F1 C | *FULLPMMU :                       1 - |
 F_ISNUM :                     1562 C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - | *INEXTMODE :                      0 - |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
*INSRCMODE :                      0 - | *INSUPMODE :                      0 - |
*L1 :                            83 C |  L10 :                           CA C |
 L11 :                           CC C | *L13 :                          12E C |
 L14 :                           FA C |  L15 :                          119 C |
*L17 :                          472 C |  L18 :                          222 C |
 L19 :                          24B C |  L2 :                           F36 C |
 L20 :                          F2C C |  L21 :                          F28 C |
 L22 :                          24B C |  L24 :                          28F C |
 L26 :                          466 C | *L28 :                          633 C |
 L29 :                          551 C |  L3 :                           F30 C |
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 46 - 4/4/2013 16:39:08


 L30 :                          561 C |  L31 :                          56A C |
 L32 :                          60B C |  L34 :                          571 C |
*L35 :                          571 C |  L37 :                          57E C |
 L38 :                          5F6 C | *L4 :                            BB C |
 L41 :                          5B3 C | *L42 :                          712 C |
 L43 :                          6CC C | *L45 :                          760 C |
*L46 :                          7C0 C | *L47 :                          833 C |
*L48 :                          8C6 C |  L49 :                          8A1 C |
 L5 :                            9E C |  L50 :                          8C6 C |
*L51 :                          944 C | *L52 :                          D80 C |
 L53 :                          98C C |  L54 :                          D5F C |
 L56 :                          9C8 C |  L57 :                          D5F C |
 L58 :                          D4E C |  L59 :                          D5F C |
*L6 :                            9E C |  L61 :                          AC6 C |
 L62 :                          AE3 C |  L63 :                          B04 C |
 L64 :                          B26 C |  L65 :                          B94 C |
 L66 :                          CFE C |  L68 :                          BF2 C |
 L70 :                          C25 C |  L71 :                          CF9 C |
 L72 :                          CFE C |  L73 :                          D4E C |
 L75 :                          D32 C |  L77 :                          A58 C |
 L78 :                          A73 C |  L79 :                          A44 C |
 L8 :                            A0 C | *L81 :                          AAB C |
*L82 :                          DBE C |  L83 :                          F1D C |
 L84 :                          DBB C | *L85 :                          DBB C |
*L87 :                          E66 C |  L88 :                          DF8 C |
 L89 :                          E45 C | *L9 :                            E5 C |
 L91 :                          E62 C | *L92 :                          EC6 C |
 L93 :                          E9B C |  L94 :                          EB1 C |
*L96 :                          F14 C |  L97 :                          EF0 C |
 L98 :                          EFF C |  LCC1802INIT :                  F3A C |
*LISTON :                         1 - |  LOOP154 :                     110F C |
 LSH164 :                      152B C | *MACEXP :                         0 - |
 MEMADDR :                        E - |  MLOOP155 :                    1177 C |
*MOMCPU :                      1802 - | *MOMCPUNAME :                  1802 - |
 MSLP150 :                     101E C |  MULTLOOP16_16151 :            102B C |
 MULTSKIP16_16151 :            103D C |  MUL_DN :                      18BA C |
 MUL_GO1 :                     1842 C |  MUL_LP1 :                     1832 C |
 MUL_LP2 :                     18CD C |  MUL_LP2A :                    18E0 C |
 MUL_LP3 :                     18E9 C |  MUL_LP3A :                    18FC C |
 MUL_LP4 :                     190D C |  MUL_NO :                      188F C |
 MUL_NXT1 :                    18E4 C | *NESTMAX :                      100 - |
 NORESTORE154 :                115D C |  NXT163 :                      1430 C |
*PACKING :                        0 - | *PADDING :                        1 - |
*PASSES :                      156B C |  POS1153 :                     10B3 C |
 POS1156 :                     1226 C |  POS2153 :                     10C3 C |
 POS2156 :                     124D C |  R0 :                             0 - |
 R1 :                             1 - |  R10 :                            A - |
 R11 :                            B - |  R12 :                            C - |
 R13 :                            D - |  R14 :                            E - |
 R15 :                            F - |  R2 :                             2 - |
 R3 :                             3 - | *R4 :                             4 - |
*R5 :                             5 - |  R6 :                             6 - |
 R7 :                             7 - |  R8 :                             8 - |
 R9 :                             9 - |  RCALL :                          4 - |
 REGARG1 :                        C - |  REGARG2 :                        D - |
*RELAXED :                        1 - |  RETADDR :                        6 - |
 RETVAL :                         F - |  RL0 :                            1 - |
 RL10 :                           B - |  RL12 :                           D - |
 RL8 :                            9 - |  RP1P2 :                          D - |
 RPC :                            3 - |  RRET :                           5 - |
 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 47 - 4/4/2013 16:39:08


 RT1 :                            8 - | *RT2 :                            9 - |
 RWORK :                          E - |  SCRATCH :                     1AA3 C |
 SETSGN163 :                   1468 C |  SGNPOS163 :                   1439 C |
 SHDN163 :                     145F C |  SHIFT155 :                    11AE C |
 SHL163 :                      144B C |  SHR164 :                      1519 C |
 SIGN164 :                     153B C |  SP :                             2 - |
*TIME :                    16:39:08 - | *TRUE :                           1 - |
 UPNXT157 :                    12F0 C | *VERSION :                     142F - |
 _00000142 :                    F54 C |  _CALL :                       1001 C |
 _DIE142 :                      F57 C |  _DIVI2 :                      10A4 C |
 _DIVI4 :                      1200 C |  _DIVU2 :                      1049 C |
 _DIVU4 :                      1100 C |  _DUBDABX :                    1275 C |
*_EXIT :                        D95 C |  _F1 :                           44 C |
 _FTOA :                        137 C | *_INP :                        1AC5 C |
 _ITOA :                        48F C |  _LTOA :                        648 C |
 _MAIN :                         48 C | *_MEMCMP :                      DC3 C |
*_MEMCPY :                      E75 C | *_MEMSET :                      ED3 C |
*_MODI2 :                       F68 C | *_MODI4 :                      131E C |
*_MODU2 :                       F60 C | *_MODU4 :                      1312 C |
 _MULT_NUMS :                    24 C | *_MULU2 :                      1023 C |
*_MULU4 :                      1166 C | *_ONEMS :                      101C C |
 _OUT :                        1ADF C | *_OUT4 :                        F70 C |
*_OUT5 :                       1AC0 C |  _PRINTF :                      949 C |
 _PRINTFLT :                    7C9 C |  _PRINTINT :                    727 C |
 _PRINTLINT :                   769 C |  _PRINTSTR :                     EA C |
 _PUTC :                       1AC0 C |  _PUTX :                        8CB C |
 _PUTXN :                       83C C |  _RETURN :                     1012 C |
 _ROUND_NUMS :                    4 C | *_SETQOFF :                     F5E C |
*_SETQON :                      F5C C |  _STRCPY :                       8C C |
 _STRLEN :                       BE C |  __FORW5 :                     1ADC C |
*__FORW6 :                     1AF0 C |

    295 symbols
     71 unused symbols

 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 48 - 4/4/2013 16:39:08


  defined macros:
  ---------------

ALU2                                  | ALU2I                                
ALU4                                  | ALU4I                                
BLKCPY                                | CCALL                                
CPY1                                  | CPY2                                 
CPY4                                  | CRETN                                
DECM                                  | INC4                                 
INCM                                  | JCF4                                 
JCI2                                  | JCI2I                                
JCI4                                  | JCU2                                 
JCU2I                                 | JCU4                                 
JEQI2                                 | JEQI4                                
JEQU2I                                | JNEU2                                
JNEU2I                                | JNEU4                                
JNI2I                                 | JNU2I                                
JNZU2                                 | JUMPV                                
JZU2                                  | LD1                                  
LD2                                   | LD2Z                                 
LD4                                   | LDA2                                 
LDAD                                  | LDAX                                 
LDI4                                  | LDIREG                               
LDN1                                  | NEGI2                                
NEGI4                                 | POPR                                 
PUSHR                                 | RELEASE                              
RELEASEL                              | RELEASES                             
RESERVE                               | RESERVEL                             
RESERVES                              | RLDMI                                
SAVMI                                 | SEXT                                 
SEXT4                                 | SHL2                                 
SHL2I                                 | SHL2R                                
SHL4                                  | SHL4I                                
SHL4R                                 | SHLC4                                
SHRC4                                 | SHRI2                                
SHRI2I                                | SHRI2R                               
SHRI4                                 | SHRI4I                               
SHRI4R                                | SHRU2                                
SHRU2I                                | SHRU2R                               
SHRU4                                 | SHRU4I                               
SHRU4R                                | ST1                                  
ST2                                   | ST4                                  
STR1                                  | ZEXT                                 
ZEXT4                                 |

     81 macros

 AS V1.42 Beta [Bld 87] - source file fragment.asm - page 49 - 4/4/2013 16:39:08


  codepages:
  ----------

STANDARD (0 changed characters)


0.23 seconds assembly time

   3456 lines source file
   8526 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
